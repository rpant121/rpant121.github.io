<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes" />
<title>TCG Pocket Battle - Online V2 (Proof of Concept)</title>
<link rel="icon" type="image/png" href="https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Pok%C3%A9_Ball_icon.svg/768px-Pok%C3%A9_Ball_icon.svg.png?20161023215848"/>
<style>
:root{
  --card-w:75px;
  --card-h:105px;
}

body {
  margin: 0;
  padding: 20px;
  font-family: system-ui, -apple-system, sans-serif;
  background: #1a1a1a;
  color: #fff;
}

.game-container {
  max-width: 1200px;
  margin: 0 auto;
}

.player-area {
  margin: 20px 0;
  padding: 20px;
  background: #2a2a2a;
  border-radius: 8px;
}

.player-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.active-slot {
  width: var(--card-w);
  height: var(--card-h);
  border: 2px solid #444;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #333;
  position: relative;
  margin: 10px 0;
}

.bench {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.bench-slot {
  width: var(--card-w);
  height: var(--card-h);
  border: 2px solid #444;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #333;
  position: relative;
  cursor: pointer;
}

.bench-slot:hover {
  border-color: #0ea5e9;
}

.bench-slot.selected {
  border-color: #22c55e;
  box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
}

.card-img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  border-radius: 4px;
}

.energy-pips {
  position: absolute;
  bottom: 5px;
  left: 5px;
  display: flex;
  gap: 2px;
  flex-wrap: wrap;
}

.energy-pip {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 1px solid #fff;
  background-size: cover;
  background-position: center;
}

.energy-zone {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  padding: 10px;
  background: #2a2a2a;
  border-radius: 4px;
  margin: 10px 0;
}

.energy-type {
  width: 40px;
  height: 40px;
  border: 2px solid #555;
  border-radius: 4px;
  cursor: pointer;
  background-size: cover;
  background-position: center;
  transition: all 0.2s;
}

.energy-type:hover {
  border-color: #0ea5e9;
  transform: scale(1.1);
}

.energy-type.selected {
  border-color: #22c55e;
  box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
}

.energy-zone.disabled {
  opacity: 0.5;
  pointer-events: none;
  cursor: not-allowed;
}

.energy-zone.disabled .energy-type {
  cursor: not-allowed;
  opacity: 0.5;
}

.hp-overlay {
  position: absolute;
  top: 5px;
  right: 5px;
  background: rgba(0, 0, 0, 0.7);
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 10px;
  font-weight: bold;
}

.retreat-button {
  margin-top: 10px;
  padding: 8px 16px;
  background: #0ea5e9;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

.retreat-button:hover {
  background: #0284c7;
}

.retreat-button:disabled {
  background: #555;
  cursor: not-allowed;
}

.status {
  padding: 10px;
  background: #333;
  border-radius: 4px;
  margin: 10px 0;
}

.log {
  max-height: 200px;
  overflow-y: auto;
  background: #1a1a1a;
  padding: 10px;
  border-radius: 4px;
  font-family: monospace;
  font-size: 12px;
}

.log-entry {
  margin: 4px 0;
  padding: 4px;
  border-left: 2px solid #0ea5e9;
  padding-left: 8px;
}

.attack-menu {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #2a2a2a;
  border: 2px solid #0ea5e9;
  border-radius: 8px;
  padding: 20px;
  z-index: 10000;
  min-width: 300px;
  max-width: 500px;
  max-height: 80vh;
  overflow-y: auto;
  display: none;
}

.attack-menu.show {
  display: block;
}

.attack-item {
  padding: 12px;
  margin: 8px 0;
  background: #333;
  border: 1px solid #555;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
}

.attack-item:hover {
  background: #3a3a3a;
  border-color: #0ea5e9;
}

.attack-item:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.attack-name {
  font-weight: bold;
  margin-bottom: 4px;
}

.attack-cost {
  font-size: 12px;
  color: #9ca3af;
  margin-bottom: 4px;
}

.attack-damage {
  font-size: 12px;
  color: #ef4444;
}

.attack-description {
  font-size: 11px;
  color: #9ca3af;
  margin-top: 4px;
}

.attack-menu-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 9999;
  display: none;
}

.attack-menu-backdrop.show {
  display: block;
}

/* Selection glow for target selection */
.heal-glow {
  box-shadow: 0 0 15px rgba(34, 197, 94, 0.8) !important;
  border: 2px solid #22c55e !important;
  animation: pulse-glow 1.5s ease-in-out infinite;
}

@keyframes pulse-glow {
  0%, 100% {
    box-shadow: 0 0 15px rgba(34, 197, 94, 0.8);
  }
  50% {
    box-shadow: 0 0 25px rgba(34, 197, 94, 1);
  }
}

/* Coin flip UI */
.coin-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10001;
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 20px;
}

.coin-container.show {
  display: flex;
}

.coin {
  width: 100px;
  height: 100px;
  position: relative;
  transform-style: preserve-3d;
  transition: transform 0.6s;
}

.coin.flip {
  animation: coin-flip 1.5s;
}

@keyframes coin-flip {
  0% { transform: rotateY(0deg); }
  50% { transform: rotateY(900deg); }
  100% { transform: rotateY(1800deg); }
}

.coin img {
  width: 100%;
  height: 100%;
  position: absolute;
  backface-visibility: hidden;
}

.coin .front {
  transform: rotateY(0deg);
}

.coin .back {
  transform: rotateY(180deg);
}

.coin-result {
  font-size: 24px;
  font-weight: bold;
  color: #fff;
  text-align: center;
}

.coin-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  z-index: 10000;
  display: none;
}

.coin-backdrop.show {
  display: block;
}
</style>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="firebase-config.js"></script>
<script src="./effects.js"></script>

<script type="module">
// ============================================================================
// ONLINE BATTLE V2 - PROOF OF CONCEPT
// Clean architecture: State-first, event-driven, reactive UI
// ============================================================================

import { initSync, isCurrentPlayer1, getCurrentMatchId, updateGameStatePartial } from './js/online/sync.js';
import { gameState } from './js/online/game-state.js';
import { broadcastAction, ACTION_TYPES } from './js/online/actions.js';
import { getCurrentUser, initAuth } from './js/auth/auth.js';

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Helper functions for effects.js compatibility
globalThis.parseInt10 = globalThis.parseInt10 || ((v, def = 0) => parseInt(v, 10) || def);
globalThis.oppPk = globalThis.oppPk || ((pk) => pk === 'p1' ? 'p2' : 'p1');
globalThis.pkToPlayer = globalThis.pkToPlayer || ((pk) => pk === 'p1' ? 'player1' : 'player2');

// Simple CSV parser for TRAINER_EFFECT_DATA
function parseCSV(text) {
  const lines = text.trim().split('\n');
  if (lines.length < 2) return [];
  
  const headers = lines[0].split(',').map(h => h.trim());
  const data = [];
  
  for (let i = 1; i < lines.length; i++) {
    const values = lines[i].split(',').map(v => v.trim());
    const obj = {};
    headers.forEach((header, idx) => {
      obj[header] = values[idx] || '';
    });
    data.push(obj);
  }
  
  return data;
}

globalThis.parseCSV = parseCSV;
window.parseCSV = parseCSV;

// Load TRAINER_EFFECT_DATA from CSV
let TRAINER_EFFECT_DATA = [];
fetch('trainer_effects.csv')
  .then(r => r.text())
  .then(t => {
    TRAINER_EFFECT_DATA = parseCSV(t);
    globalThis.TRAINER_EFFECT_DATA = TRAINER_EFFECT_DATA;
    window.TRAINER_EFFECT_DATA = TRAINER_EFFECT_DATA;
    console.log('[V2-INIT] Loaded TRAINER_EFFECT_DATA:', TRAINER_EFFECT_DATA.length, 'entries');
  })
  .catch(error => {
    console.warn('[V2-INIT] Failed to load trainer_effects.csv:', error);
    globalThis.TRAINER_EFFECT_DATA = [];
    window.TRAINER_EFFECT_DATA = [];
  });

// Shuffle function (Fisher-Yates)
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

// Check if a card is a Basic Pokemon
async function isBasicPokemon(set, num) {
  try {
    const response = await fetch(`https://api.tcgdex.net/v2/en/sets/${set}/${num}`);
    if (!response.ok) return false;
    const data = await response.json();
    return String(data.category || '').toLowerCase() === 'pokemon' &&
           String(data.stage || '').toLowerCase() === 'basic';
  } catch {
    return false;
  }
}

// Draw starting hand for a player
async function drawStartingHand(playerId, matchId, providedDeck = null) {
  console.log('[V2-DRAW] Drawing starting hand for', playerId, 'with provided deck:', providedDeck !== null);
  
  let deck = null;
  
  // If deck is provided, use it directly (for reset scenarios)
  if (providedDeck && Array.isArray(providedDeck) && providedDeck.length >= 5) {
    deck = [...providedDeck];
    console.log('[V2-DRAW] Using provided deck, size:', deck.length);
  } else {
    // Otherwise, read from state
  const state = gameState.getState();
  if (!state || !state[playerId]) {
    console.error('[V2-DRAW] Invalid state or player');
    return;
  }
  
  const player = state[playerId];
    deck = [...(player.deck || [])];
  
  if (deck.length < 5) {
      console.error('[V2-DRAW] Deck too small:', deck.length);
    return;
    }
  }
  
  if (!deck || deck.length < 5) {
    console.error('[V2-DRAW] Deck too small or invalid:', deck?.length);
    return;
  }
  
  // First, verify the deck has at least one Basic Pokemon
  console.log('[V2-DRAW] Verifying deck has Basic Pokemon...');
  let deckHasBasic = false;
  const sampleSize = Math.min(deck.length, 20); // Check first 20 cards
  for (let i = 0; i < sampleSize; i++) {
    const card = deck[i];
    const isBasic = await isBasicPokemon(card.set, card.number || card.num);
    if (isBasic) {
      deckHasBasic = true;
      break;
    }
  }
  
  if (!deckHasBasic) {
    console.warn('[V2-DRAW] Warning: No Basic Pokemon found in first 20 cards. Checking entire deck...');
    // Check entire deck if needed
    for (const card of deck) {
      const isBasic = await isBasicPokemon(card.set, card.number || card.num);
      if (isBasic) {
        deckHasBasic = true;
        break;
      }
    }
  }
  
  if (!deckHasBasic) {
    console.error('[V2-DRAW] ERROR: Deck has no Basic Pokemon! Cannot draw legal starting hand.');
    showPopup('Error: Your deck must contain at least one Basic Pokémon to play.');
    return;
  }
  
  // Keep trying until we get a legal hand (with at least one Basic)
  let tries = 0;
  let hand = [];
  let hasBasic = false;
  const MAX_TRIES = 100; // Increased from 10 to 100 to ensure we get a legal hand
  
  console.log('[V2-DRAW] Attempting to draw legal starting hand (must contain Basic Pokemon)...');
  
  while (tries < MAX_TRIES && !hasBasic) {
    tries++;
    
    // Shuffle the deck each time
    const shuffledDeck = [...deck];
    shuffle(shuffledDeck);
    
    // Draw 5 cards
    hand = shuffledDeck.slice(0, 5);
    
    // Check if hand contains at least one Basic Pokemon
    const basicChecks = await Promise.all(
      hand.map(c => isBasicPokemon(c.set, c.number || c.num))
    );
    
    hasBasic = basicChecks.some(Boolean);
    
    if (hasBasic) {
      console.log('[V2-DRAW] Legal hand found on attempt', tries, ':', {
        handCards: hand.map(c => c.name || `${c.set}-${c.number || c.num}`),
        hasBasic: true
      });
      // Update deck to reflect the shuffled version with cards removed
      deck = shuffledDeck;
      break;
    } else {
      console.log('[V2-DRAW] Attempt', tries, 'failed - no Basic Pokemon in hand');
    }
  }
  
  // Final validation - ensure we have a legal hand
  if (!hasBasic) {
    console.error('[V2-DRAW] ERROR: Failed to draw legal hand after', MAX_TRIES, 'attempts');
    showPopup('Error: Could not draw a legal starting hand. Please check your deck contains Basic Pokémon.');
    return;
  }
  
  // Remove drawn cards from deck
  const remainingDeck = deck.slice(5);
  
  // Update game state using gameState manager
  await gameState.updatePlayerState(playerId, {
    deck: remainingDeck,
    hand: hand
  });
  
  console.log('[V2-DRAW] Starting hand drawn successfully:', { 
    playerId, 
    handSize: hand.length, 
    deckSize: remainingDeck.length,
    attempts: tries,
    handCards: hand.map(c => c.name || `${c.set}-${c.number || c.num}`)
  });
}

// ============================================================================
// CARD INTERACTION HANDLERS
// ============================================================================

/**
 * Fetch card metadata from API
 * @param {string} set - Card set code
 * @param {string|number} num - Card number
 * @returns {Promise<Object>} Card metadata
 */
async function fetchCardMeta(set, num) {
  try {
    const response = await fetch(`https://api.tcgdex.net/v2/en/sets/${set}/${num}`);
    if (!response.ok) return null;
    return await response.json();
  } catch (error) {
    console.error('[V2-CARD] Error fetching card meta:', error);
    return null;
  }
}

// Make fetchCardMeta available globally for effects.js
globalThis.fetchCardMeta = fetchCardMeta;
window.fetchCardMeta = fetchCardMeta;

/**
 * Show popup message (simple alert-style popup)
 * @param {string} message - Message to display
 */
function showPopup(message) {
  // Create or get popup element
  let popup = document.getElementById('v2Popup');
  if (!popup) {
    popup = document.createElement('div');
    popup.id = 'v2Popup';
    popup.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2a2a2a;
      color: white;
      padding: 20px 30px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      z-index: 10000;
      max-width: 400px;
      text-align: center;
      border: 2px solid #0ea5e9;
    `;
    document.body.appendChild(popup);
  }
  
  popup.textContent = message;
  popup.style.display = 'block';
  
  // Auto-hide after 3 seconds
  setTimeout(() => {
    popup.style.display = 'none';
  }, 3000);
}

// Make showPopup available globally for effects.js
globalThis.showPopup = showPopup;
window.showPopup = showPopup;

/**
 * Check if it's the current player's turn
 * @returns {boolean} True if it's the current player's turn
 */
function isMyTurn() {
  const state = gameState.getState();
  if (!state) return false;
  
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  return state.currentPlayer === myPlayerId;
}

/**
 * Validate that it's the player's turn before an action
 * @param {string} actionName - Name of the action for error message
 * @returns {boolean} True if valid, false otherwise
 */
function validateTurn(actionName = 'perform this action') {
  if (!isMyTurn()) {
    showPopup(`Not your turn! You can't ${actionName} right now.`);
    return false;
  }
  return true;
}

/**
 * Handle card click - play card from hand
 * @param {Object} card - Card data
 * @param {string} playerId - Match player ID
 */
async function handleCardClick(card, playerId, handIndex = null) {
  console.log('[V2-CARD] Card clicked:', { card, playerId, handIndex });
  
  // Check if we're in setup phase
  const state = gameState.getState();
  const isSetupPhase = state?.isSetupPhase !== false; // Default to true if not set
  
  // Fetch card metadata to determine type
  const meta = await fetchCardMeta(card.set, card.number || card.num);
  if (!meta) {
    showPopup('Could not fetch card data. Please try again.');
    return;
  }
  
  const category = String(meta.category || '').toLowerCase();
  
  // During setup phase, only Basic Pokemon can be played
  if (isSetupPhase) {
    if (category !== 'pokemon') {
      showPopup("You can only play Basic Pokémon during setup.");
      return;
    }
    
    const stage = String(meta.stage || '').toLowerCase();
    if (stage !== 'basic') {
      showPopup("Only Basic Pokémon can be played during setup.");
      return;
    }
  }
  
  // Handle Pokemon cards
  if (category === 'pokemon') {
    await handlePlayPokemon(card, playerId, meta);
  } else if (category === 'trainer') {
    if (isSetupPhase) {
      showPopup("You can't play Trainer cards during setup.");
      return;
    }
    // Validate turn
    if (!validateTurn('play trainer')) {
      return;
    }
    await handlePlayTrainer(card, playerId, meta, handIndex);
  } else {
    showPopup('Unknown card type');
  }
}

/**
 * Handle playing a Pokemon card from hand
 * @param {Object} card - Card data
 * @param {string} playerId - Match player ID
 * @param {Object} meta - Card metadata
 */
// Track Pokemon being played to prevent multiple plays
const playingPokemon = new Set(); // Set of "playerId-set-num" keys

async function handlePlayPokemon(card, playerId, meta) {
  console.log('[V2-POKEMON] Playing Pokemon:', { card, playerId, meta });
  
  // Check if this is an evolution card (has evolveFrom property)
  const evolveFrom = meta.evolveFrom || meta.evolvesFrom;
  if (evolveFrom) {
    // Enter evolution mode - find compatible Pokemon in play
    await handleEvolutionMode(card, playerId, meta, evolveFrom);
    return;
  }
  
  // Validate: Must be Basic Pokemon (check again here for extra safety)
  const stage = String(meta.stage || '').toLowerCase();
  if (stage !== 'basic') {
    showPopup('Only Basic Pokémon can be played from hand.');
    return;
  }
  
  // Get current state
  const state = gameState.getState();
  if (!state || !state[playerId]) {
    showPopup('Invalid game state');
    return;
  }
  
  const player = state[playerId];
  
  // Check if card is in hand
  const handIndex = player.hand?.findIndex(c => 
    c.set === card.set && (c.number === card.number || c.num === card.num)
  );
  
  if (handIndex === -1 || handIndex === undefined) {
    showPopup('Card not found in hand');
    return;
  }
  
  // Prevent multiple plays of the same card
  const playKey = `${playerId}-${card.set}-${card.number || card.num}`;
  if (playingPokemon.has(playKey)) {
    console.log('[V2-POKEMON] Card is already being played, ignoring duplicate click');
    return;
  }
  
  // Mark as being played
  playingPokemon.add(playKey);
  
  // Determine where to play (active or bench)
  let playTo = 'bench';
  let benchIndex = null;
  
  // Check if active slot is empty
  if (!player.active) {
    playTo = 'active';
  } else {
    // Find empty bench slot
    const bench = player.bench || [];
    for (let i = 0; i < 3; i++) {
      if (!bench[i]) {
        benchIndex = i;
        break;
      }
    }
    
    if (benchIndex === null) {
      showPopup('Bench is full. Cannot play Pokemon.');
      return;
    }
  }
  
  // Create Pokemon object with instance ID
  if (!window.pokemonInstanceCounter) window.pokemonInstanceCounter = 0;
  const instanceId = ++window.pokemonInstanceCounter;
  
  const baseHp = parseInt(meta.hp || '0', 10) || 0;
  const turnNumber = state.turnNumber || 0;
  const pokemon = {
    ...card,
    instanceId: String(instanceId),
    hp: baseHp,
    chp: baseHp,
    baseHp: baseHp,
    maxHp: baseHp,
    energy: [],
    name: meta.name || card.name,
    set: card.set,
    number: card.number || card.num,
    num: card.number || card.num,
    image: card.image || highImgUrl(card.set, card.number || card.num),
    playedTurn: turnNumber  // Set playedTurn so Rare Candy can check eligibility
  };
  
  // Remove from hand
  const newHand = [...player.hand];
  newHand.splice(handIndex, 1);
  
  // Update state
  if (playTo === 'active') {
    await gameState.updatePlayerState(playerId, {
      active: pokemon,
      hand: newHand
    });
    addLog(`Played ${pokemon.name} to Active`);
  } else {
    const newBench = [...(player.bench || [])];
    newBench[benchIndex] = pokemon;
    
    await gameState.updatePlayerState(playerId, {
      bench: newBench,
      hand: newHand
    });
    addLog(`Played ${pokemon.name} to Bench`);
  }
  
  // Broadcast action for opponent
  const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
  await broadcastAction(ACTION_TYPES.PLAY_POKEMON, {
    playerId,
    card: pokemon,
    position: playTo,
    benchIndex: benchIndex
  });
  
  showStatusMessage(`Played ${pokemon.name} to ${playTo === 'active' ? 'Active' : 'Bench'}`);
  
  // Remove from playing set after a short delay (to prevent rapid clicks)
  setTimeout(() => {
    playingPokemon.delete(playKey);
  }, 1000);
}

// Global evolution mode state
let isEvoMode = false;
let evoMeta = null;
let evoCard = null;
let evoPlayerId = null;

/**
 * Handle evolution mode - when clicking an evolution card from hand
 * @param {Object} card - Evolution card from hand
 * @param {string} playerId - Match player ID
 * @param {Object} meta - Card metadata
 * @param {string} evolveFrom - Name of Pokemon this evolves from
 */
async function handleEvolutionMode(card, playerId, meta, evolveFrom) {
  console.log('[V2-EVOLVE-MODE] Entering evolution mode:', { card, playerId, evolveFrom });
  
  // Set evolution mode stateimage.png
  isEvoMode = true;
  evoMeta = meta;
  evoCard = card;
  evoPlayerId = playerId;
  
  const state = gameState.getState();
  if (!state || !state[playerId]) {
    showPopup('Invalid game state');
    return;
  }
  
  const player = state[playerId];
  const evolveFromLower = String(evolveFrom).toLowerCase();
  
  // Fossil Pokemon mapping
  const FOSSIL_MAP = {
    'helix fossil': 'omanyte',
    'dome fossil': 'kabuto',
    'old amber': 'aerodactyl',
    'skull fossil': 'cranidos',
    'armor fossil': 'shieldon'
  };
  
  // Find compatible Pokemon in play
  const compatiblePokemon = [];
  
  // Check active Pokemon
  if (player.active) {
    const activeName = (player.active.name || '').toLowerCase();
    let matches = activeName.includes(evolveFromLower) || evolveFromLower.includes(activeName);
    
    // Check fossil Pokemon
    if (!matches && FOSSIL_MAP[activeName]) {
      const fossilPokemon = FOSSIL_MAP[activeName];
      matches = fossilPokemon === evolveFromLower || evolveFromLower.includes(fossilPokemon);
    }
    
    // Check Eevee evolutions
    if (!matches && activeName.includes('eevee ex')) {
      const EEVEELUTIONS = [
        'vaporeon', 'jolteon', 'flareon', 'espeon', 'umbreon',
        'leafeon', 'glaceon', 'sylveon'
      ];
      const evoCardName = (meta.name || '').toLowerCase();
      if (EEVEELUTIONS.some(e => evoCardName.includes(e))) {
        matches = true;
      }
    }
    
    if (matches) {
      compatiblePokemon.push({
        pokemon: player.active,
        position: 'active',
        benchIndex: null
      });
    }
  }
  
  // Check bench Pokemon
  const bench = player.bench || [];
  for (let i = 0; i < bench.length; i++) {
    if (!bench[i]) continue;
    
    const benchName = (bench[i].name || '').toLowerCase();
    let matches = benchName.includes(evolveFromLower) || evolveFromLower.includes(benchName);
    
    // Check fossil Pokemon
    if (!matches && FOSSIL_MAP[benchName]) {
      const fossilPokemon = FOSSIL_MAP[benchName];
      matches = fossilPokemon === evolveFromLower || evolveFromLower.includes(fossilPokemon);
    }
    
    // Check Eevee evolutions
    if (!matches && benchName.includes('eevee ex')) {
      const EEVEELUTIONS = [
        'vaporeon', 'jolteon', 'flareon', 'espeon', 'umbreon',
        'leafeon', 'glaceon', 'sylveon'
      ];
      const evoCardName = (meta.name || '').toLowerCase();
      if (EEVEELUTIONS.some(e => evoCardName.includes(e))) {
        matches = true;
      }
    }
    
    if (matches) {
      compatiblePokemon.push({
        pokemon: bench[i],
        position: 'bench',
        benchIndex: i
      });
    }
  }
  
  if (compatiblePokemon.length === 0) {
    showPopup(`No valid ${evolveFrom} to evolve.`);
    return;
  }
  
  // Highlight compatible Pokemon and wait for selection
  showPopup(`Select ${evolveFrom} to evolve.`);
  
  // Create proxy objects for awaitSelection
  const compatibleProxies = compatiblePokemon.map(({ pokemon, position, benchIndex }) => {
    return createPokemonProxy(pokemon, playerId, position, benchIndex);
  });
  
  // Add visual highlighting to compatible Pokemon slots
  const uiPlayerId = playerId === 'player1' ? 'p1' : 'p2';
  compatiblePokemon.forEach(({ position, benchIndex }) => {
    if (position === 'active') {
      const activeArea = document.getElementById(`${uiPlayerId}Active`);
      const slot = activeArea?.querySelector('.active-slot');
      if (slot) {
        slot.classList.add('glow-evo');
      }
    } else if (benchIndex !== null) {
      const benchContainer = document.querySelector(`#${uiPlayerId}Bench .bench`);
      const slots = benchContainer?.querySelectorAll('.bench-slot');
      if (slots && slots[benchIndex]) {
        slots[benchIndex].classList.add('glow-evo');
      }
    }
  });
  
  // Wait for user to select a Pokemon
  const selected = await awaitSelection(compatibleProxies);
  
  // Remove highlighting
  compatiblePokemon.forEach(({ position, benchIndex }) => {
    if (position === 'active') {
      const activeArea = document.getElementById(`${uiPlayerId}Active`);
      const slot = activeArea?.querySelector('.active-slot');
      if (slot) {
        slot.classList.remove('glow-evo');
      }
    } else if (benchIndex !== null) {
      const benchContainer = document.querySelector(`#${uiPlayerId}Bench .bench`);
      const slots = benchContainer?.querySelectorAll('.bench-slot');
      if (slots && slots[benchIndex]) {
        slots[benchIndex].classList.remove('glow-evo');
      }
    }
  });
  
  // Clear evolution mode state
  isEvoMode = false;
  evoMeta = null;
  evoCard = null;
  evoPlayerId = null;
  
  if (!selected) {
    showPopup('Evolution cancelled.');
    return;
  }
  
  // Find the selected Pokemon data
  const selectedInstanceId = selected.__v2_pokemon?.instanceId;
  const selectedData = compatiblePokemon.find(
    ({ pokemon }) => pokemon.instanceId === selectedInstanceId
  );
  
  if (!selectedData) {
    showPopup('Selected Pokemon not found.');
    return;
  }
  
  // Evolve the selected Pokemon
  const targetProxy = createPokemonProxy(
    selectedData.pokemon,
    playerId,
    selectedData.position,
    selectedData.benchIndex
  );
  
  await evolveCard(targetProxy, meta, card, playerId, card.set, card.number || card.num);
}

/**
 * Handle playing a Trainer card from hand
 * @param {Object} card - Card data
 * @param {string} playerId - Match player ID
 * @param {Object} meta - Card metadata
 */
async function handlePlayTrainer(card, playerId, meta, handIndex = null) {
  console.log('[V2-TRAINER] Playing trainer:', { card, playerId, meta, handIndex });
  
  const state = gameState.getState();
  if (!state || !state[playerId]) {
    showPopup('Invalid game state');
    return;
  }
  
  const player = state[playerId];
  const trainerType = String(meta.trainerType || '').toLowerCase();
  
  // Check supporter restriction (one per turn)
  if (trainerType === 'supporter') {
    if (hasPlayedSupporterThisTurn) {
      showPopup('You can only play one Supporter card per turn.');
      return;
    }
  }
  
  // Get trainer effect data
  // Card ID format: SET-NUM (e.g., "B1-071")
  const cardNum = String(card.number || card.num || '').padStart(3, '0');
  const cardId = `${card.set}-${cardNum}`;
  
  // Get TRAINER_EFFECT_DATA from global scope, wait if not loaded yet
  let TRAINER_EFFECT_DATA = globalThis.TRAINER_EFFECT_DATA || window.TRAINER_EFFECT_DATA || [];
  
  // Wait for TRAINER_EFFECT_DATA to load if it's not ready
  if (!TRAINER_EFFECT_DATA || TRAINER_EFFECT_DATA.length === 0) {
    console.log('[V2-TRAINER] Waiting for TRAINER_EFFECT_DATA to load...');
    for (let i = 0; i < 20 && (!TRAINER_EFFECT_DATA || TRAINER_EFFECT_DATA.length === 0); i++) {
      await new Promise(resolve => setTimeout(resolve, 100));
      TRAINER_EFFECT_DATA = globalThis.TRAINER_EFFECT_DATA || window.TRAINER_EFFECT_DATA || [];
    }
  }
  
  if (!TRAINER_EFFECT_DATA || TRAINER_EFFECT_DATA.length === 0) {
    showPopup('Trainer effects database not loaded yet. Please try again.');
    console.warn('[V2-TRAINER] TRAINER_EFFECT_DATA not available');
    return;
  }
  
  const effectData = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
  
  if (!effectData || !effectData.effect_type) {
    showPopup(`Trainer effect not found for ${meta.name || 'this card'}.`);
    console.warn('[V2-TRAINER] Effect data not found:', { 
      cardId, 
      card, 
      meta,
      availableIds: TRAINER_EFFECT_DATA.slice(0, 10).map(e => e.id),
      totalEffects: TRAINER_EFFECT_DATA.length
    });
    return;
  }
  
  console.log('[V2-TRAINER] Found effect data:', effectData);
  
  // Validate that the effect handler exists before proceeding
  let TRAINER_EFFECTS = globalThis.TRAINER_EFFECTS || window.TRAINER_EFFECTS;
  if (!TRAINER_EFFECTS || Object.keys(TRAINER_EFFECTS).length === 0) {
    // Wait for effects.js to load
    for (let i = 0; i < 10 && (!TRAINER_EFFECTS || Object.keys(TRAINER_EFFECTS).length === 0); i++) {
      await new Promise(resolve => setTimeout(resolve, 100));
      TRAINER_EFFECTS = globalThis.TRAINER_EFFECTS || (typeof window !== 'undefined' ? window.TRAINER_EFFECTS : null);
    }
  }
  
  if (!TRAINER_EFFECTS) {
    showPopup('Trainer effects library not loaded. Please refresh.');
    console.error('[V2-TRAINER] TRAINER_EFFECTS not available');
    return;
  }
  
  const handler = TRAINER_EFFECTS[effectData.effect_type];
  if (!handler) {
    showPopup(`Effect "${effectData.effect_type}" not implemented for ${meta.name || 'this card'}.`);
    console.warn('[V2-TRAINER] Handler not found:', {
      effectType: effectData.effect_type,
      trainerName: meta.name,
      availableEffects: Object.keys(TRAINER_EFFECTS).slice(0, 10)
    });
    return;
  }
  
  // Remove card from hand BEFORE applying effect
  // This ensures the effect sees the updated hand (important for draw effects)
  let cardIndex = handIndex;
  if (cardIndex === null || cardIndex === undefined) {
    // Fallback: find first matching card
    cardIndex = player.hand?.findIndex(c => 
      c.set === card.set && (c.number || c.num) === (card.number || card.num)
    );
  }
  
  if (cardIndex === -1 || cardIndex === undefined) {
    showPopup('Card not found in hand');
    return;
  }
  
  // Remove only the card at this index (splice removes only one element)
  const newHand = [...player.hand];
  newHand.splice(cardIndex, 1);
  
  // Add card to discard
  // Discard is structured as { cards: [], energyCounts: {} }
  const discard = player.discard || { cards: [], energyCounts: {} };
  if (!discard.cards) {
    discard.cards = [];
  }
  discard.cards.push(card);
  
  // Update game state FIRST (remove card from hand before effect)
  await gameState.updatePlayerState(playerId, {
    hand: newHand,
    discard: discard
  });
  
  // Also update globalThis.playerState so effects see the updated hand
  if (!globalThis.playerState) {
    globalThis.playerState = {};
  }
  if (!globalThis.playerState[playerId]) {
    globalThis.playerState[playerId] = {};
  }
  globalThis.playerState[playerId].hand = [...newHand];
  globalThis.playerState[playerId].discard = discard;
  
  // Now try to apply the effect - only proceed if it succeeds
  let effectSucceeded = false;
  try {
    await applyTrainerEffectV2(effectData, playerId, meta);
    effectSucceeded = true;
  } catch (error) {
    // Handle SELECTION_CANCELLED - user cancelled, but card is already discarded
    if (error.message === 'SELECTION_CANCELLED') {
      console.log('[V2-TRAINER] Effect cancelled by user, card already discarded');
      // Put card back in hand since effect was cancelled
      const restoredHand = [...newHand, card];
      const restoredDiscard = { ...discard };
      restoredDiscard.cards = discard.cards.filter(c => 
        !(c.set === card.set && (c.number || c.num) === (card.number || card.num))
      );
      await gameState.updatePlayerState(playerId, {
        hand: restoredHand,
        discard: restoredDiscard
      });
      if (globalThis.playerState && globalThis.playerState[playerId]) {
        globalThis.playerState[playerId].hand = restoredHand;
        globalThis.playerState[playerId].discard = restoredDiscard;
      }
      return;
    }
    // For other errors, show error (card is already discarded)
    console.error('[V2-TRAINER] Error applying trainer effect:', error);
    showPopup(`Trainer effect error: ${error.message || 'Unknown error'}`);
    return;
  }
  
  // Effect succeeded - card is already discarded
  
  // Mark supporter as played
  if (trainerType === 'supporter') {
    hasPlayedSupporterThisTurn = true;
  }
  
  // Broadcast action
  const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
  await broadcastAction(ACTION_TYPES.PLAY_TRAINER, {
    playerId,
    card: card,
    trainerType: trainerType,
    trainerName: meta.name,
    effectType: effectData.effect_type
  });
  
  showStatusMessage(`Played ${meta.name || 'Trainer'}`);
  addLog(`Played ${meta.name || 'Trainer'}`);
}

/**
 * V2-compatible drawCards function
 * Works with gameState instead of DOM
 */
globalThis.drawCards = async function (_st, pk, n) {
  const playerId = pk === 'p1' ? 'player1' : 'player2';
  const drawCount = parseInt(n) || 0;
  
  const state = gameState.getState();
  if (!state || !state[playerId]) {
    console.error('[V2-drawCards] Invalid state');
    return;
  }
  
  const player = state[playerId];
  const deck = [...(player.deck || [])];
  const hand = [...(player.hand || [])];
  const drawnCards = [];
  
  for (let i = 0; i < drawCount && deck.length > 0; i++) {
    const card = deck.shift();
    hand.push(card);
    drawnCards.push(card);
  }
  
  // Update globalThis.playerState FIRST (before gameState) so effects can see the changes
  if (!globalThis.playerState) {
    globalThis.playerState = {};
  }
  if (!globalThis.playerState[playerId]) {
    globalThis.playerState[playerId] = {};
  }
  globalThis.playerState[playerId].deck = [...deck];
  globalThis.playerState[playerId].hand = [...hand];
  
  // Update oldState format for effect handlers
  if (_st && _st[pk]) {
    _st[pk].deck = [...deck];
    _st[pk].hand = [...hand];
  }
  
  // Update gameState AFTER updating globalThis.playerState
  // This ensures the state is synced to Firebase and persisted
  // Set a flag to prevent Firebase listener from overwriting our changes
  if (!globalThis.__updatingState) {
    globalThis.__updatingState = new Set();
  }
  globalThis.__updatingState.add(`${playerId}/hand`);
  globalThis.__updatingState.add(`${playerId}/deck`);
  
  try {
    // Set flag to prevent render during update
    globalThis.__isUpdatingLocalState = true;
    
    await gameState.updatePlayerState(playerId, {
      deck: deck,
      hand: hand
    });
    
      // Clear the render flag immediately so UI can update
      globalThis.__isUpdatingLocalState = false;
      
      // Force a render to update the UI immediately
      // Use the updated state directly to ensure we render the correct hand size
      const currentState = gameState.getState();
      if (currentState) {
        // Ensure the state has our updated hand and deck
        currentState[playerId] = {
          ...currentState[playerId],
          hand: hand,
          deck: deck
        };
        console.log('[V2-drawCards] Forcing immediate render after draw:', {
          handSize: hand.length,
          deckSize: deck.length,
          stateHandSize: currentState[playerId]?.hand?.length
        });
        renderAll(currentState);
      }
      
      // Keep the flag for a short time to prevent race conditions
      setTimeout(() => {
        if (globalThis.__updatingState) {
          globalThis.__updatingState.delete(`${playerId}/hand`);
          globalThis.__updatingState.delete(`${playerId}/deck`);
        }
      }, 1000);
  } catch (error) {
    // Clear flags on error
    globalThis.__isUpdatingLocalState = false;
    if (globalThis.__updatingState) {
      globalThis.__updatingState.delete(`${playerId}/hand`);
      globalThis.__updatingState.delete(`${playerId}/deck`);
    }
    throw error;
  }
  
  if (drawnCards.length > 0) {
    console.log(`[V2-drawCards] Drew ${drawnCards.length} card(s) for ${playerId}`, {
      newHandSize: hand.length,
      newDeckSize: deck.length,
      drawnCardNames: drawnCards.map(c => c.name)
    });
  }
};

/**
 * V2-compatible shuffleDeckAndAnimate
 * Simplified - just shuffles, no animation needed
 */
function shuffleDeckAndAnimate(state, pk) {
  if (state && state[pk] && state[pk].deck) {
    shuffle(state[pk].deck);
  }
}

// Make it available globally for effects.js
globalThis.shuffleDeckAndAnimate = shuffleDeckAndAnimate;

// Stub functions for effects.js compatibility
globalThis.renderAllHands = function() {
  // V2 uses reactive UI, so this is handled by gameState.subscribe
  // No-op for compatibility
};

globalThis.updateDeckBubbles = function() {
  // V2 uses reactive UI, so this is handled by gameState.subscribe
  // No-op for compatibility
};

globalThis.logEvent = function(event) {
  // Simple logging for effects.js compatibility
  if (event && event.text) {
    addLog(event.text);
  }
};

// ============================================================================
// V2-COMPATIBLE DOM FUNCTIONS FOR EFFECTS.JS
// These functions bridge the old DOM-based effects to the new state-first system
// ============================================================================

/**
 * V2-compatible getActiveImg - returns a proxy object that mimics an img element
 * @param {string} pk - Player key ('p1' or 'p2')
 * @returns {Object|null} Proxy object with dataset, alt, src properties, or null
 */
function getActiveImg(pk) {
  const playerId = pk === 'p1' ? 'player1' : 'player2';
  const state = gameState.getState();
  if (!state || !state[playerId] || !state[playerId].active) {
    return null;
  }
  
  const pokemon = state[playerId].active;
  return createPokemonProxy(pokemon, playerId, 'active', null);
}

/**
 * V2-compatible getAllPokemonImgs - returns array of proxy objects for all Pokémon
 * @param {string} pk - Player key ('p1' or 'p2', but in V2 p1 always means "you")
 * @returns {Array} Array of proxy objects
 */
function getAllPokemonImgs(pk) {
  // In V2, p1 always means "you" (the current player viewing the screen)
  // So we need to determine the actual match player ID
  // IMPORTANT: isCurrentPlayer1() must be available (imported from sync.js)
  let myPlayerId, playerId;
  
  if (typeof isCurrentPlayer1 !== 'function') {
    console.error('[V2-getAllPokemonImgs] isCurrentPlayer1 is not a function!', typeof isCurrentPlayer1);
    // Fallback: try to get it from globalThis
    const isCurrentPlayer1Fn = globalThis.isCurrentPlayer1;
    if (typeof isCurrentPlayer1Fn !== 'function') {
      console.error('[V2-getAllPokemonImgs] globalThis.isCurrentPlayer1 is also not a function!');
      return [];
    }
    myPlayerId = isCurrentPlayer1Fn() ? 'player1' : 'player2';
    playerId = pk === 'p1' ? myPlayerId : (myPlayerId === 'player1' ? 'player2' : 'player1');
    console.log('[V2-getAllPokemonImgs] Using globalThis.isCurrentPlayer1 fallback:', { pk, myPlayerId, playerId });
  } else {
    myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
    
    // If pk is 'p1', return Pokemon for the current player (you)
    // If pk is 'p2', return Pokemon for the opponent
    playerId = pk === 'p1' ? myPlayerId : (myPlayerId === 'player1' ? 'player2' : 'player1');
    
    console.log('[V2-getAllPokemonImgs] Player mapping:', {
      pk,
      myPlayerId,
      playerId,
      isCurrentPlayer1: isCurrentPlayer1(),
      isCurrentPlayer1Type: typeof isCurrentPlayer1
    });
  }
  
  const state = gameState.getState();
  if (!state || !state[playerId]) {
    console.log('[V2-getAllPokemonImgs] No state or player:', { pk, playerId, myPlayerId, hasState: !!state, hasPlayer: !!(state && state[playerId]) });
    return [];
  }
  
  const pokemon = [];
  const player = state[playerId];
  
  console.log('[V2-getAllPokemonImgs] Player state:', {
    playerId,
    hasActive: !!player.active,
    activeName: player.active?.name,
    benchLength: player.bench?.length || 0
  });
  
  // Add active Pokémon
  if (player.active) {
    pokemon.push(createPokemonProxy(player.active, playerId, 'active', null));
    console.log('[V2-getAllPokemonImgs] Added active:', player.active.name, 'for playerId:', playerId);
  }
  
  // Add bench Pokémon
  const bench = player.bench || [];
  console.log('[V2-getAllPokemonImgs] Bench array:', {
    length: bench.length,
    bench: bench.map((p, i) => p ? { index: i, name: p.name, instanceId: p.instanceId } : { index: i, value: null })
  });
  
  for (let i = 0; i < bench.length; i++) {
    if (bench[i]) {
      pokemon.push(createPokemonProxy(bench[i], playerId, 'bench', i));
      console.log('[V2-getAllPokemonImgs] Added bench Pokemon:', { index: i, name: bench[i].name });
    } else {
      console.log('[V2-getAllPokemonImgs] Skipped null bench slot:', i);
    }
  }
  
  console.log('[V2-getAllPokemonImgs] Total Pokemon found:', {
    count: pokemon.length,
    names: pokemon.map(p => p.alt)
  });
  
  return pokemon;
}

/**
 * V2-compatible getBenchImgs - returns array of proxy objects for bench Pokémon
 * @param {string} pk - Player key ('p1' or 'p2')
 * @returns {Array} Array of proxy objects
 */
function getBenchImgs(pk) {
  const playerId = pk === 'p1' ? 'player1' : 'player2';
  const state = gameState.getState();
  if (!state || !state[playerId]) {
    return [];
  }
  
  const pokemon = [];
  const bench = state[playerId].bench || [];
  for (let i = 0; i < bench.length; i++) {
    if (bench[i]) {
      pokemon.push(createPokemonProxy(bench[i], playerId, 'bench', i));
    }
  }
  
  return pokemon;
}

/**
 * Create a proxy object that mimics an img element for compatibility with effects.js
 * @param {Object} pokemon - Pokémon object from gameState
 * @param {string} playerId - Player ID ('player1' or 'player2')
 * @param {string} position - 'active' or 'bench'
 * @param {number|null} benchIndex - Bench index if bench Pokémon, null if active
 * @returns {Object} Proxy object with img-like properties
 */
function createPokemonProxy(pokemon, playerId, position, benchIndex) {
  const pk = playerId === 'player1' ? 'p1' : 'p2';
  
  // Create a writable dataset object (plain object, not a getter/setter)
  // This allows effects to set properties like evolvedViaRareCandy
  const datasetObj = {
      set: pokemon.set || '',
      num: pokemon.number || pokemon.num || '',
      number: pokemon.number || pokemon.num || '',
      instanceId: pokemon.instanceId || '',
    hp: String(pokemon.maxHp || pokemon.baseHp || pokemon.hp || 0),
      chp: String(pokemon.chp || pokemon.hp || 0),
    maxHp: String(pokemon.maxHp || pokemon.baseHp || pokemon.hp || 0),
    playedTurn: String(pokemon.playedTurn || 0),
    isFossil: pokemon.isFossil ? 'true' : 'false'
  };
  
  return {
    // Dataset properties (like img.dataset.set, img.dataset.num, etc.)
    // Plain object that can be modified (e.g., dataset.evolvedViaRareCandy = 'true')
    dataset: datasetObj,
    // Alt text (Pokémon name)
    alt: pokemon.name || 'Pokémon',
    // Image source
    src: pokemon.image || highImgUrl(pokemon.set, pokemon.number || pokemon.num) || 'imgs/cardback.png',
    // V2-specific properties for internal use
    __v2_pokemon: pokemon,
    __v2_playerId: playerId,
    __v2_position: position,
    __v2_benchIndex: benchIndex,
    __v2_pk: pk,
    // closest() method for compatibility (returns a slot proxy or player div)
    closest: function(selector) {
      if (selector === '.card-slot') {
        return createSlotProxy(pokemon, playerId, position, benchIndex);
      }
      // For Rare Candy compatibility - check if selector is #player1 or #player2
      if (selector === '#player1' && playerId === 'player1') {
        return { id: 'player1' };
      }
      if (selector === '#player2' && playerId === 'player2') {
        return { id: 'player2' };
      }
      return null;
    }
  };
}

/**
 * Create a proxy object that mimics a card slot element
 * @param {Object} pokemon - Pokémon object
 * @param {string} playerId - Player ID
 * @param {string} position - 'active' or 'bench'
 * @param {number|null} benchIndex - Bench index
 * @returns {Object} Slot proxy object
 */
function createSlotProxy(pokemon, playerId, position, benchIndex) {
  return {
    dataset: {
      maxHp: String(pokemon.maxHp || pokemon.baseHp || 0),
      empty: '0'
    },
    querySelector: function(selector) {
      // For energy-pips, return a proxy that allows energy manipulation
      if (selector === '.energy-pips') {
        return {
          __v2_pokemon: pokemon,
          __v2_playerId: playerId,
          __v2_position: position,
          __v2_benchIndex: benchIndex
        };
      }
      return null;
    },
    appendChild: function() {
      // No-op for compatibility
    },
    innerHTML: '',
    __v2_pokemon: pokemon,
    __v2_playerId: playerId,
    __v2_position: position,
    __v2_benchIndex: benchIndex
  };
}

/**
 * V2-compatible healImg - heals a Pokémon by updating gameState
 * @param {Object} imgProxy - Proxy object from getActiveImg/getAllPokemonImgs
 * @param {number} amount - Amount to heal
 * @returns {boolean} True if healed, false otherwise
 */
async function healImg(imgProxy, amount) {
  if (!imgProxy || !imgProxy.__v2_pokemon || amount <= 0) {
    return false;
  }
  
  const pokemon = imgProxy.__v2_pokemon;
  const playerId = imgProxy.__v2_playerId;
  const position = imgProxy.__v2_position;
  const benchIndex = imgProxy.__v2_benchIndex;
  
  // Check for heal-blocking abilities
  const state = gameState.getState();
  const allPokemon = [];
  if (state.player1?.active) allPokemon.push(state.player1.active);
  if (state.player1?.bench) allPokemon.push(...state.player1.bench.filter(p => p));
  if (state.player2?.active) allPokemon.push(state.player2.active);
  if (state.player2?.bench) allPokemon.push(...state.player2.bench.filter(p => p));
  
  for (const p of allPokemon) {
    const cacheKey = `${p.set}-${p.number || p.num}`;
    const abilityRow = globalThis.abilityCache?.[cacheKey];
    if (abilityRow?.effect_type === 'prevent_all_healing') {
      showPopup(`Heal Block: ${p.name} prevents all healing!`);
      return false;
    }
  }
  
  const maxHp = pokemon.maxHp || pokemon.baseHp || 0;
  const currentHp = pokemon.chp || pokemon.hp || 0;
  
  if (currentHp >= maxHp) {
    return false; // Already at full HP
  }
  
  const newHp = Math.min(maxHp, currentHp + amount);
  
  // Update gameState
  if (position === 'active') {
    await gameState.updatePlayerState(playerId, {
      active: {
        ...pokemon,
        chp: newHp
      }
    });
  } else if (position === 'bench' && benchIndex !== null) {
    const bench = [...(state[playerId].bench || [])];
    bench[benchIndex] = {
      ...pokemon,
      chp: newHp
    };
    await gameState.updatePlayerState(playerId, {
      bench: bench
    });
  }
  
  // Update the proxy object's dataset for compatibility
  imgProxy.dataset.chp = String(newHp);
  pokemon.chp = newHp;
  
  return true;
}

/**
 * V2-compatible attachEnergy - attaches energy to a Pokémon
 * @param {Object} imgProxy - Proxy object from getActiveImg/getAllPokemonImgs
 * @param {string} energyType - Energy type to attach
 * @returns {boolean} True if attached, false otherwise
 */
async function attachEnergy(imgProxy, energyType) {
  if (!imgProxy || !imgProxy.__v2_pokemon || !energyType) {
    return false;
  }
  
  const pokemon = imgProxy.__v2_pokemon;
  const playerId = imgProxy.__v2_playerId;
  const position = imgProxy.__v2_position;
  const benchIndex = imgProxy.__v2_benchIndex;
  
  // Add energy to Pokémon's energy array
  const energy = pokemon.energy || [];
  energy.push(energyType);
  
  // Update gameState
  const state = gameState.getState();
  if (position === 'active') {
    await gameState.updatePlayerState(playerId, {
      active: {
        ...pokemon,
        energy: energy
      }
    });
  } else if (position === 'bench' && benchIndex !== null) {
    const bench = [...(state[playerId].bench || [])];
    bench[benchIndex] = {
      ...pokemon,
      energy: energy
    };
    await gameState.updatePlayerState(playerId, {
      bench: bench
    });
  }
  
  return true;
}

/**
 * V2-compatible getSlotFromImg - returns slot proxy from img proxy
 * @param {Object} imgProxy - Proxy object from getActiveImg/getAllPokemonImgs
 * @returns {Object|null} Slot proxy object
 */
function getSlotFromImg(imgProxy) {
  if (!imgProxy || !imgProxy.__v2_pokemon) {
    return null;
  }
  return createSlotProxy(
    imgProxy.__v2_pokemon,
    imgProxy.__v2_playerId,
    imgProxy.__v2_position,
    imgProxy.__v2_benchIndex
  );
}

/**
 * V2-compatible awaitSelection - creates selection UI for choosing targets
 * @param {Array} candidates - Array of img proxy objects
 * @param {string} glowClass - CSS class for highlighting (default: 'heal-glow')
 * @returns {Promise<Object|null>} Selected img proxy or null if cancelled
 */
function awaitSelection(candidates, glowClass = 'heal-glow') {
  console.log('[V2-SELECTION] awaitSelection called:', {
    candidatesCount: candidates?.length || 0,
    glowClass,
    candidates: candidates?.map(c => c.alt || c.__v2_pokemon?.name || 'unknown')
  });
  
  return new Promise((resolve, reject) => {
    try {
    // Check if it's the current player's turn (for online mode)
    const getCurrentMatchIdFn = globalThis.getCurrentMatchId;
    const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
    const isOnline = matchId && (typeof window !== 'undefined' && window.firebaseDatabase);
    const isSabrinaSelection = globalThis.__silverSelectionActive;
      const isForceSwitchSelection = globalThis.__forceSwitchSelection;
      
      console.log('[V2-SELECTION] Turn check:', {
        isOnline,
        matchId,
        isSabrinaSelection,
        isForceSwitchSelection
      });
      
      if (isOnline && !isSabrinaSelection && !isForceSwitchSelection) {
      const isCurrentPlayer1Fn = globalThis.isCurrentPlayer1;
      const isMyTurn = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
        
        console.log('[V2-SELECTION] Turn check result:', { isMyTurn });
      
      if (!isMyTurn) {
        console.log('[V2-SELECTION] Blocking selection - not current player\'s turn');
        resolve(null);
        return;
      }
    }
    
    if (!candidates || candidates.length === 0) {
        console.warn('[V2-SELECTION] No candidates provided');
      resolve(null);
      return;
    }
      
      console.log('[V2-SELECTION] Filtering candidates:', {
        candidatesCount: candidates.length,
        candidates: candidates.map(c => ({
          hasV2Pokemon: !!c.__v2_pokemon,
          name: c.alt || c.__v2_pokemon?.name,
          position: c.__v2_position,
          benchIndex: c.__v2_benchIndex
        }))
      });
    
    // Filter valid candidates (must be in play, not in hand)
    const validCandidates = candidates.filter(imgProxy => {
      // In V2, all candidates from getAllPokemonImgs are already in play
      // Check if it's a proxy object (has __v2_pokemon) or a DOM element
      const isProxy = imgProxy && imgProxy.__v2_pokemon;
      const isDOMElement = imgProxy instanceof HTMLElement || (imgProxy && imgProxy.tagName === 'IMG');
      
      if (!isProxy && !isDOMElement) {
        console.warn('[V2-SELECTION] Invalid candidate (neither proxy nor DOM):', imgProxy);
        return false;
      }
      
      // If it's a DOM element, we need to find the corresponding proxy
      // by looking up the Pokemon by instanceId
      if (isDOMElement && !isProxy) {
        const instanceId = imgProxy.dataset?.instanceId;
        if (!instanceId) {
          console.warn('[V2-SELECTION] DOM element has no instanceId:', imgProxy);
          return false;
        }
        
        // Find the corresponding proxy from the original candidates
        // This shouldn't happen, but handle it just in case
        console.warn('[V2-SELECTION] DOM element passed instead of proxy, trying to find proxy by instanceId:', instanceId);
        // For now, we'll try to create a proxy from the DOM element's data
        // This is a fallback - ideally we should fix why DOM elements are being passed
        return true; // Allow it through and handle in highlighting
      }
      
      return isProxy;
    });
    
    console.log('[V2-SELECTION] Valid candidates:', {
      validCount: validCandidates.length,
      totalCount: candidates.length
    });
    
    if (validCandidates.length === 0) {
      console.warn('[V2-SELECTION] No valid candidates after filtering');
      resolve(null);
      return;
    }
    
    // Highlight valid candidates by adding glow to their DOM elements
    const highlightedElements = [];
    validCandidates.forEach(candidate => {
      // Handle both proxy objects and DOM elements
      let imgProxy = candidate;
      let playerId, position, benchIndex;
      
      if (candidate.__v2_pokemon) {
        // It's a proxy object
        playerId = candidate.__v2_playerId;
        position = candidate.__v2_position;
        benchIndex = candidate.__v2_benchIndex;
      } else if (candidate instanceof HTMLElement || candidate.tagName === 'IMG') {
        // It's a DOM element - find the corresponding Pokemon from state
        const instanceId = candidate.dataset?.instanceId;
        if (!instanceId) {
          console.warn('[V2-SELECTION] DOM element has no instanceId, skipping');
          return;
        }
        
        // Find the Pokemon in state
        const state = gameState.getState();
        let foundPokemon = null;
        let foundPlayerId = null;
        let foundPosition = null;
        let foundBenchIndex = null;
        
        // Check both players
        for (const pid of ['player1', 'player2']) {
          if (state[pid]?.active?.instanceId === instanceId) {
            foundPokemon = state[pid].active;
            foundPlayerId = pid;
            foundPosition = 'active';
            foundBenchIndex = null;
            break;
          }
          
          const bench = state[pid]?.bench || [];
          for (let i = 0; i < bench.length; i++) {
            if (bench[i]?.instanceId === instanceId) {
              foundPokemon = bench[i];
              foundPlayerId = pid;
              foundPosition = 'bench';
              foundBenchIndex = i;
              break;
            }
          }
          if (foundPokemon) break;
        }
        
        if (!foundPokemon) {
          console.warn('[V2-SELECTION] Could not find Pokemon for instanceId:', instanceId);
          return;
        }
        
        // Create a proxy for this Pokemon
        imgProxy = createPokemonProxy(foundPokemon, foundPlayerId, foundPosition, foundBenchIndex);
        playerId = foundPlayerId;
        position = foundPosition;
        benchIndex = foundBenchIndex;
      } else {
        console.warn('[V2-SELECTION] Unknown candidate type:', candidate);
        return;
      }
      
      // Find the actual DOM element
      // In V2, p1 is always "you" (current player) and p2 is always "opponent"
      const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
      const uiPlayerId = playerId === myPlayerId ? 'p1' : 'p2';
      
      let element = null;
      if (position === 'active') {
        const activeSlot = document.querySelector(`#${uiPlayerId}Active .active-slot`);
        if (activeSlot) {
          const img = activeSlot.querySelector('img');
          if (img) element = img;
        }
      } else if (position === 'bench' && benchIndex !== null) {
        // Try multiple selector patterns to find bench slots
        const benchContainer = document.querySelector(`#${uiPlayerId}Bench .bench`);
        if (benchContainer) {
          const benchSlots = benchContainer.querySelectorAll('.bench-slot');
          if (benchSlots && benchSlots[benchIndex]) {
            const img = benchSlots[benchIndex].querySelector('img:not(.tool-thumb)');
            if (img) {
              element = img;
            } else {
              // If no img found, try to find it in the slot itself
              const slot = benchSlots[benchIndex];
              const allImgs = slot.querySelectorAll('img');
              if (allImgs.length > 0) {
                element = allImgs[0]; // Use first img if no non-tool-thumb found
              }
            }
          } else {
            console.warn('[V2-SELECTION] Bench slot not found:', {
              uiPlayerId,
              benchIndex,
              totalSlots: benchSlots?.length || 0,
              selector: `#${uiPlayerId}Bench .bench`
            });
          }
        } else {
          console.warn('[V2-SELECTION] Bench container not found:', {
            uiPlayerId,
            selector: `#${uiPlayerId}Bench .bench`
          });
        }
      }
      
      if (element) {
        element.classList.add(glowClass);
        highlightedElements.push({ element, imgProxy });
        
        // Also add glow to the parent bench slot for better visibility
        if (position === 'bench' && benchIndex !== null) {
          // uiPlayerId already calculated above
          const benchContainer = document.querySelector(`#${uiPlayerId}Bench .bench`);
          if (benchContainer) {
            const benchSlots = benchContainer.querySelectorAll('.bench-slot');
            if (benchSlots && benchSlots[benchIndex]) {
              benchSlots[benchIndex].classList.add(glowClass);
            }
          }
        }
        
        console.log('[V2-SELECTION] Highlighted element:', {
          playerId,
          position,
          benchIndex,
          elementFound: !!element,
          glowClass
        });
      } else {
        console.warn('[V2-SELECTION] Could not find DOM element for:', {
          playerId,
          position,
          benchIndex
        });
      }
    });
    
    console.log('[V2-SELECTION] Highlighting complete:', {
      highlightedCount: highlightedElements.length,
      candidatesCount: validCandidates.length,
      highlightedElements: highlightedElements.map(h => ({
        name: h.imgProxy.alt,
        position: h.imgProxy.__v2_position,
        benchIndex: h.imgProxy.__v2_benchIndex,
        elementFound: !!h.element
      }))
    });
    
    if (highlightedElements.length === 0) {
      console.warn('[V2-SELECTION] No highlighted elements found!');
      showPopup('No valid targets found.');
      resolve(null);
      return;
    }
    
    // Check if cancellation is allowed (Sabrina doesn't allow cancellation)
    const allowCancel = !globalThis.__forceSwitchNoCancel;
    const cancelMessage = allowCancel ? 'Press ESC to cancel.' : '';
    showPopup(`Click on a highlighted Pokémon to select it. ${cancelMessage}`);
    
    // Set global flag to indicate selection is active
    globalThis.__selectionActive = true;
    
    const cleanup = () => {
      document.removeEventListener('click', clickHandler, true);
      if (allowCancel) {
      document.removeEventListener('keydown', escapeHandler);
      }
      highlightedElements.forEach(({ element, imgProxy }) => {
        if (element && element.classList) {
        element.classList.remove(glowClass);
        }
        
        // Also remove glow from parent bench slot
        if (imgProxy && imgProxy.__v2_position === 'bench' && imgProxy.__v2_benchIndex !== null) {
          const playerId = imgProxy.__v2_playerId;
          // In V2, p1 is always "you" (current player) and p2 is always "opponent"
          const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
          const uiPlayerId = playerId === myPlayerId ? 'p1' : 'p2';
          const benchContainer = document.querySelector(`#${uiPlayerId}Bench .bench`);
          if (benchContainer) {
            const benchSlots = benchContainer.querySelectorAll('.bench-slot');
            if (benchSlots && benchSlots[imgProxy.__v2_benchIndex]) {
              benchSlots[imgProxy.__v2_benchIndex].classList.remove(glowClass);
            }
          }
        }
      });
      globalThis.__forceSwitchNoCancel = false; // Reset flag
      globalThis.__forceSwitchSelection = false; // Reset selection flag
      globalThis.__selectionActive = false; // Reset selection active flag
    };
    
    const clickHandler = (e) => {
      console.log('[V2-SELECTION] Click detected:', {
        target: e.target,
        targetTag: e.target.tagName,
        targetClass: e.target.className,
        hasGlow: e.target.classList?.contains(glowClass)
      });
      
      // Check if click is on a bench slot or active slot
      const clickedSlot = e.target.closest('.bench-slot') || e.target.closest('.active-slot');
      const clickedImg = e.target.closest('img');
      
      // If clicking on a slot, find the img inside it
      let targetImg = clickedImg;
      if (clickedSlot && !clickedImg) {
        targetImg = clickedSlot.querySelector('img:not(.tool-thumb)');
      }
      
      // Also check if the clicked element itself is an img
      if (!targetImg && e.target.tagName === 'IMG') {
        targetImg = e.target;
      }
      
      console.log('[V2-SELECTION] Target img found:', {
        targetImg: !!targetImg,
        targetImgInstanceId: targetImg?.dataset.instanceId,
        clickedSlot: !!clickedSlot,
        slotIndex: clickedSlot?.dataset.index
      });
      
      if (!targetImg) {
        // If cancellation is not allowed, don't allow clicking outside
        if (!allowCancel) {
          e.stopPropagation();
          e.preventDefault();
          showPopup('You must select a highlighted Pokémon.');
          return;
        }
        e.stopPropagation();
        e.preventDefault();
        cleanup();
        resolve(null);
        return;
      }
      
      // Find which candidate was clicked (by instanceId, element match, or bench index)
      const clicked = highlightedElements.find(({ element, imgProxy }) => {
        // Direct element match
        if (element === targetImg) {
          console.log('[V2-SELECTION] Found by direct element match');
          return true;
        }
        
        // Match by instanceId if available
        if (targetImg.dataset.instanceId && imgProxy.__v2_pokemon) {
          const matches = imgProxy.__v2_pokemon.instanceId === targetImg.dataset.instanceId;
          if (matches) {
            console.log('[V2-SELECTION] Found by instanceId match:', targetImg.dataset.instanceId);
          }
          return matches;
        }
        
        // Match by slot if clicking on bench slot
        if (clickedSlot && imgProxy.__v2_position === 'bench') {
          const benchIndex = parseInt(clickedSlot.dataset.index || '-1', 10);
          const matches = benchIndex === imgProxy.__v2_benchIndex;
          if (matches) {
            console.log('[V2-SELECTION] Found by bench index match:', benchIndex);
          }
          return matches;
        }
        
        // Match by slot if clicking on active slot
        if (clickedSlot && clickedSlot.classList.contains('active-slot') && imgProxy.__v2_position === 'active') {
          console.log('[V2-SELECTION] Found by active slot match');
          return true;
        }
        
        return false;
      });
      
      if (!clicked) {
        console.log('[V2-SELECTION] No match found for clicked element');
        e.stopPropagation();
        e.preventDefault();
        if (allowCancel) {
          cleanup();
          resolve(null);
        } else {
        showPopup('Please select a highlighted Pokémon.');
        }
        return;
      }
      
      // Valid selection
      console.log('[V2-SELECTION] Valid selection made:', clicked.imgProxy.alt);
        e.stopPropagation();
        e.preventDefault();
        cleanup();
        resolve(clicked.imgProxy);
    };
    
    const escapeHandler = (e) => {
      if (e.key === 'Escape' && allowCancel) {
        e.preventDefault();
        cleanup();
        resolve(null);
      } else if (e.key === 'Escape' && !allowCancel) {
        e.preventDefault();
        showPopup('You cannot cancel this selection.');
      }
    };
    
    document.addEventListener('click', clickHandler, true);
      if (allowCancel) {
    document.addEventListener('keydown', escapeHandler);
      }
    } catch (error) {
      console.error('[V2-SELECTION] Error in awaitSelection:', error);
      reject(error);
    }
  });
}

/**
 * V2-compatible flipCoin - performs a coin flip with UI
 * @param {string|null} pk - Player key ('p1' or 'p2') or null
 * @returns {Promise<string>} 'heads' or 'tails'
 */
async function flipCoin(pk = null) {
  // Check for guaranteed heads
  let isHeads = Math.random() < 0.5;
  if (pk && globalThis.state?.guaranteedHeads?.[pk]) {
    isHeads = true;
    globalThis.state.guaranteedHeads[pk] = false;
  }
  
  const resultStr = isHeads ? 'heads' : 'tails';
  
  // Show coin flip UI
  const coinContainer = document.getElementById('coinContainer');
  const coinBackdrop = document.getElementById('coinBackdrop');
  const coinEl = document.getElementById('coin');
  const coinResult = document.getElementById('coinResult');
  
  if (coinContainer && coinBackdrop && coinEl && coinResult) {
    // Show UI
    coinBackdrop.classList.add('show');
    coinContainer.classList.add('show');
    
    const front = coinEl.querySelector('.front');
    const back = coinEl.querySelector('.back');
    
    // Reset coin position
    if (front && back) {
      front.style.transform = 'rotateY(0deg)';
      back.style.transform = 'rotateY(180deg)';
    }
    
    coinResult.textContent = 'Flipping...';
    
    // Animate flip
    coinEl.classList.add('flip');
    
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    coinEl.classList.remove('flip');
    
    // Show result
    if (front && back) {
      if (isHeads) {
        front.style.transform = 'rotateY(0deg)';
        back.style.transform = 'rotateY(180deg)';
        coinResult.textContent = 'Heads!';
      } else {
        front.style.transform = 'rotateY(180deg)';
        back.style.transform = 'rotateY(0deg)';
        coinResult.textContent = 'Tails!';
      }
    }
    
    // Hide UI after a delay
    await new Promise(resolve => setTimeout(resolve, 1000));
    coinBackdrop.classList.remove('show');
    coinContainer.classList.remove('show');
  } else {
    // Fallback: just show popup
    showPopup(`Coin flip: ${resultStr}`);
  }
  
  return resultStr;
}

/**
 * V2-compatible moveEnergy - moves energy from one Pokémon to another
 * @param {Object} sourceImgProxy - Source Pokémon img proxy
 * @param {Object} targetImgProxy - Target Pokémon img proxy
 * @param {string} energyType - Energy type to move (or 'all' for all energy)
 * @returns {number} Number of energy moved
 */
async function moveEnergy(sourceImgProxy, targetImgProxy, energyType = 'all') {
  if (!sourceImgProxy || !targetImgProxy || !sourceImgProxy.__v2_pokemon || !targetImgProxy.__v2_pokemon) {
    return 0;
  }
  
  const sourcePokemon = sourceImgProxy.__v2_pokemon;
  const targetPokemon = targetImgProxy.__v2_pokemon;
  const sourcePlayerId = sourceImgProxy.__v2_playerId;
  const targetPlayerId = targetImgProxy.__v2_playerId;
  const sourcePosition = sourceImgProxy.__v2_position;
  const targetPosition = targetImgProxy.__v2_position;
  const sourceBenchIndex = sourceImgProxy.__v2_benchIndex;
  const targetBenchIndex = targetImgProxy.__v2_benchIndex;
  
  const sourceEnergy = sourcePokemon.energy || [];
  const targetEnergy = targetPokemon.energy || [];
  
  let moved = 0;
  const energyToMove = [];
  const remainingEnergy = [];
  
  if (energyType === 'all') {
    energyToMove.push(...sourceEnergy);
    moved = sourceEnergy.length;
  } else {
    for (const energy of sourceEnergy) {
      if (energy === energyType) {
        energyToMove.push(energy);
        moved++;
      } else {
        remainingEnergy.push(energy);
      }
    }
  }
  
  if (moved === 0) {
    return 0;
  }
  
  // Update source Pokémon
  const state = gameState.getState();
  if (sourcePosition === 'active') {
    await gameState.updatePlayerState(sourcePlayerId, {
      active: {
        ...sourcePokemon,
        energy: remainingEnergy
      }
    });
  } else if (sourcePosition === 'bench' && sourceBenchIndex !== null) {
    const bench = [...(state[sourcePlayerId].bench || [])];
    bench[sourceBenchIndex] = {
      ...sourcePokemon,
      energy: remainingEnergy
    };
    await gameState.updatePlayerState(sourcePlayerId, {
      bench: bench
    });
  }
  
  // Update target Pokémon
  const newTargetEnergy = [...targetEnergy, ...energyToMove];
  if (targetPosition === 'active') {
    await gameState.updatePlayerState(targetPlayerId, {
      active: {
        ...targetPokemon,
        energy: newTargetEnergy
      }
    });
  } else if (targetPosition === 'bench' && targetBenchIndex !== null) {
    const bench = [...(state[targetPlayerId].bench || [])];
    bench[targetBenchIndex] = {
      ...targetPokemon,
      energy: newTargetEnergy
    };
    await gameState.updatePlayerState(targetPlayerId, {
      bench: bench
    });
  }
  
  return moved;
}

/**
 * V2-compatible getHpFromImg - gets HP values from img proxy
 * @param {Object} imgProxy - Proxy object
 * @returns {Object} { base, cur } HP values
 */
function getHpFromImg(imgProxy) {
  if (!imgProxy || !imgProxy.__v2_pokemon) {
    return { base: 0, cur: 0 };
  }
  const pokemon = imgProxy.__v2_pokemon;
  const base = pokemon.maxHp || pokemon.baseHp || 0;
  const cur = pokemon.chp || pokemon.hp || 0;
  return { base, cur };
}

/**
 * V2-compatible setHpOnImg - sets HP on img proxy (updates gameState)
 * @param {Object} imgProxy - Proxy object
 * @param {number} base - Base/max HP
 * @param {number} cur - Current HP
 */
async function setHpOnImg(imgProxy, base, cur) {
  if (!imgProxy || !imgProxy.__v2_pokemon) {
    return;
  }
  
  const pokemon = imgProxy.__v2_pokemon;
  const playerId = imgProxy.__v2_playerId;
  const position = imgProxy.__v2_position;
  const benchIndex = imgProxy.__v2_benchIndex;
  
  const state = gameState.getState();
  
  if (position === 'active') {
    await gameState.updatePlayerState(playerId, {
      active: {
        ...pokemon,
        maxHp: base,
        baseHp: base,
        chp: cur
      }
    });
  } else if (position === 'bench' && benchIndex !== null) {
    const bench = [...(state[playerId].bench || [])];
    bench[benchIndex] = {
      ...pokemon,
      maxHp: base,
      baseHp: base,
      chp: cur
    };
    await gameState.updatePlayerState(playerId, {
      bench: bench
    });
  }
  
  // Update proxy
  imgProxy.dataset.hp = String(base);
  imgProxy.dataset.chp = String(cur);
  imgProxy.dataset.maxHp = String(base);
  pokemon.maxHp = base;
  pokemon.baseHp = base;
  pokemon.chp = cur;
}

// Make these functions globally available for effects.js
globalThis.getActiveImg = getActiveImg;
// Override the global function to use our V2 version
globalThis.getAllPokemonImgs = getAllPokemonImgs;
console.log('[V2-INIT] getAllPokemonImgs function registered');
globalThis.getBenchImgs = getBenchImgs;

/**
 * V2-compatible promoteFromBench - forces opponent to switch active with bench
 * @param {Object} state - State object (for compatibility, not used in V2)
 * @param {string} oppKey - Opponent key ('p1' or 'p2')
 * @param {boolean} requireChoice - Whether to require player choice (default: true)
 * @returns {boolean} True if promotion was initiated, false otherwise
 */
globalThis.promoteFromBench = function(state, oppKey, requireChoice = true) {
  const opponentId = oppKey === 'p1' ? 'player2' : 'player1';
  const currentState = gameState.getState();
  
  if (!currentState || !currentState[opponentId]) {
    return false;
  }
  
  const oppState = currentState[opponentId];
  const bench = oppState.bench || [];
  const validBench = bench.filter(p => p !== null && p !== undefined);
  
  if (requireChoice && validBench.length === 0) {
    return false;
  }
  
  // In V2, we handle this through the force_opponent_switch effect handler
  // This function is called by effects.js, but the actual switching is handled
  // in applyTrainerEffectV2 when the effect type is 'force_opponent_switch'
  // For now, just return true to indicate the effect was handled
  // The actual switching will be done by the effect handler
  return true;
};
globalThis.healImg = healImg;
globalThis.attachEnergy = attachEnergy;
globalThis.getSlotFromImg = getSlotFromImg;
globalThis.awaitSelection = awaitSelection;
globalThis.flipCoin = flipCoin;
globalThis.moveEnergy = moveEnergy;
globalThis.getHpFromImg = getHpFromImg;
globalThis.setHpOnImg = setHpOnImg;

/**
 * V2-compatible beginPromotionFlow - prompts user to select a benched Pokemon to promote
 * @param {string} owner - Player ID ('player1' or 'player2')
 * @returns {Promise<void>} Resolves when promotion is complete
 */
async function beginPromotionFlow(owner) {
  console.log('[V2-PROMOTION] beginPromotionFlow called for:', owner);
  
  // Map owner to pk for getBenchImgs
  const pk = owner === 'player1' ? 'p1' : 'p2';
  
  // Get bench Pokemon
  const benchImgs = getBenchImgs(pk);
  
  if (!benchImgs || benchImgs.length === 0) {
    console.log('[V2-PROMOTION] No bench Pokemon - checking for game over');
    const foe = owner === 'player1' ? 'player2' : 'player1';
    // Check if game should end (no benched Pokemon to promote)
    const state = gameState.getState();
    if (state && state[foe]) {
      const foeBench = state[foe].bench || [];
      const validFoeBench = foeBench.filter(p => p !== null && p !== undefined);
      if (validFoeBench.length === 0) {
        // Game over - opponent has no bench
        await gameState.updateState({
          gameOver: true,
          winner: foe
        });
        showPopup(`${foe === 'player1' ? 'Player 1' : 'Player 2'} wins! (Opponent has no benched Pokemon)`);
        return;
      }
    }
    showPopup('No Benched Pokémon to promote.');
    return;
  }
  
  // Highlight bench Pokemon and wait for selection
  showPopup('Choose a Benched Pokémon to promote.');
  
  const selected = await awaitSelection(benchImgs, 'promote-glow');
  
  if (!selected || !selected.__v2_pokemon) {
    console.log('[V2-PROMOTION] Selection cancelled');
    return;
  }
  
  const selectedPokemon = selected.__v2_pokemon;
  const benchIndex = selected.__v2_benchIndex;
  
  console.log('[V2-PROMOTION] Selected Pokemon:', {
    name: selectedPokemon.name,
    benchIndex,
    owner
  });
  
  // Get current state
  const state = gameState.getState();
  if (!state || !state[owner]) {
    console.error('[V2-PROMOTION] Invalid state');
    return;
  }
  
  const player = state[owner];
  const currentActive = player.active;
  const bench = [...(player.bench || [])];
  
  // Swap active and bench
  const newBench = [...bench];
  newBench[benchIndex] = currentActive;
  
  // Update state
  await gameState.updatePlayerState(owner, {
    active: selectedPokemon,
    bench: newBench
  });
  
  // Broadcast promotion action
  const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
  await broadcastAction(ACTION_TYPES.PROMOTE, {
    owner: owner,
    promoted: selectedPokemon,
    benched: currentActive,
    benchIndex: benchIndex,
    isForcedSwitch: false,
    turnNumber: state.turnNumber || 0
  });
  
  showPopup(`Promoted ${selectedPokemon.name || 'Pokemon'} to Active.`);
  addLog(`${owner === 'player1' ? 'Player 1' : 'Player 2'} promoted ${selectedPokemon.name || 'Pokemon'} to Active.`);
}

globalThis.beginPromotionFlow = beginPromotionFlow;

/**
 * V2-compatible activeFor - gets active slot element for a player
 * @param {string} playerId - Player ID ('player1' or 'player2')
 * @returns {HTMLElement|null} Active area element
 */
function activeFor(playerId) {
  const uiPlayerId = playerId === 'player1' ? 'p1' : 'p2';
  const activeArea = document.getElementById(`${uiPlayerId}Active`);
  return activeArea;
}

/**
 * V2-compatible detachAttachments - extracts energy, HP, and tool data from a slot
 * @param {HTMLElement} slot - Slot element
 * @returns {Object} Object with energy, hp, toolThumb, toolData, maxHp, chp, baseHp
 */
function detachAttachments(slot) {
  if (!slot) return { energy: null, hp: null, toolThumb: null, toolData: null, maxHp: null, chp: null, baseHp: null };
  
  // Get Pokemon from slot
  const img = slot.querySelector('img:not(.tool-thumb)');
  if (!img) return { energy: null, hp: null, toolThumb: null, toolData: null, maxHp: null, chp: null, baseHp: null };
  
  // Get Pokemon data from gameState using instanceId
  const instanceId = img.dataset.instanceId;
  if (!instanceId) return { energy: null, hp: null, toolThumb: null, toolData: null, maxHp: null, chp: null, baseHp: null };
  
  const state = gameState.getState();
  if (!state) return { energy: null, hp: null, toolThumb: null, toolData: null, maxHp: null, chp: null, baseHp: null };
  
  // Find Pokemon in state
  let pokemon = null;
  let playerId = null;
  let position = null;
  let benchIndex = null;
  
  // Check player1
  if (state.player1?.active?.instanceId === instanceId) {
    pokemon = state.player1.active;
    playerId = 'player1';
    position = 'active';
  } else if (state.player1?.bench) {
    for (let i = 0; i < state.player1.bench.length; i++) {
      if (state.player1.bench[i]?.instanceId === instanceId) {
        pokemon = state.player1.bench[i];
        playerId = 'player1';
        position = 'bench';
        benchIndex = i;
        break;
      }
    }
  }
  
  // Check player2
  if (!pokemon) {
    if (state.player2?.active?.instanceId === instanceId) {
      pokemon = state.player2.active;
      playerId = 'player2';
      position = 'active';
    } else if (state.player2?.bench) {
      for (let i = 0; i < state.player2.bench.length; i++) {
        if (state.player2.bench[i]?.instanceId === instanceId) {
          pokemon = state.player2.bench[i];
          playerId = 'player2';
          position = 'bench';
          benchIndex = i;
          break;
        }
      }
    }
  }
  
  if (!pokemon) {
    return { energy: null, hp: null, toolThumb: null, toolData: null, maxHp: null, chp: null, baseHp: null };
  }
  
  // Extract data from Pokemon object
  const energy = pokemon.energy || [];
  const chp = pokemon.chp || pokemon.hp || 0;
  const baseHp = pokemon.baseHp || 0;
  const maxHp = pokemon.maxHp || pokemon.baseHp || 0;
  const toolData = pokemon.tool || null;
  
  // Return data in format expected by effects.js
  return {
    energy: energy.length > 0 ? { __v2_energy: energy, __v2_pokemon: pokemon } : null,
    hp: { __v2_chp: chp, __v2_maxHp: maxHp },
    toolThumb: toolData ? { __v2_tool: toolData } : null,
    toolData: toolData,
    maxHp: maxHp,
    chp: chp,
    baseHp: baseHp,
    __v2_pokemon: pokemon,
    __v2_playerId: playerId,
    __v2_position: position,
    __v2_benchIndex: benchIndex
  };
}

/**
 * V2-compatible attachAttachments - attaches energy, HP, and tool data to a slot
 * @param {HTMLElement} slot - Slot element
 * @param {Object} pack - Object with energy, hp, toolThumb, toolData, etc.
 */
async function attachAttachments(slot, pack) {
  if (!slot || !pack) return;
  
  // Get Pokemon from slot
  const img = slot.querySelector('img:not(.tool-thumb)');
  if (!img) return;
  
  const instanceId = img.dataset.instanceId;
  if (!instanceId) return;
  
  const state = gameState.getState();
  if (!state) return;
  
  // Find Pokemon in state
  let pokemon = null;
  let playerId = null;
  let position = null;
  let benchIndex = null;
  
  // Check player1
  if (state.player1?.active?.instanceId === instanceId) {
    pokemon = state.player1.active;
    playerId = 'player1';
    position = 'active';
  } else if (state.player1?.bench) {
    for (let i = 0; i < state.player1.bench.length; i++) {
      if (state.player1.bench[i]?.instanceId === instanceId) {
        pokemon = state.player1.bench[i];
        playerId = 'player1';
        position = 'bench';
        benchIndex = i;
        break;
      }
    }
  }
  
  // Check player2
  if (!pokemon) {
    if (state.player2?.active?.instanceId === instanceId) {
      pokemon = state.player2.active;
      playerId = 'player2';
      position = 'active';
    } else if (state.player2?.bench) {
      for (let i = 0; i < state.player2.bench.length; i++) {
        if (state.player2.bench[i]?.instanceId === instanceId) {
          pokemon = state.player2.bench[i];
          playerId = 'player2';
          position = 'bench';
          benchIndex = i;
          break;
        }
      }
    }
  }
  
  if (!pokemon) return;
  
  // Update Pokemon with data from pack
  const updates = { ...pokemon };
  
  // Restore energy if provided
  if (pack.energy && pack.energy.__v2_energy) {
    updates.energy = [...pack.energy.__v2_energy];
  } else if (pack.energy === null) {
    updates.energy = [];
  }
  
  // Restore HP if provided
  if (pack.hp) {
    if (pack.hp.__v2_chp !== undefined) updates.chp = pack.hp.__v2_chp;
    if (pack.hp.__v2_maxHp !== undefined) {
      updates.maxHp = pack.hp.__v2_maxHp;
      updates.baseHp = pack.hp.__v2_maxHp;
    }
  } else if (pack.chp !== undefined) {
    updates.chp = pack.chp;
  }
  if (pack.maxHp !== undefined) {
    updates.maxHp = pack.maxHp;
    updates.baseHp = pack.maxHp;
  }
  
  // Restore tool if provided
  if (pack.toolData) {
    updates.tool = pack.toolData;
  } else if (pack.toolData === null) {
    updates.tool = null;
  }
  
  // Update gameState
  if (position === 'active') {
    await gameState.updatePlayerState(playerId, {
      active: updates
    });
  } else if (position === 'bench' && benchIndex !== null) {
    const bench = [...(state[playerId].bench || [])];
    bench[benchIndex] = updates;
    await gameState.updatePlayerState(playerId, {
      bench: bench
    });
  }
}

/**
 * V2-compatible markSlot - marks a slot as empty or not (no-op in V2, state handles this)
 * @param {HTMLElement} slot - Slot element
 * @param {boolean} has - Whether slot has a Pokemon
 */
function markSlot(slot, has) {
  // In V2, slots are managed by state, so this is mostly a no-op
  // But we can update the dataset for compatibility
  if (slot) {
    slot.dataset.empty = has ? '0' : '1';
  }
}

/**
 * V2-compatible evolveCard - evolves a Pokemon using gameState
 * @param {Object} targetImgProxy - Proxy object for the Pokemon to evolve
 * @param {Object} meta - Metadata for the evolution card
 * @param {Object} handCard - Card object from hand
 * @param {string} owner - Player ID ('player1' or 'player2')
 * @param {string} set - Set code
 * @param {string|number} num - Card number
 */
async function evolveCard(targetImgProxy, meta, handCard, owner, set, num) {
  if (!targetImgProxy || !targetImgProxy.__v2_pokemon) {
    console.error('[V2-EVOLVE] Invalid target Pokemon');
    return;
  }
  
  const pokemon = targetImgProxy.__v2_pokemon;
  const playerId = targetImgProxy.__v2_playerId;
  const position = targetImgProxy.__v2_position;
  const benchIndex = targetImgProxy.__v2_benchIndex;
  
  // Validate owner matches
  if (playerId !== owner) {
    console.error('[V2-EVOLVE] Owner mismatch:', { playerId, owner });
    showPopup('Cannot evolve - owner mismatch.');
    return;
  }
  
  // Get current state
  const state = gameState.getState();
  if (!state || !state[playerId]) {
    console.error('[V2-EVOLVE] Invalid game state');
    return;
  }
  
  // Check turn restrictions (already checked by Rare Candy, but double-check)
  const turnNumber = state.turnNumber || 0;
  if (turnNumber <= 2) {
    showPopup('You cannot evolve during the first two turns.');
    return;
  }
  
  // Get played turn from Pokemon
  const playedTurn = pokemon.playedTurn || 0;
  if (playedTurn === turnNumber) {
    showPopup('Cannot evolve the turn it was played.');
    return;
  }
  
  // Get new HP from meta
  const newHp = parseInt(meta.hp || '0', 10) || pokemon.hp || 0;
  
  // Get previous base HP (before evolution)
  const prevBaseHp = pokemon.baseHp || pokemon.hp || 0;
  
  // Calculate HP increase from evolution
  const hpIncrease = newHp - prevBaseHp;
  
  // Preserve current HP and add the HP increase (evolution increases HP)
  // Use pokemon.chp if it exists, otherwise use pokemon.hp
  const currentHp = pokemon.chp !== undefined ? pokemon.chp : (pokemon.hp || 0);
  // Add the HP increase from evolution
  const preservedHp = Math.max(0, currentHp + hpIncrease);
  
  // Build image URL - ensure it has /high.png at the end
  let imageUrl = highImgUrl(set, num || handCard.number || handCard.num);
  if (!imageUrl && meta.image) {
    // If meta.image exists but highImgUrl failed, use meta.image and ensure /high.png
    imageUrl = meta.image;
    if (!imageUrl.endsWith('/high.png')) {
      imageUrl = imageUrl.endsWith('/') ? imageUrl + 'high.png' : imageUrl + '/high.png';
    }
  }
  
  // Create evolved Pokemon object
  const evolvedPokemon = {
    ...pokemon, // Preserve all existing properties
    set: set,
    num: num || handCard.number || handCard.num,
    name: meta.name || handCard.name,
    image: imageUrl,
    stage: meta.stage || 'Stage 2',
    hp: newHp,
    baseHp: newHp,
    maxHp: newHp,
    // Preserve HP (evolution doesn't heal)
    chp: preservedHp,
    // Preserve energy and tool
    energy: pokemon.energy || [],
    tool: pokemon.tool || null,
    // Preserve instance ID
    instanceId: pokemon.instanceId,
    // Update played turn to current (evolution counts as "played")
    playedTurn: turnNumber
  };
  
  // Remove evolution card from hand
  const hand = [...(state[playerId].hand || [])];
  
  console.log('[V2-EVOLVE] Searching for evolution card in hand:', {
    handCard: {
      name: handCard.name,
      set: handCard.set,
      number: handCard.number || handCard.num,
      num: handCard.num
    },
    handSize: hand.length,
    handCards: hand.map(c => ({ 
      name: c.name, 
      set: c.set, 
      number: c.number || c.num,
      num: c.num
    }))
  });
  
  // Try multiple matching strategies to find the card
  let handIndex = hand.findIndex(card => {
    const cardNum = card.number || card.num;
    const handCardNum = handCard.number || handCard.num;
    return card.set === handCard.set && String(cardNum) === String(handCardNum);
  });
  
  console.log('[V2-EVOLVE] First match attempt result:', handIndex);
  
  // If not found, try matching by name and set
  if (handIndex === -1 && handCard.name) {
    handIndex = hand.findIndex(card => {
      const nameMatch = (card.name || '').toLowerCase() === (handCard.name || '').toLowerCase();
      const setMatch = card.set === handCard.set;
      return nameMatch && setMatch;
    });
    console.log('[V2-EVOLVE] Second match attempt (name+set) result:', handIndex);
  }
  
  // If still not found, try matching by name only (in case set differs)
  if (handIndex === -1 && handCard.name) {
    handIndex = hand.findIndex(card => 
      (card.name || '').toLowerCase() === (handCard.name || '').toLowerCase()
    );
    console.log('[V2-EVOLVE] Third match attempt (name only) result:', handIndex);
  }
  
  // If still not found, try matching by instanceId if available
  if (handIndex === -1 && handCard.instanceId) {
    handIndex = hand.findIndex(card => card.instanceId === handCard.instanceId);
    console.log('[V2-EVOLVE] Fourth match attempt (instanceId) result:', handIndex);
  }
  
  if (handIndex === -1) {
    console.warn('[V2-EVOLVE] Evolution card not found in hand after all attempts:', {
      handCard: {
        name: handCard.name,
        set: handCard.set,
        number: handCard.number || handCard.num,
        num: handCard.num,
        instanceId: handCard.instanceId
      },
      handSize: hand.length,
      handCards: hand.map(c => ({ 
        name: c.name, 
        set: c.set, 
        number: c.number || c.num,
        num: c.num,
        instanceId: c.instanceId
      }))
    });
    // Even if card not found, still update the hand (it might have been removed already)
    // This ensures the state is synced
  } else {
    const removedCard = hand.splice(handIndex, 1)[0];
    console.log('[V2-EVOLVE] Removed evolution card from hand:', {
      cardName: removedCard.name || handCard.name,
      handIndex: handIndex,
      newHandSize: hand.length,
      removedCard: removedCard
    });
  }
  
  // Update gameState - ALWAYS update hand to ensure card removal is synced
  const updates = {
    hand: hand
  };
  
  console.log('[V2-EVOLVE] Updating state with hand:', {
    playerId,
    handSize: hand.length,
    handCards: hand.map(c => c.name || `${c.set}-${c.number || c.num}`)
  });
  
  if (position === 'active') {
    updates.active = evolvedPokemon;
  } else if (position === 'bench' && benchIndex !== null) {
    const bench = [...(state[playerId].bench || [])];
    bench[benchIndex] = evolvedPokemon;
    updates.bench = bench;
  }
  
  // Set flag to prevent Firebase from overwriting our updates
  if (!globalThis.__updatingState) {
    globalThis.__updatingState = new Set();
  }
  globalThis.__updatingState.add(`${playerId}/hand`);
  if (position === 'active') {
    globalThis.__updatingState.add(`${playerId}/active`);
  } else if (position === 'bench') {
    globalThis.__updatingState.add(`${playerId}/bench`);
  }
  
  try {
    // Set flag to prevent render during update
    globalThis.__isUpdatingLocalState = true;
  
  await gameState.updatePlayerState(playerId, updates);
    
    console.log('[V2-EVOLVE] State updated successfully');
    
    // Clear the render flag immediately so UI can update
    globalThis.__isUpdatingLocalState = false;
    
    // Force a render to update the UI immediately
    const currentState = gameState.getState();
    if (currentState) {
      console.log('[V2-EVOLVE] Forcing immediate render after evolution');
      renderAll(currentState);
    }
    
    // Clear flags after a delay
    setTimeout(() => {
      if (globalThis.__updatingState) {
        globalThis.__updatingState.delete(`${playerId}/hand`);
        if (position === 'active') {
          globalThis.__updatingState.delete(`${playerId}/active`);
        } else if (position === 'bench') {
          globalThis.__updatingState.delete(`${playerId}/bench`);
        }
      }
    }, 1000);
  } catch (error) {
    // Clear flags on error
    globalThis.__isUpdatingLocalState = false;
    if (globalThis.__updatingState) {
      globalThis.__updatingState.delete(`${playerId}/hand`);
      if (position === 'active') {
        globalThis.__updatingState.delete(`${playerId}/active`);
      } else if (position === 'bench') {
        globalThis.__updatingState.delete(`${playerId}/bench`);
      }
    }
    throw error;
  }
  
  // Broadcast evolution action
  const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
  await broadcastAction(ACTION_TYPES.EVOLVE, {
    playerId,
    position,
    benchIndex,
    evolvedPokemon,
    previousPokemon: pokemon,
    evolutionCard: handCard
  });
  
  showPopup(`${pokemon.name || 'Pokemon'} evolved into ${meta.name || 'Pokemon'}!`);
  addLog(`${playerId === 'player1' ? 'Player 1' : 'Player 2'} evolved ${pokemon.name || 'Pokemon'} into ${meta.name || 'Pokemon'}`);
}

// Make these functions globally available for effects.js
globalThis.activeFor = activeFor;
globalThis.detachAttachments = detachAttachments;
globalThis.attachAttachments = attachAttachments;
globalThis.markSlot = markSlot;
globalThis.evolveCard = evolveCard;

/**
 * Apply trainer effect using V2 state-first architecture
 * Bridges old effect handlers to new gameState system
 * @param {Object} effectData - Trainer effect data
 * @param {string} playerId - Match player ID (player1/player2)
 * @param {Object} meta - Card metadata
 */
async function applyTrainerEffectV2(effectData, playerId, meta) {
  console.log('[V2-TRAINER-EFFECT] Applying effect:', {
    effectType: effectData.effect_type,
    playerId,
    trainerName: meta.name
  });
  
  // Get current game state
  const state = gameState.getState();
  if (!state || !state[playerId]) {
    throw new Error('Invalid game state');
  }
  
  // Convert V2 gameState to old state format for effect handlers
  const pk = playerId === 'player1' ? 'p1' : 'p2';
  
  // CRITICAL: Use the actual arrays from state, not copies, so effects can modify them in-place
  // This ensures that when effects modify globalThis.playerState, the changes are reflected
  const oldState = {
    p1: {
      deck: state.player1?.deck || [],
      hand: state.player1?.hand || [],
      discard: state.player1?.discard || { cards: [], energyCounts: {} }
    },
    p2: {
      deck: state.player2?.deck || [],
      hand: state.player2?.hand || [],
      discard: state.player2?.discard || { cards: [], energyCounts: {} }
    },
    temp: {
      p1: {},
      p2: {}
    }
  };
  
  // Set up globalThis.playerState for effects that use it directly
  // Use the SAME array references from oldState so modifications are reflected
  if (!globalThis.playerState) {
    globalThis.playerState = {};
  }
  globalThis.playerState[playerId] = {
    deck: oldState[pk].deck,  // Same array reference
    hand: oldState[pk].hand,  // Same array reference
    discard: oldState[pk].discard
  };
  
  // Also set up opponent's playerState for effects that might modify it
  const oppId = playerId === 'player1' ? 'player2' : 'player1';
  const oppPk = oppId === 'player1' ? 'p1' : 'p2';
  globalThis.playerState[oppId] = {
    deck: oldState[oppPk].deck,  // Same array reference
    hand: oldState[oppPk].hand,  // Same array reference
    discard: oldState[oppPk].discard
  };
  
  // Set globalThis.turnNumber for effects that check it (like Rare Candy)
  globalThis.turnNumber = state.turnNumber || 0;
  
  // Debug logging for Rare Candy
  if (effectData.effect_type === 'evolve_basic_to_stage2') {
    const currentState = gameState.getState();
    console.log('[V2-RARE-CANDY-DEBUG] oldState setup:', {
      pk,
      hasP1Hand: !!oldState.p1?.hand,
      p1HandSize: oldState.p1?.hand?.length || 0,
      hasP2Hand: !!oldState.p2?.hand,
      p2HandSize: oldState.p2?.hand?.length || 0,
      turnNumber: globalThis.turnNumber,
      playerId,
      p1DeckSize: oldState.p1?.deck?.length || 0,
      p2DeckSize: oldState.p2?.deck?.length || 0
    });
    console.log('[V2-RARE-CANDY-DEBUG] Current gameState bench:', {
      playerId,
      hasActive: !!currentState?.[playerId]?.active,
      activeName: currentState?.[playerId]?.active?.name,
      benchLength: currentState?.[playerId]?.bench?.length || 0,
      bench: currentState?.[playerId]?.bench?.map((p, i) => p ? { index: i, name: p.name, instanceId: p.instanceId, set: p.set, num: p.num || p.number } : { index: i, value: null }) || []
    });
    
    // Also check what getAllPokemonImgs actually returns
    const testPokemon = globalThis.getAllPokemonImgs?.(pk) || [];
    console.log('[V2-RARE-CANDY-DEBUG] getAllPokemonImgs result:', {
      count: testPokemon.length,
      pokemon: testPokemon.map(p => ({
        name: p.alt,
        instanceId: p.dataset.instanceId,
        set: p.dataset.set,
        num: p.dataset.num
      }))
    });
  }
  
  // Get TRAINER_EFFECTS
  let TRAINER_EFFECTS = globalThis.TRAINER_EFFECTS || window.TRAINER_EFFECTS;
  if (!TRAINER_EFFECTS || Object.keys(TRAINER_EFFECTS).length === 0) {
    // Wait for effects.js to load
    for (let i = 0; i < 10 && (!TRAINER_EFFECTS || Object.keys(TRAINER_EFFECTS).length === 0); i++) {
      await new Promise(resolve => setTimeout(resolve, 100));
      TRAINER_EFFECTS = globalThis.TRAINER_EFFECTS || (typeof window !== 'undefined' ? window.TRAINER_EFFECTS : null);
    }
  }
  
  if (!TRAINER_EFFECTS) {
    throw new Error('TRAINER_EFFECTS not available');
  }
  
  const handler = TRAINER_EFFECTS[effectData.effect_type];
  if (!handler) {
    throw new Error(`Effect handler not found: ${effectData.effect_type}`);
  }
  
  // Special handling for effects that require DOM manipulation
  if (effectData.effect_type === 'force_opponent_switch') {
    // V2-compatible version: force opponent to switch active with bench
    const opponentId = playerId === 'player1' ? 'player2' : 'player1';
    const oppState = state[opponentId];
    if (!oppState || !oppState.bench || oppState.bench.length === 0) {
      showPopup('Opponent has no benched Pokémon to switch to.');
      throw new Error('No valid target');
    }
    
    // Filter out null bench slots
    const validBench = oppState.bench.filter(p => p !== null && p !== undefined);
    if (validBench.length === 0) {
      showPopup('Opponent has no benched Pokémon to switch to.');
      throw new Error('No valid target');
    }
    
    // Broadcast action to opponent to trigger selection on their side
    const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
    await broadcastAction(ACTION_TYPES.FORCE_SWITCH_SELECTION, {
      fromPlayer: playerId,
      opponentId: opponentId,
      turnNumber: state.turnNumber || 0
    });
    
    // Show message to current player
    showPopup('Waiting for opponent to choose a benched Pokémon...');
    
    // Wait for opponent's selection (handled by action listener)
    return new Promise((resolve, reject) => {
      // Store the promise resolvers for when opponent selects
      globalThis.__forceSwitchPromise = { resolve, reject };
      
      // Set timeout to prevent hanging
      setTimeout(() => {
        if (globalThis.__forceSwitchPromise) {
          globalThis.__forceSwitchPromise = null;
          reject(new Error('SELECTION_TIMEOUT'));
        }
      }, 60000); // 60 second timeout
    });
  }
  
  // Special handling for return_active_to_hand
  if (effectData.effect_type === 'return_active_to_hand') {
    // This effect returns the active Pokemon to hand and triggers promotion
    const activePokemon = state[playerId]?.active;
    if (!activePokemon) {
      throw new Error('No active Pokemon to return');
    }
    
    // Add active Pokemon to hand
    const hand = [...(state[playerId].hand || [])];
    hand.push({
      name: activePokemon.name,
      set: activePokemon.set,
      number: activePokemon.number || activePokemon.num,
      image: activePokemon.image,
      instanceId: activePokemon.instanceId
    });
    
    // Clear active slot
    await gameState.updatePlayerState(playerId, {
      active: null,
      hand: hand
    });
    
    // Trigger promotion flow
    await beginPromotionFlow(playerId);
    
    // Broadcast action
    const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
    await broadcastAction(ACTION_TYPES.RETURN_TO_HAND, {
      playerId: playerId,
      returnedPokemon: activePokemon,
      turnNumber: state.turnNumber || 0
    });
    
    showPopup('Returned Active to hand.');
    return; // Early return, don't execute the old handler
  }
  
  if (effectData.effect_type === 'force_switch_damaged_bench') {
    // V2-compatible version: update gameState instead of DOM
    const opponentId = playerId === 'player1' ? 'player2' : 'player1';
    const oppState = state[opponentId];
    if (!oppState || !oppState.bench) {
      throw new Error('No valid target');
    }
    
    // Find damaged bench Pokemon
    const damagedBench = oppState.bench.filter(p => {
      if (!p) return false;
      const chp = p.chp || p.hp || 0;
      const maxHp = p.maxHp || p.baseHp || p.hp || 0;
      return chp < maxHp;
    });
    
    if (damagedBench.length === 0) {
      throw new Error('No valid target');
    }
    
    // Get bench images for selection UI
    const oppPk = opponentId === 'player1' ? 'p1' : 'p2';
    const benchImgs = getBenchImgs(oppPk);
    const damagedBenchImgs = benchImgs.filter(img => {
      const instanceId = img.dataset.instanceId;
      return damagedBench.some(p => p.instanceId === instanceId);
    });
    
    showPopup('Choose a damaged bench Pokemon to switch in');
    const chosen = await awaitSelection(damagedBenchImgs);
    if (!chosen) {
      throw new Error('SELECTION_CANCELLED');
    }
    
    // Find the selected Pokemon in state
    const chosenInstanceId = chosen.dataset.instanceId;
    const chosenPokemon = damagedBench.find(p => p.instanceId === chosenInstanceId);
    if (!chosenPokemon) {
      throw new Error('Selected Pokemon not found in state');
    }
    
    // Find bench index
    const benchIndex = oppState.bench.findIndex(p => p && p.instanceId === chosenInstanceId);
    if (benchIndex === -1) {
      throw new Error('Could not find bench index');
    }
    
    // Swap active and bench Pokemon
    const currentActive = oppState.active;
    const newBench = [...oppState.bench];
    newBench[benchIndex] = currentActive;
    
    await gameState.updatePlayerState(opponentId, {
      active: chosenPokemon,
      bench: newBench
    });
    
    // Broadcast action for opponent
    const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
    await broadcastAction(ACTION_TYPES.PROMOTE, {
      owner: opponentId,
      promoted: chosenPokemon,
      benched: currentActive,
      isForcedSwitch: true,
      turnNumber: state.turnNumber || 0
    });
    
    showPopup(`Forced ${chosenPokemon.name || 'Pokemon'} to active spot!`);
    return; // Early return, don't execute the old handler
  }
  
  // Execute the effect handler
  try {
    await handler(oldState, pk, {
      param1: effectData.param1,
      param2: effectData.param2
    });
  } catch (error) {
    // Re-throw SELECTION_CANCELLED or "Evolution cancelled." so caller can handle it (don't discard card)
    if (error.message === 'SELECTION_CANCELLED' || error.message === 'Evolution cancelled.') {
      console.log('[V2-TRAINER-EFFECT] Selection cancelled by user:', error.message);
      // Convert to SELECTION_CANCELLED for consistency
      const cancelledError = new Error('SELECTION_CANCELLED');
      cancelledError.originalError = error;
      throw cancelledError; // Re-throw so caller knows not to discard
    }
    throw error;
  }
  
  // Extract state changes back to V2 gameState
  const updates = {};
  
  // Priority: ALWAYS check globalThis.playerState first (many effects modify this directly)
  // Effects like drawCards, shuffle_hand_draw, etc. modify globalThis.playerState
  // When effects modify globalThis.playerState, they often replace the entire array,
  // so we should always use globalThis.playerState if it exists
  if (globalThis.playerState && globalThis.playerState[playerId]) {
    const playerStateDeck = globalThis.playerState[playerId].deck;
    const playerStateHand = globalThis.playerState[playerId].hand;
    const playerStateDiscard = globalThis.playerState[playerId].discard;
    
    // Always extract from globalThis.playerState if it exists (effects modify this directly)
    // Compare with current state to avoid unnecessary updates
    const currentState = gameState.getState();
    const currentPlayerState = currentState?.[playerId];
    
    if (playerStateDeck && Array.isArray(playerStateDeck)) {
      // Always extract deck from globalThis.playerState (effects modify this directly)
      // Always update to ensure deck changes are synced (e.g., after drawing cards)
      updates.deck = [...playerStateDeck];
    }
    if (playerStateHand && Array.isArray(playerStateHand)) {
      // Always extract hand from globalThis.playerState (effects modify this directly)
      // Always update - effects may have modified the array even if length is the same
      // This ensures drawn cards are always synced
      // For draw_cards and similar effects, always update to ensure cards are synced
      const currentState = gameState.getState();
      const currentHand = currentState?.[playerId]?.hand || [];
      
      // For draw effects, ALWAYS update the hand to ensure cards are synced
      // The comparison might fail if drawCards updated gameState directly
      // Also check if the hand size increased (which indicates cards were drawn)
      const handChanged = playerStateHand.length !== currentHand.length || 
                          JSON.stringify(playerStateHand) !== JSON.stringify(currentHand);
      const isDrawEffect = effectData.effect_type === 'draw_cards' || 
                          effectData.effect_type === 'shuffle_hand_draw' ||
                          effectData.effect_type === 'shuffle_opponent_hand_draw' ||
                          effectData.effect_type === 'shuffle_hand_draw_match_opponent' ||
                          effectData.effect_type === 'shuffle_both_hands_draw_same';
      
      // Always update for draw effects (even if drawCards already updated gameState)
      // This ensures the hand is properly synced even if the comparison fails
      if (isDrawEffect) {
        // For draw effects, always update to ensure cards are synced
        // drawCards may have updated gameState, but we still need to ensure the update is applied
      updates.hand = [...playerStateHand];
        console.log('[V2-TRAINER-EFFECT] Extracting hand from globalThis.playerState (draw effect):', {
          handSize: playerStateHand.length,
          currentHandSize: currentHand.length,
          isDrawEffect,
          handCards: playerStateHand.slice(0, 5).map(c => c.name) // Log first 5 cards
        });
      } else if (handChanged) {
        // For non-draw effects, only update if hand actually changed
        updates.hand = [...playerStateHand];
        console.log('[V2-TRAINER-EFFECT] Extracting hand from globalThis.playerState (hand changed):', {
          handSize: playerStateHand.length,
          currentHandSize: currentHand.length,
          handChanged,
          handCards: playerStateHand.slice(0, 5).map(c => c.name) // Log first 5 cards
        });
      } else {
        console.log('[V2-TRAINER-EFFECT] Hand unchanged, skipping update:', {
          handSize: playerStateHand.length,
          currentHandSize: currentHand.length,
          isDrawEffect
        });
      }
    }
    if (playerStateDiscard) {
      updates.discard = playerStateDiscard;
    }
  }
  
  // Fall back to oldState ONLY if globalThis.playerState wasn't set or didn't have the data
  // (Some effects modify oldState directly instead of globalThis.playerState)
  if (!updates.deck && oldState[pk].deck && Array.isArray(oldState[pk].deck)) {
    const currentState = gameState.getState();
    const currentDeckLength = currentState?.[playerId]?.deck?.length || 0;
    if (oldState[pk].deck.length !== currentDeckLength) {
      updates.deck = [...oldState[pk].deck];
    }
  }
  if (!updates.hand && oldState[pk].hand && Array.isArray(oldState[pk].hand)) {
    const currentState = gameState.getState();
    const currentHandLength = currentState?.[playerId]?.hand?.length || 0;
    if (oldState[pk].hand.length !== currentHandLength) {
      updates.hand = [...oldState[pk].hand];
    }
  }
  if (!updates.discard && oldState[pk].discard) {
    updates.discard = oldState[pk].discard;
  }
  
  // Update gameState if there are changes
  if (Object.keys(updates).length > 0) {
    console.log('[V2-TRAINER-EFFECT] Applying state updates:', {
      playerId,
      updates: Object.keys(updates),
      handSize: updates.hand?.length,
      deckSize: updates.deck?.length,
      handCards: updates.hand?.slice(0, 5).map(c => c.name) // Log first 5 cards
    });
    
    // Set flags to prevent Firebase from overwriting our updates
    if (!globalThis.__updatingState) {
      globalThis.__updatingState = new Set();
    }
    Object.keys(updates).forEach(key => {
      globalThis.__updatingState.add(`${playerId}/${key}`);
    });
    
    try {
      // Set flag to prevent render during update
      globalThis.__isUpdatingLocalState = true;
      
    await gameState.updatePlayerState(playerId, updates);
    console.log('[V2-TRAINER-EFFECT] Updated game state:', Object.keys(updates));
      
      // Also update globalThis.playerState to ensure consistency
      if (!globalThis.playerState) {
        globalThis.playerState = {};
      }
      if (!globalThis.playerState[playerId]) {
        globalThis.playerState[playerId] = {};
      }
      if (updates.hand) {
        globalThis.playerState[playerId].hand = [...updates.hand];
      }
      if (updates.deck) {
        globalThis.playerState[playerId].deck = [...updates.deck];
      }
      if (updates.discard) {
        globalThis.playerState[playerId].discard = updates.discard;
      }
      
      // Clear the render flag immediately so UI can update
      globalThis.__isUpdatingLocalState = false;
      
      // Force a render to update the UI immediately (especially important for draw effects)
      // Use the updated state directly to ensure we render the correct hand size
      const currentState = gameState.getState();
      if (currentState) {
        // Ensure the state has our updated hand and deck
        if (updates.hand) {
          currentState[playerId] = {
            ...currentState[playerId],
            hand: updates.hand
          };
        }
        if (updates.deck) {
          currentState[playerId] = {
            ...currentState[playerId],
            deck: updates.deck
          };
        }
        console.log('[V2-TRAINER-EFFECT] Forcing immediate render after effect:', {
          effectType: effectData.effect_type,
          handSize: updates.hand?.length,
          deckSize: updates.deck?.length,
          stateHandSize: currentState[playerId]?.hand?.length
        });
        renderAll(currentState);
      }
      
      // Keep flags for a short time to prevent race conditions
      setTimeout(() => {
        if (globalThis.__updatingState) {
          Object.keys(updates).forEach(key => {
            globalThis.__updatingState.delete(`${playerId}/${key}`);
          });
        }
      }, 2000); // Longer timeout for trainer effects
    } catch (error) {
      // Clear flags on error
      globalThis.__isUpdatingLocalState = false;
      if (globalThis.__updatingState) {
        Object.keys(updates).forEach(key => {
          globalThis.__updatingState.delete(`${playerId}/${key}`);
        });
      }
      throw error;
    }
  }
  
  // Handle opponent state changes (for effects that modify opponent)
  const opponentId = playerId === 'player1' ? 'player2' : 'player1';
  const oppPkForUpdates = opponentId === 'player1' ? 'p1' : 'p2';
  const oppUpdates = {};
  
  if (oldState[oppPkForUpdates].deck && Array.isArray(oldState[oppPkForUpdates].deck)) {
    oppUpdates.deck = [...oldState[oppPkForUpdates].deck];
  }
  if (oldState[oppPkForUpdates].hand && Array.isArray(oldState[oppPkForUpdates].hand)) {
    oppUpdates.hand = [...oldState[oppPkForUpdates].hand];
  }
  if (oldState[oppPkForUpdates].discard) {
    oppUpdates.discard = oldState[oppPkForUpdates].discard;
  }
  
  if (globalThis.playerState && globalThis.playerState[opponentId]) {
    if (globalThis.playerState[opponentId].deck && Array.isArray(globalThis.playerState[opponentId].deck)) {
      oppUpdates.deck = [...globalThis.playerState[opponentId].deck];
    }
    if (globalThis.playerState[opponentId].hand && Array.isArray(globalThis.playerState[opponentId].hand)) {
      oppUpdates.hand = [...globalThis.playerState[opponentId].hand];
    }
    if (globalThis.playerState[opponentId].discard) {
      oppUpdates.discard = globalThis.playerState[opponentId].discard;
    }
  }
  
  if (Object.keys(oppUpdates).length > 0) {
    await gameState.updatePlayerState(opponentId, oppUpdates);
    console.log('[V2-TRAINER-EFFECT] Updated opponent state:', Object.keys(oppUpdates));
  }
  
  // Sync to Firebase (gameState.updatePlayerState already does this, but ensure it)
  // The reactive UI will update automatically via gameState.subscribe
}

// ============================================================================
// ENERGY ATTACHMENT
// ============================================================================

// Track selected energy and attachment state
let selectedEnergy = null;
let hasAttachedEnergyThisTurn = false;
let isAttachingEnergy = false; // Flag to prevent multiple simultaneous attachments
let hasRetreatedThisTurn = false; // Track if player has retreated this turn
let hasPlayedSupporterThisTurn = false; // Track if player has played a supporter this turn

/**
 * Energy type icons mapping
 */
const ENERGY_ICONS = {
  fire: 'https://archives.bulbagarden.net/media/upload/thumb/a/ad/Fire-attack.png/20px-Fire-attack.png',
  water: 'https://archives.bulbagarden.net/media/upload/thumb/1/11/Water-attack.png/20px-Water-attack.png',
  grass: 'https://archives.bulbagarden.net/media/upload/thumb/2/2e/Grass-attack.png/20px-Grass-attack.png',
  lightning: 'https://archives.bulbagarden.net/media/upload/thumb/0/04/Lightning-attack.png/20px-Lightning-attack.png',
  psychic: 'https://archives.bulbagarden.net/media/upload/thumb/e/ef/Psychic-attack.png/20px-Psychic-attack.png',
  fighting: 'https://archives.bulbagarden.net/media/upload/thumb/4/48/Fighting-attack.png/20px-Fighting-attack.png',
  darkness: 'https://archives.bulbagarden.net/media/upload/thumb/a/ab/Darkness-attack.png/20px-Darkness-attack.png',
  metal: 'https://archives.bulbagarden.net/media/upload/thumb/6/64/Metal-attack.png/20px-Metal-attack.png',
  dragon: 'https://archives.bulbagarden.net/media/upload/thumb/8/8a/Dragon-attack.png/20px-Dragon-attack.png',
  colorless: 'https://archives.bulbagarden.net/media/upload/thumb/1/1d/Colorless-attack.png/30px-Colorless-attack.png'
};

/**
 * Handle energy type selection
 */
function handleEnergySelection(energyType) {
  // Toggle selection
  if (selectedEnergy === energyType) {
    selectedEnergy = null;
  } else {
    selectedEnergy = energyType;
  }
  
  // Update UI
  document.querySelectorAll('.energy-type').forEach(el => {
    if (el.dataset.energy === selectedEnergy) {
      el.classList.add('selected');
    } else {
      el.classList.remove('selected');
    }
  });
  
  console.log('[V2-ENERGY] Energy selected:', selectedEnergy);
}

/**
 * Attach energy to a Pokemon slot
 * @param {string} playerId - Match player ID
 * @param {HTMLElement} slot - Pokemon slot element
 * @param {string} energyKey - Energy type key
 */
async function attachEnergyToSlot(playerId, slot, energyKey) {
  if (!slot || !energyKey) return;
  
  // Prevent multiple simultaneous attachments
  if (isAttachingEnergy) {
    console.log('[V2-ENERGY] Energy attachment already in progress, ignoring duplicate click');
    return;
  }
  
  // Validate turn first
  if (!validateTurn('attach energy')) {
    return;
  }
  
  const state = gameState.getState();
  if (!state) {
    return;
  }
  
  // Set flag to prevent concurrent attachments
  isAttachingEnergy = true;
  
  try {
    const isSetupPhase = state.isSetupPhase !== false;
    
    // Prevent energy attachment on turn 1 (unless setup phase)
    const currentTurnNumber = state.turnNumber || 0;
    if (currentTurnNumber === 1 && !isSetupPhase) {
      showPopup('You cannot attach Energy on your first turn.');
      return;
    }
    
    // Check if already attached energy this turn
    if (hasAttachedEnergyThisTurn && !isSetupPhase) {
      showPopup('You can only attach one Energy per turn.');
      return;
    }
    
    // Validate that this energy type is allowed for this player
    const playerState = state[playerId];
    if (!playerState) {
      return;
    }
    
    const allowedEnergyTypes = playerState.energyTypes || [];
    if (!allowedEnergyTypes.includes(energyKey)) {
      showPopup(`You cannot attach ${energyKey} Energy. Only selected energy types are allowed.`);
      return;
    }
    
    // Find Pokemon in slot
    const img = slot.querySelector('img:not(.tool-thumb)');
    if (!img) {
      showPopup('Select a Pokémon in play.');
      return;
    }
    
    // Get Pokemon data from state
    const player = state[playerId];
    if (!player) return;
    
    // Determine if this is active or bench
    const isActive = slot.closest('.active-slot') !== null;
    let pokemon = null;
    let benchIndex = null;
    
    if (isActive) {
      pokemon = player.active;
    } else {
      // Find bench index
      const benchSlots = Array.from(slot.parentElement.querySelectorAll('.bench-slot'));
      benchIndex = benchSlots.indexOf(slot);
      if (benchIndex >= 0 && benchIndex < (player.bench || []).length) {
        pokemon = player.bench[benchIndex];
      }
    }
    
    if (!pokemon) {
      showPopup('No Pokémon found in this slot.');
      return;
    }
    
    // Add energy to Pokemon
    const currentEnergy = pokemon.energy || [];
    const newEnergy = [...currentEnergy, { type: energyKey }];
    
    // Update Pokemon with new energy
    const updatedPokemon = { ...pokemon, energy: newEnergy };
    
    // Update state
    if (isActive) {
      await gameState.updatePlayerState(playerId, {
        active: updatedPokemon
      });
    } else {
      const newBench = [...(player.bench || [])];
      newBench[benchIndex] = updatedPokemon;
      await gameState.updatePlayerState(playerId, {
        bench: newBench
      });
    }
    
    // Update visual energy pips
    updateEnergyVisuals(slot, newEnergy);
    
    // Mark as attached this turn
    if (!isSetupPhase) {
      hasAttachedEnergyThisTurn = true;
      // Disable energy zone after attachment
      disableEnergyZone();
    }
    
    // Clear selection
    selectedEnergy = null;
    document.querySelectorAll('.energy-type').forEach(el => el.classList.remove('selected'));
    
    // Broadcast action
    const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
    await broadcastAction(ACTION_TYPES.ATTACH_ENERGY, {
      playerId,
      energyKey,
      target: {
        position: isActive ? 'active' : 'bench',
        benchIndex: benchIndex,
        instanceId: pokemon.instanceId
      }
    });
    
    addLog(`Attached ${energyKey} Energy to ${pokemon.name || 'Pokemon'}`);
    showStatusMessage(`Attached ${energyKey} Energy`);
  } catch (error) {
    console.error('[V2-ENERGY] Error attaching energy:', error);
    showPopup('Error attaching energy: ' + error.message);
  } finally {
    // Always reset flag after attachment completes (or fails)
    isAttachingEnergy = false;
  }
}

/**
 * Update energy visuals on a slot
 * @param {HTMLElement} slot - Pokemon slot element
 * @param {Array} energy - Array of energy objects
 */
function updateEnergyVisuals(slot, energy) {
  // Remove existing energy pips
  const existingPips = slot.querySelector('.energy-pips');
  if (existingPips) {
    existingPips.remove();
  }
  
  if (!energy || energy.length === 0) return;
  
  // Create energy pips container
  const pipsContainer = document.createElement('div');
  pipsContainer.className = 'energy-pips';
  
  // Count energy by type
  const energyCounts = {};
  energy.forEach(e => {
    const type = e.type || e;
    energyCounts[type] = (energyCounts[type] || 0) + 1;
  });
  
  // Create pip for each energy
  Object.entries(energyCounts).forEach(([type, count]) => {
    for (let i = 0; i < count; i++) {
      const pip = document.createElement('div');
      pip.className = 'energy-pip';
      pip.dataset.type = type;
      pip.style.backgroundImage = `url('${ENERGY_ICONS[type] || ''}')`;
      pipsContainer.appendChild(pip);
    }
  });
  
  slot.appendChild(pipsContainer);
}

// ============================================================================
// STATE-FIRST ACTION HANDLERS
// ============================================================================

/**
 * Show retreat selection menu
 * @param {string} playerId - Match player ID
 * @param {Object} pokemon - Active Pokemon
 * @param {number} retreatCost - Retreat cost
 */
async function showRetreatSelection(playerId, pokemon, retreatCost) {
  const state = gameState.getState();
  if (!state || !state[playerId]) return;
  
  const player = state[playerId];
  const bench = player.bench || [];
  const availableBench = bench.filter((p, i) => p !== null && p !== undefined);
  
  if (availableBench.length === 0) {
    showPopup('No bench Pokemon to retreat to!');
    return;
  }
  
  // If only one bench Pokemon, auto-select it
  if (availableBench.length === 1) {
    const benchIndex = bench.findIndex(p => p !== null && p !== undefined);
    await handleRetreat(playerId, benchIndex, retreatCost);
    return;
  }
  
  // Show selection menu for multiple bench Pokemon
  showPopup('Click on a bench Pokemon to retreat to it.');
  
  // Highlight bench Pokemon
  const benchContainer = document.querySelector('#p1Bench .bench');
  if (benchContainer) {
    benchContainer.querySelectorAll('.bench-slot').forEach((slot, i) => {
      if (bench[i]) {
        slot.style.border = '2px solid #22c55e';
        slot.style.boxShadow = '0 0 10px rgba(34, 197, 94, 0.5)';
        slot.style.cursor = 'pointer';
        
        // Add click handler
        const clickHandler = async (e) => {
          e.stopPropagation();
          // Remove all highlights and handlers
          benchContainer.querySelectorAll('.bench-slot').forEach(s => {
            s.style.border = '';
            s.style.boxShadow = '';
            s.style.cursor = '';
            s.removeEventListener('click', clickHandler);
          });
          await handleRetreat(playerId, i, retreatCost);
        };
        
        slot.addEventListener('click', clickHandler, { once: true });
      }
    });
  }
}

/**
 * Handle retreat action - Clean implementation using state manager
 * @param {string} playerId - Match player ID ('player1' or 'player2')
 * @param {number} benchIndex - Index of Pokemon to promote from bench
 * @param {number} retreatCost - Retreat cost (optional, will fetch if not provided)
 */
async function handleRetreat(playerId, benchIndex, retreatCost = null) {
  console.log('[RETREAT-V2] Starting retreat:', { playerId, benchIndex });
  
  // Validate turn
  if (!validateTurn('retreat')) {
    return;
  }
  
  const state = gameState.getState();
  if (!state || !state[playerId]) {
    console.error('[RETREAT-V2] Invalid state or player');
    return;
  }
  
  const player = state[playerId];
  
  // Validation
  if (!player.active) {
    console.error('[RETREAT-V2] No active Pokemon');
    return;
  }
  
  if (!player.bench || benchIndex >= player.bench.length) {
    console.error('[RETREAT-V2] Invalid bench index');
    return;
  }
  
  const promoted = player.bench[benchIndex];
  if (!promoted) {
    console.error('[RETREAT-V2] No Pokemon at bench index');
    return;
  }
  
  // Fetch retreat cost from card metadata if not provided
  if (retreatCost === null) {
    const activeMeta = await fetchCardMeta(player.active.set, player.active.num || player.active.number);
    if (!activeMeta) {
      showPopup('Could not fetch card data for retreat.');
      return;
    }
    retreatCost = parseInt(activeMeta.retreat || activeMeta.retreatCost || '0', 10) || 0;
  }
  const energy = player.active.energy || [];
  
  if (energy.length < retreatCost) {
    showPopup(`Not enough energy to retreat! Need ${retreatCost}, have ${energy.length}`);
    return;
  }
  
  // Check if there's a bench Pokemon to retreat to
  if (!player.bench || player.bench.length === 0 || !player.bench.some(p => p !== null && p !== undefined)) {
    showPopup('No bench Pokemon to retreat to!');
    return;
  }
  
  // Remove energy (discard retreat cost)
  const energyToDiscard = energy.slice(0, retreatCost);
  const remainingEnergy = energy.slice(retreatCost);
  
  // Update discard pile
  const discard = player.discard || { cards: [], energyCounts: {} };
  const newEnergyCounts = { ...discard.energyCounts };
  energyToDiscard.forEach(e => {
    const energyType = e.type || e;
    newEnergyCounts[energyType] = (newEnergyCounts[energyType] || 0) + 1;
  });
  
  // Swap active and bench
  // Retreated Pokemon keeps remaining energy and all other properties (tools, HP, etc.)
  const retreatedPokemon = {
    ...player.active, // Preserve all properties (HP, tools, etc.)
    energy: remainingEnergy // Keep remaining energy after paying retreat cost
  };
  
  const newActive = { 
    ...promoted, // Preserve all properties (HP, tools, etc.)
    energy: [...(promoted.energy || [])] // Promoted Pokemon keeps its own energy
  };
  
  const newBench = player.bench.map((p, i) => 
    i === benchIndex 
      ? retreatedPokemon // Retreated Pokemon goes to bench with remaining energy and all attachments
      : p
  );
  
  // Update state (ONE call - no mapping needed!)
  await gameState.updatePlayerState(playerId, {
    active: newActive,
    bench: newBench,
    discard: {
      ...discard,
      energyCounts: newEnergyCounts
    }
  });
  
  // Broadcast action for opponent
  const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
  await broadcastAction(ACTION_TYPES.RETREAT, {
    playerId,
    benchIndex,
    energyDiscarded: energyToDiscard,
    promotedPokemon: promoted,
    retreatedPokemon: player.active
  });
  
  addLog(`Retreated ${player.active.name || 'Pokemon'} to bench, promoted ${promoted.name || 'Pokemon'}`);
  showStatusMessage('Retreat successful!');
  
  // Mark as retreated this turn
  hasRetreatedThisTurn = true;
}

/**
 * Handle opponent retreat - Clean implementation
 * @param {Object} actionData - Retreat action data from opponent
 */
/**
 * Handle opponent's force switch selection request (Sabrina)
 * @param {Object} actionData - Action data with opponentId and fromPlayer
 */
async function handleForceSwitchSelection(actionData) {
  const { opponentId, fromPlayer } = actionData;
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  
  // Only handle if we are the opponent
  if (myPlayerId !== opponentId) {
    return;
  }
  
  const state = gameState.getState();
  if (!state || !state[myPlayerId]) {
    console.error('[V2-FORCE-SWITCH] Invalid state');
    return;
  }
  
  const myState = state[myPlayerId];
  if (!myState.bench || myState.bench.length === 0) {
    showPopup('You have no benched Pokémon to switch to.');
    // Broadcast cancellation
    const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
    await broadcastAction(ACTION_TYPES.FORCE_SWITCH_SELECTED, {
      fromPlayer: fromPlayer,
      opponentId: opponentId,
      cancelled: true
    });
    return;
  }
  
  // Filter out null bench slots
  const validBench = myState.bench.filter(p => p !== null && p !== undefined);
  if (validBench.length === 0) {
    showPopup('You have no benched Pokémon to switch to.');
    const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
    await broadcastAction(ACTION_TYPES.FORCE_SWITCH_SELECTED, {
      fromPlayer: fromPlayer,
      opponentId: opponentId,
      cancelled: true
    });
    return;
  }
  
  // Get bench images for selection UI
  // IMPORTANT: In V2, p1 is always "you" and p2 is always "opponent"
  // So we always use 'p1' to get our own bench, regardless of match player ID
  const benchImgs = getBenchImgs('p1'); // Always use p1 because p1 is always "you"
  
  if (benchImgs.length === 0) {
    showPopup('You have no benched Pokémon to switch to.');
    const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
    await broadcastAction(ACTION_TYPES.FORCE_SWITCH_SELECTED, {
      fromPlayer: fromPlayer,
      opponentId: opponentId,
      cancelled: true
    });
    return;
  }
  
  // Set flag to allow selection (even if not our turn) and prevent cancellation
  globalThis.__forceSwitchSelection = true;
  globalThis.__forceSwitchNoCancel = true; // Prevent cancellation for Sabrina
  showPopup('Opponent used Sabrina! You must choose a benched Pokémon to switch to active.');
  
  try {
    const chosen = await awaitSelection(benchImgs, 'heal-glow');
    
    if (!chosen) {
      // Selection should not be cancellable, but if it somehow is, retry
      console.error('[V2-FORCE-SWITCH] Selection was cancelled but should not be allowed');
      showPopup('You must select a benched Pokémon. Please try again.');
      // Don't broadcast cancellation - force a retry by calling the function again
      setTimeout(() => handleForceSwitchSelection(actionData), 100);
      return;
    }
    
    // Find the selected Pokemon in state
    const chosenInstanceId = chosen.dataset.instanceId;
    const chosenPokemon = validBench.find(p => p.instanceId === chosenInstanceId);
    if (!chosenPokemon) {
      console.error('[V2-FORCE-SWITCH] Selected Pokemon not found in state');
      const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
      await broadcastAction(ACTION_TYPES.FORCE_SWITCH_SELECTED, {
        fromPlayer: fromPlayer,
        opponentId: opponentId,
        cancelled: true
      });
      return;
    }
    
    // Find bench index
    const benchIndex = myState.bench.findIndex(p => p && p.instanceId === chosenInstanceId);
    if (benchIndex === -1) {
      console.error('[V2-FORCE-SWITCH] Could not find bench index');
      const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
      await broadcastAction(ACTION_TYPES.FORCE_SWITCH_SELECTED, {
        fromPlayer: fromPlayer,
        opponentId: opponentId,
        cancelled: true
      });
      return;
    }
    
    // Swap active and bench Pokemon
    const currentActive = myState.active;
    const newBench = [...myState.bench];
    newBench[benchIndex] = currentActive;
    
    await gameState.updatePlayerState(myPlayerId, {
      active: chosenPokemon,
      bench: newBench
    });
    
    // Broadcast selection back to original player
    const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
    await broadcastAction(ACTION_TYPES.FORCE_SWITCH_SELECTED, {
      fromPlayer: fromPlayer,
      opponentId: opponentId,
      selectedInstanceId: chosenInstanceId,
      promoted: chosenPokemon,
      benched: currentActive,
      benchIndex: benchIndex
    });
    
    showPopup(`Switched ${chosenPokemon.name || 'Pokemon'} to active spot!`);
  } finally {
    globalThis.__forceSwitchSelection = false;
  }
}

/**
 * Handle opponent's force switch selection result
 * @param {Object} actionData - Action data with selection result
 */
async function handleForceSwitchSelected(actionData) {
  const { fromPlayer, opponentId, cancelled, selectedInstanceId } = actionData;
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  
  // Only handle if we are the player who used Sabrina
  if (myPlayerId !== fromPlayer) {
    return;
  }
  
  // Resolve the promise if it exists
  if (globalThis.__forceSwitchPromise) {
    if (cancelled) {
      globalThis.__forceSwitchPromise.reject(new Error('SELECTION_CANCELLED'));
    } else {
      globalThis.__forceSwitchPromise.resolve(actionData);
    }
    globalThis.__forceSwitchPromise = null;
  }
  
  if (cancelled) {
    showPopup('Opponent cancelled the switch.');
  } else {
    showPopup(`Opponent switched to ${actionData.promoted?.name || 'Pokemon'}!`);
  }
}

async function handleOpponentRetreat(actionData) {
  console.log('[RETREAT-V2] Handling opponent retreat:', actionData);
  
  const { playerId, benchIndex, energyDiscarded } = actionData;
  
  // State is already updated via Firebase sync, we just need to ensure UI is updated
  // The reactive renderer will handle this automatically!
  
  addLog(`Opponent retreated and promoted from bench`);
}

// ============================================================================
// REACTIVE UI RENDERER
// ============================================================================

// Store click handlers to prevent duplicates
const activeSlotClickHandlers = new WeakMap();

/**
 * Render Pokemon card in a slot
 * @param {HTMLElement} slot - DOM element to render into
 * @param {Object} pokemon - Pokemon data from state
 */
function renderPokemonCard(slot, pokemon) {
  if (!slot) return;
  
  slot.innerHTML = '';
  
  if (!pokemon) {
    slot.innerHTML = '<span style="color: #666;">Empty</span>';
    return;
  }
  
  // Create card image - ensure image URL has /high.png
  const img = document.createElement('img');
  let imageUrl = pokemon.image || highImgUrl(pokemon.set, pokemon.num || pokemon.number);
  if (imageUrl && !imageUrl.endsWith('/high.png')) {
    // Ensure /high.png is at the end
    imageUrl = imageUrl.endsWith('/') ? imageUrl + 'high.png' : imageUrl + '/high.png';
  }
  img.src = imageUrl || 'imgs/cardback.png';
  img.alt = pokemon.name || 'Pokemon';
  img.className = 'card-img';
  img.dataset.set = pokemon.set;
  img.dataset.num = pokemon.num;
  img.dataset.instanceId = pokemon.instanceId;
  slot.appendChild(img);
  
  // Render HP overlay - always show if hp exists
  if (pokemon.hp !== undefined && pokemon.hp !== null) {
    const hpOverlay = document.createElement('div');
    hpOverlay.className = 'hp-overlay';
    const currentHp = pokemon.chp !== undefined && pokemon.chp !== null ? pokemon.chp : pokemon.hp;
    const maxHp = pokemon.maxHp !== undefined && pokemon.maxHp !== null ? pokemon.maxHp : pokemon.hp;
    hpOverlay.textContent = `${currentHp}/${maxHp}`;
    slot.appendChild(hpOverlay);
  }
  
  // Render energy pips
  updateEnergyVisuals(slot, pokemon.energy || []);
}

/**
 * Render active Pokemon
 * @param {string} playerId - Match player ID
 * @param {Object} pokemon - Active Pokemon data
 */
function renderActive(uiPlayerId, pokemon) {
  const activeArea = document.getElementById(`${uiPlayerId}Active`);
  if (!activeArea) {
    console.warn(`[RENDER-ACTIVE] Active area not found for ${uiPlayerId}`);
    return;
  }
  
  const slot = activeArea.querySelector('.active-slot');
  if (!slot) {
    console.warn(`[RENDER-ACTIVE] Active slot not found for ${uiPlayerId}`);
    return;
  }
  
  // Don't re-render if selection is active (preserve glow classes)
  if (globalThis.__selectionActive || globalThis.__forceSwitchSelection || globalThis.__silverSelectionActive) {
    console.log('[V2-RENDER] Skipping active re-render during selection');
    return;
  }
  
  // Always clear and re-render to ensure consistency
  slot.innerHTML = '';
  
  // Remove old click handler if it exists (stored in WeakMap)
  const oldHandler = activeSlotClickHandlers.get(slot);
  if (oldHandler) {
    slot.removeEventListener('click', oldHandler);
    activeSlotClickHandlers.delete(slot);
  }
  
  if (pokemon) {
    renderPokemonCard(slot, pokemon);
    slot.dataset.currentInstanceId = pokemon.instanceId || '';
    
    // Add click handler for energy attachment or attack menu (only on own active)
    if (uiPlayerId === 'p1') {
      const clickHandler = async (e) => {
        // Check if selection is active (Rare Candy, Sabrina, etc.) - let selection handler process it
        if (globalThis.__selectionActive || globalThis.__forceSwitchSelection || globalThis.__silverSelectionActive || isEvoMode) {
          // Don't handle clicks during selection - let the selection handler process it
          return;
        }
        
        // Prevent multiple rapid clicks
        if (slot.dataset.processing === 'true') {
          e.stopPropagation();
          e.preventDefault();
          return;
        }
        slot.dataset.processing = 'true';
        
        try {
          // Get current Pokemon from state (may have changed)
          const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
          const state = gameState.getState();
          if (!state) return;
          
          const currentPokemon = state[myPlayerId]?.active;
          
          if (!currentPokemon) {
            return;
          }
          
          // If energy is selected, attach energy
          if (selectedEnergy) {
            e.stopPropagation();
            e.preventDefault();
            await attachEnergyToSlot(myPlayerId, slot, selectedEnergy);
          } else {
            // Otherwise, show attack menu
            e.stopPropagation();
            e.preventDefault();
            await showAttackMenu(currentPokemon, myPlayerId, slot);
          }
        } finally {
          // Reset processing flag after a short delay
          setTimeout(() => {
            if (slot && slot.dataset) {
              slot.dataset.processing = 'false';
            }
          }, 500);
        }
      };
      
      // Store handler reference in WeakMap
      activeSlotClickHandlers.set(slot, clickHandler);
      slot.addEventListener('click', clickHandler);
    }
  } else {
    // No Pokemon - clear instance ID
    slot.dataset.currentInstanceId = '';
  }
}

/**
 * Render bench Pokemon
 * @param {string} playerId - Match player ID
 * @param {Array} bench - Bench array
 */
function renderBench(uiPlayerId, bench) {
  const benchContainer = document.querySelector(`#${uiPlayerId}Bench .bench`);
  if (!benchContainer) return;
  
  // Don't re-render if selection is active (preserve glow classes)
  if (globalThis.__forceSwitchSelection || globalThis.__silverSelectionActive || globalThis.__selectionActive) {
    console.log('[V2-RENDER] Skipping bench re-render during selection');
    return;
  }
  
  // Clear existing
  benchContainer.innerHTML = '';
  
  // Render each bench slot (3 slots for V2)
  for (let i = 0; i < 3; i++) {
    const slot = document.createElement('div');
    slot.className = 'bench-slot';
    slot.dataset.index = i;
    
    if (bench && bench[i]) {
      renderPokemonCard(slot, bench[i]);
      
      // Add click handlers
      // Only allow clicks on own bench (p1 is always "you")
      if (uiPlayerId === 'p1') {
        slot.addEventListener('click', (e) => {
          // Check if selection is active (Rare Candy, Sabrina, etc.) - let selection handler process it
          if (globalThis.__selectionActive || globalThis.__forceSwitchSelection || globalThis.__silverSelectionActive || isEvoMode) {
            // Don't handle clicks during selection - let the selection handler process it
            return;
          }
          
          // If energy is selected, attach energy
          if (selectedEnergy) {
            e.stopPropagation();
            const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
            attachEnergyToSlot(myPlayerId, slot, selectedEnergy);
            return;
          }
          
          // Bench slot clicked (no energy selected) - could be used for other actions later
        });
      }
    } else {
      slot.innerHTML = '<span style="color: #666; font-size: 12px;">Empty</span>';
    }
    
    benchContainer.appendChild(slot);
  }
}

/**
 * Render hand with card images
 * @param {string} uiPlayerId - UI player ID ('p1' or 'p2')
 * @param {Array} hand - Hand array
 * @param {string} matchPlayerId - Match player ID (for determining if it's "my" hand)
 */
function renderHand(uiPlayerId, hand, matchPlayerId) {
  const handEl = document.querySelector(`#${uiPlayerId}Hand`);
  if (!handEl) return;
  
  // Update text
  handEl.textContent = `Hand: ${hand?.length || 0} cards`;
  
  // Find or create hand container for cards
  let handContainer = handEl.parentElement?.querySelector('.hand-cards');
  if (!handContainer) {
    handContainer = document.createElement('div');
    handContainer.className = 'hand-cards';
    handContainer.style.display = 'flex';
    handContainer.style.flexWrap = 'wrap';
    handContainer.style.gap = '4px';
    handContainer.style.marginTop = '8px';
    handEl.parentElement?.appendChild(handContainer);
  }
  
  // Clear existing cards
  handContainer.innerHTML = '';
  
  // Render each card
  if (hand && hand.length > 0) {
    const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
    // matchPlayerId is the match player ID for this hand (myPlayerId or opponentPlayerId)
    const isMyHand = matchPlayerId && matchPlayerId === myPlayerId;
    
    hand.forEach((card, index) => {
      const cardImg = document.createElement('img');
      
      // Show card back for opponent's hand
      if (isMyHand) {
        cardImg.src = card.image || highImgUrl(card.set, card.number || card.num) || 'imgs/cardback.png';
        cardImg.alt = card.name || 'Card';
        cardImg.style.cursor = 'pointer';
        cardImg.style.opacity = '1';
        
        // Store the card index in the image element for precise removal
        cardImg.dataset.handIndex = index;
        
        // Check if Rare Candy selection is active and this is an eligible Stage 2
        if (globalThis.__rareCandyActive && globalThis.__rareCandySelection) {
          const rareCandyData = globalThis.__rareCandySelection;
          const pairsForBasic = rareCandyData.pairsForBasic || [];
          
          // Check if this card is a valid Stage 2 for the selected Basic
          const matchingPair = pairsForBasic.find(p => 
            p.handCard.set === card.set && 
            String(p.handCard.number || p.handCard.num) === String(card.number || card.num)
          );
          
          if (matchingPair) {
            // Highlight eligible Stage 2 cards
            cardImg.style.border = '3px solid #22c55e';
            cardImg.style.boxShadow = '0 0 15px rgba(34, 197, 94, 0.8)';
            cardImg.style.transform = 'scale(1.05)';
            cardImg.style.transition = 'all 0.2s';
            cardImg.title = `Click to evolve ${rareCandyData.chosenBasic?.alt || 'Pokemon'} into ${card.name}`;
          }
        }
        
        // Add click handler for card play - use closure to capture the exact card and index
        cardImg.addEventListener('click', () => {
          // Check if Rare Candy selection is active
          if (globalThis.__rareCandyActive && globalThis.__rareCandySelection) {
            const rareCandyData = globalThis.__rareCandySelection;
            const pairsForBasic = rareCandyData.pairsForBasic || [];
            
            // Check if this card is a valid Stage 2 for the selected Basic
            const matchingPair = pairsForBasic.find(p => 
              p.handCard.set === card.set && 
              String(p.handCard.number || p.handCard.num) === String(card.number || card.num)
            );
            
            if (matchingPair) {
              // Resolve Rare Candy selection with this pair
              if (globalThis.__rareCandyResolve) {
                globalThis.__rareCandyResolve(matchingPair);
                globalThis.__rareCandyResolve = null;
              }
              return;
            } else {
              // Rare Candy is active but this card doesn't match - don't allow normal play
              showPopup('This card is not a valid evolution for the selected Basic Pokémon.');
              return;
            }
          }
          
          addLog(`Clicked card: ${card.name} at index ${index}`);
          // Pass both the card and its index to ensure we remove the correct one
          handleCardClick(card, matchPlayerId, index);
        });
      } else {
        // Opponent's hand - show card back
        cardImg.src = 'imgs/cardback.png';
        cardImg.alt = 'Card';
        cardImg.style.cursor = 'not-allowed';
        cardImg.style.opacity = '0.7';
      }
      
      cardImg.className = 'card-img';
      cardImg.style.width = 'var(--card-w)';
      cardImg.style.height = 'var(--card-h)';
      cardImg.dataset.set = card.set;
      cardImg.dataset.num = card.number || card.num;
      
      handContainer.appendChild(cardImg);
    });
  }
}

/**
 * Render discard pile
 * @param {string} uiPlayerId - UI player ID ('p1' or 'p2')
 * @param {Object} discard - Discard object with cards array
 * @param {string} matchPlayerId - Match player ID ('player1' or 'player2')
 */
function renderDiscard(uiPlayerId, discard, matchPlayerId) {
  const discardDiv = document.getElementById(`${uiPlayerId}Discard`);
  if (!discardDiv) return;
  
  // Find the container div inside
  let discardContainer = discardDiv.querySelector('div');
  if (!discardContainer) {
    discardContainer = document.createElement('div');
    discardContainer.style.cssText = 'display: flex; gap: 5px; flex-wrap: wrap; position: relative; min-height: 110px;';
    discardDiv.appendChild(discardContainer);
  }
  
  // Clear existing cards
  discardContainer.innerHTML = '';
  
  // Get discard cards array
  const discardCards = discard?.cards || [];
  
  // Show count
  const countEl = document.getElementById(`${uiPlayerId}DiscardCount`);
  if (countEl) {
    countEl.textContent = `Discard: ${discardCards.length} cards`;
  }
  
  // Render top 5 cards (most recent)
  const cardsToShow = discardCards.slice(-5).reverse();
  
  cardsToShow.forEach((card, index) => {
    const cardImg = document.createElement('img');
    cardImg.src = card.src || card.image || highImgUrl(card.set, card.num || card.number) || 'imgs/cardback.png';
    cardImg.alt = card.name || 'Discarded Card';
    cardImg.className = 'card-img';
    cardImg.style.width = 'var(--card-w)';
    cardImg.style.height = 'var(--card-h)';
    cardImg.style.opacity = '0.8';
    cardImg.style.cursor = 'pointer';
    
    // Stack cards with slight offset
    cardImg.style.position = 'relative';
    cardImg.style.left = `${index * 2}px`;
    cardImg.style.top = `${index * 2}px`;
    cardImg.style.marginLeft = `${-index * 2}px`;
    cardImg.style.marginTop = `${-index * 2}px`;
    
    // Add click to view card
    cardImg.addEventListener('click', () => {
      console.log('[V2-DISCARD] Card clicked:', card);
    });
    
    discardContainer.appendChild(cardImg);
  });
}

/**
 * Render all UI from state
 * @param {Object} state - Game state from state manager
 */
function renderAll(state) {
  if (!state) return;
  
  // Determine which player is "me" (UI player1 is always bottom)
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  const opponentPlayerId = myPlayerId === 'player1' ? 'player2' : 'player1';
  
  console.log('[V2-RENDER] Rendering state:', {
    myPlayerId,
    opponentPlayerId,
    isCurrentPlayer1: isCurrentPlayer1(),
    player1HandLength: state.player1?.hand?.length || 0,
    player2HandLength: state.player2?.hand?.length || 0,
    myHandLength: state[myPlayerId]?.hand?.length || 0,
    opponentHandLength: state[opponentPlayerId]?.hand?.length || 0
  });
  
  // Update UI labels based on which player you are
  // UI player1 (bottom) is always "you", UI player2 (top) is always "opponent"
  const p1Header = document.getElementById('p1Header');
  const p2Header = document.getElementById('p2Header');
  if (p1Header) {
    // UI player1 is always "you" - show which match player you are
    p1Header.textContent = myPlayerId === 'player1' ? 'Player 1 (You)' : 'Player 2 (You)';
  }
  if (p2Header) {
    // UI player2 is always "opponent" - show which match player they are
    p2Header.textContent = opponentPlayerId === 'player1' ? 'Player 1 (Opponent)' : 'Player 2 (Opponent)';
  }
  
  // Render my side (always UI player1 - bottom)
  renderActive('p1', state[myPlayerId]?.active);
  renderBench('p1', state[myPlayerId]?.bench || []);
  renderHand('p1', state[myPlayerId]?.hand || [], myPlayerId);
  renderDiscard('p1', state[myPlayerId]?.discard, myPlayerId);
  
  // Render opponent side (always UI player2 - top)
  renderActive('p2', state[opponentPlayerId]?.active);
  renderBench('p2', state[opponentPlayerId]?.bench || []);
  renderHand('p2', state[opponentPlayerId]?.hand || [], opponentPlayerId);
  renderDiscard('p2', state[opponentPlayerId]?.discard, opponentPlayerId);
  
  // Update points
  const pointsEl = document.getElementById('points');
  if (pointsEl) {
    pointsEl.textContent = `P1: ${state.p1Points || 0} | P2: ${state.p2Points || 0}`;
  }
  
  // Update turn info
  const turnEl = document.getElementById('turnInfo');
  if (turnEl) {
    const isSetupPhase = state.isSetupPhase !== false;
    if (isSetupPhase) {
      turnEl.textContent = 'Setup Phase';
    } else {
      const currentPlayerName = state.currentPlayer === 'player1' ? 'Player 1' : 'Player 2';
      const isMyTurn = state.currentPlayer === myPlayerId;
      turnEl.textContent = `Turn ${state.turnNumber || 1} - ${currentPlayerName}${isMyTurn ? ' (Your Turn)' : ' (Opponent\'s Turn)'}`;
    }
  }
  
  // Update deck counts
  updateDeckCounts(state, myPlayerId, opponentPlayerId);
  
  // Update buttons
  updateEndTurnButton();
  updateStartGameButton();
  
  // Update energy zone to only show allowed energy types
  updateEnergyZone(state[myPlayerId]?.energyTypes || []);
}

/**
 * Update energy zone to only show allowed energy types
 * Also disables the zone if it's not the player's turn or if it's the first turn
 * @param {Array<string>} allowedEnergyTypes - Array of allowed energy type keys
 */
function updateEnergyZone(allowedEnergyTypes) {
  const energyZone = document.getElementById('energyZone');
  if (!energyZone) return;
  
  const state = gameState.getState();
  if (!state) return;
  
  // Check if it's the player's turn
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  const isMyTurn = state.currentPlayer === myPlayerId;
  const isSetupPhase = state.isSetupPhase !== false;
  const turnNumber = state.turnNumber || 0;
  const isFirstTurn = turnNumber === 1 && !isSetupPhase;
  
  // Disable energy zone if:
  // 1. It's not the player's turn
  // 2. It's the first turn (and not setup phase)
  // 3. Energy has already been attached this turn (handled by disableEnergyZone elsewhere)
  if (!isMyTurn || isFirstTurn) {
    energyZone.classList.add('disabled');
  } else {
    // Only enable if it's the player's turn and not first turn
    // (but don't enable if energy was already attached - that's handled by disableEnergyZone)
    if (!hasAttachedEnergyThisTurn) {
      energyZone.classList.remove('disabled');
    }
  }
  
  // Get all energy type elements
  const energyTypes = energyZone.querySelectorAll('.energy-type');
  
  energyTypes.forEach(el => {
    const energyType = el.dataset.energy;
    if (allowedEnergyTypes.includes(energyType)) {
      el.style.display = 'block';
    } else {
      el.style.display = 'none';
    }
  });
  
  // If no energy types are allowed yet, show a message
  if (allowedEnergyTypes.length === 0) {
    const message = energyZone.querySelector('.energy-zone-message');
    if (!message) {
      const msgEl = document.createElement('div');
      msgEl.className = 'energy-zone-message';
      msgEl.textContent = 'No energy types selected. Please wait for game to initialize.';
      msgEl.style.cssText = 'width: 100%; padding: 10px; text-align: center; color: #9ca3af;';
      energyZone.appendChild(msgEl);
    }
  } else {
    const message = energyZone.querySelector('.energy-zone-message');
    if (message) {
      message.remove();
    }
  }
}

/**
 * Update deck counts and create clickable deck viewers
 */
function updateDeckCounts(state, myPlayerId, opponentPlayerId) {
  // Update my deck count
  const myDeckCount = state[myPlayerId]?.deck?.length || 0;
  const myDeckEl = document.getElementById('p1Deck');
  if (myDeckEl) {
    myDeckEl.textContent = `Deck: ${myDeckCount} cards`;
    myDeckEl.onclick = () => showDeckViewer(myPlayerId, state[myPlayerId]?.deck || []);
  }
  
  // Update opponent deck count
  const opponentDeckCount = state[opponentPlayerId]?.deck?.length || 0;
  const opponentDeckEl = document.getElementById('p2Deck');
  if (opponentDeckEl) {
    opponentDeckEl.textContent = `Deck: ${opponentDeckCount} cards`;
    opponentDeckEl.onclick = () => showDeckViewer(opponentPlayerId, state[opponentPlayerId]?.deck || []);
  }
}

/**
 * Show deck viewer popup with cards in order
 */
function showDeckViewer(playerId, deck) {
  const playerName = playerId === 'player1' ? 'Player 1' : 'Player 2';
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  const isMyDeck = playerId === myPlayerId;
  
  // Create popup overlay
  const overlay = document.createElement('div');
  overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center;';
  overlay.onclick = (e) => {
    if (e.target === overlay) {
      overlay.remove();
    }
  };
  
  // Create popup content
  const popup = document.createElement('div');
  popup.style.cssText = 'background: white; padding: 20px; border-radius: 10px; max-width: 90%; max-height: 90%; overflow-y: auto; position: relative;';
  
  const title = document.createElement('h2');
  title.textContent = `${playerName}'s Deck (${deck.length} cards)`;
  title.style.cssText = 'margin-top: 0; margin-bottom: 15px;';
  
  const closeBtn = document.createElement('button');
  closeBtn.textContent = '×';
  closeBtn.style.cssText = 'position: absolute; top: 10px; right: 10px; background: #ef4444; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 20px; line-height: 1;';
  closeBtn.onclick = () => overlay.remove();
  
  const cardsContainer = document.createElement('div');
  cardsContainer.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; margin-top: 15px;';
  
  // Add cards in order
  deck.forEach((card, index) => {
    const cardWrapper = document.createElement('div');
    cardWrapper.style.cssText = 'position: relative; cursor: pointer;';
    
    const cardImg = document.createElement('img');
    const cardNum = card.number || card.num;
    cardImg.src = highImgUrl(card.set, cardNum) || 'imgs/cardback.png';
    cardImg.style.cssText = 'width: 100%; height: auto; border-radius: 5px;';
    cardImg.alt = card.name || `${card.set}-${cardNum}`;
    cardImg.title = card.name || `${card.set}-${cardNum}`;
    
    // Add card number overlay
    const cardNumber = document.createElement('div');
    cardNumber.textContent = index + 1;
    cardNumber.style.cssText = 'position: absolute; top: 2px; left: 2px; background: rgba(0,0,0,0.7); color: white; padding: 2px 5px; border-radius: 3px; font-size: 10px; font-weight: bold;';
    
    cardWrapper.appendChild(cardImg);
    cardWrapper.appendChild(cardNumber);
    cardsContainer.appendChild(cardWrapper);
  });
  
  if (deck.length === 0) {
    const emptyMsg = document.createElement('div');
    emptyMsg.textContent = 'Deck is empty';
    emptyMsg.style.cssText = 'text-align: center; color: #9ca3af; padding: 20px;';
    cardsContainer.appendChild(emptyMsg);
  }
  
  popup.appendChild(title);
  popup.appendChild(closeBtn);
  popup.appendChild(cardsContainer);
  overlay.appendChild(popup);
  document.body.appendChild(overlay);
}

/**
 * Disable energy zone (after energy attachment)
 */
function disableEnergyZone() {
  const energyZone = document.getElementById('energyZone');
  if (energyZone) {
    energyZone.classList.add('disabled');
  }
}

/**
 * Enable energy zone (at start of turn)
 * Only enables if it's the player's turn and not the first turn
 */
function enableEnergyZone() {
  const energyZone = document.getElementById('energyZone');
  if (!energyZone) return;
  
  const state = gameState.getState();
  if (!state) return;
  
  // Check if it's the player's turn
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  const isMyTurn = state.currentPlayer === myPlayerId;
  const isSetupPhase = state.isSetupPhase !== false;
  const turnNumber = state.turnNumber || 0;
  const isFirstTurn = turnNumber === 1 && !isSetupPhase;
  
  // Only enable if it's the player's turn and not first turn
  if (isMyTurn && !isFirstTurn) {
    energyZone.classList.remove('disabled');
  } else {
    // Disable if not player's turn or first turn
    energyZone.classList.add('disabled');
  }
}

// ============================================================================
// ATTACK SYSTEM
// ============================================================================

/**
 * Show attack menu for a Pokemon
 * @param {Object} pokemon - Pokemon data
 * @param {string} playerId - Match player ID
 * @param {HTMLElement} slot - Pokemon slot element
 */
async function showAttackMenu(pokemon, playerId, slot) {
  // Validate turn
  if (!validateTurn('attack')) {
    return;
  }
  
  // Fetch card metadata to get attacks and retreat cost
  const meta = await fetchCardMeta(pokemon.set, pokemon.num || pokemon.number);
  if (!meta) {
    showPopup('Could not fetch card data.');
    return;
  }
  
  // Create or get attack menu
  let menu = document.getElementById('attackMenu');
  let backdrop = document.getElementById('attackMenuBackdrop');
  
  if (!menu) {
    menu = document.createElement('div');
    menu.id = 'attackMenu';
    menu.className = 'attack-menu';
    document.body.appendChild(menu);
  }
  
  if (!backdrop) {
    backdrop = document.createElement('div');
    backdrop.id = 'attackMenuBackdrop';
    backdrop.className = 'attack-menu-backdrop';
    backdrop.addEventListener('click', closeAttackMenu);
    document.body.appendChild(backdrop);
  }
  
  // Clear menu
  menu.innerHTML = `<div style="font-weight: bold; margin-bottom: 12px; font-size: 16px;">Select Action - ${pokemon.name || 'Pokemon'}</div>`;
  
  // Add each attack
  const attachedEnergy = pokemon.energy || [];
  const attachedEnergyTypes = attachedEnergy.map(e => e.type || e);
  
  if (meta.attacks && meta.attacks.length > 0) {
    meta.attacks.forEach((attack, index) => {
      const attackItem = document.createElement('div');
      attackItem.className = 'attack-item';
      
      // Check if energy cost is met
      const cost = attack.cost || [];
      const canUse = canAffordAttack(cost, attachedEnergyTypes);
      
      if (!canUse) {
        attackItem.style.opacity = '0.5';
        attackItem.style.cursor = 'not-allowed';
      }
      
      attackItem.innerHTML = `
        <div class="attack-name">${attack.name || 'Attack'}</div>
        <div class="attack-cost">Cost: ${formatEnergyCostWithIcons(cost)}</div>
        ${attack.damage ? `<div class="attack-damage">Damage: ${attack.damage}</div>` : ''}
        ${attack.text ? `<div class="attack-description">${attack.text}</div>` : ''}
      `;
      
      if (canUse) {
        attackItem.addEventListener('click', () => {
          closeAttackMenu();
          executeAttack(attack, meta, pokemon, playerId);
        });
      } else {
        attackItem.addEventListener('click', () => {
          showPopup('Not enough energy to use this attack.');
        });
      }
      
      menu.appendChild(attackItem);
    });
  }
  
  // Add retreat option at the bottom
  const state = gameState.getState();
  const player = state?.[playerId];
  const retreatCost = parseInt(meta.retreat || meta.retreatCost || '0', 10) || 0;
  const hasBench = player?.bench && player.bench.some(p => p !== null && p !== undefined);
  const canRetreat = hasBench && attachedEnergy.length >= retreatCost && !hasRetreatedThisTurn;
  
  // Add separator if there are attacks
  if (meta.attacks && meta.attacks.length > 0) {
    const separator = document.createElement('div');
    separator.style.cssText = 'height: 1px; background: #555; margin: 12px 0;';
    menu.appendChild(separator);
  }
  
  // Retreat option
  const retreatItem = document.createElement('div');
  retreatItem.className = 'attack-item';
  retreatItem.style.borderTop = '2px solid #0ea5e9';
  
  if (!canRetreat) {
    retreatItem.style.opacity = '0.5';
    retreatItem.style.cursor = 'not-allowed';
  }
  
  let retreatDescription = 'Switch this Pokemon with a bench Pokemon';
  if (hasRetreatedThisTurn) {
    retreatDescription = 'You can only retreat once per turn';
  }
  
  retreatItem.innerHTML = `
    <div class="attack-name">Retreat</div>
    <div class="attack-cost">Cost: ${formatEnergyCostWithIcons(Array(retreatCost).fill('colorless'))}</div>
    <div class="attack-description">${retreatDescription}</div>
  `;
  
  if (canRetreat) {
    retreatItem.addEventListener('click', async () => {
      closeAttackMenu();
      await showRetreatSelection(playerId, pokemon, retreatCost);
    });
  } else {
    retreatItem.addEventListener('click', () => {
      if (hasRetreatedThisTurn) {
        showPopup('You can only retreat once per turn!');
      } else if (!hasBench) {
        showPopup('No bench Pokemon to retreat to!');
      } else {
        showPopup(`Not enough energy to retreat! Need ${retreatCost}, have ${attachedEnergy.length}`);
      }
    });
  }
  
  menu.appendChild(retreatItem);
  
  // Show menu
  menu.classList.add('show');
  backdrop.classList.add('show');
}

/**
 * Close attack menu
 */
function closeAttackMenu() {
  const menu = document.getElementById('attackMenu');
  const backdrop = document.getElementById('attackMenuBackdrop');
  if (menu) menu.classList.remove('show');
  if (backdrop) backdrop.classList.remove('show');
}

/**
 * Check if player can afford attack cost
 * @param {Array} cost - Attack energy cost array
 * @param {Array} attachedEnergyTypes - Array of attached energy types
 * @returns {boolean} True if cost can be paid
 */
function canAffordAttack(cost, attachedEnergyTypes) {
  if (!cost || cost.length === 0) return true;
  
  const availableEnergy = [...attachedEnergyTypes];
  
  for (const energyReq of cost) {
    const energyType = (energyReq.type || energyReq).toLowerCase();
    
    // Check for colorless (can be paid with any energy)
    if (energyType === 'colorless' || energyType === 'c') {
      if (availableEnergy.length === 0) return false;
      availableEnergy.shift(); // Remove one energy
    } else {
      // Specific energy type required
      const index = availableEnergy.findIndex(e => e.toLowerCase() === energyType);
      if (index === -1) return false;
      availableEnergy.splice(index, 1);
    }
  }
  
  return true;
}

/**
 * Format energy cost for display
 * @param {Array} cost - Attack energy cost array
 * @returns {string} Formatted cost string
 */
function formatEnergyCost(cost) {
  if (!cost || cost.length === 0) return 'None';
  
  const counts = {};
  cost.forEach(e => {
    const type = (e.type || e).toLowerCase();
    counts[type] = (counts[type] || 0) + 1;
  });
  
  return Object.entries(counts)
    .map(([type, count]) => `${count} ${type}`)
    .join(', ');
}

/**
 * Format energy cost with icons/pips
 * @param {Array} cost - Attack energy cost array
 * @returns {string} HTML string with energy icons
 */
function formatEnergyCostWithIcons(cost) {
  if (!cost || cost.length === 0) return '<span style="color: #9ca3af;">None</span>';
  
  const counts = {};
  cost.forEach(e => {
    const type = (e.type || e).toLowerCase();
    counts[type] = (counts[type] || 0) + 1;
  });
  
  let html = '<span style="display: inline-flex; gap: 2px; align-items: center;">';
  Object.entries(counts).forEach(([type, count]) => {
    for (let i = 0; i < count; i++) {
      html += `<img src="${ENERGY_ICONS[type] || ENERGY_ICONS.colorless}" alt="${type}" style="width: 16px; height: 16px; display: inline-block;">`;
    }
  });
  html += '</span>';
  
  return html;
}

/**
 * Execute an attack
 * @param {Object} attack - Attack data
 * @param {Object} meta - Card metadata
 * @param {Object} pokemon - Attacking Pokemon
 * @param {string} playerId - Match player ID
 */
async function executeAttack(attack, meta, pokemon, playerId) {
  console.log('[V2-ATTACK] Executing attack:', { attack, pokemon, playerId });
  
  const state = gameState.getState();
  if (!state) return;
  
  const opponentId = playerId === 'player1' ? 'player2' : 'player1';
  const opponent = state[opponentId];
  
  if (!opponent || !opponent.active) {
    showPopup('Opponent has no active Pokemon.');
    return;
  }
  
  // Calculate damage
  let damage = 0;
  if (attack.damage) {
    const dmgStr = String(attack.damage).toLowerCase();
    const match = dmgStr.match(/\d+/);
    if (match) {
      damage = parseInt(match[0], 10);
    }
  }
  
  // Apply damage to opponent's active Pokemon
  const opponentActive = opponent.active;
  const currentHp = opponentActive.chp || opponentActive.hp || 0;
  const newHp = Math.max(0, currentHp - damage);
  
  const updatedOpponentActive = {
    ...opponentActive,
    chp: newHp
  };
  
  // Update opponent's active Pokemon
  await gameState.updatePlayerState(opponentId, {
    active: updatedOpponentActive
  });
  
  // Broadcast attack action
  const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
  await broadcastAction(ACTION_TYPES.ATTACK, {
    playerId,
    attack: attack.name,
    damage,
    target: opponentId,
    pokemonName: pokemon.name
  });
  
  addLog(`${pokemon.name || 'Pokemon'} used ${attack.name || 'attack'}${damage > 0 ? ` for ${damage} damage` : ''}`);
  showStatusMessage(`${pokemon.name || 'Pokemon'} attacked for ${damage} damage!`);
  
  // Check for knockout
  if (newHp === 0) {
    addLog(`${opponentActive.name || 'Opponent Pokemon'} was knocked out!`);
    // TODO: Handle knockout (prize cards, bench promotion, etc.)
  }
  
  // End turn after attacking
  console.log('[V2-ATTACK] Attack completed, ending turn...');
  await handleEndTurn();
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Get high-resolution card image URL
function highImgUrl(set, num) {
  if (!set || num == null) return null;
  const paddedNum = String(num).padStart(3, '0');
  return `https://assets.tcgdex.net/en/tcgp/${set}/${paddedNum}/high.png`;
}

function getEnergyColor(energyType) {
  const colors = {
    fire: '#f97316',
    water: '#38bdf8',
    grass: '#22c55e',
    lightning: '#facc15',
    psychic: '#a855f7',
    fighting: '#f97316',
    darkness: '#4b5563',
    metal: '#9ca3af',
    colorless: '#e5e7eb'
  };
  return colors[energyType] || '#666';
}

function showStatusMessage(message) {
  const statusEl = document.getElementById('status');
  if (statusEl) {
    statusEl.textContent = message;
    setTimeout(() => {
      statusEl.textContent = '';
    }, 3000);
  }
}

function addLog(message) {
  const logEl = document.getElementById('log');
  if (logEl) {
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    logEl.appendChild(entry);
    logEl.scrollTop = logEl.scrollHeight;
  }
}


/**
 * Update Start Game button state
 */
function updateStartGameButton() {
  const button = document.getElementById('startGameButton');
  if (!button) return;
  
  const state = gameState.getState();
  if (!state) {
    button.style.display = 'none';
    return;
  }
  
  const isSetupPhase = state.isSetupPhase !== false;
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  const myReadyKey = myPlayerId === 'player1' ? 'player1Ready' : 'player2Ready';
  const opponentReadyKey = myPlayerId === 'player1' ? 'player2Ready' : 'player1Ready';
  
  const myReady = state[myReadyKey] === true;
  const opponentReady = state[opponentReadyKey] === true;
  
  // Show button only during setup phase
  if (!isSetupPhase) {
    button.style.display = 'none';
    return;
  }
  
  button.style.display = 'block';
  
  // Check if both players have active Pokemon
  const myPlayer = state[myPlayerId];
  const hasActive = myPlayer?.active !== null && myPlayer?.active !== undefined;
  
  if (!hasActive) {
    button.disabled = true;
    button.textContent = 'Place Active Pokemon First';
    return;
  }
  
  if (myReady && opponentReady) {
    button.disabled = true;
    button.textContent = 'Both players ready - Starting game...';
  } else if (myReady) {
    button.disabled = true;
    button.textContent = 'Waiting for opponent...';
  } else {
    button.disabled = false;
    button.textContent = 'Start Game';
  }
}

/**
 * Update End Turn button state
 */
function updateEndTurnButton() {
  const button = document.getElementById('endTurnButton');
  if (!button) {
    console.warn('[V2-END-TURN] Button not found in updateEndTurnButton');
    return;
  }
  
  const state = gameState.getState();
  if (!state) {
    button.disabled = true;
    button.textContent = 'End Turn';
    return;
  }
  
  const isSetupPhase = state.isSetupPhase !== false;
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  const isMyTurn = state.currentPlayer === myPlayerId;
  
  console.log('[V2-END-TURN] Updating button state:', { isSetupPhase, myPlayerId, currentPlayer: state.currentPlayer, isMyTurn });
  
  // Hide during setup phase
  if (isSetupPhase) {
    button.style.display = 'none';
    return;
  }
  
  button.style.display = 'block';
  
  // Enable only on your turn
  button.disabled = !isMyTurn;
  button.textContent = isMyTurn ? 'End Turn' : 'Waiting for opponent...';
  
  console.log('[V2-END-TURN] Button state:', { disabled: button.disabled, text: button.textContent, display: button.style.display });
}

/**
 * Handle starting the game (mark player as ready)
 */
async function handleStartGame() {
  const state = gameState.getState();
  if (!state) return;
  
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  const myPlayer = state[myPlayerId];
  
  // Validate: Must have active Pokemon
  if (!myPlayer?.active) {
    showPopup('You must place an Active Pokemon before starting the game.');
    return;
  }
  
  // Mark player as ready
  const readyKey = myPlayerId === 'player1' ? 'player1Ready' : 'player2Ready';
  await gameState.updateState({
    [readyKey]: true
  });
  
  addLog(`${myPlayerId === 'player1' ? 'Player 1' : 'Player 2'} is ready to start`);
  showStatusMessage('Waiting for opponent to start game...');
  
  // Check if both players are ready after a short delay (to allow state to sync)
  setTimeout(async () => {
    const currentState = gameState.getState();
    if (currentState) {
      const opponentReadyKey = myPlayerId === 'player1' ? 'player2Ready' : 'player1Ready';
      const bothReady = currentState[readyKey] === true && currentState[opponentReadyKey] === true;
      const isSetupPhase = currentState.isSetupPhase !== false;
      
      console.log('[V2-START] Checking ready state after update:', { 
        myPlayerId, 
        isP1: myPlayerId === 'player1',
        myReady: currentState[readyKey], 
        opponentReady: currentState[opponentReadyKey],
        bothReady, 
        isSetupPhase 
      });
      
      // If both ready and still in setup, and we're player1, start the game
      if (bothReady && isSetupPhase && myPlayerId === 'player1') {
        console.log('[V2-START] Both ready detected in handleStartGame, starting game...');
        await startGameFromReady();
      }
    }
  }, 200);
}

/**
 * Start the game when both players are ready
 */
async function startGameFromReady() {
  console.log('[V2-START] Both players ready, starting game...');
  
  const state = gameState.getState();
  if (!state) return;
  
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  const isP1 = myPlayerId === 'player1';
  
  // Only player1 (host) should handle coin flip and game start
  // This prevents both players from doing it simultaneously
  if (!isP1) {
    console.log('[V2-START] Player 2 waiting for Player 1 to start game...');
    return;
  }
  
  // Perform coin flip to determine first player
  const coinFlip = Math.random() < 0.5 ? 'player1' : 'player2';
  const firstPlayer = coinFlip;
  
  console.log('[V2-START] Coin flip result:', { firstPlayer });
  addLog(`Coin flip: ${firstPlayer === 'player1' ? 'Player 1' : 'Player 2'} goes first`);
  
  // Update game state: end setup phase, set first player, start turn 1
  await gameState.updateState({
    isSetupPhase: false,
    firstPlayer: firstPlayer,
    currentPlayer: firstPlayer,
    turnNumber: 1
  });
  
  // Broadcast game start action
  const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
  await broadcastAction(ACTION_TYPES.START_TURN, {
    firstPlayer: firstPlayer,
    turnNumber: 1
  });
  
  showStatusMessage('Game started!');
  addLog('Game started!');
  
  // Start first turn - draw card for first player
  // Note: This will be called, and the turnDraws map will prevent double draws
  // even if the state subscription also tries to call handleTurnStart
  console.log('[V2-START] About to call handleTurnStart for first player:', firstPlayer);
  await handleTurnStart(firstPlayer, 1);
  console.log('[V2-START] Called handleTurnStart for first player:', firstPlayer);
}

/**
 * Handle ending the turn
 */
async function handleEndTurn() {
  console.log('[V2-END-TURN] End turn clicked');
  
  if (!validateTurn('end your turn')) {
    console.log('[V2-END-TURN] Turn validation failed');
    return;
  }
  
  const state = gameState.getState();
  if (!state) {
    console.error('[V2-END-TURN] No state available');
    return;
  }
  
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  const nextPlayer = myPlayerId === 'player1' ? 'player2' : 'player1';
  const newTurnNumber = (state.turnNumber || 1) + 1;
  
  console.log('[V2-END-TURN] Ending turn:', { myPlayerId, nextPlayer, newTurnNumber });
  
  try {
    // Set a flag to prevent state subscription from calling handleTurnStart during turn end
    globalThis.__endingTurn = true;
    
    // Call handleTurnStart BEFORE updating turn info to ensure draw happens at START of turn
    // This prevents the state subscription from triggering the draw first
    console.log('[V2-END-TURN] Calling handleTurnStart for next player BEFORE turn update:', nextPlayer, newTurnNumber);
    await handleTurnStart(nextPlayer, newTurnNumber);
    
    // Now update turn info (this will trigger state subscription, but draw is already done)
    await gameState.updateTurnInfo({
      currentPlayer: nextPlayer,
      turnNumber: newTurnNumber
    });
    
    console.log('[V2-END-TURN] Turn info updated');
    
    // Broadcast turn end action
    const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
    await broadcastAction(ACTION_TYPES.END_TURN, {
      previousPlayer: myPlayerId,
      nextPlayer: nextPlayer,
      turnNumber: newTurnNumber
    });
    
    console.log('[V2-END-TURN] Turn end action broadcasted');
    
    addLog(`Turn ended. Turn ${newTurnNumber} - ${nextPlayer === 'player1' ? 'Player 1' : 'Player 2'}`);
    showStatusMessage('Turn ended');
    
    // Clear the flag after turn start is handled
    setTimeout(() => {
      globalThis.__endingTurn = false;
    }, 100);
  } catch (error) {
    console.error('[V2-END-TURN] Error ending turn:', error);
    showPopup('Error ending turn: ' + error.message);
  }
}

/**
 * Handle turn start (draw card, trigger abilities, etc.)
 * @param {string} playerId - Player whose turn is starting
 * @param {number} turnNumber - Current turn number
 */
// Track which turns have already drawn to prevent double draws
const turnDraws = new Map(); // Map of "playerId-turnNumber" -> true

async function handleTurnStart(playerId, turnNumber) {
  console.log('[V2-TURN] Turn started:', { playerId, turnNumber });
  
  const state = gameState.getState();
  if (!state) return;
  
  const player = state[playerId];
  if (!player) return;
  
  const firstPlayer = state.firstPlayer || 'player1';
  const isFirstTurn = turnNumber === 1;
  const isFirstPlayerOnTurn1 = isFirstTurn && playerId === firstPlayer;
  
  // Reset energy attachment flag, retreat flag, and supporter flag for the player whose turn it is
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  if (playerId === myPlayerId) {
    hasAttachedEnergyThisTurn = false;
    hasRetreatedThisTurn = false;
    hasPlayedSupporterThisTurn = false;
    // Re-enable energy zone at start of turn
    enableEnergyZone();
  }
  
  // Draw a card at the start of turn (all players, including first player on turn 1)
  // But only if we haven't already drawn for this turn
  const drawKey = `${playerId}-${turnNumber}`;
  console.log('[V2-TURN] Checking draw:', { 
    drawKey, 
    hasDrawn: turnDraws.has(drawKey), 
    hasDeck: !!player.deck, 
    deckLength: player.deck?.length || 0 
  });
  
  if (!turnDraws.has(drawKey) && player.deck && player.deck.length > 0) {
    console.log('[V2-TURN] Drawing card for turn start:', { playerId, turnNumber });
    turnDraws.set(drawKey, true);
    
    // Clean up old entries (keep only last 10 turns)
    if (turnDraws.size > 20) {
      const entries = Array.from(turnDraws.entries());
      const toKeep = entries.slice(-10);
      turnDraws.clear();
      toKeep.forEach(([key, value]) => turnDraws.set(key, value));
    }
    
    const newDeck = [...player.deck];
    const drawnCard = newDeck.shift();
    const newHand = [...(player.hand || []), drawnCard];
    
    console.log('[V2-TURN] Draw details:', {
      drawnCard: drawnCard?.name,
      newHandSize: newHand.length,
      newDeckSize: newDeck.length
    });
    
    // Set flag to prevent Firebase from overwriting
    if (!globalThis.__updatingState) {
      globalThis.__updatingState = new Set();
    }
    globalThis.__updatingState.add(`${playerId}/hand`);
    globalThis.__updatingState.add(`${playerId}/deck`);
    
    try {
      // Set flag to prevent render during update
      globalThis.__isUpdatingLocalState = true;
    
    await gameState.updatePlayerState(playerId, {
      deck: newDeck,
      hand: newHand
    });
      
      console.log('[V2-TURN] State updated, forcing render');
      
      // Clear the render flag immediately so UI can update
      globalThis.__isUpdatingLocalState = false;
      
      // Force a render to update the UI immediately
      const currentState = gameState.getState();
      if (currentState) {
        console.log('[V2-TURN] Rendering UI with updated state');
        renderAll(currentState);
      }
      
      // Clear flags after a delay
      setTimeout(() => {
        if (globalThis.__updatingState) {
          globalThis.__updatingState.delete(`${playerId}/hand`);
          globalThis.__updatingState.delete(`${playerId}/deck`);
        }
      }, 1000);
    } catch (error) {
      // Clear flags on error
      globalThis.__isUpdatingLocalState = false;
      if (globalThis.__updatingState) {
        globalThis.__updatingState.delete(`${playerId}/hand`);
        globalThis.__updatingState.delete(`${playerId}/deck`);
      }
      throw error;
    }
    
    addLog(`${playerId === 'player1' ? 'Player 1' : 'Player 2'} drew a card`);
    console.log('[V2-TURN] Draw complete for turn start');
  } else if (turnDraws.has(drawKey)) {
    console.log('[V2-TURN] Skipping draw - already drew for this turn:', drawKey);
  } else if (!player.deck || player.deck.length === 0) {
    console.log('[V2-TURN] Skipping draw - no cards in deck');
  }
  
  // TODO: Trigger turn start abilities
  // TODO: Apply status effects (burn, poison damage, etc.)
  
  showStatusMessage(`${playerId === 'player1' ? 'Player 1' : 'Player 2'}'s turn`);
}

/**
 * Handle resetting the game (for testing)
 * When clicked, sends a reset request to the opponent
 */
async function handleResetGame() {
  console.log('[V2-RESET] Reset button clicked...');
  
  try {
    const state = gameState.getState();
    if (!state) {
      showPopup('No game state to reset');
      return;
    }
    
    const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
    console.log('[V2-RESET] My player ID:', myPlayerId);
    
    // Broadcast reset request to opponent
    const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
    console.log('[V2-RESET] Imported ACTION_TYPES:', ACTION_TYPES);
    console.log('[V2-RESET] RESET_REQUEST value:', ACTION_TYPES.RESET_REQUEST);
    
    const actionData = {
      fromPlayer: myPlayerId
    };
    console.log('[V2-RESET] Broadcasting reset request with data:', actionData);
    
    await broadcastAction(ACTION_TYPES.RESET_REQUEST, actionData);
    
    console.log('[V2-RESET] Broadcast complete');
    addLog(`${myPlayerId === 'player1' ? 'Player 1' : 'Player 2'} requested game reset. Waiting for opponent...`);
    showStatusMessage('Reset requested. Waiting for opponent to confirm...');
  } catch (error) {
    console.error('[V2-RESET] Error requesting reset:', error);
    console.error('[V2-RESET] Error stack:', error.stack);
    showPopup('Error requesting reset: ' + error.message);
  }
}

/**
 * Handle reset request from opponent
 */
async function handleResetRequest(actionData) {
  console.log('[V2-RESET] Received reset request from opponent:', actionData);
  
  if (!actionData || !actionData.fromPlayer) {
    console.error('[V2-RESET] Invalid action data:', actionData);
    return;
  }
  
  const { fromPlayer } = actionData;
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  
  console.log('[V2-RESET] Reset request details:', { fromPlayer, myPlayerId });
  
  // Only show popup if we're the opponent
  if (fromPlayer === myPlayerId) {
    console.log('[V2-RESET] Ignoring own reset request');
    return; // This is our own request, ignore
  }
  
  // Show popup asking if they want to reset
  // Use showPopup instead of confirm to avoid browser suppression issues
  const opponentName = fromPlayer === 'player1' ? 'Player 1' : 'Player 2';
  
  // Create a custom confirmation dialog
  let confirmed = false;
  const confirmMessage = `${opponentName} requested to create a new game with the same decks. Do you want to continue?`;
  
  // Use a promise-based confirmation that works even when tab is not active
  confirmed = await new Promise((resolve) => {
    // Create a modal dialog
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'flex';
    modal.style.zIndex = '10000';
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 400px;">
        <h3>Reset Game Request</h3>
        <p>${confirmMessage}</p>
        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
          <button id="resetConfirmYes" style="padding: 10px 20px; background: #22c55e; color: white; border: none; border-radius: 5px; cursor: pointer;">Yes</button>
          <button id="resetConfirmNo" style="padding: 10px 20px; background: #ef4444; color: white; border: none; border-radius: 5px; cursor: pointer;">No</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    const yesBtn = document.getElementById('resetConfirmYes');
    const noBtn = document.getElementById('resetConfirmNo');
    
    const cleanup = () => {
      document.body.removeChild(modal);
    };
    
    yesBtn.addEventListener('click', () => {
      cleanup();
      resolve(true);
    });
    
    noBtn.addEventListener('click', () => {
      cleanup();
      resolve(false);
    });
    
    // Close on backdrop click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        cleanup();
        resolve(false);
      }
    });
  });
  
  console.log('[V2-RESET] User response to reset request:', confirmed);
  
  const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
  
  if (confirmed) {
    // Accept reset - broadcast acceptance
    console.log('[V2-RESET] Broadcasting reset acceptance');
    await broadcastAction(ACTION_TYPES.RESET_ACCEPTED, {
      fromPlayer: fromPlayer,
      acceptedBy: myPlayerId
    });
    
    addLog(`${myPlayerId === 'player1' ? 'Player 1' : 'Player 2'} accepted the reset request.`);
    
    // Create new match (only player1 should do this to avoid race conditions)
    // If we're player1, create it now. If we're player2, player1 will create it when they receive the acceptance
    if (myPlayerId === 'player1') {
      console.log('[V2-RESET] Player1 creating new match after accepting request from', fromPlayer);
      // Small delay to ensure state is ready
      setTimeout(async () => {
        console.log('[V2-RESET] About to create new match from handleResetRequest');
        await createNewMatchWithSameDecks();
        console.log('[V2-RESET] New match created');
      }, 200);
    } else {
      console.log('[V2-RESET] Player2 accepted, waiting for Player1 to create new match');
      // Player 2 accepted, but Player 1 needs to create the new match
      // Player 1 will receive the RESET_ACCEPTED action and create it
    }
  } else {
    // Decline reset - broadcast decline
    console.log('[V2-RESET] Broadcasting reset decline');
    await broadcastAction(ACTION_TYPES.RESET_DECLINED, {
      fromPlayer: fromPlayer,
      declinedBy: myPlayerId
    });
    
    addLog(`${myPlayerId === 'player1' ? 'Player 1' : 'Player 2'} declined the reset request.`);
    showStatusMessage('Reset declined.');
  }
}

/**
 * Handle reset acceptance from opponent
 */
async function handleResetAccepted(actionData) {
  console.log('[V2-RESET] Reset accepted by opponent:', actionData);
  
  const { fromPlayer, acceptedBy, newMatchId } = actionData;
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  
  console.log('[V2-RESET] Reset acceptance check:', {
    fromPlayer,
    acceptedBy,
    myPlayerId,
    newMatchId,
    shouldPerform: myPlayerId === 'player1'
  });
  
  // If newMatchId is provided, redirect to the new match (Player 2 receives this)
  if (newMatchId) {
    console.log('[V2-RESET] New match ID received, redirecting to:', newMatchId);
    addLog('New game created! Redirecting...');
    showStatusMessage('New game created! Redirecting...');
    setTimeout(() => {
      window.location.href = `online-battle-v2.html#matchId=${newMatchId}`;
    }, 500);
    return;
  }
  
  // Only player1 should create the new match to avoid race conditions
  // If we are player1, create the new match regardless of who requested it
  if (myPlayerId === 'player1') {
    // We are player1 - we should create the new match
    addLog('Reset accepted. Creating new game...');
    console.log('[V2-RESET] Player1 creating new match (from handleResetAccepted)');
    setTimeout(async () => {
      console.log('[V2-RESET] About to create new match from handleResetAccepted');
      try {
        await createNewMatchWithSameDecks();
        console.log('[V2-RESET] New match created successfully');
      } catch (error) {
        console.error('[V2-RESET] Error creating new match:', error);
        showPopup('Error creating new game: ' + error.message);
      }
    }, 200);
  } else {
    // We are player2 - player1 will create the new match
    addLog('Opponent accepted the reset request. Creating new game...');
    console.log('[V2-RESET] Player2 waiting for Player1 to create new match');
  }
}

/**
 * Collect all cards from a player's game state (deck, hand, active, bench, discard, prize cards, energy, tools)
 */
function collectAllCardsFromState(playerState, playerId) {
  const allCards = [];
  
  // Add cards from deck
  if (playerState?.deck && Array.isArray(playerState.deck)) {
    const deckCards = playerState.deck.filter(c => c && typeof c === 'object');
    allCards.push(...deckCards);
  }
  
  // Add cards from hand
  if (playerState?.hand && Array.isArray(playerState.hand)) {
    const handCards = playerState.hand.filter(c => c && typeof c === 'object');
    allCards.push(...handCards);
  }
  
  // Add active Pokemon
  if (playerState?.active && typeof playerState.active === 'object') {
    allCards.push(playerState.active);
    
    // Also collect energy attached to active Pokemon
    if (playerState.active.energy && Array.isArray(playerState.active.energy)) {
      const energyCards = playerState.active.energy.filter(c => c && typeof c === 'object');
      allCards.push(...energyCards);
    }
    
    // Also collect tool attached to active Pokemon
    if (playerState.active.tool && typeof playerState.active.tool === 'object') {
      allCards.push(playerState.active.tool);
    }
  }
  
  // Add bench Pokemon
  if (playerState?.bench && Array.isArray(playerState.bench)) {
    playerState.bench.forEach(pokemon => {
      if (pokemon && typeof pokemon === 'object') {
        allCards.push(pokemon);
        
        // Also collect energy attached to bench Pokemon
        if (pokemon.energy && Array.isArray(pokemon.energy)) {
          const energyCards = pokemon.energy.filter(c => c && typeof c === 'object');
          allCards.push(...energyCards);
        }
        
        // Also collect tool attached to bench Pokemon
        if (pokemon.tool && typeof pokemon.tool === 'object') {
          allCards.push(pokemon.tool);
        }
      }
    });
  }
  
  // Add cards from discard
  if (playerState?.discard) {
    // Add discard cards
    if (playerState.discard.cards && Array.isArray(playerState.discard.cards)) {
      const discardCards = playerState.discard.cards.filter(c => c && typeof c === 'object');
      allCards.push(...discardCards);
    }
    
    // Convert energy counts to energy card objects
    if (playerState.discard.energyCounts && typeof playerState.discard.energyCounts === 'object') {
      Object.entries(playerState.discard.energyCounts).forEach(([type, count]) => {
        for (let i = 0; i < count; i++) {
          allCards.push({
            set: 'ENERGY',
            number: type,
            name: `${type} Energy`,
            category: 'Energy',
            isEnergy: true
          });
        }
      });
    }
  }
  
  // Add prize cards
  if (playerState?.prizeCards && Array.isArray(playerState.prizeCards)) {
    const prizeCards = playerState.prizeCards.filter(c => c && typeof c === 'object');
    allCards.push(...prizeCards);
  }
  
  return allCards;
}

/**
 * Create a new match with the same decks as the current match
 */
async function createNewMatchWithSameDecks() {
  console.log('[V2-RESET] ===== CREATING NEW MATCH WITH SAME DECKS =====');
  
  try {
    if (!window.firebaseDatabase) {
      throw new Error('Firebase Database not initialized');
    }
    
    const currentMatchId = getCurrentMatchId();
    if (!currentMatchId) {
      throw new Error('No current match ID found');
    }
    
    // Get current match document to extract player IDs and decks
    const { getMatchRef, DB_PATHS } = await import('./js/online/schema.js');
    const matchRef = getMatchRef(currentMatchId);
    const matchSnapshot = await matchRef.once('value');
    const currentMatch = matchSnapshot.val();
    
    if (!currentMatch) {
      throw new Error('Current match not found');
    }
    
    const player1Id = currentMatch.player1Id;
    const player2Id = currentMatch.player2Id;
    
    if (!player1Id || !player2Id) {
      throw new Error('Match player IDs not found');
    }
    
    console.log('[V2-RESET] Current match info:', {
      matchId: currentMatchId,
      player1Id,
      player2Id
    });
    
    // Get original decks - prefer stored originalDecks, fallback to collecting from current state
    let player1Deck = null;
    let player2Deck = null;
    let player1Energy = [];
    let player2Energy = [];
    
    // Try to get from stored originalDecks first
    if (originalDecks.player1 && originalDecks.player1.length >= 15) {
      player1Deck = originalDecks.player1;
      console.log('[V2-RESET] Using stored original deck for player1:', player1Deck.length, 'cards');
    } else if (currentMatch.gameState?.player1?.deck && currentMatch.gameState.player1.deck.length >= 20) {
      player1Deck = currentMatch.gameState.player1.deck;
      console.log('[V2-RESET] Using match document deck for player1:', player1Deck.length, 'cards');
    } else {
      // Try to collect all cards from current game state
      console.log('[V2-RESET] Original deck not found, collecting cards from current game state for player1...');
      const state = gameState.getState();
      if (state?.player1) {
        player1Deck = collectAllCardsFromState(state.player1, 'player1');
        console.log('[V2-RESET] Collected', player1Deck.length, 'cards for player1 from current state');
      }
    }
    
    if (originalDecks.player2 && originalDecks.player2.length >= 15) {
      player2Deck = originalDecks.player2;
      console.log('[V2-RESET] Using stored original deck for player2:', player2Deck.length, 'cards');
    } else if (currentMatch.gameState?.player2?.deck && currentMatch.gameState.player2.deck.length >= 20) {
      player2Deck = currentMatch.gameState.player2.deck;
      console.log('[V2-RESET] Using match document deck for player2:', player2Deck.length, 'cards');
    } else {
      // Try to collect all cards from current game state
      console.log('[V2-RESET] Original deck not found, collecting cards from current game state for player2...');
      const state = gameState.getState();
      if (state?.player2) {
        player2Deck = collectAllCardsFromState(state.player2, 'player2');
        console.log('[V2-RESET] Collected', player2Deck.length, 'cards for player2 from current state');
      }
    }
    
    // Get energy types from current match
    if (currentMatch.gameState?.player1?.energyTypes) {
      player1Energy = currentMatch.gameState.player1.energyTypes;
    }
    if (currentMatch.gameState?.player2?.energyTypes) {
      player2Energy = currentMatch.gameState.player2.energyTypes;
    }
    
    if (!player1Deck || player1Deck.length < 15) {
      console.error('[V2-RESET] Player1 deck issue:', {
        hasDeck: !!player1Deck,
        deckLength: player1Deck?.length || 0,
        hasOriginal: !!originalDecks.player1,
        originalLength: originalDecks.player1?.length || 0
      });
      throw new Error(`Could not retrieve player1 deck. Found ${player1Deck?.length || 0} cards. Please ensure decks were properly loaded.`);
    }
    
    if (!player2Deck || player2Deck.length < 15) {
      console.error('[V2-RESET] Player2 deck issue:', {
        hasDeck: !!player2Deck,
        deckLength: player2Deck?.length || 0,
        hasOriginal: !!originalDecks.player2,
        originalLength: originalDecks.player2?.length || 0
      });
      throw new Error(`Could not retrieve player2 deck. Found ${player2Deck?.length || 0} cards. Please ensure decks were properly loaded.`);
    }
    
    console.log('[V2-RESET] Decks for new match:', {
      player1DeckLength: player1Deck.length,
      player2DeckLength: player2Deck.length,
      player1Energy: player1Energy.length,
      player2Energy: player2Energy.length
    });
    
    // Create new match
    const { createMatch } = await import('./js/online/schema.js');
    const newMatchId = window.firebaseDatabase.ref(DB_PATHS.MATCHES).push().key;
    
    // createMatch can handle expanded decks, so we can pass them as-is
    const newMatch = createMatch(
      newMatchId,
      player1Id,
      player2Id,
      null, // roomId
      player1Deck,
      player1Energy,
      player2Deck,
      player2Energy
    );
    
    // Save new match to Firebase
    const newMatchRef = getMatchRef(newMatchId);
    await newMatchRef.set(newMatch);
    
    // Update user active matches for both players
    await window.firebaseDatabase.ref(DB_PATHS.USER_ACTIVE_MATCH(player1Id)).set(newMatchId);
    await window.firebaseDatabase.ref(DB_PATHS.USER_ACTIVE_MATCH(player2Id)).set(newMatchId);
    
    console.log('[V2-RESET] New match created:', newMatchId);
    addLog('New game created! Redirecting...');
    showStatusMessage('New game created! Redirecting...');
    
    // Broadcast new match ID to both players via reset_accepted action
    const { broadcastAction, ACTION_TYPES } = await import('./js/online/actions.js');
    await broadcastAction(ACTION_TYPES.RESET_ACCEPTED, {
      fromPlayer: 'player1',
      acceptedBy: 'player1',
      newMatchId: newMatchId
    });
    
    // Redirect both players to the new match
    // Small delay to ensure match is saved
    setTimeout(() => {
      window.location.href = `online-battle-v2.html#matchId=${newMatchId}`;
    }, 500);
    
  } catch (error) {
    console.error('[V2-RESET] Error creating new match:', error);
    showPopup('Error creating new game: ' + error.message);
    throw error;
  }
}

/**
 * Handle reset decline from opponent
 */
async function handleResetDeclined(actionData) {
  console.log('[V2-RESET] Reset declined by opponent:', actionData);
  
  const { fromPlayer, declinedBy } = actionData;
  const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
  
  if (fromPlayer === myPlayerId) {
    // We requested the reset but opponent declined
    addLog('Opponent declined the reset request.');
    showStatusMessage('Reset declined by opponent.');
  }
}

/**
 * Actually perform the game reset (called when both players have requested it)
 */
async function performGameReset() {
  console.log('[V2-RESET] ===== PERFORMING GAME RESET =====');
  console.log('[V2-RESET] performGameReset called');
  
  try {
    const state = gameState.getState();
    if (!state) {
      console.error('[V2-RESET] No game state available');
      showPopup('No game state to reset');
      return;
    }
    
    console.log('[V2-RESET] Current state before reset:', {
      player1: {
        deckSize: state.player1?.deck?.length || 0,
        handSize: state.player1?.hand?.length || 0,
        hasActive: !!state.player1?.active,
        benchCount: state.player1?.bench?.filter(b => b).length || 0,
        discardCount: state.player1?.discard?.cards?.length || 0,
        prizeCount: state.player1?.prizeCards?.length || 0
      },
      player2: {
        deckSize: state.player2?.deck?.length || 0,
        handSize: state.player2?.hand?.length || 0,
        hasActive: !!state.player2?.active,
        benchCount: state.player2?.bench?.filter(b => b).length || 0,
        discardCount: state.player2?.discard?.cards?.length || 0,
        prizeCount: state.player2?.prizeCards?.length || 0
      }
    });
    
    // Reset all game state flags
    hasAttachedEnergyThisTurn = false;
    hasRetreatedThisTurn = false;
    hasPlayedSupporterThisTurn = false;
    hasDrawnStartingHand = false;
    turnDraws.clear();
    playingPokemon.clear();
    globalThis.__updatingState = new Set();
    globalThis.__isUpdatingLocalState = false;
    globalThis.__selectionActive = false;
    globalThis.__forceSwitchSelection = false;
    globalThis.__forceSwitchNoCancel = false;
    globalThis.__silverSelectionActive = false;
    globalThis.__rareCandyActive = false;
    globalThis.__rareCandySelection = null;
    globalThis.__rareCandyResolve = null;
    
    // Get match ID for drawStartingHand
    let matchId = null;
    if (window.location.hash) {
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      matchId = hashParams.get('matchId');
    }
    if (!matchId) {
      const urlParams = new URLSearchParams(window.location.search);
      matchId = urlParams.get('matchId');
    }
    
    // Log full state for both players to debug deck collection
    console.log('[V2-RESET] Full Player 1 State:', {
      deck: state.player1?.deck,
      deckLength: state.player1?.deck?.length || 0,
      hand: state.player1?.hand,
      handLength: state.player1?.hand?.length || 0,
      active: state.player1?.active,
      bench: state.player1?.bench,
      benchLength: state.player1?.bench?.filter(b => b !== null).length || 0,
      discard: state.player1?.discard,
      discardCardsLength: state.player1?.discard?.cards?.length || 0,
      prizeCards: state.player1?.prizeCards,
      prizeCardsLength: state.player1?.prizeCards?.length || 0
    });
    
    console.log('[V2-RESET] Full Player 2 State:', {
      deck: state.player2?.deck,
      deckLength: state.player2?.deck?.length || 0,
      hand: state.player2?.hand,
      handLength: state.player2?.hand?.length || 0,
      active: state.player2?.active,
      bench: state.player2?.bench,
      benchLength: state.player2?.bench?.filter(b => b !== null).length || 0,
      discard: state.player2?.discard,
      discardCardsLength: state.player2?.discard?.cards?.length || 0,
      prizeCards: state.player2?.prizeCards,
      prizeCardsLength: state.player2?.prizeCards?.length || 0
    });
    
    // Collect all cards from all zones back into the deck for each player
    // This ensures we have a complete deck before resetting
    function collectAllCards(playerState, playerId) {
      const allCards = [];
      const counts = {
        deck: 0,
        hand: 0,
        active: 0,
        bench: 0,
        discard: 0,
        prizeCards: 0,
        energy: 0
      };
      
      // Add cards from deck
      if (playerState?.deck && Array.isArray(playerState.deck)) {
        const deckCards = playerState.deck.filter(c => c && typeof c === 'object');
        allCards.push(...deckCards);
        counts.deck = deckCards.length;
      }
      
      // Add cards from hand
      if (playerState?.hand && Array.isArray(playerState.hand)) {
        const handCards = playerState.hand.filter(c => c && typeof c === 'object');
        allCards.push(...handCards);
        counts.hand = handCards.length;
      }
      
      // Add active Pokemon
      if (playerState?.active && typeof playerState.active === 'object') {
        allCards.push(playerState.active);
        counts.active = 1;
        
        // Also collect energy attached to active Pokemon
        if (playerState.active.energy && Array.isArray(playerState.active.energy)) {
          const energyCards = playerState.active.energy.filter(c => c && typeof c === 'object');
          allCards.push(...energyCards);
          counts.energy += energyCards.length;
        }
        
        // Also collect tool attached to active Pokemon
        if (playerState.active.tool && typeof playerState.active.tool === 'object') {
          allCards.push(playerState.active.tool);
          console.log(`[V2-RESET] Collected tool from active Pokemon:`, playerState.active.tool.name || 'Unknown tool');
        }
      }
      
      // Add bench Pokemon
      if (playerState?.bench && Array.isArray(playerState.bench)) {
        playerState.bench.forEach(pokemon => {
          if (pokemon && typeof pokemon === 'object') {
            allCards.push(pokemon);
            counts.bench++;
            
            // Also collect energy attached to bench Pokemon
            if (pokemon.energy && Array.isArray(pokemon.energy)) {
              const energyCards = pokemon.energy.filter(c => c && typeof c === 'object');
              allCards.push(...energyCards);
              counts.energy += energyCards.length;
            }
            
            // Also collect tool attached to bench Pokemon
            if (pokemon.tool && typeof pokemon.tool === 'object') {
              allCards.push(pokemon.tool);
              console.log(`[V2-RESET] Collected tool from bench Pokemon:`, pokemon.tool.name || 'Unknown tool');
            }
          }
        });
      }
      
      // Add cards from discard
      if (playerState?.discard) {
        // Add discard cards
        if (playerState.discard.cards && Array.isArray(playerState.discard.cards)) {
          const discardCards = playerState.discard.cards.filter(c => c && typeof c === 'object');
          allCards.push(...discardCards);
          counts.discard = discardCards.length;
        }
        
        // Convert energy counts to energy card objects
        if (playerState.discard.energyCounts && typeof playerState.discard.energyCounts === 'object') {
          Object.entries(playerState.discard.energyCounts).forEach(([type, count]) => {
            for (let i = 0; i < count; i++) {
              allCards.push({
                set: 'ENERGY',
                number: type,
                name: `${type} Energy`,
                category: 'Energy',
                isEnergy: true
              });
              counts.energy++;
            }
          });
        }
      }
      
      // Add prize cards
      if (playerState?.prizeCards && Array.isArray(playerState.prizeCards)) {
        const prizeCards = playerState.prizeCards.filter(c => c && typeof c === 'object');
        allCards.push(...prizeCards);
        counts.prizeCards = prizeCards.length;
      }
      
      console.log(`[V2-RESET] Collected cards for ${playerId}:`, {
        total: allCards.length,
        breakdown: counts,
        sampleCards: allCards.slice(0, 5).map(c => ({
          name: c.name || 'Unknown',
          set: c.set,
          number: c.number || c.num,
          category: c.category
        }))
      });
      
      // If we collected very few cards, log detailed state for debugging
      if (allCards.length < 10) {
        console.warn(`[V2-RESET] WARNING: Collected very few cards for ${playerId}!`, {
          total: allCards.length,
          breakdown: counts,
          playerState: {
            hasDeck: !!playerState?.deck,
            deckLength: playerState?.deck?.length || 0,
            hasHand: !!playerState?.hand,
            handLength: playerState?.hand?.length || 0,
            hasActive: !!playerState?.active,
            hasBench: !!playerState?.bench,
            benchLength: playerState?.bench?.filter(b => b).length || 0,
            hasDiscard: !!playerState?.discard,
            discardLength: playerState?.discard?.cards?.length || 0,
            hasPrizeCards: !!playerState?.prizeCards,
            prizeCardsLength: playerState?.prizeCards?.length || 0
          }
        });
      }
      
      return allCards;
    }
    
    // ALWAYS collect all cards from current state first to ensure we don't lose any cards
    // This includes cards in deck, hand, active, bench, discard, prize cards, and attached energy
    console.log('[V2-RESET] Collecting all cards from current state for both players...');
    const player1Collected = collectAllCards(state.player1, 'player1');
    const player2Collected = collectAllCards(state.player2, 'player2');
    
    // Use original decks as reference to verify we have the right number of cards
    // But always use collected cards to ensure we don't lose any cards that were in play
    let player1AllCards = null;
    let player2AllCards = null;
    
    // Check if originalDecks are valid (>= 15 cards suggests they're full decks, not partial)
    // If originalDecks are too small, ignore them and use collected cards
    const validP1Original = originalDecks.player1 && originalDecks.player1.length >= 15;
    const validP2Original = originalDecks.player2 && originalDecks.player2.length >= 15;
    
    // Check if we collected enough cards (should match original deck size if original is valid)
    const expectedP1Size = validP1Original ? originalDecks.player1.length : player1Collected.length;
    const expectedP2Size = validP2Original ? originalDecks.player2.length : player2Collected.length;
    
    console.log('[V2-RESET] Card collection results:', {
      player1: {
        collected: player1Collected.length,
        expected: expectedP1Size,
        hasOriginal: !!originalDecks.player1,
        originalSize: originalDecks.player1?.length || 0,
        originalValid: validP1Original
      },
      player2: {
        collected: player2Collected.length,
        expected: expectedP2Size,
        hasOriginal: !!originalDecks.player2,
        originalSize: originalDecks.player2?.length || 0,
        originalValid: validP2Original
      }
    });
    
    // Use collected cards (they include all cards from all zones)
    // If collected cards are too few (< 15), try to use original decks if available
    // Otherwise use collected cards even if they're few (might be a new game)
    // CRITICAL: If we have valid original decks, always prefer them over collected cards
    // because collected cards might be incomplete if cards are in zones we're not checking
    if (validP1Original && originalDecks.player1.length >= 15) {
      // We have a valid original deck - use it (it's more reliable than collection)
      console.log('[V2-RESET] Using original deck for player1:', originalDecks.player1.length, 'cards (more reliable than collection)');
      player1AllCards = JSON.parse(JSON.stringify(originalDecks.player1));
    } else if (player1Collected.length >= 15) {
      // Collected enough cards - use them
      player1AllCards = player1Collected;
      console.log('[V2-RESET] Using collected cards for player1:', player1AllCards.length, 'cards');
    } else {
      // Use collected cards even if few (might be a new game or cards are elsewhere)
      console.warn('[V2-RESET] Player1 collected few cards (', player1Collected.length, '), no valid original deck. Using collected cards.');
      player1AllCards = player1Collected;
    }
    
    if (validP2Original && originalDecks.player2.length >= 15) {
      // We have a valid original deck - use it (it's more reliable than collection)
      console.log('[V2-RESET] Using original deck for player2:', originalDecks.player2.length, 'cards (more reliable than collection)');
      player2AllCards = JSON.parse(JSON.stringify(originalDecks.player2));
    } else if (player2Collected.length >= 15) {
      // Collected enough cards - use them
      player2AllCards = player2Collected;
      console.log('[V2-RESET] Using collected cards for player2:', player2AllCards.length, 'cards');
    } else {
      // Use collected cards even if few (might be a new game or cards are elsewhere)
      console.warn('[V2-RESET] Player2 collected few cards (', player2Collected.length, '), no valid original deck. Using collected cards.');
      player2AllCards = player2Collected;
    }
    
    console.log('[V2-RESET] Total cards for reset:', {
      player1: player1AllCards.length,
      player2: player2AllCards.length,
      usingOriginalDecks: {
        player1: originalDecks.player1 !== null,
        player2: originalDecks.player2 !== null
      }
    });
    
    // If decks are too small, warn but continue (might be a new game)
    if (player1AllCards.length < 5) {
      console.warn('[V2-RESET] Warning: Player1 has fewer than 5 cards. This might indicate a new game or missing cards.');
    }
    if (player2AllCards.length < 5) {
      console.warn('[V2-RESET] Warning: Player2 has fewer than 5 cards. This might indicate a new game or missing cards.');
    }
    
    // Shuffle the complete decks
    shuffle(player1AllCards);
    shuffle(player2AllCards);
    
    // Set flags to prevent state subscription from interfering
    globalThis.__isUpdatingLocalState = true;
    if (!globalThis.__updatingState) {
      globalThis.__updatingState = new Set();
    }
    
    // Mark all paths as being updated
    globalThis.__updatingState.add('isSetupPhase');
    globalThis.__updatingState.add('player1Ready');
    globalThis.__updatingState.add('player2Ready');
    globalThis.__updatingState.add('currentPlayer');
    globalThis.__updatingState.add('turnNumber');
    globalThis.__updatingState.add('p1Points');
    globalThis.__updatingState.add('p2Points');
    globalThis.__updatingState.add('player1/deck');
    globalThis.__updatingState.add('player2/deck');
    globalThis.__updatingState.add('player1/hand');
    globalThis.__updatingState.add('player2/hand');
    globalThis.__updatingState.add('player1/active');
    globalThis.__updatingState.add('player2/active');
    globalThis.__updatingState.add('player1/bench');
    globalThis.__updatingState.add('player2/bench');
    globalThis.__updatingState.add('player1/discard');
    globalThis.__updatingState.add('player2/discard');
    
    try {
      // Reset game state to initial setup phase
      await gameState.updateState({
        isSetupPhase: true,
        player1Ready: false,
        player2Ready: false,
        player1ResetRequested: false,
        player2ResetRequested: false,
        currentPlayer: null,
        turnNumber: 0,
        firstPlayer: null,
        p1Points: 0,
        p2Points: 0,
        gameOver: false,
        winner: null
      });
      
      // Reset player states with shuffled complete decks
      await gameState.updatePlayerState('player1', {
        active: null,
        bench: [null, null, null],
        hand: [],
        discard: { cards: [], energyCounts: {} },
        prizeCards: [],
        deck: player1AllCards,
        energyTypes: state.player1?.energyTypes || []
      });
      
      await gameState.updatePlayerState('player2', {
        active: null,
        bench: [null, null, null],
        hand: [],
        discard: { cards: [], energyCounts: {} },
        prizeCards: [],
        deck: player2AllCards,
        energyTypes: state.player2?.energyTypes || []
      });
      
      // Clear flags after a delay to allow state to propagate
      setTimeout(() => {
        globalThis.__isUpdatingLocalState = false;
        globalThis.__updatingState.clear();
      }, 500);
    } catch (error) {
      globalThis.__isUpdatingLocalState = false;
      globalThis.__updatingState.clear();
      throw error;
    }
    
    // Clear log
    const logEl = document.getElementById('log');
    if (logEl) {
      logEl.innerHTML = '';
    }
    
    addLog('Game reset! Drawing starting hands...');
    showStatusMessage('Game reset. Drawing starting hands...');
    
    // Draw starting hands for both players
    // Reset the flag so starting hands can be drawn
    hasDrawnStartingHand = false;
    
    // Draw starting hands using the decks we just prepared
    // IMPORTANT: Wait a bit for state to propagate before drawing hands
    // This ensures the deck we set is actually in the state before we try to draw from it
    await new Promise(resolve => setTimeout(resolve, 200));
    
    // Verify the decks are in the state before drawing
    const stateAfterReset = gameState.getState();
    console.log('[V2-RESET] State after reset, before drawing hands:', {
      player1DeckSize: stateAfterReset?.player1?.deck?.length || 0,
      player2DeckSize: stateAfterReset?.player2?.deck?.length || 0,
      expectedP1Size: player1AllCards.length,
      expectedP2Size: player2AllCards.length
    });
    
    // If decks aren't in state correctly, set them again
    if (stateAfterReset) {
      if ((stateAfterReset.player1?.deck?.length || 0) !== player1AllCards.length) {
        console.warn('[V2-RESET] Player1 deck size mismatch, updating...');
        await gameState.updatePlayerState('player1', {
          deck: player1AllCards
        });
      }
      if ((stateAfterReset.player2?.deck?.length || 0) !== player2AllCards.length) {
        console.warn('[V2-RESET] Player2 deck size mismatch, updating...');
        await gameState.updatePlayerState('player2', {
          deck: player2AllCards
        });
      }
    }
    
    // Wait again for state to propagate
    await new Promise(resolve => setTimeout(resolve, 200));
    
    // Draw starting hands using the decks we just prepared
    // Pass the decks directly to avoid state propagation issues
    if (matchId) {
      try {
        let handsDrawn = 0;
        
        // Only draw if we have enough cards
        if (player1AllCards.length >= 5) {
          console.log('[V2-RESET] Drawing starting hand for player1, deck size:', player1AllCards.length);
          await drawStartingHand('player1', matchId, player1AllCards);
          
          // Verify deck was updated correctly after drawing
          const stateAfterDraw = gameState.getState();
          const p1DeckSize = stateAfterDraw?.player1?.deck?.length || 0;
          console.log('[V2-RESET] Player1 deck size after draw:', p1DeckSize, '(expected:', player1AllCards.length - 5, ')');
          
          handsDrawn++;
        } else {
          console.warn('[V2-RESET] Cannot draw starting hand for player1: deck too small (', player1AllCards.length, 'cards)');
          addLog('Player 1: Cannot draw starting hand - deck too small (' + player1AllCards.length + ' cards). Please load a deck first.');
        }
        
        if (player2AllCards.length >= 5) {
          console.log('[V2-RESET] Drawing starting hand for player2, deck size:', player2AllCards.length);
          await drawStartingHand('player2', matchId, player2AllCards);
          
          // Verify deck was updated correctly after drawing
          const stateAfterDraw = gameState.getState();
          const p2DeckSize = stateAfterDraw?.player2?.deck?.length || 0;
          console.log('[V2-RESET] Player2 deck size after draw:', p2DeckSize, '(expected:', player2AllCards.length - 5, ')');
          
          handsDrawn++;
        } else {
          console.warn('[V2-RESET] Cannot draw starting hand for player2: deck too small (', player2AllCards.length, 'cards)');
          addLog('Player 2: Cannot draw starting hand - deck too small (' + player2AllCards.length + ' cards). Please load a deck first.');
        }
        
        if (handsDrawn === 2) {
          addLog('Starting hands drawn for both players!');
          showStatusMessage('Game reset complete! Place your Active Pokemon and click "Start Game" to begin.');
        } else if (handsDrawn === 1) {
          addLog('Starting hand drawn for one player. Other player needs to load a deck.');
          showStatusMessage('Game reset complete! One player needs to load a deck.');
        } else {
          addLog('Game reset, but no starting hands drawn - decks are too small. Please load decks first.');
          showStatusMessage('Game reset, but decks are too small. Please load decks first.');
        }
      } catch (error) {
        console.error('[V2-RESET] Error drawing starting hands:', error);
        showPopup('Game reset, but error drawing starting hands: ' + error.message);
      }
    } else {
      console.warn('[V2-RESET] No match ID, cannot draw starting hands');
      showStatusMessage('Game reset complete! (Starting hands will be drawn automatically)');
    }
    
    console.log('[V2-RESET] Game reset complete');
  } catch (error) {
    console.error('[V2-RESET] Error performing reset:', error);
    showPopup('Error resetting game: ' + error.message);
  }
}

// ============================================================================
// INITIALIZATION
// ============================================================================

let hasDrawnStartingHand = false; // Track if we've drawn starting hand

// Store original decks for reset functionality
let originalDecks = {
  player1: null,
  player2: null
};

async function initializeGame() {
  try {
    // Get match ID from URL - check hash first (server may rewrite query strings)
    let matchId = null;
    
    // Check hash (primary method to avoid server rewriting issues)
    if (window.location.hash) {
      const hashParams = new URLSearchParams(window.location.hash.substring(1));
      matchId = hashParams.get('matchId');
    }
    
    // Fallback to query string if hash not found
    if (!matchId) {
      const urlParams = new URLSearchParams(window.location.search);
      matchId = urlParams.get('matchId');
    }
    
    // Log for debugging
    console.log('[V2-INIT] URL:', window.location.href);
    console.log('[V2-INIT] Search:', window.location.search);
    console.log('[V2-INIT] Hash:', window.location.hash);
    console.log('[V2-INIT] Match ID from URL:', matchId);
    
    if (!matchId) {
      // No match ID in URL - redirect back to index to create/join a room
      console.log('[V2-INIT] No match ID in URL, redirecting to lobby');
      showStatusMessage('No match ID found. Redirecting to lobby...');
      setTimeout(() => {
        window.location.href = 'index.html';
      }, 2000);
      return;
    }
    
    // Initialize auth first
    initAuth();
    
    // Wait for auth state to be ready (Firebase Auth is asynchronous)
    let user = null;
    let authReady = false;
    
    // Try to get user immediately
    user = getCurrentUser();
    if (!user && window.firebaseAuth) {
      user = window.firebaseAuth.currentUser;
    }
    
    // If no user found, wait for auth state change
    if (!user) {
      console.log('[V2-INIT] Waiting for auth state...');
      showStatusMessage('Initializing...');
      
      // Wait for auth state with timeout
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Auth timeout'));
        }, 5000);
        
        if (window.firebaseAuth) {
          // Listen for auth state change
          const unsubscribe = window.firebaseAuth.onAuthStateChanged((authUser) => {
            clearTimeout(timeout);
            unsubscribe();
            user = authUser;
            authReady = true;
            resolve();
          });
        } else {
          clearTimeout(timeout);
          reject(new Error('Firebase Auth not available'));
        }
      }).catch(error => {
        console.error('[V2-INIT] Auth error:', error);
      });
    }
    
    if (!user) {
      console.log('[V2-INIT] No user found, redirecting to login');
      showStatusMessage('Please log in first. Redirecting...');
      setTimeout(() => {
        window.location.href = 'index.html';
      }, 2000);
      return;
    }
    
    console.log('[V2-INIT] User authenticated:', user.uid);
    
    // Try to fetch original decks from match document before initializing sync
    // This ensures we get the full decks before they're reduced by gameplay
    if (window.firebaseDatabase) {
      try {
        const { getMatchRef } = await import('./js/online/schema.js');
        const matchRef = getMatchRef(matchId);
        const matchSnapshot = await matchRef.once('value');
        const match = matchSnapshot.val();
        
        if (match && match.gameState) {
          console.log('[V2-INIT] Fetched match document, checking for original decks...');
          
          // Check if decks in match are full (>= 20 cards) - these are the original decks
          const p1Deck = match.gameState.player1?.deck || [];
          const p2Deck = match.gameState.player2?.deck || [];
          
          console.log('[V2-INIT] Match decks:', {
            player1DeckSize: p1Deck.length,
            player2DeckSize: p2Deck.length,
            player1IsFull: p1Deck.length >= 20,
            player2IsFull: p2Deck.length >= 20
          });
          
          // Store original decks if they're full (>= 20 cards)
          if (p1Deck.length >= 20 && Array.isArray(p1Deck)) {
            originalDecks.player1 = JSON.parse(JSON.stringify(p1Deck));
            console.log('[V2-INIT] Stored original deck for player1 from match document:', originalDecks.player1.length, 'cards');
          }
          
          if (p2Deck.length >= 20 && Array.isArray(p2Deck)) {
            originalDecks.player2 = JSON.parse(JSON.stringify(p2Deck));
            console.log('[V2-INIT] Stored original deck for player2 from match document:', originalDecks.player2.length, 'cards');
          }
        } else {
          console.log('[V2-INIT] Match document not found or has no gameState');
        }
      } catch (error) {
        console.error('[V2-INIT] Error fetching match document for original decks:', error);
        // Continue anyway - we'll try to collect from state during reset
      }
    }
    
    // Initialize sync
    await initSync(matchId, user.uid);
    console.log('[V2-INIT] Sync initialized:', {
      matchId,
      userId: user.uid,
      isCurrentPlayer1: isCurrentPlayer1()
    });
    addLog('Game initialized');
    
    // Subscribe to state changes - REACTIVE UI!
    gameState.subscribe(async (newState, oldState) => {
      // Skip rendering if we're in the middle of a local update (to avoid flicker)
      if (globalThis.__isUpdatingLocalState) {
        console.log('[RENDER-V2] Skipping render due to local state update in progress.');
        return;
      }
      
      console.log('[RENDER-V2] State changed, rendering UI...');
      
      // Store original decks on first load (if not already stored)
      // IMPORTANT: Only store if the deck appears to be a full deck (before starting hands are drawn)
      // This prevents storing partial decks that have already had starting hands drawn
      if (newState) {
        const isSetupPhase = newState.isSetupPhase !== false;
        const p1HandEmpty = !newState.player1?.hand || newState.player1.hand.length === 0;
        const p2HandEmpty = !newState.player2?.hand || newState.player2.hand.length === 0;
        
        // Store player1 deck only if:
        // 1. We don't have it stored yet
        // 2. The deck is large enough (>= 15 cards suggests it's a full deck)
        // 3. We're in setup phase AND hand is empty (suggesting starting hands haven't been drawn)
        // OR the deck is >= 20 cards (definitely a full deck)
        if (newState.player1?.deck && Array.isArray(newState.player1.deck) && newState.player1.deck.length > 0) {
          const deckSize = newState.player1.deck.length;
          const shouldStore = !originalDecks.player1 && (
            (deckSize >= 20) || // Definitely a full deck
            (deckSize >= 15 && isSetupPhase && p1HandEmpty) // Likely a full deck before starting hands
          );
          
          if (shouldStore) {
            // Use JSON deep clone to ensure complete isolation
            originalDecks.player1 = JSON.parse(JSON.stringify(newState.player1.deck));
            console.log('[V2-INIT] Stored original deck for player1:', originalDecks.player1.length, 'cards (deep cloned via JSON)', {
              deckSize,
              isSetupPhase,
              handEmpty: p1HandEmpty
            });
          } else if (!originalDecks.player1) {
            console.log('[V2-INIT] Skipping storage of player1 deck (too small or not in setup):', {
              deckSize,
              isSetupPhase,
              handEmpty: p1HandEmpty,
              hasOriginal: !!originalDecks.player1
            });
          }
        }
        
        // Store player2 deck only if:
        // 1. We don't have it stored yet
        // 2. The deck is large enough (>= 15 cards suggests it's a full deck)
        // 3. We're in setup phase AND hand is empty (suggesting starting hands haven't been drawn)
        // OR the deck is >= 20 cards (definitely a full deck)
        if (newState.player2?.deck && Array.isArray(newState.player2.deck) && newState.player2.deck.length > 0) {
          const deckSize = newState.player2.deck.length;
          const shouldStore = !originalDecks.player2 && (
            (deckSize >= 20) || // Definitely a full deck
            (deckSize >= 15 && isSetupPhase && p2HandEmpty) // Likely a full deck before starting hands
          );
          
          if (shouldStore) {
            // Use JSON deep clone to ensure complete isolation
            originalDecks.player2 = JSON.parse(JSON.stringify(newState.player2.deck));
            console.log('[V2-INIT] Stored original deck for player2:', originalDecks.player2.length, 'cards (deep cloned via JSON)', {
              deckSize,
              isSetupPhase,
              handEmpty: p2HandEmpty
            });
          } else if (!originalDecks.player2) {
            console.log('[V2-INIT] Skipping storage of player2 deck (too small or not in setup):', {
              deckSize,
              isSetupPhase,
              handEmpty: p2HandEmpty,
              hasOriginal: !!originalDecks.player2
            });
          }
        }
      }
      
      // Update globalThis.turnNumber for effects that check it (like Rare Candy)
      globalThis.turnNumber = newState.turnNumber || 0;
      
      renderAll(newState);
      
      // Check if both players became ready
      if (newState) {
        const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
        const isP1 = myPlayerId === 'player1';
        const myReadyKey = myPlayerId === 'player1' ? 'player1Ready' : 'player2Ready';
        const opponentReadyKey = myPlayerId === 'player1' ? 'player2Ready' : 'player1Ready';
        
        const bothReady = newState[myReadyKey] === true && newState[opponentReadyKey] === true;
        const wasBothReady = oldState ? (oldState[myReadyKey] === true && oldState[opponentReadyKey] === true) : false;
        const isSetupPhase = newState.isSetupPhase !== false;
        
        console.log('[V2-START-CHECK]', { 
          myPlayerId, 
          isP1, 
          myReady: newState[myReadyKey], 
          opponentReady: newState[opponentReadyKey],
          bothReady, 
          wasBothReady, 
          isSetupPhase 
        });
        
        // If both players just became ready and we're still in setup phase
        if (bothReady && !wasBothReady && isSetupPhase) {
          console.log('[V2-START] Both players ready detected:', { isP1, myPlayerId, bothReady, isSetupPhase });
          // Only player1 should start the game to avoid race conditions
          if (isP1) {
            console.log('[V2-START] Player 1 starting game...');
            // Use setTimeout to ensure state is fully synced
            setTimeout(async () => {
              await startGameFromReady();
            }, 100);
          } else {
            console.log('[V2-START] Player 2 waiting for Player 1 to start game...');
            // Player2: wait for player1 to start the game
            // The state change will be detected when isSetupPhase becomes false
          }
        }
        
        // Check if setup phase just ended
        if (oldState) {
          const wasSetupPhase = oldState.isSetupPhase !== false;
          if (wasSetupPhase && !isSetupPhase) {
            console.log('[V2-START] Setup phase ended, game started');
            showStatusMessage('Game started!');
            
            // Note: handleTurnStart is called from startGame(), so we don't call it here
            // to avoid double draws on turn 1
            }
          }
          
          // Check if turn changed (after game has started)
        // This needs to be outside the oldState check to handle first turn
        const oldCurrentPlayer = oldState?.currentPlayer;
          const newCurrentPlayer = newState.currentPlayer;
        const oldTurnNumber = oldState?.turnNumber || 0;
        const newTurnNumber = newState.turnNumber || 0;
        
        // Only call handleTurnStart if turn actually changed (not just state refresh)
        // Also handle first turn when oldState is null or currentPlayer is first set
        const turnChanged = oldCurrentPlayer !== newCurrentPlayer;
        const isFirstTurn = !oldState && newCurrentPlayer && newTurnNumber === 1;
        // Also check if setup phase just ended and this is turn 1 (game just started)
        const setupJustEnded = oldState && oldState.isSetupPhase !== false && isSetupPhase === false;
        const isTurnStart = (turnChanged || isFirstTurn || (setupJustEnded && newTurnNumber === 1)) && !isSetupPhase && newTurnNumber > 0 && newCurrentPlayer;
        
        if (isTurnStart) {
          // Skip if we're in the middle of ending a turn (handleEndTurn will call handleTurnStart)
          if (globalThis.__endingTurn) {
            console.log('[V2-TURN] Skipping handleTurnStart - turn end in progress');
          } else {
            // Also check if we haven't already handled this turn
            const turnKey = `${newCurrentPlayer}-${newTurnNumber}`;
            if (!turnDraws.has(turnKey)) {
              console.log('[V2-TURN] Turn changed:', { 
                oldCurrentPlayer, 
                newCurrentPlayer, 
                newTurnNumber, 
                isFirstTurn, 
                setupJustEnded,
                turnChanged,
                hasOldState: !!oldState
              });
              await handleTurnStart(newCurrentPlayer, newTurnNumber);
            } else {
              console.log('[V2-TURN] Skipping handleTurnStart - already handled:', turnKey);
            }
          }
        } else if (newCurrentPlayer && newTurnNumber > 0 && !isSetupPhase) {
          // Debug logging to understand why turn start isn't triggering
          console.log('[V2-TURN] Turn start check failed:', {
            turnChanged,
            isFirstTurn,
            setupJustEnded,
            isSetupPhase,
            newTurnNumber,
            newCurrentPlayer,
            oldCurrentPlayer,
            oldTurnNumber,
            hasOldState: !!oldState
          });
        }
      }
      
      // Check if we need to draw starting hands (only once)
      if (!hasDrawnStartingHand && newState) {
        const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
        const myHand = gameState.getHand(myPlayerId);
        const myDeck = gameState.getDeck(myPlayerId);
        
        console.log('[V2-DRAW-CHECK]', { 
          myPlayerId, 
          handLength: myHand?.length || 0, 
          deckLength: myDeck?.length || 0 
        });
        
        // If hand is empty and deck has cards, draw starting hand
        if ((!myHand || myHand.length === 0) && myDeck && myDeck.length >= 5) {
          console.log('[V2-DRAW] Drawing starting hand for', myPlayerId);
          hasDrawnStartingHand = true; // Mark as drawn to prevent duplicates
          try {
            await drawStartingHand(myPlayerId, matchId);
          } catch (error) {
            console.error('[V2-DRAW] Error drawing starting hand:', error);
            hasDrawnStartingHand = false; // Reset on error so we can retry
          }
        }
      }
    });
    
    // Listen for opponent actions
    const { onAction } = await import('./js/online/sync.js');
    const { ACTION_TYPES: ACTION_TYPES_IMPORTED } = await import('./js/online/actions.js');
    if (onAction) {
      onAction(async (action) => {
        console.log('[V2-ACTION] Received action:', action.actionType, action.actionData);
        
        if (action.actionType === ACTION_TYPES_IMPORTED.RETREAT || action.actionType === ACTION_TYPES.RETREAT) {
          handleOpponentRetreat(action.actionData);
        } else if (action.actionType === ACTION_TYPES_IMPORTED.PLAY_POKEMON || action.actionType === ACTION_TYPES.PLAY_POKEMON) {
          // State is already synced via Firebase, UI will update automatically
          console.log('[V2-OPPONENT] Opponent played Pokemon:', action.actionData);
        } else if (action.actionType === ACTION_TYPES_IMPORTED.ATTACH_ENERGY || action.actionType === ACTION_TYPES.ATTACH_ENERGY) {
          // State is already synced via Firebase, UI will update automatically
          console.log('[V2-OPPONENT] Opponent attached energy:', action.actionData);
        } else if (action.actionType === ACTION_TYPES_IMPORTED.PLAY_TRAINER || action.actionType === ACTION_TYPES.PLAY_TRAINER || action.actionType === 'play_trainer') {
          // Opponent played a trainer card - state is already synced via Firebase
          // For draw supporters, the state should already reflect the drawn cards
          console.log('[V2-OPPONENT] Opponent played trainer:', action.actionData);
          const { trainerName, effectType, playerId } = action.actionData;
          if (effectType === 'draw_cards') {
            addLog(`Opponent used ${trainerName || 'a trainer'} to draw cards.`);
          } else {
            addLog(`Opponent used ${trainerName || 'a trainer'}.`);
          }
        } else if (action.actionType === ACTION_TYPES_IMPORTED.FORCE_SWITCH_SELECTION || action.actionType === ACTION_TYPES.FORCE_SWITCH_SELECTION) {
          // Opponent used Sabrina - we need to select a benched Pokemon
          await handleForceSwitchSelection(action.actionData);
        } else if (action.actionType === ACTION_TYPES_IMPORTED.FORCE_SWITCH_SELECTED || action.actionType === ACTION_TYPES.FORCE_SWITCH_SELECTED) {
          // Opponent selected their benched Pokemon - complete the switch
          await handleForceSwitchSelected(action.actionData);
        } else if (action.actionType === ACTION_TYPES_IMPORTED.RESET_REQUEST || action.actionType === ACTION_TYPES.RESET_REQUEST || action.actionType === 'reset_request') {
          // Opponent requested a reset - show popup
          console.log('[V2-RESET] Handling reset request from opponent');
          await handleResetRequest(action.actionData);
        } else if (action.actionType === ACTION_TYPES_IMPORTED.RESET_ACCEPTED || action.actionType === ACTION_TYPES.RESET_ACCEPTED || action.actionType === 'reset_accepted') {
          // Opponent accepted our reset request
          console.log('[V2-RESET] Handling reset acceptance from opponent');
          await handleResetAccepted(action.actionData);
        } else if (action.actionType === ACTION_TYPES_IMPORTED.RESET_DECLINED || action.actionType === ACTION_TYPES.RESET_DECLINED || action.actionType === 'reset_declined') {
          // Opponent declined our reset request
          console.log('[V2-RESET] Handling reset decline from opponent');
          await handleResetDeclined(action.actionData);
        } else if (action.actionType === ACTION_TYPES_IMPORTED.END_TURN || action.actionType === ACTION_TYPES.END_TURN || action.actionType === 'end_turn') {
          // Opponent ended their turn - state is already synced, but we need to trigger turn start draw
          console.log('[V2-OPPONENT] Opponent ended turn:', action.actionData);
          const { nextPlayer, turnNumber } = action.actionData;
          // The state subscription should handle this, but if it doesn't, trigger it here
          // Check if we need to draw for the new turn
          const myPlayerId = isCurrentPlayer1() ? 'player1' : 'player2';
          if (nextPlayer === myPlayerId) {
            // It's now our turn - trigger turn start draw
            const drawKey = `${nextPlayer}-${turnNumber}`;
            if (!turnDraws.has(drawKey)) {
              console.log('[V2-OPPONENT] Triggering turn start draw for our turn:', nextPlayer, turnNumber);
              await handleTurnStart(nextPlayer, turnNumber);
            }
          }
        } else {
          console.log('[V2-ACTION] Unhandled action type:', action.actionType, 'Available types:', Object.keys(ACTION_TYPES_IMPORTED || {}));
        }
      });
    }
    
    // Set up Start Game button
    const startGameButton = document.getElementById('startGameButton');
    if (startGameButton) {
      startGameButton.addEventListener('click', async () => {
        await handleStartGame();
      });
    }
    
    // Set up End Turn button
    const endTurnButton = document.getElementById('endTurnButton');
    if (endTurnButton) {
      endTurnButton.addEventListener('click', async () => {
        console.log('[V2-END-TURN] Button clicked');
        await handleEndTurn();
      });
      console.log('[V2-INIT] End Turn button handler attached');
    } else {
      console.error('[V2-INIT] End Turn button not found!');
    }
    
    // Set up Reset Game button
    const resetGameButton = document.getElementById('resetGameButton');
    if (resetGameButton) {
      resetGameButton.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('[V2-INIT] Reset button clicked, calling handleResetGame');
        try {
          await handleResetGame();
        } catch (error) {
          console.error('[V2-INIT] Error in reset button handler:', error);
          showPopup('Error: ' + error.message);
        }
      });
      console.log('[V2-INIT] Reset Game button handler attached');
    } else {
      console.warn('[V2-INIT] Reset Game button not found in DOM');
    }
    
    // Set up energy selection
    document.querySelectorAll('.energy-type').forEach(el => {
      el.addEventListener('click', () => {
        const energyType = el.dataset.energy;
        handleEnergySelection(energyType);
      });
    });
    
    // Initial render
    const initialState = gameState.getState();
    if (initialState) {
      renderAll(initialState);
    }
    
    addLog('Game ready!');
    
  } catch (error) {
    console.error('[INIT-V2] Error initializing game:', error);
    showStatusMessage('Error initializing game: ' + error.message);
  }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeGame);
} else {
  initializeGame();
}

</script>
</head>
<body>
  <div class="game-container">
    <h1>TCG Pocket Battle - Online V2 (Proof of Concept)</h1>
    <div id="status" class="status"></div>
    <div id="turnInfo"></div>
    <div id="points"></div>
    
    <!-- Player 2 (Opponent) -->
    <div class="player-area">
      <div class="player-header">
        <h2 id="p2Header">Player 2 (Opponent)</h2>
        <div id="p2Hand">Hand: 0 cards</div>
        <div id="p2Deck" style="cursor: pointer; color: #3b82f6; text-decoration: underline; margin-top: 5px;">Deck: 0 cards</div>
      </div>
      <div id="p2Active">
        <div class="active-slot"></div>
      </div>
      <div id="p2Bench">
        <h3>Bench</h3>
        <div class="bench"></div>
      </div>
      <div id="p2Discard">
        <h3 id="p2DiscardCount">Discard: 0 cards</h3>
        <div style="display: flex; gap: 5px; flex-wrap: wrap; position: relative; min-height: 110px;"></div>
      </div>
    </div>
    
    <!-- Player 1 (You) -->
    <div class="player-area">
      <div class="player-header">
        <h2 id="p1Header">Player 1 (You)</h2>
        <div id="p1Hand">Hand: 0 cards</div>
        <div id="p1Deck" style="cursor: pointer; color: #3b82f6; text-decoration: underline; margin-top: 5px;">Deck: 0 cards</div>
      </div>
      <div id="p1Active">
        <div class="active-slot"></div>
      </div>
      <div id="p1Bench">
        <h3>Bench</h3>
        <div class="bench"></div>
      </div>
      <div id="p1Discard">
        <h3 id="p1DiscardCount">Discard: 0 cards</h3>
        <div style="display: flex; gap: 5px; flex-wrap: wrap; position: relative; min-height: 110px;"></div>
      </div>
      <div class="energy-zone" id="energyZone">
        <div style="width: 100%; margin-bottom: 5px; font-weight: bold;">Select Energy Type:</div>
        <div class="energy-type" data-energy="fire" style="background-image: url('https://archives.bulbagarden.net/media/upload/thumb/a/ad/Fire-attack.png/20px-Fire-attack.png');"></div>
        <div class="energy-type" data-energy="water" style="background-image: url('https://archives.bulbagarden.net/media/upload/thumb/1/11/Water-attack.png/20px-Water-attack.png');"></div>
        <div class="energy-type" data-energy="grass" style="background-image: url('https://archives.bulbagarden.net/media/upload/thumb/2/2e/Grass-attack.png/20px-Grass-attack.png');"></div>
        <div class="energy-type" data-energy="lightning" style="background-image: url('https://archives.bulbagarden.net/media/upload/thumb/0/04/Lightning-attack.png/20px-Lightning-attack.png');"></div>
        <div class="energy-type" data-energy="psychic" style="background-image: url('https://archives.bulbagarden.net/media/upload/thumb/e/ef/Psychic-attack.png/20px-Psychic-attack.png');"></div>
        <div class="energy-type" data-energy="fighting" style="background-image: url('https://archives.bulbagarden.net/media/upload/thumb/4/48/Fighting-attack.png/20px-Fighting-attack.png');"></div>
        <div class="energy-type" data-energy="darkness" style="background-image: url('https://archives.bulbagarden.net/media/upload/thumb/a/ab/Darkness-attack.png/20px-Darkness-attack.png');"></div>
        <div class="energy-type" data-energy="metal" style="background-image: url('https://archives.bulbagarden.net/media/upload/thumb/6/64/Metal-attack.png/20px-Metal-attack.png');"></div>
        <div class="energy-type" data-energy="dragon" style="background-image: url('https://archives.bulbagarden.net/media/upload/thumb/8/8a/Dragon-attack.png/20px-Dragon-attack.png');"></div>
        <div class="energy-type" data-energy="colorless" style="background-image: url('https://archives.bulbagarden.net/media/upload/thumb/1/1d/Colorless-attack.png/30px-Colorless-attack.png');"></div>
      </div>
      <button id="startGameButton" class="retreat-button" style="background: #22c55e; margin-bottom: 10px;">Start Game</button>
      <button id="endTurnButton" class="retreat-button" style="margin-top: 10px; background: #f59e0b;" disabled>End Turn</button>
      <button id="resetGameButton" class="retreat-button" style="margin-top: 10px; background: #ef4444;" title="Reset game for testing">Reset Game</button>
    </div>
    
    <div class="log">
      <h3>Game Log</h3>
      <div id="log"></div>
    </div>
  </div>
  
  <!-- Coin flip UI -->
  <div class="coin-backdrop" id="coinBackdrop"></div>
  <div class="coin-container" id="coinContainer">
    <div class="coin" id="coin">
      <img class="front" src="imgs/coin_front.png" alt="Coin front" crossorigin="anonymous">
      <img class="back" src="imgs/Coin_Back_TM.png" alt="Coin back" crossorigin="anonymous">
    </div>
    <div class="coin-result" id="coinResult">Flipping...</div>
  </div>
</body>
</html>

