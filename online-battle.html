<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes" />
<title>TCG Pocket Battle - Online</title>
<link rel="icon" type="image/png" href="https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Pok%C3%A9_Ball_icon.svg/768px-Pok%C3%A9_Ball_icon.svg.png?20161023215848"/>
<style>
:root{
  --card-w:75px;
  --card-h:105px;
}
@media (max-width: 768px) {
  :root{
    --card-w:70px;
    --card-h:98px;
  }
}
@media (max-width: 480px) {
  :root{
    --card-w:65px;
    --card-h:91px;
  }
}

@keyframes flipCoin {
  0% {
    transform: rotateY(0deg);
  }
  100% {
    transform: rotateY(1800deg);
  }
}

@keyframes damageFlash {
  0% {
    filter: brightness(1);
    box-shadow: 0 0 0 rgba(239, 68, 68, 0);
  }
  50% {
    filter: brightness(1.8) saturate(1.5);
    box-shadow: 0 0 30px rgba(239, 68, 68, 1);
    border-color: #ef4444;
  }
  100% {
    filter: brightness(1);
    box-shadow: 0 0 0 rgba(239, 68, 68, 0);
  }
}

@keyframes glowPulse {
  0% {
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.4);
    border-color: rgba(0, 212, 255, 0.6);
  }
  50% {
    box-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
    border-color: rgba(0, 212, 255, 1);
  }
  100% {
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.4);
    border-color: rgba(0, 212, 255, 0.6);
  }
}

@keyframes evoGlow {
  0% {
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.6);
    border-color: rgba(34, 197, 94, 0.8);
    filter: brightness(1.1);
  }
  50% {
    box-shadow: 0 0 40px rgba(34, 197, 94, 1);
    border-color: rgba(34, 197, 94, 1);
    filter: brightness(1.3);
  }
  100% {
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.6);
    border-color: rgba(34, 197, 94, 0.8);
    filter: brightness(1.1);
  }
}

@keyframes promoteGlow {
  0% {
    box-shadow: 0 0 20px rgba(168, 85, 247, 0.6);
    border-color: rgba(168, 85, 247, 0.8);
    filter: brightness(1.1);
  }
  50% {
    box-shadow: 0 0 40px rgba(168, 85, 247, 1);
    border-color: rgba(168, 85, 247, 1);
    filter: brightness(1.3);
  }
  100% {
    box-shadow: 0 0 20px rgba(168, 85, 247, 0.6);
    border-color: rgba(168, 85, 247, 0.8);
    filter: brightness(1.1);
  }
}

@keyframes popupSlide {
  0% {
    opacity: 0;
    transform: translate(-50%, -100%);
  }
  10% {
    opacity: 1;
    transform: translate(-50%, -50%);
  }
  90% {
    opacity: 1;
    transform: translate(-50%, -50%);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -50%);
  }
}

@keyframes nebulaPulse {
  0%, 100% {
    opacity: 0.3;
  }
  50% {
    opacity: 0.6;
  }
}

@keyframes twinkle {
  0%, 100% {
    opacity: 0.3;
  }
  50% {
    opacity: 1;
  }
}

body{
  font-family:'Segoe UI',Arial,sans-serif;
  background:linear-gradient(135deg, #0a0a1a 0%, #1a0f2e 50%, #2d1b4e 100%);
  background-size: 200% 200%;
  animation: backgroundShift 30s ease infinite;
  margin:0;
  padding:0;
  color:#e5e7eb;
  height:100vh;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  align-items:center;
  background-attachment:fixed;
  position: relative;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  touch-action: manipulation;
}

@keyframes backgroundShift {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: 
    radial-gradient(circle at 20% 30%, rgba(0, 212, 255, 0.08) 0%, transparent 50%),
    radial-gradient(circle at 80% 70%, rgba(227, 53, 13, 0.08) 0%, transparent 50%),
    radial-gradient(circle at 50% 50%, rgba(138, 43, 226, 0.05) 0%, transparent 70%);
  animation: particleFloat 25s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

@keyframes particleFloat {
  0%, 100% { opacity: 0.5; transform: translate(0, 0) scale(1); }
  33% { opacity: 0.7; transform: translate(20px, -20px) scale(1.1); }
  66% { opacity: 0.6; transform: translate(-20px, 20px) scale(0.9); }
}
h1{
  margin:0;
  width:100%;
  padding:.4rem 0;
  text-align:center;
  background:linear-gradient(135deg,#e3350d,#0074d9);
  color:#fff;
  font-size:1.05rem;
  letter-spacing:.2px;
}
.main-layout{
  display:flex;
  justify-content:center;
  align-items:center;
  width:100%;
  height:calc(100vh - 52px);
  position:relative;
  z-index:1;
}
.battlefield{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:space-evenly;
  max-width:850px !important;
  width:100%;
  height:95%;
  transform-origin:center center;
  transform:scale(0.92);
}
.player-area{
  transition: background 0.6s ease, box-shadow 0.6s ease, border-color 0.6s ease, min-height 0.3s ease !important;
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  padding:6px 0;
  position:relative;
  z-index:1;
  min-height: fit-content;
}

.card-slot.drag-target {
  border: 2px dashed #6e4e9c;
  background: rgba(110, 78, 156, 0.1);
}

.card-slot.drag-over {
  border: 2px solid #9d7dd4;
  background: rgba(157, 125, 212, 0.2);
  transform: scale(1.05);
}

.hand .card-img[draggable="true"] {
  cursor: grab;
}

.hand .card-img[draggable="true"]:active {
  cursor: grabbing;
}

.hand,.bench,.active{
  display:flex;
  justify-content:center;
  gap:8px;
  flex-wrap:wrap;
  position:relative;
}
.bench,.active{
  min-height:calc(var(--card-h) + 6px);
}
.card-slot{
  width:var(--card-w);
  height:var(--card-h);
  border-radius:8px;
  background:rgba(20, 20, 30, 0.65);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:10px;
  color:#a1a1aa;
  box-shadow:0 1px 3px rgba(0,0,0,.5);
  position:relative;
  flex-shrink:0;
  border:2px solid rgba(138, 43, 226, 0.3);
  backdrop-filter:blur(8px);
  transition: all 0.3s ease;
}

.card-slot:hover {
  border-color: rgba(138, 43, 226, 0.6);
  box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4), 0 0 20px rgba(138, 43, 226, 0.2);
  background: rgba(20, 20, 30, 0.8);
}
.slot-label{
  position:absolute;
  inset:auto 0 6px 0;
  text-align:center;
  font-weight:700;
  background:rgba(0,0,0,.7);
  color:#fff;
  border-radius:12px;
  line-height:1;
  padding:3px 8px;
  width:70px;
  margin:auto;
  font-size:10px;
  pointer-events:none;
}

.hp-badge {
  position: absolute;
  top: 4px;
  right: 4px;
  background: rgba(239, 68, 68, 0.95);
  color: #fff;
  font-weight: 700;
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 8px;
  pointer-events: none;
  z-index: 10;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  border: 1px solid rgba(255, 255, 255, 0.2);
}
.hp-badge.tool-boosted {
  background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
  animation: pulse-green 2s ease-in-out infinite;
}
@keyframes pulse-green {
  0%, 100% { box-shadow: 0 2px 4px rgba(0,0,0,0.3), 0 0 0 0 rgba(34, 197, 94, 0.7); }
  50% { box-shadow: 0 2px 4px rgba(0,0,0,0.3), 0 0 0 4px rgba(34, 197, 94, 0); }
}
.card-img{
  width:var(--card-w);
  height:var(--card-h);
  object-fit:contain;
  border-radius:6px;
  cursor:pointer;
  transition:all .3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), left 0.4s cubic-bezier(0.4, 0, 0.2, 1), top 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  z-index:2;
  position:relative;
  transform:perspective(700px) rotateX(0deg);
  transform-style: preserve-3d;
  will-change: transform;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  user-select: none;
}

.card-img.moving {
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 100;
}

@keyframes cardSlideIn {
  from {
    opacity: 0;
    transform: perspective(700px) rotateX(0deg) translateY(-20px) scale(0.9);
  }
  to {
    opacity: 1;
    transform: perspective(700px) rotateX(0deg) translateY(0) scale(1);
  }
}

.card-img.just-added {
  animation: cardSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.card-img:hover {
  transform: perspective(700px) rotateX(5deg) rotateY(5deg) translateZ(10px) scale(1.05) !important;
  box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4), 0 0 40px rgba(138, 43, 226, 0.3) !important;
  filter: brightness(1.1);
  z-index: 1;
}
.active .card-img{
  border:3px solid #00d4ff !important;
  box-shadow:0 0 8px rgba(255,215,0,.6);
  transform:perspective(700px) rotateX(12deg);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.active .card-img:hover {
  transform: perspective(700px) rotateX(8deg) rotateY(5deg) translateZ(15px) scale(1.08) !important;
  box-shadow: 0 12px 35px rgba(0, 212, 255, 0.5), 0 0 50px rgba(255, 215, 0, 0.4) !important;
  z-index: 1;
}
.bench .card-img{
  transform:perspective(700px) rotateX(6deg);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.bench .card-img:hover {
  transform: perspective(700px) rotateX(4deg) rotateY(5deg) translateZ(12px) scale(1.06) !important;
  box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4), 0 0 40px rgba(138, 43, 226, 0.3) !important;
  z-index: 1;
}
.hand .card-img{
  transform:perspective(700px) rotateX(3deg);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.hand .card-img:hover {
  transform: perspective(700px) rotateX(2deg) rotateY(5deg) translateZ(10px) scale(1.05) !important;
  box-shadow: 0 8px 25px rgba(0, 212, 255, 0.4), 0 0 35px rgba(138, 43, 226, 0.3) !important;
  z-index: 1;
}

.poke-comm-glow {
  animation: poke-comm-pulse 1.5s ease-in-out infinite;
  box-shadow: 0 0 20px rgba(59, 130, 246, 0.8), 0 0 40px rgba(59, 130, 246, 0.4) !important;
  border: 2px solid #3b82f6 !important;
}
@keyframes poke-comm-pulse {
  0%, 100% { transform: perspective(700px) rotateX(3deg) scale(1); }
  50% { transform: perspective(700px) rotateX(3deg) scale(1.05); }
}
#p1Active,#p1Bench{
  outline:1.5px solid #4da3ff;
  outline-offset:3px;
  border-radius:5px;
}
#p2Active,#p2Bench{
  outline:1.5px solid #ff6b6b;
  outline-offset:3px;
  border-radius:5px;
}
.deck-bubble, .hand-bubble, .discard-bubble{
  position:absolute;
  width:32px;
  height:32px;
  border-radius:50%;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  font-weight:700;
  font-size:12px;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 2px 6px rgba(0,0,0,.5);
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  transition: all 0.3s ease;
  cursor: pointer;
  z-index: 100;
}

.deck-bubble:hover, .hand-bubble:hover, .discard-bubble:hover {
  transform: scale(1.15);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.5), 0 0 20px rgba(0, 212, 255, 0.3);
  border-color: rgba(0, 212, 255, 0.6) !important;
  background: rgba(40, 40, 50, 1) !important;
}

#p1Bubble{
  right: 70px;
  bottom: 20px;
  transform: none;
}

#p2Bubble{
  left: 70px;
  top: 20px;
  transform: none;
}

#p1HandBubble{
  right: 10px;
  bottom: 60px;
  transform: none;
}

#p2HandBubble{
  left: 10px;
  top: 80px;
  transform: none;
}

#p1DiscardBubble{
  left: 20px;
  bottom: 20px;
  transform: translateY(0);
}

#p2DiscardBubble{
  left: 20px;
  top: calc(50% + 60px);
  transform: translateY(0);
}

.deck-stack {
  position: absolute;
  width: 60px;
  height: 84px;
  perspective: 1000px;
}

#p1DeckStack {
  right: 20px;
  bottom: 20px;
  transform: none;
}

#p2DeckStack {
  left: 20px;
  top: 20px;
  transform: none;
}

.deck-card {
  position: absolute;
  width: 60px;
  height: 84px;
  background-image: url('imgs/cardback.png');
  background-size: cover;
  background-position: center;
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(100, 100, 120, 0.3);
  transition: transform 0.3s ease, opacity 0.3s ease;
}

.deck-card:nth-child(1) { transform: translateY(0px) rotate(0deg); z-index: 10; }
.deck-card:nth-child(2) { transform: translateY(2px) rotate(0.5deg); z-index: 9; opacity: 0.95; }
.deck-card:nth-child(3) { transform: translateY(4px) rotate(-0.5deg); z-index: 8; opacity: 0.9; }
.deck-card:nth-child(4) { transform: translateY(6px) rotate(0.3deg); z-index: 7; opacity: 0.85; }
.deck-card:nth-child(5) { transform: translateY(8px) rotate(-0.3deg); z-index: 6; opacity: 0.8; }
.deck-card:nth-child(n+6) { transform: translateY(10px) rotate(0deg); z-index: 5; opacity: 0.75; }

.deck-stack.shuffling .deck-card {
  animation: deckShuffle 0.6s ease-in-out;
}

@keyframes deckShuffle {
  0%, 100% { transform: translateY(0) rotate(0deg); }
  25% { transform: translateY(-5px) rotate(2deg); }
  50% { transform: translateY(5px) rotate(-2deg); }
  75% { transform: translateY(-3px) rotate(1deg); }
}

.card-draw-animation {
  position: fixed;
  width: 60px;
  height: 84px;
  background-image: url('imgs/cardback.png');
  background-size: cover;
  background-position: center;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
  border: 1px solid rgba(100, 100, 120, 0.5);
  z-index: 10000;
  pointer-events: none;
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}
.points-indicator{
  position:absolute;
  top:calc(50% + 26px);
  transform:translateY(-50%);
  display:flex;
  gap:6px;
  align-items:center;
  z-index:5;
  filter:brightness(1.1) !important;
}
#p1Points{
  right:4px;transform:translateX(50%);
}
#p2Points{
  left:4px;transform:translateX(-50%);
}
.point-bubble{
  width:14px;
  height:14px;
  border-radius:50%;
  border:1.5px solid #94a3b8;
  background:rgba(40, 40, 50, 0.8) !important;
  box-shadow:0 0 4px rgba(0,0,0,.5);
  transition:background .25s,border-color .25s,box-shadow .25s;
  border-color:rgba(100, 100, 120, 0.5) !important;
}
.point-bubble.filled{
  background:#facc15 !important;
  border-color:#fde047 !important;
  box-shadow:0 0 8px 2px rgba(250, 204, 21, 0.7) !important;
}
.energy-zone{
  display:flex !important;
  flex-wrap:wrap;
  gap:6px !important;
  justify-content:center;
  background:rgba(40, 40, 50, 0.96) !important;
  backdrop-filter:blur(20px);
  border-radius:12px !important;
  padding:10px !important;
  z-index:200 !important;
  position:fixed !important;
  pointer-events:all !important;
  visibility:visible !important;
  left:50% !important;
  transform:translateX(-50%) !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  bottom:60px !important;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4), 0 0 20px rgba(0, 212, 255, 0.2) !important;
  transition: all 0.3s ease;
}

.energy-zone:hover {
  border-color: rgba(0, 212, 255, 0.5) !important;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 30px rgba(0, 212, 255, 0.3) !important;
  background: rgba(40, 40, 50, 1) !important;
}

.energy{
  width:30px !important;
  height:30px !important;
  border-radius:50% !important;
  background-size:contain !important;
  background-position:center !important;
  cursor:pointer !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  box-shadow:0 2px 6px rgba(0, 0, 0, 0.3) !important;
  background-repeat:no-repeat !important;
  transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
  position: relative;
}

.energy-zone .energy-container > .energy {
  width: 36px !important;
  height: 36px !important;
  background-size: cover !important;
}

.energy:hover {
  transform: scale(1.2) rotate(5deg) !important;
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.5), 0 0 20px rgba(0, 212, 255, 0.3) !important;
  border-color: rgba(0, 212, 255, 0.6) !important;
  z-index: 1;
}
.energy-pips{
  position:absolute;
  left:3px;
  bottom:3px;
  height:16px;
  display:flex;
  gap:2px;
  z-index:5;
}
.energy-pip{
  width:16px;
  height:16px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #1f2937;
}
.status-icon{
  position:absolute;
  left:4px;
  top:4px;
  width:20px;
  height:20px;
  border-radius:50%;
  background-size:contain;
  background-repeat:no-repeat;
  background-position:center;
  pointer-events:none;
  z-index:6;
}
.zoom-status{
  width:22px;
  height:22px;
  border-radius:50%;
  background-size:contain;
  background-repeat:no-repeat;
  background-position:center;
  flex-shrink:0;
}
.zoom-status-icon{
  width:22px;
  height:22px;
  border-radius:50%;
  background-size:contain;
  background-position:center;
  background-repeat:no-repeat;
  flex-shrink:0;
}
.hp-overlay{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom:22px;
  min-width:72px;
  text-align:center;
  background:rgba(0,0,0,.85);
  color:#fff;
  font-weight:800;
  font-size:10px;
  padding:2px 8px;
  border-radius:12px;
  z-index:5;
  line-height:1;
  white-space:nowrap;
  pointer-events:none;
  transition: all 0.3s ease;
  box-shadow: 0 2px 8px rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
}

.hp-overlay:hover {
  transform: translateX(-50%) scale(1.1);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.4);
}
.tool-thumb{
  position:absolute;
  top:30px;
  left:6px;
  width:34px;
  height:44px;
  border-radius:4px;
  box-shadow:0 2px 6px rgba(0,0,0,.6);
  border:1px solid #111827;
  background-color:#0b0f14;
  z-index:5;
  cursor:pointer;
  object-fit:cover;
  object-position:center 15%;
  clip-path:inset(15% 5% 45% 5%);
  transition:transform .15s ease;
}
#zoomTools img{
  width:88px;
  height:108px;
  border-radius:8px;
  border:1px solid #444;
  object-fit:cover;
  object-position:center 15%;
  clip-path:inset(15% 10% 45% 10%);
  box-shadow:0 0 8px rgba(0,0,0,.4);
  margin-top:0 !important;
}
#zoomTools{
  display:flex;
  align-items:center;
  gap:10px;
  padding:0 !important;
}
.side-panel{
  position:fixed;
  top:20px;
  right:20px;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:.6rem;
  z-index:10;
}
@media (max-width: 768px) {
  .side-panel {
    top: 50% !important;
    right: 8px !important;
    transform: translateY(-50%) !important;
    margin-top: 35px !important;
  }
}
@media (max-width: 480px) {
  .side-panel {
    top: 50% !important;
    right: 6px !important;
    transform: translateY(-50%) !important;
    margin-top: 30px !important;
  }
}
.coin{
  width:70px;
  height:70px;
  position:relative;
  transform-style:preserve-3d;
  transition:transform 1.5s ease-in-out;
}
.coin img{
  width:100%;
  height:100%;
  border-radius:50%;
  position:absolute;
  backface-visibility:hidden;
}
.coin .back{
  transform:rotateY(180deg);
}
.coin.flip{
  animation:flipCoin 1.5s ease-in-out;
  transform-style: preserve-3d;
}

.coin.flip .front,
.coin.flip .back {
  animation: coinSpin 1.5s ease-in-out;
}

@keyframes coinSpin {
  0% { transform: rotateY(0deg); }
  100% { transform: rotateY(1800deg); }
}
#coinResult{
  text-align:center;
  font-weight:700;
  font-size:13px;
  min-height:35px;
}
button{
  background:linear-gradient(135deg,#e3350d,#0074d9);
  color:#fff;
  border:1px solid #1f2937;
  padding:8px 14px;
  border-radius:10px;
  cursor:pointer;
  font-size:.9rem;
  transition:transform 0.15s ease, box-shadow 0.15s ease;
  position: relative;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  transform: translateY(0);
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4), 0 6px 20px rgba(227, 53, 13, 0.4);
}

button:active {
  transform: translateY(-1px) scale(0.98);
  box-shadow: 0 3px 10px rgba(0,0,0,0.4);
  transition: transform 0.1s ease, box-shadow 0.1s ease;
}

button::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: translate(-50%, -50%);
  transition: width 0.4s ease-out, height 0.4s ease-out, opacity 0.4s ease-out;
  opacity: 0;
  pointer-events: none;
}

button:active::after {
  width: 300px;
  height: 300px;
  opacity: 1;
}
.turnbox{
  width:150px;
  border:1px solid #3b3f46;
  background:#23272e;
  border-radius:12px;
  padding:10px;
  text-align:center;
  font-size:.92rem;
  box-shadow:0 1px 3px rgba(0,0,0,.4);
  color:#e5e7eb;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.turnbox::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(227, 53, 13, 0.1));
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

.turnbox:hover::before {
  opacity: 1;
}

.turnbox:hover {
  border-color: rgba(0, 212, 255, 0.5);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
  transform: translateY(-2px);
}
.turnbox .big{
  font-weight:800;
  font-size:1.05rem;
}
#popup{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%) scale(0.8);
  background:linear-gradient(135deg, rgba(17,17,17,0.95) 0%, rgba(30,30,40,0.95) 100%);
  color:#fff;
  padding:12px 20px;
  border-radius:12px;
  font-size:14px;
  font-weight:800;
  opacity:0;
  z-index:200;
  transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 8px 32px rgba(0,0,0,0.5), 0 0 20px rgba(0, 212, 255, 0.3);
  border: 1px solid rgba(0, 212, 255, 0.3);
  backdrop-filter: blur(10px);
}
#popup.show{
  opacity:1;
  transform:translate(-50%,-50%) scale(1);
  animation: popupBounce 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}
@keyframes popupBounce {
  0% { transform: translate(-50%,-50%) scale(0.3); opacity: 0; }
  50% { transform: translate(-50%,-50%) scale(1.1); }
  100% { transform: translate(-50%,-50%) scale(1); opacity: 1; }
}
.disable-clicks{
  pointer-events:none;
  filter:saturate(.9) brightness(.98);
}
.glow-evo{
  animation:evoGlow 1.5s ease-in-out infinite !important;
  outline:3px solid rgba(255,215,0,.95);
  border-radius:8px;
  cursor:pointer;
  filter:drop-shadow(0 0 6px rgba(255,215,0,.85));
  border:3px solid #ffd700 !important;
}
.promote-glow{
  animation:glowPulse .9s ease-in-out infinite alternate;
  outline:3px solid rgba(59,130,246,.95);
  border-radius:8px;
}
.attack-menu{
  position:fixed !important;
  
  background:rgba(255, 255, 255, 0.98) !important;
  border:1px solid #3b3f46;
  border-radius:12px !important;
  box-shadow:0 14px 38px rgba(0,0,0,.5);
  padding:18px !important;
  min-width:280px !important;
  z-index:1000 !important;
  opacity:0;
  color:#e5e7eb;
  backdrop-filter:blur(20px);
  width:280px !important;
  overflow-y:auto !important;
  
  transform-origin: center center;
}
.attack-menu.show{
  opacity:1;
  
}

@keyframes menuSlideIn {
  0% {
    opacity: 0;
    transform: translateY(-10px) scale(0.9);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}
.attack-item{
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  gap:8px;
  padding:14px 16px !important;
  border-radius:10px !important;
  cursor:pointer;
  background:linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%) !important;
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  color:#ffffff !important;
  min-height:52px;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.attack-item:hover {
  transform: translateX(4px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.attack-item.payable{
  background:rgba(0, 212, 255, 0.15) !important;
  border-color:#00d4ff !important;
}

.attack-item.payable:hover {
  background:rgba(0, 212, 255, 0.25) !important;
  box-shadow: 0 4px 16px rgba(0, 212, 255, 0.4);
  transform: translateX(4px) scale(1.02);
}
.attack-name{
  font-size:14px !important;
  font-weight:700 !important;
  color:#ffffff !important;
  line-height:1.2 !important;
  margin-right:8px !important;
  flex-shrink:0 !important;
}
.attack-cost{
  display:flex !important;
  gap:2px !important;
  margin-right:8px !important;
}
.cost-icon{
  width:16px;
  height:18px !important;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
  margin:0 1px !important;
}
.cost-icon.missing{
  filter:grayscale(100%) brightness(50%);
}
.damage-flash{
  animation:damageFlash 0.4s ease-out !important;
}
.zoom-backdrop{
  position:fixed;
  inset:0;
  background:rgba(0, 0, 0, 0.88) !important;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:3000 !important;
  backdrop-filter:blur(10px);
}
.zoom-backdrop.show{
  display:flex;
}
.zoom-modal{
  display:flex;
  gap:18px;
  align-items:flex-start;
  max-width:1180px;
  animation: zoomModalAppear 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes zoomModalAppear {
  0% {
    opacity: 0;
    transform: scale(0.8) translateY(20px);
  }
  100% {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.zoom-modal img{
  width:calc(var(--card-w) * 4);
  height:auto;
  border-radius:14px;
  box-shadow:0 18px 48px rgba(0,0,0,.65);
  background:#111;
  transition: transform 0.3s ease;
}

.zoom-modal img:hover {
  transform: scale(1.02);
}
.zoom-panel{
  min-width:470px;
  max-width:520px;
  background:rgba(30, 30, 40, 0.98) !important;
  border:1px solid #3b3f46;
  border-radius:18px !important;
  box-shadow:0 10px 28px rgba(0,0,0,.45);
  padding:16px;
  color:#e5e7eb !important;
  backdrop-filter:blur(20px);
  max-height:90vh !important;
  overflow-y:auto !important;
}
.zoom-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:10px;
}
.zoom-title{
  font-weight:700 !important;
  font-size:22px !important;
  color:#ffffff !important;
}
.zoom-hp{
  font-size:12px;
  color:#ffffff !important;
}
.zoom-type{
  width:24px;
  height:24px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
}
.hpbar-container{
  width:100%;
  height:12px;
  background:#2f343c;
  border-radius:8px;
  overflow:hidden;
  margin:8px 0 6px;
}
.hpbar-fill{
  height:100%;
  width:0;
  border-radius:8px;
  transition:width .4s cubic-bezier(0.4, 0, 0.2, 1), background .3s ease;
  background:linear-gradient(90deg,#22c55e,#16a34a);
  position: relative;
  overflow: hidden;
}

.hpbar-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  animation: hpbarShine 2s ease-in-out infinite;
}

@keyframes hpbarShine {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}
.zoom-section{
  border-top:1px solid #3b3f46;
  margin-top:12px;
  padding-top:12px;
  opacity:1 !important;
  margin-bottom:20px !important;
}
.row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  margin:4px 0;
}
.chip{
  font-size:12px;
  background:#2a2f36;
  border:1px solid #3b3f46;
  border-radius:999px;
  padding:2px 8px;
  color:#e5e7eb;
}
.icon-row{
  display:flex;
  gap:6px;
  align-items:center;
  flex-wrap:wrap;
}
.mini-icon{
  width:18px;
  height:18px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
  display:inline-block;
}
.mini-badge{
  font-size:11px;
  color:#cbd5e1;
  margin-left:4px;
}
.zoom-attack{
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  padding:16px !important;
  margin:10px 0;
  cursor:pointer;
  transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
  background:rgba(50, 50, 60, 0.8) !important;
  margin-bottom:12px !important;
  position: relative;
}

.zoom-attack:hover {
  transform: translateX(4px);
  border-color: rgba(0, 212, 255, 0.6) !important;
  box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
  background: rgba(50, 50, 60, 0.95) !important;
}
.zoom-attack .dmg {
  font-size:16px !important;
  font-weight:800 !important;
  color:#000000 !important; 
  transition: all 0.3s ease;
  text-shadow: 0 1px 3px rgba(0,0,0,0.5);
  display: inline-block;
}

.zoom-attack:hover .dmg {
  transform: scale(1.15);
  
  
}

.zoom-attack .top{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
  border-radius:10px;
  padding:8px 10px;
}
.zoom-attack .name{
  font-weight:800;
}
.zoom-attack .dmg{
  font-weight:900;
}
.thin{
  height:1px;
  background:#3b3f46;
  margin:8px 0;
}
.effect{
  font-size:12px;
  color:#cbd5e1;
  line-height:1.25;
}
.muted{
  opacity:.45;cursor:not-allowed;
}
.mini-icon.missing{
  filter:grayscale(100%) brightness(65%);
}
.discard-btn{
  position:absolute;
  left:12px;
  top:50%;
  transform:translateY(-50%);
  z-index:9;
}
.discard-btn.right{
  left:auto;
  right:12px;
}
.discard-drawer{
  position:fixed;
  top:0;
  bottom:0;
  width:320px;
  background:linear-gradient(180deg, #1a1e24 0%, #0f1216 100%);
  right:0;
  left:auto;
  border-left:2px solid rgba(0, 212, 255, 0.3);
  box-shadow:-20px 0 40px rgba(0,0,0,.7), 0 0 30px rgba(0, 212, 255, 0.1);
  z-index:1200;
  padding:20px;
  display:none;
  overflow:auto;
  color:#e5e7eb;
  backdrop-filter: blur(20px);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  transform: translateX(100%);
}

.discard-drawer.show {
  transform: translateX(0);
}

.discard-drawer::-webkit-scrollbar {
  width: 8px;
}

.discard-drawer::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}

.discard-drawer::-webkit-scrollbar-thumb {
  background: rgba(0, 212, 255, 0.4);
  border-radius: 4px;
}

.discard-drawer::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 212, 255, 0.6);
}

#p1DiscardDrawer {
  z-index: 1201;
}

#p2DiscardDrawer {
  z-index: 1200;
}

.discard-drawer.show{
  display:block;
  animation: drawerSlideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes drawerSlideInRight {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.discard-item{
  display:flex;
  align-items:center;
  gap:12px;
  margin:12px 0;
  padding:10px;
  background:rgba(30, 34, 42, 0.6);
  border-radius:12px;
  border:1px solid rgba(100, 100, 120, 0.2);
  transition: all 0.2s ease;
}

.discard-item:hover {
  background:rgba(40, 44, 52, 0.8);
  border-color: rgba(0, 212, 255, 0.4);
  transform: translateX(4px);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
}

.discard-item img{
  width:65px;
  height:91px;
  border-radius:10px;
  box-shadow:0 8px 20px rgba(0,0,0,.6), 0 0 15px rgba(0, 212, 255, 0.2);
  transition: all 0.3s ease;
  border: 2px solid rgba(100, 100, 120, 0.3);
}

.discard-item:hover img {
  transform: scale(1.05) rotate(2deg);
  box-shadow: 0 10px 25px rgba(0,0,0,.7), 0 0 20px rgba(0, 212, 255, 0.3);
  border-color: rgba(0, 212, 255, 0.5);
}

.discard-group{
  display:flex;
  align-items:center;
  gap:12px;
  flex-wrap: wrap;
}

.discard-count{
  font-weight:800;
  color:#ffffff;
  background:linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(138, 43, 226, 0.2));
  border:1px solid rgba(0, 212, 255, 0.4);
  border-radius:999px;
  padding:4px 12px;
  box-shadow: 0 2px 8px rgba(0, 212, 255, 0.2);
  font-size: 13px;
}
#victoryOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.68);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
  backdrop-filter: blur(8px);
  animation: fadeInOverlay 0.4s ease;
}

@keyframes fadeInOverlay {
  from { opacity: 0; }
  to { opacity: 1; }
}

#victoryCard{
  width:min(540px,92vw);
  background:#101418;
  border:1px solid #334155;
  border-radius:16px;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
  padding:22px;
  color:#e5e7eb;
  text-align:center;
  animation: victoryCardAppear 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
}

@keyframes victoryCardAppear {
  0% {
    opacity: 0;
    transform: scale(0.5) translateY(-50px);
  }
  50% {
    transform: scale(1.05) translateY(0);
  }
  100% {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

#victoryCard::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: 
    radial-gradient(circle at 20% 30%, rgba(255, 215, 0, 0.3) 0%, transparent 2%),
    radial-gradient(circle at 80% 70%, rgba(0, 212, 255, 0.3) 0%, transparent 2%),
    radial-gradient(circle at 50% 50%, rgba(227, 53, 13, 0.3) 0%, transparent 2%);
  animation: confettiFall 3s ease-in-out infinite;
  pointer-events: none;
}

@keyframes confettiFall {
  0% { transform: translateY(-100%) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
}
#victoryCard h2{
  margin:4px 0 8px 0;
  font-size:24px;
}
#victoryCard p{
  margin:6px 0 16px 0;
  color:#cbd5e1;
}
#victoryBtns{
  display:flex;
  gap:10px;
  justify-content:center;
}
#victoryOverlay,#victoryOverlay *{
  pointer-events:auto;
}
#toolBackdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:1100;
}
#toolBackdrop.show{
  display:flex;
}
#toolCard{
  display:flex;
  gap:18px;
  align-items:flex-start;
  max-width:980px;
}
#toolCard img{
  width:calc(var(--card-w) * 4);
  height:auto;
  border-radius:14px;
  box-shadow:0 18px 48px rgba(0,0,0,.65);
  background:#111;
}
#toolPanel{
  min-width:360px;
  max-width:420px;
  background:#1f232a;
  border:1px solid #3b3f46;
  border-radius:16px;
  box-shadow:0 10px 28px rgba(0,0,0,.45);
  padding:16px;
  color:#e5e7eb;
}
#toolPanel h3{
  margin:0 0 8px 0;
}
#zoomAttached{
  padding-bottom:0;margin-bottom:0 !important;
}
#zoomAttached .row{
  margin:0 0 4px 0 !important;
}
#zoomAttached+.zoom-section{
  margin-top:6px;padding-top:8px !important;
}
.ability-box{
  border:1px solid #3b3f46;
  border-radius:10px;
  background:#23272e;
  margin:6px 0;
  padding:6px 8px;
}
.ability-head{
  display:flex;
  align-items:center;
  gap:6px;
  border-radius:8px;
  padding:6px 8px;
  font-weight:800;
  color:#0b0f14;
}
.ability-head img{
  width:60px;
  height:18px;
  border-radius:3px;
  display:block;
}
.ability-name{
  font-size:13px;
}
.ability-text{
  font-size:12px;
  color:#cbd5e1;
  margin-top:6px;
  line-height:1.25;
}
.heal-glow{
  animation:glowPulse .9s ease-in-out infinite alternate;
  outline:3px solid rgba(74,222,128,.95);
  border-radius:8px;
  cursor:pointer;
  filter:drop-shadow(0 0 6px rgba(74,222,128,.85));
}
#zoomRetreatRow{
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  background:linear-gradient(180deg,#2a2f36,#262b32);
  transition:all .2s ease;
  margin-top:10px;
  padding:8px 10px;
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  font-weight:700 !important;
  color:#ffffff !important;
  user-select:none;
  min-height:36px !important;
}
#zoomRetreatRow.enabled{
  cursor:pointer;
  filter:brightness(1.08);
  transform:scale(1.02);
}
#zoomRetreatRow.disabled{
  opacity:.5;
  cursor:not-allowed;
  filter:grayscale(80%);
}
#handType{
  color:#fff;
  font-weight:700;
  border:none;
  text-transform:capitalize;
}
#logToggleBtn{
  position:fixed;
  right:30px;
  top:355px;
  z-index:1500;
  background:linear-gradient(90deg,#2a2f36,#1f232a);
  border:1px solid #334155;
  padding:8px 14px;
  color:#e5e7eb;
  border-radius:10px;
  font-size:.85rem;
  cursor:pointer;
  box-shadow:0 4px 10px rgba(0,0,0,.4);
}
#logPanel{
  position:fixed;
  top:100px;
  right:-380px;
  width:360px;
  height:calc(100vh - 140px);
  background:linear-gradient(180deg, #0f1216 0%, #1a1e24 100%);
  border-left:2px solid rgba(0, 212, 255, 0.3);
  box-shadow:-15px 0 35px rgba(0,0,0,.7), 0 0 25px rgba(0, 212, 255, 0.1);
  padding:16px 16px 24px 16px;
  overflow-y:auto;
  transition:right .3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index:1200;
  color:#e5e7eb;
  backdrop-filter: blur(20px);
  clip-path: inset(0 0 0 0);
}

#logPanel:not(.show) {
  overflow: hidden;
  pointer-events: none;
  box-shadow: none !important;
  border-left: none !important;
}

#logPanel::-webkit-scrollbar {
  width: 8px;
}

#logPanel::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}

#logPanel::-webkit-scrollbar-thumb {
  background: rgba(0, 212, 255, 0.4);
  border-radius: 4px;
}

#logPanel::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 212, 255, 0.6);
}

#logPanel.show{
  right:20px;
  animation: logPanelSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes logPanelSlideIn {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}
#closeLogBtn{
  background:#d92d2d;
  color:white;
  border:none;
  padding:6px 10px;
  border-radius:6px;
  cursor:pointer;
  font-size:12px;
  width:100%;
  margin-bottom:10px;
}
#logPanelHeader{
  background:linear-gradient(135deg, rgba(217, 45, 45, 0.95) 0%, rgba(166, 28, 28, 0.95) 100%);
  color:white;
  padding:14px 16px;
  font-size:16px;
  font-weight:800;
  letter-spacing:1px;
  border-bottom:3px solid rgba(138, 20, 20, 0.8);
  margin-bottom:12px;
  border-radius:10px;
  box-shadow: 0 4px 12px rgba(217, 45, 45, 0.3);
  text-transform: uppercase;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
.turn-bar{
  background:linear-gradient(135deg, rgba(47, 52, 60, 0.9) 0%, rgba(36, 42, 49, 0.9) 100%);
  border-top:2px solid rgba(0, 212, 255, 0.3);
  border-bottom:2px solid rgba(0, 212, 255, 0.3);
  padding:12px 16px;
  font-size:14px;
  font-weight:800;
  color:#e5e7eb;
  display:flex;
  align-items:center;
  gap:10px;
  box-shadow:0 4px 12px rgba(0,0,0,.4), 0 0 10px rgba(0, 212, 255, 0.1);
  margin-top:10px;
  margin-bottom:10px;
  border-radius:10px;
  backdrop-filter: blur(10px);
}

.turn-icon{
  width:22px;
  height:22px;
  border-radius:50%;
  background:linear-gradient(135deg, #d92d2d, #a61c1c);
  display:flex;
  align-items:center;
  justify-content:center;
  color:white;
  font-size:12px;
  font-weight:900;
  box-shadow: 0 2px 8px rgba(217, 45, 45, 0.4);
  border: 2px solid rgba(255, 255, 255, 0.2);
}
.log-entry{
  background:linear-gradient(135deg, rgba(31, 35, 42, 0.95) 0%, rgba(20, 24, 30, 0.95) 100%);
  border:1px solid rgba(59, 63, 70, 0.5);
  border-left:4px solid #334155;
  padding:12px 14px;
  margin-bottom:14px;
  border-radius:12px;
  font-size:12px;
  line-height:1.4;
  color:#e5e7eb;
  box-shadow:0 4px 12px rgba(0,0,0,.4), 0 0 8px rgba(0,0,0,.2);
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
  position: relative;
  overflow: hidden;
}

.log-entry::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  background: inherit;
  transition: width 0.3s ease;
}

.log-entry:hover {
  transform: translateX(4px);
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(0, 212, 255, 0.2);
  border-color: rgba(100, 100, 120, 0.6);
}

.log-entry:hover::before {
  width: 6px;
}

.log-entry.p1{
  border-left-color:#3b82f6;
  background:linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(31, 35, 42, 0.95) 100%);
}

.log-entry.p1:hover {
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(59, 130, 246, 0.3);
  border-left-color: #60a5fa;
}

.log-entry.p2{
  border-left-color:#ef4444;
  background:linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(31, 35, 42, 0.95) 100%);
}

.log-entry.p2:hover {
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(239, 68, 68, 0.3);
  border-left-color: #f87171;
}

.log-entry.sys{
  border-left-color:#9ca3af;
  background:linear-gradient(135deg, rgba(156, 163, 175, 0.1) 0%, rgba(31, 35, 42, 0.95) 100%);
}

.log-entry.sys:hover {
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(156, 163, 175, 0.2);
  border-left-color: #cbd5e1;
}
.entry-player{
  font-weight:800;
  margin-bottom:4px;
}
.entry-player.p1{
  color:#1e73d8;
}
.entry-player.p2{
  color:#d82020;
}
.entry-player.sys{
  color:#888;
}
.entry-text{
  line-height:1.35;
}
.log-thumb{
  width:48px;
  height:67px;
  border-radius:6px;
  margin-top:8px;
  box-shadow:0 2px 6px rgba(0,0,0,.45);
  border:1px solid #1f2937;
  cursor:pointer;
  align-self:flex-start;
}
#historyBackdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.7);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
}
#historyBackdrop.show{
  display:flex;
}
#historyCard{
  width:min(600px,90vw);
  background:#101418;
  border:1px solid #334155;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
  border-radius:16px;
  padding:20px;
  color:#e5e7eb;
  max-height:80vh;
  overflow-y:auto;
}
#historyCard h2{
  margin:0 0 10px 0;
  font-size:22px;
  text-align:center;
}
#fullHistory{
  font-size:13px;
  line-height:1.32;
}
.match-log-entry{
  background:#111827;
  border:1px solid #374151;
  border-left:4px solid #9ca3af;
  border-radius:8px;
  padding:8px 10px;
  box-shadow:0 2px 6px rgba(0,0,0,.4);
  margin-bottom:12px;
  color:#e5e7eb;
}
.ability-glow{
  animation:glowPulse 1.2s infinite;
  cursor:pointer;
  box-shadow:0 0 10px rgba(255,255,255,0.6);
}
.ability-disabled{
  opacity:0.45;
  filter:grayscale(70%);
  pointer-events:none;
}
.ability-entry{
  background:rgba(85, 105, 255, 0.14);
  border:1px solid rgba(110, 150, 255, 0.4);
  border-radius:8px;
  padding:8px 10px;
  margin:6px 0;
  transition:0.15s ease;
}
.ability-entry.disabled{
  opacity:0.45;
  pointer-events:none;
}
.ability-header{
  display:flex;
  align-items:center;
  gap:6px;
  margin-bottom:6px;
}
.ability-badge{
  background:linear-gradient(90deg, #cc2a2a, #ff5959);
  color:white;
  padding:2px 8px;
  border-radius:6px;
  font-size:11px;
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:0.5px;
}
.ability-title{
  font-size:14px;
  font-weight:700;
  color:#ffffff;
}
.ability-desc{
  font-size:12px;
  line-height:1.3;
  opacity:0.9;
  color:#e8e8e8;
  margin-top:3px;
}
.ability-used-tag{
  margin-top:6px;
  font-size:11px;
  font-weight:bold;
  color:#ffaaaa;
  text-align:right;
}
.attack-ability-wrapper{
  margin-bottom:8px;
}
.attack-ability-row{
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  padding:6px 10px;
  border-radius:10px !important;
  background:linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
  box-shadow:0 0 0 1px rgba(15,23,42,0.7);
  cursor:pointer;
  transition:transform 0.08s ease-out, box-shadow 0.08s ease-out, opacity 0.15s;
  min-height:52px;
}
.attack-ability-row.used{
  opacity:0.45;
  cursor:default;
}
.attack-ability-left{
  display:flex;
  flex-direction:column;
  gap:2px;
}
.attack-ability-label{
  font-size:9px !important;
  font-weight:700;
  padding:1px 6px;
  border-radius:999px;
  background:rgba(0,0,0,0.4);
  text-transform:uppercase;
  letter-spacing:0.8px !important;
  color:rgba(255, 255, 255, 0.95) !important;
}
.attack-ability-name{
  font-size:14px !important;
  font-weight:700 !important;
  color:#fff !important;
  margin-top:2px !important;
  line-height:1.2 !important;
}
.attack-ability-right{
  display:flex;
  align-items:center;
  gap:4px;
  font-size:11px;
  opacity:0.8;
}
.attack-ability-toggle{
  cursor:pointer;
}
.attack-ability-desc{
  margin-top:4px;
  padding:6px 10px 7px;
  border-radius:8px;
  background:rgba(254, 226, 226, 0.2) !important;
  font-size:11px;
  color:#fecaca !important;
  line-height:1.3 !important;
  display:none;
}
.attack-desc{
  margin-top:-2px !important;
  margin-bottom:4px !important;
  padding:4px 10px 6px;
  border-radius:8px;
  background:rgba(30, 30, 40, 0.8) !important;
  font-size:11px;
  color:#d1d5db !important;
  display:none;
  line-height:1.3 !important;
}
.attack-info{
  font-size:12px !important;
  margin-left:6px;
  opacity:0.7;
  cursor:pointer;
  padding:2px 6px !important;
  color:#00d4ff !important;
}
#player1{
  border-radius:16px;
  padding:12px;
  box-shadow:0 -4px 16px rgba(0, 212, 255, 0.15);
  transition: background 0.6s ease, box-shadow 0.6s ease, border-color 0.6s ease, opacity 0.3s ease;
  position: relative;
}

#player1::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 16px;
  padding: 2px;
  background: linear-gradient(135deg, rgba(0, 212, 255, 0.3), rgba(0, 212, 255, 0.1));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

#player1:hover::before {
  opacity: 1;
}

#player2{
  border-radius:16px;
  padding:12px;
  box-shadow:0 4px 16px rgba(227, 53, 13, 0.15);
  transition: background 0.6s ease, box-shadow 0.6s ease, border-color 0.6s ease, opacity 0.3s ease;
  position: relative;
}

#player2::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 16px;
  padding: 2px;
  background: linear-gradient(135deg, rgba(227, 53, 13, 0.3), rgba(227, 53, 13, 0.1));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

#player2:hover::before {
  opacity: 1;
}
.zoom-card{
  border-radius:16px !important;
}
.zoom-hp-bar{
  background:linear-gradient(90deg, #22c55e 0%, #16a34a 100%) !important;
  border-radius:8px;
  box-shadow:inset 0 1px 2px rgba(0, 0, 0, 0.2);
}
.zoom-ability-card{
  background:linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border:2px solid #ef4444 !important;
  border-radius:10px !important;
  padding:16px !important;
  backdrop-filter:blur(10px);
  margin-bottom:8px !important;
}
.energy.selected{
  border:3px solid #00d4ff !important;
  box-shadow:0 0 16px rgba(0, 255, 255, 0.8) !important;
  transform:scale(1.2) !important;
}

.energy.selected-glow,
.card-img.selected-glow {
  box-shadow: 0 0 20px rgba(0, 212, 255, 0.8), 0 0 40px rgba(0, 212, 255, 0.6), 0 0 60px rgba(0, 212, 255, 0.4) !important;
  border: 2px solid #00d4ff !important;
  animation: pulse-glow 1.5s ease-in-out infinite !important;
  transform: scale(1.05) !important;
  z-index: 100 !important;
  position: relative;
}

@keyframes pulse-glow {
  0%, 100% {
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.8), 0 0 40px rgba(0, 212, 255, 0.6), 0 0 60px rgba(0, 212, 255, 0.4) !important;
  }
  50% {
    box-shadow: 0 0 30px rgba(0, 212, 255, 1), 0 0 60px rgba(0, 212, 255, 0.8), 0 0 90px rgba(0, 212, 255, 0.6) !important;
  }
}
#mainButton{
  background:rgba(40, 40, 50, 0.98) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:50px !important;
  padding:12px 20px !important;
  font-size:14px !important;
  font-weight:700 !important;
  text-transform:uppercase;
  letter-spacing:1px;
  transition:all 0.3s ease;
  z-index:150 !important;
  backdrop-filter:blur(20px);
  position:fixed !important;
  right:30px !important;
  top:50% !important;
  transform:translateY(-50%) !important;
  bottom:220px !important;
}
.popup{
  background:linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(243, 244, 246, 0.98) 100%) !important;
  backdrop-filter:blur(20px);
  color:#111827 !important;
  border-radius:50px !important;
  padding:14px 28px !important;
  font-weight:600 !important;
  font-size:15px !important;
  border:2px solid #e5e7eb !important;
  z-index:2500 !important;
}
.deck-bubble, .discard-btn{
  background:rgba(15, 15, 25, 0.85) !important;
  backdrop-filter:blur(12px);
  border:2px solid rgba(138, 43, 226, 0.4) !important;
  border-radius:12px !important;
}
.victory-overlay{
  background:rgba(0, 0, 0, 0.9) !important;
  backdrop-filter:blur(12px);
  z-index:5000 !important;
}
.victory-content{
  background:linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(243, 244, 246, 0.98) 100%) !important;
  backdrop-filter:blur(20px);
  border-radius:24px !important;
  border:3px solid #00d4ff !important;
}
.victory-title{
  font-size:44px !important;
  font-weight:700 !important;
  color:#111827 !important;
  text-transform:uppercase;
  letter-spacing:2px;
}
.victory-btn{
  background:linear-gradient(135deg, #00d4ff 0%, #0ff 100%) !important;
  color:#000 !important;
  border:none !important;
  border-radius:50px !important;
  padding:16px 40px !important;
  font-size:17px !important;
  font-weight:700 !important;
  text-transform:uppercase;
  letter-spacing:1px;
  box-shadow:0 8px 24px rgba(0, 212, 255, 0.5) !important;
}
.glow-promote, .promote-glow{
  animation:promoteGlow 1.5s ease-in-out infinite !important;
  border:3px solid #0ff !important;
}
.zoom-attack-name{
  font-size:16px !important;
  font-weight:700 !important;
  color:#ffffff !important;
}
.zoom-attack-text{
  font-size:14px !important;
  line-height:1.4 !important;
  color:#d1d5db !important;
  margin-top:4px !important;
}
.zoom-stats{
  border-radius:10px !important;
  padding:12px !important;
  margin-top:16px !important;
}
.zoom-stat-label{
  color:#9ca3af !important;
  font-weight:600 !important;
  font-size:12px !important;
  text-transform:uppercase;
  letter-spacing:1px;
  margin-bottom:6px !important;
}
.zoom-stat-value{
  color:#ffffff !important;
  font-weight:700 !important;
  display:flex !important;
  align-items:center !important;
  gap:6px !important;
  font-size:16px !important;
}
.attack-ability-wrapper[data-type="grass"] .attack-ability-row{
  background:linear-gradient(90deg, #22c55e 0%, #16a34a 100%) !important;
}
.attack-ability-wrapper[data-type="fire"] .attack-ability-row{
  background:linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
}
.attack-ability-wrapper[data-type="water"] .attack-ability-row{
  background:linear-gradient(90deg, #3b82f6 0%, #2563eb 100%) !important;
}
.attack-ability-wrapper[data-type="lightning"] .attack-ability-row{
  background:linear-gradient(90deg, #eab308 0%, #ca8a04 100%) !important;
}
.attack-ability-wrapper[data-type="psychic"] .attack-ability-row{
  background:linear-gradient(90deg, #a855f7 0%, #9333ea 100%) !important;
}
.attack-ability-wrapper[data-type="fighting"] .attack-ability-row{
  background:linear-gradient(90deg, #f97316 0%, #ea580c 100%) !important;
}
.attack-ability-wrapper[data-type="darkness"] .attack-ability-row{
  background:linear-gradient(90deg, #64748b 0%, #475569 100%) !important;
}
.attack-ability-wrapper[data-type="metal"] .attack-ability-row{
  background:linear-gradient(90deg, #94a3b8 0%, #64748b 100%) !important;
}
.attack-ability-wrapper[data-type="dragon"] .attack-ability-row{
  background:linear-gradient(90deg, #d3ba30 0%, #b89e20 100%) !important;
}
.attack-ability-wrapper[data-type="fairy"] .attack-ability-row{
  background:linear-gradient(90deg, #ec4899 0%, #db2777 100%) !important;
}
.attack-ability-wrapper[data-type="colorless"] .attack-ability-row{
  background:linear-gradient(90deg, #9ca3af 0%, #6b7280 100%) !important;
}
.attack-item.payable[data-type="grass"]{
  background:rgba(34, 197, 94, 0.2) !important;
  border-color:#22c55e !important;
}
.attack-item.payable[data-type="grass"] .attack-name{
  color:#15803d !important;
}
.attack-item.payable[data-type="fire"]{
  background:rgba(239, 68, 68, 0.2) !important;
  border-color:#ef4444 !important;
}
.attack-item.payable[data-type="fire"] .attack-name{
  color:#b91c1c !important;
}
.attack-item.payable[data-type="water"]{
  background:rgba(59, 130, 246, 0.2) !important;
  border-color:#3b82f6 !important;
}
.attack-item.payable[data-type="water"] .attack-name{
  color:#1e40af !important;
}
.attack-item.payable[data-type="lightning"]{
  background:rgba(234, 179, 8, 0.2) !important;
  border-color:#eab308 !important;
}
.attack-item.payable[data-type="lightning"] .attack-name{
  color:#a16207 !important;
}
.attack-item.payable[data-type="psychic"]{
  background:rgba(168, 85, 247, 0.2) !important;
  border-color:#a855f7 !important;
}
.attack-item.payable[data-type="psychic"] .attack-name{
  color:#7e22ce !important;
}
.attack-item.payable[data-type="fighting"]{
  background:rgba(249, 115, 22, 0.2) !important;
  border-color:#f97316 !important;
}
.attack-item.payable[data-type="fighting"] .attack-name{
  color:#c2410c !important;
}
.attack-item.payable[data-type="darkness"]{
  background:rgba(100, 116, 139, 0.2) !important;
  border-color:#64748b !important;
}
.attack-item.payable[data-type="darkness"] .attack-name{
  color:#334155 !important;
}
.attack-item.payable[data-type="metal"]{
  background:rgba(148, 163, 184, 0.2) !important;
  border-color:#94a3b8 !important;
}
.attack-item.payable[data-type="metal"] .attack-name{
  color:#475569 !important;
}
.attack-item.payable[data-type="dragon"]{
  background:linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%) !important;
  border-color:#8b5cf6 !important;
}
.attack-item.payable[data-type="dragon"] .attack-name{
  color:#6d28d9 !important;
}
.attack-item.payable[data-type="fairy"]{
  background:linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%) !important;
  border-color:#ec4899 !important;
}
.attack-item.payable[data-type="fairy"] .attack-name{
  color:#be185d !important;
}
.attack-item.payable[data-type="colorless"]{
  background:linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%) !important;
  border-color:#9ca3af !important;
}
.attack-item.payable[data-type="colorless"] .attack-name{
  color:#4b5563 !important;
}
.log-toggle-btn{
  bottom:20px !important;
  z-index:100 !important;
}
.prize-area{
  z-index:50 !important;
}
.hand{
  max-width:100% !important;
  flex-wrap:wrap !important;
  justify-content:center !important;
  min-height:calc(var(--card-h) + 12px);
  transition: min-height 0.3s ease;
}
.bench{
  max-width:100% !important;
  flex-wrap:wrap !important;
  justify-content:center !important;
}
.player-area > * + *{
  margin-top:2px !important;
}
.zoom-attack-header{
  display:flex !important;
  justify-content:space-between !important;
  align-items:center !important;
  margin-bottom:10px !important;
}
.zoom-attack-damage{
  font-size:20px !important;
  font-weight:900 !important;
  color:#ffffff !important;
  transition: all 0.3s ease;
  text-shadow: 0 1px 3px rgba(0,0,0,0.5);
  display: inline-block;
}

.zoom-attack:hover .zoom-attack-damage {
  transform: scale(1.15);
  text-shadow: 0 2px 6px rgba(0, 212, 255, 0.6), 0 0 12px rgba(0, 212, 255, 0.4);
  color: #00d4ff !important;
}
.zoom-attack-cost{
  display:flex !important;
  gap:3px !important;
  margin-right:8px !important;
}
.zoom-retreat-cost{
  background:rgba(40, 40, 50, 0.6) !important;
  border-radius:10px !important;
  padding:12px !important;
  margin-top:12px !important;
}
.zoom-retreat-btn{
  background:rgba(50, 50, 60, 0.8) !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  color:#ffffff !important;
  border-radius:10px !important;
  padding:14px !important;
  margin-top:12px !important;
  font-size:15px !important;
  font-weight:700 !important;
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
}
.zoom-panel *{
  filter:none !important;
  color:inherit;
}
.attack-damage{
  font-weight:900 !important;
  transition: all 0.3s ease;
  display: inline-block;
}

.attack-item:hover .attack-damage {
  transform: scale(1.15);
  text-shadow: 0 2px 6px rgba(0, 212, 255, 0.6), 0 0 12px rgba(0, 212, 255, 0.4);
  color: #00d4ff !important;
}
[id*="log"] button{
  z-index:90 !important;
}
.zoom-ability-card[data-type="grass"]{
  background:linear-gradient(135deg, rgba(34, 197, 94, 0.3) 0%, rgba(22, 163, 74, 0.3) 100%) !important;
  border-color:#22c55e !important;
}
.zoom-ability-card[data-type="grass"] .zoom-ability-name{
  color:#15803d !important;
}
.zoom-ability-card[data-type="fire"]{
  background:linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border-color:#ef4444 !important;
}
.zoom-ability-card[data-type="fire"] .zoom-ability-name{
  color:#b91c1c !important;
}
.zoom-ability-card[data-type="water"]{
  background:linear-gradient(135deg, rgba(59, 130, 246, 0.3) 0%, rgba(37, 99, 235, 0.3) 100%) !important;
  border-color:#3b82f6 !important;
}
.zoom-ability-card[data-type="water"] .zoom-ability-name{
  color:#1e40af !important;
}
.zoom-ability-card[data-type="lightning"]{
  background:linear-gradient(135deg, rgba(234, 179, 8, 0.3) 0%, rgba(202, 138, 4, 0.3) 100%) !important;
  border-color:#eab308 !important;
}
.zoom-ability-card[data-type="lightning"] .zoom-ability-name{
  color:#a16207 !important;
}
.zoom-ability-card[data-type="psychic"]{
  background:linear-gradient(135deg, rgba(168, 85, 247, 0.3) 0%, rgba(147, 51, 234, 0.3) 100%) !important;
  border-color:#a855f7 !important;
}
.zoom-ability-card[data-type="psychic"] .zoom-ability-name{
  color:#7e22ce !important;
}
.zoom-ability-card[data-type="fighting"]{
  background:linear-gradient(135deg, rgba(249, 115, 22, 0.3) 0%, rgba(234, 88, 12, 0.3) 100%) !important;
  border-color:#f97316 !important;
}
.zoom-ability-card[data-type="fighting"] .zoom-ability-name{
  color:#c2410c !important;
}
.zoom-ability-card[data-type="darkness"]{
  background:linear-gradient(135deg, rgba(100, 116, 139, 0.3) 0%, rgba(71, 85, 105, 0.3) 100%) !important;
  border-color:#64748b !important;
}
.zoom-ability-card[data-type="darkness"] .zoom-ability-name{
  color:#334155 !important;
}
.zoom-ability-card[data-type="metal"]{
  background:linear-gradient(135deg, rgba(148, 163, 184, 0.3) 0%, rgba(100, 116, 139, 0.3) 100%) !important;
  border-color:#94a3b8 !important;
}
.zoom-ability-card[data-type="metal"] .zoom-ability-name{
  color:#475569 !important;
}
.zoom-ability-text{
  -webkit-font-smoothing:antialiased !important;
  -moz-osx-font-smoothing:grayscale !important;
  text-rendering:optimizeLegibility !important;
  font-size:14px !important;
  line-height:1.4 !important;
  color:#d1d5db !important;
}
.zoom-section-title{
  color:#9ca3af !important;
  margin-bottom:10px !important;
}
.zoom-ability-name{
  font-size:18px !important;
  font-weight:700 !important;
  color:#ffffff !important;
  margin-bottom:6px !important;
}
.zoom-ability-card[data-type="grass"] .zoom-ability-text{
  color:#bbf7d0 !important;
}
.zoom-ability-card[data-type="fire"] .zoom-ability-text{
  color:#fecaca !important;
}
.zoom-ability-card[data-type="water"] .zoom-ability-text{
  color:#bfdbfe !important;
}
.zoom-ability-card[data-type="lightning"] .zoom-ability-text{
  color:#fde68a !important;
}
.zoom-ability-card[data-type="psychic"] .zoom-ability-text{
  color:#e9d5ff !important;
}
.zoom-ability-card[data-type="fighting"] .zoom-ability-text{
  color:#fdba74 !important;
}
.zoom-ability-card[data-type="darkness"] .zoom-ability-text{
  color:#cbd5e1 !important;
}
.zoom-ability-card[data-type="metal"] .zoom-ability-text{
  color:#e2e8f0 !important;
}
.zoom-tool-section{
  color:#e5e7eb !important;
}
.zoom-close{
  background:#ef4444 !important;
  color:#fff !important;
}
.zoom-tool-count{
  background:rgba(50, 50, 60, 0.8) !important;
  color:#ffffff !important;
  padding:4px 10px !important;
  border-radius:12px !important;
  font-weight:700 !important;
}
.zoom-attack-cost-icon{
  width:20px !important;
  height:18px !important;
  border-radius:50% !important;
  background-size:contain !important;
  background-position:center !important;
  border:1px solid rgba(255, 255, 255, 0.2) !important;
}
div[style*="retreat"]{
  margin-top:6px !important;
  padding:6px 10px !important;
  min-height:36px !important;
  background:rgba(60, 60, 70, 0.6) !important;
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  color:#ffffff !important;
}
[class*="retreat"] button{
  padding:6px 10px !important;
  min-height:36px !important;
  font-size:13px !important;
  color:#ffffff !important;
}
.zoom-ability-badge{
  padding:3px 10px !important;
  font-size:10px !important;
  margin-bottom:6px !important;
}
.zoom-resistance{
  background:rgba(40, 40, 50, 0.6) !important;
  border-radius:8px !important;
}
.attack-menu *{
  color:#ffffff !important;
}
.show-log-btn{
  z-index:100 !important;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:12px !important;
  padding:10px 16px !important;
  font-weight:600 !important;
  position:fixed !important;
  bottom:20px !important;
  right:20px !important;
}
[class*="turn"]{
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:1px solid rgba(100, 100, 120, 0.3) !important;
}
[class*="discard"] button{
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:12px !important;
  padding:10px 16px !important;
  font-weight:600 !important;
  transition:all 0.2s ease !important;
}
.deck-count{
  color:#ffffff !important;
  font-weight:700 !important;
}
.energy-zone.horizontal{
  flex-direction:row !important;
  border-radius:40px !important;
  padding:10px 14px !important;
}
[class*="turn-box"]{
  position:fixed !important;
  right:30px !important;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  border-radius:12px !important;
  padding:12px 16px !important;
  font-weight:600 !important;
  text-align:center !important;
  z-index:50 !important;
  min-width:120px !important;
}
#player1 .discard-btn{
  position:absolute !important;
  left:20px !important;
  bottom:50% !important;
  transform:translateY(50%) !important;
}
#player2 .discard-btn{
  position:absolute !important;
  left:20px !important;
  top:50% !important;
  transform:translateY(-50%) !important;
}
#turnInfo{
  bottom:300px !important;
}
.turn-info{
  z-index:50 !important;
}

#logToggleBtn, #showLogBtn, .show-log-btn {
  position: fixed;
  right: 30px;
  bottom: 20px;
  padding: 8px 16px;
  background: rgba(40, 40, 50, 0.9);
  border: 1px solid rgba(100, 100, 120, 0.4);
  border-radius: 12px;
  color: #e5e7eb;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  z-index: 100;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  transition: all 0.2s ease;
  width: auto;
  height: auto;
  min-width: auto;
}

#logToggleBtn:hover, #showLogBtn:hover {
  background: rgba(50, 50, 60, 0.95);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.3);
}

.energy-zone {
  position: fixed;
  right: 30px;
  bottom: 60px;
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 6px;
  padding: 10px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.3);
  border-radius: 12px;
  z-index: 200;
  width: auto;
  max-width: 120px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
}

.energy-container {
  position: relative;
  display: inline-block;
}

.energy-container {
  position: relative;
  display: inline-block;
}

.energy-zone .energy-container > .energy-next-turn {
  position: absolute !important;
  bottom: -2px !important;
  right: -2px !important;
  width: 10px !important;
  height: 10px !important;
  opacity: 1 !important;
  cursor: default !important;
  pointer-events: none !important;
  border: 1.5px solid rgba(255, 255, 255, 1) !important;
  filter: grayscale(0%) brightness(100%) !important;
  border-radius: 50% !important;
  background-color: transparent !important;
  box-shadow: 0 0 0 1px rgba(40, 40, 50, 1), 0 1px 3px rgba(0, 0, 0, 0.9) !important;
  z-index: 10 !important;
  display: block !important;
  visibility: visible !important;
  overflow: hidden !important;
}

.energy-zone .energy-container > .energy-next-turn > img {
  width: 100% !important;
  height: 100% !important;
  object-fit: cover !important;
  border-radius: 50% !important;
  display: block !important;
}

.energy:hover {
  transform: scale(1.1);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.5);
}

.energy.selected {
  border: 3px solid #0ff;
  box-shadow: 0 0 16px rgba(0, 255, 255, 0.8);
  transform: scale(1.15);
}

.discard-btn {
  position: absolute;
  width: 85px;
  height: 36px;
  background: rgba(40, 40, 50, 0.9);
  color: #fff;
  border: 2px solid rgba(100, 100, 120, 0.4);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: 700;
  cursor: pointer;
  z-index: 9;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  transition: all 0.2s ease;
  padding: 0;
}

.discard-btn:hover {
  background: rgba(50, 50, 60, 0.95);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.4);
  transform: scale(1.05);
}

.deck-bubble {
  width: 36px;
  height: 36px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.4);
  border-radius: 50%;
  font-size: 13px;
  font-weight: 700;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

.turnbox, #turnInfo {
  width: 120px;
  padding: 8px 12px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.3);
  border-radius: 10px;
  font-size: 13px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

#mainButton {
  padding: 12px 24px;
  font-size: 15px;
  font-weight: 700;
  min-width: 140px;
  height: auto;
  border-radius: 50px;
}

#mainButton {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  padding: 8px 14px !important;
  font-size: 0.9rem !important;
  min-width: 150px !important;
  max-width: none !important;
  height: auto !important;
  border-radius: 10px !important;
  background: linear-gradient(135deg, #e3350d, #0074d9) !important;
  border: 1px solid #1f2937 !important;
  color: #fff !important;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35) !important;
  cursor: pointer !important;
  z-index: auto !important;
}

#mainButton::after {
  display: none !important;
}

.energy-zone {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  display: flex !important;
  flex-wrap: wrap !important;
  gap: 6px !important;
  justify-content: center !important;
  padding: 0 !important;
  background: transparent !important;
  border: none !important;
  border-radius: 0 !important;
  z-index: auto !important;
  width: auto !important;
  max-width: none !important;
  box-shadow: none !important;
}

.energy.selected {
  border: 3px solid #0ff !important;
  box-shadow: 0 0 12px rgba(0, 255, 255, 0.8) !important;
  transform: scale(1.15) !important;
}

.side-panel {
  position: fixed !important;
  top: 20px !important;
  right: 20px !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  gap: 0.6rem !important;
  z-index: 10 !important;
}

.turnbox, #turnInfo {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  width: 150px !important;
  border: 1px solid #3b3f46 !important;
  background: #23272e !important;
  border-radius: 12px !important;
  padding: 10px !important;
  text-align: center !important;
  font-size: 0.92rem !important;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4) !important;
  color: #e5e7eb !important;
  z-index: auto !important;
}

.turnbox .big {
  font-weight: 800;
  font-size: 1.05rem;
}

#logToggleBtn, #showLogBtn, .show-log-btn {
  position: fixed !important;
  right: 30px !important;
  top: 355px !important;
  bottom: auto !important;
  z-index: 1500 !important;
  background: linear-gradient(90deg, #2a2f36, #1f232a) !important;
  border: 1px solid #334155 !important;
  padding: 8px 14px !important;
  color: #e5e7eb !important;
  border-radius: 10px !important;
  font-size: 0.85rem !important;
  cursor: pointer !important;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4) !important;
  width: auto !important;
  height: auto !important;
  min-width: auto !important;
}

#logToggleBtn:hover, #showLogBtn:hover {
  filter: brightness(1.08);
}

.energy-zone-label,
#energyZoneLabel {
  display: none !important;
}

.energy-zone::before {
  content: none !important;
  display: none !important;
}

.coin {
  position: static !important;
  top: auto !important;
  right: auto !important;
  width: 70px !important;
  height: 70px !important;
  transform-style: preserve-3d !important;
  transition: transform 1.5s ease-in-out !important;
  z-index: auto !important;
}

#coinResult {
  text-align: center;
  font-weight: 700;
  font-size: 13px;
  min-height: 35px;
}

.side-panel button {
  background: linear-gradient(135deg, #e3350d, #0074d9);
  color: #fff;
  border: none;
  padding: 8px 14px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 0.9rem;
  min-width: 150px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
  border: 1px solid #1f2937;
}

.side-panel button:hover {
  opacity: 0.95;
}

.attack-menu {
  background: rgba(30, 30, 40, 0.98) !important;
  backdrop-filter: blur(20px) !important;
  border: 2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 12px !important;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8) !important;
  padding: 8px !important;
  min-width: 240px !important;
  color: #e5e7eb !important;
}

.attack-item {
  padding: 8px 10px !important;
  margin-bottom: 4px !important;
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 8px !important;
  color: #ffffff !important;
  min-height: 36px !important;
}

.attack-item:hover {
  background: rgba(60, 60, 70, 0.9) !important;
  border-color: #00d4ff !important;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.3) !important;
}

.attack-item.payable {
  border-color: #00d4ff !important;
  background: rgba(0, 212, 255, 0.15) !important;
}

.attack-name {
  font-size: 13px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
  line-height: 1.2 !important;
}

.attack-cost {
  gap: 3px !important;
}

.cost-icon {
  width: 18px !important;
  height: 18px !important;
}

.attack-desc {
  padding: 3px 5px !important;
  margin-top: 2px !important;
  margin-bottom: 4px !important;
  font-size: 11px !important;
  line-height: 1.3 !important;
  background: rgba(20, 20, 30, 0.8) !important;
  color: #d1d5db !important;
  border-radius: 6px !important;
}

.attack-ability-wrapper {
  margin-bottom: 6px !important;
}

.attack-ability-row {
  padding: 8px 10px !important;
  background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
  border-radius: 8px !important;
  min-height: 36px !important;
}

.attack-ability-row:hover {
  background: linear-gradient(90deg, #dc2626 0%, #b91c1c 100%) !important;
}

.attack-ability-name {
  font-size: 13px !important;
  font-weight: 700 !important;
  color: #fff !important;
  line-height: 1.2 !important;
}

.attack-ability-label {
  font-size: 9px !important;
  padding: 2px 6px !important;
}

.attack-ability-desc {
  padding: 3px 5px !important;
  font-size: 11px !important;
  line-height: 1.3 !important;
  background: rgba(254, 226, 226, 0.2) !important;
  color: #fecaca !important;
}

.zoom-panel {
  background: rgba(30, 30, 40, 0.98) !important;
  backdrop-filter: blur(20px) !important;
  border-radius: 16px !important;
  padding: 16px !important;
  color: #e5e7eb !important;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9) !important;
  border: 2px solid rgba(100, 100, 120, 0.3) !important;
}

.zoom-header {
  margin-bottom: 12px !important;
  padding-bottom: 10px !important;
}

.zoom-title {
  font-size: 20px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
}

.zoom-hp {
  font-size: 14px !important;
  color: #ffffff !important;
  margin-bottom: 8px !important;
}

.hpbar-container {
  margin: 6px 0 !important;
}

.zoom-section {
  margin-top: 10px !important;
  padding-top: 10px !important;
  border-top: 1px solid rgba(100, 100, 120, 0.3) !important;
}

.zoom-attack {
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 10px !important;
  padding: 10px 12px !important;
  margin: 8px 0 !important;
}

.zoom-attack .top {
  padding: 6px 8px !important;
}

.zoom-attack-name,
.zoom-attack .name {
  font-size: 15px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
}

.zoom-attack-damage,
.zoom-attack .dmg {
  font-size: 18px !important;
  font-weight: 900 !important;
  color: #ffffff !important;
}

.zoom-attack-text,
.effect {
  font-size: 12px !important;
  line-height: 1.4 !important;
  color: #d1d5db !important;
  margin-top: 4px !important;
}

.zoom-ability-card,
.ability-box {
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border: 2px solid #ef4444 !important;
  border-radius: 10px !important;
  padding: 10px 12px !important;
  margin: 8px 0 !important;
}

.zoom-ability-name,
.ability-name {
  font-size: 16px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
  margin-bottom: 6px !important;
}

.zoom-ability-text,
.ability-text {
  font-size: 12px !important;
  line-height: 1.4 !important;
  color: #fecaca !important;
}

#zoomRetreatRow {
  padding: 10px 12px !important;
  margin-top: 10px !important;
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
}

.row {
  margin: 6px 0 !important;
  gap: 6px !important;
}

.chip {
  padding: 3px 8px !important;
  font-size: 11px !important;
}

#player1.type-grass,
#player2.type-grass {
  background: linear-gradient(180deg, 
    rgba(34, 197, 94, 0.3) 0%, 
    rgba(22, 163, 74, 0.5) 50%, 
    rgba(21, 128, 61, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(34, 197, 94, 0.3) !important;
  border: 1px solid rgba(34, 197, 94, 0.3) !important;
}

#player1.type-fire,
#player2.type-fire {
  background: linear-gradient(180deg, 
    rgba(239, 68, 68, 0.3) 0%, 
    rgba(220, 38, 38, 0.5) 50%, 
    rgba(185, 28, 28, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(239, 68, 68, 0.3) !important;
  border: 1px solid rgba(239, 68, 68, 0.3) !important;
}

#player1.type-water,
#player2.type-water {
  background: linear-gradient(180deg, 
    rgba(59, 130, 246, 0.3) 0%, 
    rgba(37, 99, 235, 0.5) 50%, 
    rgba(29, 78, 216, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(59, 130, 246, 0.3) !important;
  border: 1px solid rgba(59, 130, 246, 0.3) !important;
}

#player1.type-lightning,
#player2.type-lightning {
  background: linear-gradient(180deg, 
    rgba(234, 179, 8, 0.3) 0%, 
    rgba(202, 138, 4, 0.5) 50%, 
    rgba(161, 98, 7, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(234, 179, 8, 0.3) !important;
  border: 1px solid rgba(234, 179, 8, 0.3) !important;
}

#player1.type-psychic,
#player2.type-psychic {
  background: linear-gradient(180deg, 
    rgba(168, 85, 247, 0.3) 0%, 
    rgba(147, 51, 234, 0.5) 50%, 
    rgba(126, 34, 206, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(168, 85, 247, 0.3) !important;
  border: 1px solid rgba(168, 85, 247, 0.3) !important;
}

#player1.type-fighting,
#player2.type-fighting {
  background: linear-gradient(180deg, 
    rgba(249, 115, 22, 0.3) 0%, 
    rgba(234, 88, 12, 0.5) 50%, 
    rgba(194, 65, 12, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(249, 115, 22, 0.3) !important;
  border: 1px solid rgba(249, 115, 22, 0.3) !important;
}

#player1.type-darkness,
#player2.type-darkness {
  background: linear-gradient(180deg, 
    rgba(100, 116, 139, 0.3) 0%, 
    rgba(71, 85, 105, 0.5) 50%, 
    rgba(51, 65, 85, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(100, 116, 139, 0.3) !important;
  border: 1px solid rgba(100, 116, 139, 0.3) !important;
}

#player1.type-metal,
#player2.type-metal {
  background: linear-gradient(180deg, 
    rgba(148, 163, 184, 0.3) 0%, 
    rgba(100, 116, 139, 0.5) 50%, 
    rgba(71, 85, 105, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(148, 163, 184, 0.3) !important;
  border: 1px solid rgba(148, 163, 184, 0.3) !important;
}

#player1.type-dragon,
#player2.type-dragon {
  background: linear-gradient(180deg, 
    rgba(211, 186, 48, 0.3) 0%, 
    rgba(184, 158, 32, 0.5) 50%, 
    rgba(169, 142, 28, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(211, 186, 48, 0.3) !important;
  border: 1px solid rgba(211, 186, 48, 0.3) !important;
}

#player1.type-fairy,
#player2.type-fairy {
  background: linear-gradient(180deg, 
    rgba(236, 72, 153, 0.3) 0%, 
    rgba(219, 39, 119, 0.5) 50%, 
    rgba(190, 24, 93, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(236, 72, 153, 0.3) !important;
  border: 1px solid rgba(236, 72, 153, 0.3) !important;
}

#player1.type-colorless,
#player2.type-colorless {
  background: linear-gradient(180deg, 
    rgba(156, 163, 175, 0.3) 0%, 
    rgba(107, 114, 128, 0.5) 50%, 
    rgba(75, 85, 99, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(156, 163, 175, 0.3) !important;
  border: 1px solid rgba(156, 163, 175, 0.3) !important;
}

#player1:not([class*="type-"]) {
  background: linear-gradient(180deg, 
    transparent 0%, 
    rgba(30, 58, 95, 0.4) 15%, 
    rgba(13, 31, 58, 0.6) 100%) !important;
  box-shadow: 0 -6px 24px rgba(59, 130, 246, 0.25) !important;
  border: 1px solid rgba(59, 130, 246, 0.2) !important;
}

#player2:not([class*="type-"]) {
  background: linear-gradient(180deg, 
    rgba(95, 30, 30, 0.6) 0%, 
    rgba(58, 13, 13, 0.4) 75%, 
    transparent 100%) !important;
  box-shadow: 0 6px 24px rgba(239, 68, 68, 0.25) !important;
  border: 1px solid rgba(239, 68, 68, 0.2) !important;
}

.attack-menu {
  z-index: 99999 !important;
  position: fixed !important;
}

.card-slot {
  position: relative;
  isolation: auto !important; 
}

.active {
  position: relative;
  z-index: auto !important;
  isolation: auto !important;
}

#player1, #player2 {
  position: relative;
  z-index: 1 !important;
}

.player-area {
  z-index: auto !important;
}

.active:has(.attack-menu) {
  z-index: 99998 !important;
}

.active:has(.attack-menu) .card-slot {
  z-index: 99998 !important;
}

.active:has(.attack-menu) .attack-menu {
  z-index: 99999 !important;
}

.attack-menu-backdrop { display: none !important; }

.attack-menu.ptcgl-style {
  position: fixed !important;
  z-index: 99999 !important;
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
  display: block !important;
}

.ptcgl-card-container {
  position: relative;
  width: 280px;
  height: 392px;
  border-radius: 12px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
  overflow: hidden;
}

.ptcgl-card-container img {
  width: 100%;
  height: 100%;
  border-radius: 12px;
  object-fit: cover;
}

.ptcgl-hp-type-bar {
  position: absolute;
  top: 6px;
  right: 6px;
  background: rgba(0, 0, 0, 0.85);
  padding: 6px 10px;
  border-radius: 15px;
  display: flex;
  align-items: center;
  gap: 10px;
  z-index: 10;
}

.ptcgl-hp-number {
  font-size: 16px;
  font-weight: 900;
  color: #ffffff;
}

.ptcgl-type-icon-inline {
  width: 20px;
  height: 20px;
  background-size: cover;
  border-radius: 50%;
}

.ptcgl-actions-overlay {
  position: absolute;
  top: 225px;
  left: 10px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 3px;
  z-index: 10;
}

.ptcgl-ability-overlay {
  background: rgba(239, 68, 68, 0.96);  
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  padding: 3px 5px;
  cursor: pointer;
}

.ptcgl-ability-overlay.type-grass {
  background: rgba(139, 195, 74, 0.96);
  border: 1px solid rgba(104, 159, 56, 0.8);
}

.ptcgl-ability-overlay.type-fire {
  background: rgba(239, 83, 80, 0.96);
  border: 1px solid rgba(211, 47, 47, 0.8);
}

.ptcgl-ability-overlay.type-water {
  background: rgba(66, 165, 245, 0.96);
  border: 1px solid rgba(25, 118, 210, 0.8);
}

.ptcgl-ability-overlay.type-lightning {
  background: rgba(255, 202, 40, 0.96);
  border: 1px solid rgba(251, 192, 45, 0.8);
}

.ptcgl-ability-overlay.type-psychic {
  background: rgba(171, 71, 188, 0.96);
  border: 1px solid rgba(123, 31, 162, 0.8);
}

.ptcgl-ability-overlay.type-fighting {
  background: rgba(255, 138, 101, 0.96);
  border: 1px solid rgba(230, 74, 25, 0.8);
}

.ptcgl-ability-overlay.type-darkness {
  background: rgba(66, 66, 66, 0.96);
  border: 1px solid rgba(33, 33, 33, 0.8);
}

.ptcgl-ability-overlay.type-metal {
  background: rgba(158, 158, 158, 0.96);
  border: 1px solid rgba(117, 117, 117, 0.8);
}

.ptcgl-ability-overlay.type-dragon {
  background: rgba(211, 186, 48, 0.96);  
  border: 1px solid rgba(184, 158, 32, 0.8);
}

.ptcgl-ability-overlay.type-fairy {
  background: rgba(236, 64, 122, 0.96);
  border: 1px solid rgba(194, 24, 91, 0.8);
}

.ptcgl-ability-overlay.type-colorless {
  background: rgba(189, 189, 189, 0.96);
  border: 1px solid rgba(158, 158, 158, 0.8);
}

.ptcgl-ability-name {
  font-size: 10px;
  font-weight: 900;
  color: #ffffff;
}

.ptcgl-ability-text {
  font-size: 8px;
  color: rgba(255, 255, 255, 0.95);
}

.ptcgl-attack-overlay {
  background: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(0, 0, 0, 0.1);
  border-radius: 8px;
  cursor: not-allowed;
  overflow: hidden;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  opacity: 0.7;
}

.ptcgl-attack-overlay.payable {
  cursor: pointer;
  opacity: 1;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
}

.ptcgl-attack-overlay.payable:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.ptcgl-attack-overlay.payable.type-grass {
  background: rgba(139, 195, 74, 0.95);
  border: 2px solid rgba(104, 159, 56, 0.8);
}

.ptcgl-attack-overlay.payable.type-fire {
  background: rgba(239, 83, 80, 0.95);
  border: 2px solid rgba(211, 47, 47, 0.8);
}

.ptcgl-attack-overlay.payable.type-water {
  background: rgba(66, 165, 245, 0.95);
  border: 2px solid rgba(25, 118, 210, 0.8);
}

.ptcgl-attack-overlay.payable.type-lightning {
  background: rgba(255, 202, 40, 0.95);
  border: 2px solid rgba(251, 192, 45, 0.8);
}

.ptcgl-attack-overlay.payable.type-psychic {
  background: rgba(171, 71, 188, 0.95);
  border: 2px solid rgba(123, 31, 162, 0.8);
}

.ptcgl-attack-overlay.payable.type-fighting {
  background: rgba(255, 138, 101, 0.95);
  border: 2px solid rgba(230, 74, 25, 0.8);
}

.ptcgl-attack-overlay.payable.type-darkness {
  background: rgba(66, 66, 66, 0.95);
  border: 2px solid rgba(33, 33, 33, 0.8);
}

.ptcgl-attack-overlay.payable.type-metal {
  background: rgba(158, 158, 158, 0.95);
  border: 2px solid rgba(117, 117, 117, 0.8);
}

.ptcgl-attack-overlay.payable.type-dragon {
  background: rgba(211, 186, 48, 0.95);  
  border: 2px solid rgba(184, 158, 32, 0.8);
}

.ptcgl-attack-overlay.payable.type-fairy {
  background: rgba(236, 64, 122, 0.95);
  border: 2px solid rgba(194, 24, 91, 0.8);
}

.ptcgl-attack-overlay.payable.type-colorless {
  background: rgba(189, 189, 189, 0.95);
  border: 2px solid rgba(158, 158, 158, 0.8);
}

.ptcgl-attack-left {
  flex: 1;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 6px 10px;
  z-index: 2;
}

.ptcgl-attack-name {
  font-size: 12px;
  font-weight: 700;
  color: rgba(0, 0, 0, 0.3);
  line-height: 1;
}

.ptcgl-attack-overlay.payable .ptcgl-attack-name {
  color: #000000 !important;
  text-shadow: 0 1px 2px rgba(255,255,255,0.5);
}

.ptcgl-attack-cost {
  display: flex;
  gap: 2px;
}

.ptcgl-cost-icon {
  width: 18px;
  height: 18px;
  background-size: cover;
  border-radius: 50%;
  opacity: 0.4;
}

.ptcgl-attack-overlay.payable .ptcgl-cost-icon {
  opacity: 1;
  filter: brightness(1.1);
}

.ptcgl-attack-separator {
  display: none;
}

.ptcgl-attack-overlay.payable .ptcgl-attack-separator {
  opacity: 0.95;
}

.ptcgl-attack-damage-box {
  position: relative;
  right: auto;
  top: auto;
  width: auto;
  min-width: 40px;
  background: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 8px;
  z-index: 2;
}

.ptcgl-attack-damage {
  font-size: 22px;
  font-weight: 900;
  color: rgba(0, 0, 0, 0.3);
  line-height: 1;
  transition: all 0.3s ease;
  display: inline-block;
}

.ptcgl-attack-overlay.payable .ptcgl-attack-damage {
  color: #000000 !important;
  text-shadow: 0 1px 2px rgba(255,255,255,0.5);
}

.ptcgl-attack-overlay.payable:hover .ptcgl-attack-damage {
  transform: scale(1.15);
  text-shadow: 0 2px 4px rgba(0, 212, 255, 0.5), 0 0 8px rgba(0, 212, 255, 0.3);
  color: #00d4ff !important;
}

.ptcgl-attack-effect {
  font-size: 8px;
  color: rgba(255, 255, 255, 0.85);
  padding: 0 5px 3px 5px;
}

.ptcgl-retreat-corner {
  position: absolute;
  bottom: 35px;
  right: 6px;
  background: rgba(255, 255, 255, 0.98);
  border-radius: 12px;
  padding: 3px 10px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  z-index: 10;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ptcgl-retreat-corner:hover {
  background: rgba(255, 255, 255, 1);
  transform: translateY(-1px);
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
}

.ptcgl-retreat-corner[data-type="water"] { background: #6890f0 !important; }
.ptcgl-retreat-corner[data-type="fire"] { background: #f08030 !important; }
.ptcgl-retreat-corner[data-type="grass"] { background: #78c850 !important; }
.ptcgl-retreat-corner[data-type="lightning"] { background: #f8d030 !important; }
.ptcgl-retreat-corner[data-type="psychic"] { background: #f85888 !important; }
.ptcgl-retreat-corner[data-type="fighting"] { background: #c03028 !important; }
.ptcgl-retreat-corner[data-type="darkness"] { background: #705848 !important; }
.ptcgl-retreat-corner[data-type="metal"] { background: #b8b8d0 !important; }
.ptcgl-retreat-corner[data-type="colorless"] { background: #c6c6a7 !important; }
.ptcgl-retreat-corner[data-type="dragon"] { background: #7038f8 !important; }

.ptcgl-retreat-corner[data-type] .ptcgl-retreat-label,
.ptcgl-retreat-corner[data-type] .ptcgl-retreat-icon {
  color: #ffffff !important;
}

.ptcgl-retreat-label {
  font-size: 10px;
  font-weight: 700;
  color: #000000;
  text-transform: lowercase;
  letter-spacing: 0.3px;
  line-height: 1;
}

.ptcgl-energy-pips {
  position: absolute;
  bottom: 6px;
  left: 6px;
  right: 6px;
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  max-height: 50px;
  z-index: 5;
  pointer-events: none;
}

.ptcgl-energy-pip {
  width: 20px;
  height: 20px;
  background-size: cover;
  background-position: center;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, 0.8);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  flex-shrink: 0;
}

.ptcgl-weakness-corner {
  position: absolute;
  bottom: 35px;
  left: 6px;
  background: rgba(255, 255, 255, 0.98);
  padding: 4px 6px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 4px;
  z-index: 10;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ptcgl-weakness-label {
  font-size: 9px;
  font-weight: 700;
  color: #000000 !important;
  text-transform: lowercase;
  letter-spacing: 0.3px;
  line-height: 1;
}

.ptcgl-weakness-value {
  font-size: 13px;
  font-weight: 900;
  color: #000000 !important;
  line-height: 1;
}

.ptcgl-weakness-icon {
  width: 16px;
  height: 16px;
  background-size: cover;
  border-radius: 50%;
}

.type-grass { color: #22c55e !important; }
.type-fire { color: #ef4444 !important; }
.type-water { color: #3b82f6 !important; }
.type-lightning { color: #eab308 !important; }
.type-psychic { color: #a855f7 !important; }
.type-fighting { color: #f97316 !important; }
.type-darkness { color: #64748b !important; }
.type-metal { color: #94a3b8 !important; }
.type-dragon { color: #8b5cf6 !important; }
.type-fairy { color: #ec4899 !important; }
.type-colorless { color: #9ca3af !important; }

.card-slot.menu-open {
  opacity: 0 !important;
  pointer-events: none !important;
}

.ability-option {
  padding: 12px 16px;
  margin: 8px 0;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  color: white;
  font-weight: 500;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
  border: 2px solid transparent;
}

.ability-option:not(.passive-ability):hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.3);
  border-color: rgba(255,255,255,0.3);
}

.ability-option.passive-ability {
  cursor: not-allowed;
  opacity: 0.75;
  border: 2px solid rgba(255,255,255,0.2);
  filter: saturate(0.7);
}

.ability-option.passive-ability:hover {
  transform: none;
  box-shadow: none;
}

.passive-label {
  display: inline-block;
  padding: 3px 8px;
  background: rgba(0, 0, 0, 0.4);
  border-radius: 4px;
  font-size: 10px;
  font-weight: bold;
  color: white;
  margin-left: 8px;
  letter-spacing: 0.5px;
  vertical-align: middle;
}

.ability-grass {
  background: linear-gradient(135deg, #78C850 0%, #5CA935 100%);
}

.ability-fire {
  background: linear-gradient(135deg, #F08030 0%, #DD6610 100%);
}

.ability-water {
  background: linear-gradient(135deg, #6890F0 0%, #386CEB 100%);
}

.ability-lightning,
.ability-electric {
  background: linear-gradient(135deg, #F8D030 0%, #F0C108 100%);
  color: #333; 
  text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
}

.ability-psychic {
  background: linear-gradient(135deg, #F85888 0%, #F61C5D 100%);
}

.ability-fighting {
  background: linear-gradient(135deg, #C03028 0%, #9D2721 100%);
}

.ability-darkness,
.ability-dark {
  background: linear-gradient(135deg, #705848 0%, #513F34 100%);
}

.ability-metal,
.ability-steel {
  background: linear-gradient(135deg, #B8B8D0 0%, #9999B3 100%);
}

.ability-dragon {
  background: linear-gradient(135deg, #d3ba30 0%, #b89e20 100%);
  color: #2d2d2d; 
  text-shadow: 1px 1px 2px rgba(255,255,255,0.2);
}

.ability-fairy {
  background: linear-gradient(135deg, #EE99AC 0%, #E67199 100%);
}

.ability-colorless,
.ability-normal {
  background: linear-gradient(135deg, #A8A878 0%, #8A8A59 100%);
}

.move-dragon {
  background: linear-gradient(135deg, #d3ba30 0%, #b89e20 100%);
  color: #2d2d2d;
  text-shadow: 1px 1px 2px rgba(255,255,255,0.2);
}

.move-lightning,
.move-electric {
  background: linear-gradient(135deg, #F8D030 0%, #F0C108 100%);
  color: #333;
  text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
}

.ability-option strong {
  font-size: 16px;
  display: block;
  margin-bottom: 4px;
}

.ability-option small {
  font-size: 12px;
  opacity: 0.9;
  line-height: 1.4;
}

@media (max-width: 768px) {
  body {
    overflow-y: auto;
    overflow-x: hidden;
    height: auto;
    min-height: 100vh;
  }
  
  h1 {
    font-size: 0.85rem;
    padding: 0.25rem 0;
  }
  
  .main-layout {
    height: auto;
    min-height: calc(100vh - 40px);
    padding: 4px 0;
  }
  
  .battlefield {
    transform: scale(0.98);
    max-width: 100% !important;
    padding: 0 2px;
    height: auto;
    min-height: 95%;
  }
  
  .player-area {
    padding: 3px 0;
    margin: 2px 0;
  }
  
  .hand, .bench, .active {
    gap: 6px;
  }
  
  .card-slot {
    min-width: var(--card-w);
    min-height: var(--card-h);
  }
  
  .hp-overlay {
    font-size: 11px !important;
    padding: 3px 6px !important;
  }
  
  .hp-badge {
    font-size: 11px !important;
    padding: 2px 5px !important;
    top: 3px !important;
    right: 3px !important;
  }
  
  .energy-pips {
    height: 16px !important;
    gap: 2px !important;
    display: flex !important;
  }
  
  .energy-pip {
    width: 16px !important;
    height: 16px !important;
    min-width: 16px !important;
    min-height: 16px !important;
    display: block !important;
    visibility: visible !important;
  }
  
  .status-icon {
    width: 18px;
    height: 18px;
    top: 3px;
    left: 3px;
  }
  
  .deck-bubble {
    width: 32px;
    height: 32px;
    font-size: 11px;
    min-width: 32px;
    min-height: 32px;
  }
  
  #p1Bubble {
    left: -30px;
  }
  
  #p2Bubble {
    right: -30px;
  }
  
  .points-indicator {
    gap: 4px;
  }
  
  .point-bubble {
    width: 11px;
    height: 11px;
  }
  
  .side-panel {
    top: 50% !important;
    right: 8px !important;
    transform: translateY(-50%) !important;
    margin-top: 0 !important;
    gap: 0.25rem !important;
  }
  
  .side-panel .turnbox {
    order: 1 !important;
  }
  
  .side-panel .energy-zone {
    order: 2 !important;
  }
  
  .side-panel #coin {
    order: 3 !important;
  }
  
  .side-panel #mainButton {
    order: 4 !important;
  }
  
  .side-panel #logToggleBtn,
  .side-panel #showLogBtn {
    order: 5 !important;
  }
  
  .side-panel h4 {
    display: none !important;
  }
  
  .turnbox, [class*="turn-box"] {
    position: static !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    margin-top: 0 !important;
    font-size: 9px !important;
    padding: 3px 6px !important;
    width: auto !important;
    min-width: 55px !important;
  }
  
  .energy-zone {
    position: static !important;
    bottom: auto !important;
    top: auto !important;
    transform: none !important;
    left: auto !important;
    right: auto !important;
    padding: 3px 5px !important;
    gap: 2px !important;
    border-radius: 6px !important;
    width: auto !important;
    max-width: 50px !important;
    margin-top: 0 !important;
    z-index: 10 !important;
  }
  
  .energy-zone .energy-container {
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    gap: 2px !important;
    position: relative !important;
    min-height: 22px !important;
  }
  
  .energy-zone .energy-container > .energy:not(.energy-next-turn) {
    display: block !important;
    width: 22px !important;
    height: 22px !important;
    min-width: 22px !important;
    min-height: 22px !important;
    background-size: cover !important;
    background-repeat: no-repeat !important;
    background-position: center !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn {
    display: block !important;
    width: 10px !important;
    height: 10px !important;
    min-width: 10px !important;
    min-height: 10px !important;
    position: absolute !important;
    bottom: -2px !important;
    right: -2px !important;
    border: 1px solid rgba(255, 255, 255, 1) !important;
    box-shadow: 0 0 0 0.5px rgba(40, 40, 50, 1), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
    z-index: 11 !important;
    background: transparent !important;
    background-image: none !important;
    border-radius: 50% !important;
    overflow: hidden !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn > img {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
    border-radius: 50% !important;
    display: block !important;
  }
  
  #coin, .coin {
    width: 32px !important;
    height: 32px !important;
  }
  
  .energy:not(.energy-next-turn) {
    width: 20px !important;
    height: 20px !important;
    min-width: 20px !important;
    min-height: 20px !important;
  }
  
  .energy.energy-next-turn {
    width: 10px !important;
    height: 10px !important;
    min-width: 10px !important;
    min-height: 10px !important;
  }
  
  #mainButton {
    position: static !important;
    padding: 4px 8px !important;
    font-size: 8px !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    border-radius: 16px !important;
    min-height: 22px !important;
    min-width: 55px !important;
    margin-top: 0 !important;
    width: auto !important;
  }
  
  #logToggleBtn, #showLogBtn {
    position: static !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    margin-top: 0 !important;
    padding: 3px 6px !important;
    font-size: 8px !important;
    min-height: 20px !important;
    min-width: 50px !important;
    width: auto !important;
  }
  
  .points-indicator {
    right: 2px !important;
    left: auto !important;
  }
  
  #p1Points {
    right: 2px !important;
    transform: translateX(0) !important;
  }
  
  #p2Points {
    left: 2px !important;
    transform: translateX(0) !important;
  }
  
  .battlefield {
    margin-left: 0 !important;
    padding-left: 4px !important;
  }
  
  .popup {
    padding: 10px 16px !important;
    font-size: 12px !important;
    border-radius: 30px !important;
  }
  
  .discard-btn {
    padding: 6px 12px !important;
    font-size: 11px !important;
    border-radius: 8px !important;
    min-height: 32px;
  }
  
  .ability-option {
    padding: 10px 12px;
  }
  
  .ability-option strong {
    font-size: 14px;
  }
  
  .ability-option small {
    font-size: 11px;
  }
  
  .passive-label {
    font-size: 9px;
    padding: 2px 6px;
  }
  
  .zoom-backdrop {
    padding: 10px !important;
  }
  
  .zoom-content {
    max-width: 90vw !important;
    max-height: 85vh !important;
  }
  
  .attack-menu {
    max-width: 90vw !important;
    max-height: 80vh !important;
    font-size: 13px !important;
  }
  
  .attack-item {
    padding: 10px !important;
    font-size: 13px !important;
  }
  
  .tool-thumb {
    width: 22px !important;
    height: 22px !important;
  }
  
  .slot-label {
    font-size: 9px;
    padding: 2px 6px;
    width: 55px;
  }
}

@media (max-width: 480px) {
  body {
    overflow-y: auto;
  }
  
  h1 {
    font-size: 0.75rem;
    padding: 0.2rem 0;
  }
  
  .battlefield {
    transform: scale(0.96);
    max-width: 100% !important;
    padding: 0 2px;
  }
  
  .hand, .bench, .active {
    gap: 5px;
  }
  
  .hp-overlay {
    font-size: 10px !important;
    padding: 2px 5px !important;
  }
  
  .hp-badge {
    font-size: 10px !important;
    padding: 2px 4px !important;
  }
  
  .energy-pips {
    height: 14px !important;
    gap: 2px !important;
    display: flex !important;
  }
  
  .energy-pip {
    width: 14px !important;
    height: 14px !important;
    min-width: 14px !important;
    min-height: 14px !important;
    display: block !important;
    visibility: visible !important;
  }
  
  .status-icon {
    width: 17px;
    height: 17px;
  }
  
  .deck-bubble {
    width: 30px;
    height: 30px;
    font-size: 10px;
    min-width: 30px;
    min-height: 30px;
  }
  
  #p1Bubble {
    left: -28px;
  }
  
  #p2Bubble {
    right: -28px;
  }
  
  .point-bubble {
    width: 10px;
    height: 10px;
  }
  
  .energy-zone {
    bottom: auto !important;
    top: 50% !important;
    transform: translate(-50%, -50%) !important;
    left: 50% !important;
    right: auto !important;
    padding: 2px 4px !important;
    gap: 2px !important;
    width: auto !important;
    max-width: 48px !important;
    margin-top: 0 !important;
  }
  
  .energy:not(.energy-next-turn) {
    width: 18px !important;
    height: 18px !important;
    min-width: 18px !important;
    min-height: 18px !important;
  }
  
  .energy.energy-next-turn {
    width: 8px !important;
    height: 8px !important;
    min-width: 8px !important;
    min-height: 8px !important;
  }
  
  .energy-zone .energy-container > .energy:not(.energy-next-turn) {
    width: 20px !important;
    height: 20px !important;
    min-width: 20px !important;
    min-height: 20px !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn {
    width: 8px !important;
    height: 8px !important;
    min-width: 8px !important;
    min-height: 8px !important;
    position: absolute !important;
    bottom: -1px !important;
    right: -1px !important;
    border: 1px solid rgba(255, 255, 255, 1) !important;
    box-shadow: 0 0 0 0.5px rgba(40, 40, 50, 1), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
    z-index: 11 !important;
    background: transparent !important;
    background-image: none !important;
    border-radius: 50% !important;
    overflow: hidden !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn > img {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
    border-radius: 50% !important;
    display: block !important;
  }
  
  .side-panel {
    top: 50% !important;
    right: 6px !important;
    transform: translateY(-50%) !important;
    margin-top: 0 !important;
    gap: 0.2rem !important;
  }
  
  .side-panel .turnbox {
    order: 1 !important;
  }
  
  .side-panel .energy-zone {
    order: 2 !important;
  }
  
  .side-panel #coin {
    order: 3 !important;
  }
  
  .side-panel #mainButton {
    order: 4 !important;
  }
  
  .side-panel #logToggleBtn,
  .side-panel #showLogBtn {
    order: 5 !important;
  }
  
  .side-panel h4 {
    display: none !important;
  }
  
  .turnbox, [class*="turn-box"] {
    position: static !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    margin-top: 0 !important;
    font-size: 8px !important;
    padding: 2px 5px !important;
    width: auto !important;
    min-width: 50px !important;
  }
  
  .energy-zone {
    position: static !important;
    bottom: auto !important;
    top: auto !important;
    transform: none !important;
    left: auto !important;
    right: auto !important;
    padding: 2px 4px !important;
    gap: 2px !important;
    width: auto !important;
    max-width: 48px !important;
    margin-top: 0 !important;
    z-index: 10 !important;
  }
  
  .energy-zone .energy-container {
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    gap: 2px !important;
    position: relative !important;
    min-height: 20px !important;
  }
  
  .energy-zone .energy-container > .energy:not(.energy-next-turn) {
    display: block !important;
    width: 20px !important;
    height: 20px !important;
    min-width: 20px !important;
    min-height: 20px !important;
    background-size: cover !important;
    background-repeat: no-repeat !important;
    background-position: center !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn {
    display: block !important;
    width: 8px !important;
    height: 8px !important;
    min-width: 8px !important;
    min-height: 8px !important;
    position: absolute !important;
    bottom: -1px !important;
    right: -1px !important;
    border: 1px solid rgba(255, 255, 255, 1) !important;
    box-shadow: 0 0 0 0.5px rgba(40, 40, 50, 1), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
    z-index: 11 !important;
    background: transparent !important;
    background-image: none !important;
    border-radius: 50% !important;
    overflow: hidden !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn > img {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
    border-radius: 50% !important;
    display: block !important;
  }
  
  #coin, .coin {
    width: 28px !important;
    height: 28px !important;
  }
  
  #mainButton {
    position: static !important;
    padding: 3px 6px !important;
    font-size: 7px !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    border-radius: 14px !important;
    min-height: 20px !important;
    min-width: 50px !important;
    margin-top: 0 !important;
    width: auto !important;
  }
  
  #logToggleBtn, #showLogBtn {
    position: static !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    margin-top: 0 !important;
    padding: 2px 5px !important;
    font-size: 7px !important;
    min-height: 18px !important;
    min-width: 45px !important;
    width: auto !important;
  }
  
  .points-indicator {
    right: 2px !important;
    left: auto !important;
  }
  
  #p1Points {
    right: 2px !important;
    transform: translateX(0) !important;
  }
  
  #p2Points {
    left: 2px !important;
    transform: translateX(0) !important;
  }
  
  .battlefield {
    margin-left: 0 !important;
    padding-left: 4px !important;
  }
  
  #mainButton {
    position: static !important;
    padding: 3px 6px !important;
    font-size: 7px !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    border-radius: 14px !important;
    min-height: 20px !important;
    min-width: 50px !important;
    margin-top: 0 !important;
    width: auto !important;
  }
  
  #logToggleBtn, #showLogBtn {
    position: static !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    margin-top: 0 !important;
    padding: 2px 5px !important;
    font-size: 7px !important;
    min-height: 18px !important;
    min-width: 45px !important;
    width: auto !important;
  }
  
  .points-indicator {
    right: 2px !important;
    left: auto !important;
  }
  
  #p1Points {
    right: 2px !important;
    transform: translateX(0) !important;
  }
  
  #p2Points {
    left: 2px !important;
    transform: translateX(0) !important;
  }
  
  .battlefield {
    margin-left: 0 !important;
    padding-left: 4px !important;
  }
  
  #mainButton {
    padding: 4px 8px !important;
    font-size: 8px !important;
    left: 50% !important;
    right: auto !important;
    top: 50% !important;
    transform: translate(-50%, -50%) !important;
    bottom: auto !important;
    border-radius: 16px !important;
    min-height: 24px;
    min-width: 60px;
    margin-top: -60px;
  }
  
  #logToggleBtn, #showLogBtn {
    left: 50% !important;
    right: auto !important;
    top: 50% !important;
    transform: translate(-50%, -50%) !important;
    bottom: auto !important;
    margin-top: 65px;
    padding: 2px 5px !important;
    font-size: 7px !important;
    min-height: 20px;
    min-width: 50px;
  }
  
  .popup {
    padding: 8px 14px !important;
    font-size: 11px !important;
  }
  
  .discard-btn {
    padding: 5px 10px !important;
    font-size: 10px !important;
    min-height: 28px;
  }
  
  .zoom-content {
    max-width: 95vw !important;
    max-height: 90vh !important;
  }
  
  .attack-menu {
    max-width: 95vw !important;
    max-height: 85vh !important;
    font-size: 12px !important;
  }
  
  .attack-item {
    padding: 8px !important;
    font-size: 12px !important;
  }
  
  .ability-option {
    padding: 8px 10px;
  }
  
  .ability-option strong {
    font-size: 13px;
  }
  
  .ability-option small {
    font-size: 10px;
  }
  
  .slot-label {
    font-size: 8px;
    padding: 2px 5px;
    width: 50px;
  }
  
  .tool-thumb {
    width: 20px !important;
    height: 20px !important;
  }
}

</style>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="firebase-config.js"></script>

<script type="module">
import { ENERGY_ICONS, STATUS_TYPES, ABILITY_BADGE, STATUS_ICON_URLS } from './js/core/constants.js';
import { pkToPlayer, oppPk, parseInt10, normStr, parseCSV, csvIdFor, getAbilityCardKey, abilityRequiresActive } from './js/core/utils.js';
import { energyIconUrl, updateDeckStack, updateDeckBubbles, updateHandBubbles, updateDiscardBubbles, updatePointsUI, updateTurnBox, setHpOnImage, renderHand, renderAllHands, renderDiscard, renderEnergyZone } from './js/ui/render.js';
import { showPopup, closeAttackMenu, openToolModal, countPipsOn, getToolDataFromSlot, extractAbilities } from './js/ui/modals.js';
import { canAttack, isActiveBlockedFromAttacking, getFightingCoachBoost, getThickFatReduction, applyGuardedGrill, shouldBlockDamageFromEx, getCounterattackDamage, applyTypesToAttackMenu } from './js/game/attacks.js';
import { applyAbilityEffect, populateAbilityCache, hasArceusInPlay, getAbilityRow, getPassiveDamageReduction, checkPassiveAbility, hasCrystalBody, hasLevitateZeroRetreat, getPassiveAbility } from './js/game/abilities.js';
import { canUseSupporter, trainerColor, isGengarBlocking, setToolDataOnSlot, ensureToolThumb, removeToolThumb, attachToolToSlot, applyTrainerEffect, addTrainerToDiscard } from './js/game/trainers.js';
import { getCurrentUser, initAuth, onAuthStateChanged } from './js/auth/auth.js';
import { createRoom, joinRoomByCode, onRoomChange, getCurrentRoomId, leaveRoom, startGameFromRoom } from './js/online/lobby.js';
import { joinQueue, leaveQueue, onQueueUpdate, getIsInQueue } from './js/online/matchmaking.js';
import { initSync, onStateChange, onConnectionChange, getIsConnected, setupReconnectionHandler, updateGameStatePartial, isCurrentPlayer1, getCurrentMatchId } from './js/online/sync.js';
import { broadcastAction, ACTION_TYPES } from './js/online/actions.js';
import { executeActionWithValidation, executeTurnAction } from './js/online/validation.js';
import { isMyTurn, checkTurnBeforeAction, setupTurnListener } from './js/online/turn-manager.js';
import { handleError, handleValidationError, handleMatchNotFound, handleOpponentDisconnected } from './js/online/error-handler.js';
import { loadPocketSets, parseDecklist, fetchCardData } from './deckparser.js';

globalThis.ENERGY_ICONS = ENERGY_ICONS;
globalThis.STATUS_TYPES = STATUS_TYPES;
globalThis.ABILITY_BADGE = ABILITY_BADGE;
globalThis.STATUS_ICON_URLS = STATUS_ICON_URLS;
globalThis.pkToPlayer = pkToPlayer;
globalThis.oppPk = oppPk;
globalThis.parseInt10 = parseInt10;
globalThis.normStr = normStr;
globalThis.parseCSV = parseCSV;
globalThis.csvIdFor = csvIdFor;
globalThis.getAbilityCardKey = getAbilityCardKey;
globalThis.abilityRequiresActive = abilityRequiresActive;
globalThis.energyIconUrl = energyIconUrl;
globalThis.updateDeckStack = updateDeckStack;
globalThis.updateDeckBubbles = updateDeckBubbles;
globalThis.updateHandBubbles = updateHandBubbles;
globalThis.updateDiscardBubbles = updateDiscardBubbles;
globalThis.updatePointsUI = updatePointsUI;
globalThis.updateTurnBox = updateTurnBox;
globalThis.setHpOnImage = setHpOnImage;
globalThis.initAuth = initAuth;
globalThis.onAuthStateChanged = onAuthStateChanged;
globalThis.getCurrentUser = getCurrentUser;
globalThis.createRoom = createRoom;
globalThis.joinRoomByCode = joinRoomByCode;
globalThis.onRoomChange = onRoomChange;
globalThis.startGameFromRoom = startGameFromRoom;
globalThis.joinQueue = joinQueue;
globalThis.leaveQueue = leaveQueue;
globalThis.onQueueUpdate = onQueueUpdate;
globalThis.handleError = handleError;
globalThis.handleValidationError = handleValidationError;
globalThis.handleMatchNotFound = handleMatchNotFound;
globalThis.handleOpponentDisconnected = handleOpponentDisconnected;
globalThis.initSync = initSync;
globalThis.onStateChange = onStateChange;
globalThis.onConnectionChange = onConnectionChange;
globalThis.getIsConnected = getIsConnected;
globalThis.setupReconnectionHandler = setupReconnectionHandler;
globalThis.updateGameStatePartial = updateGameStatePartial;
globalThis.isCurrentPlayer1 = isCurrentPlayer1;
globalThis.getCurrentMatchId = getCurrentMatchId;
globalThis.executeActionWithValidation = executeActionWithValidation;
globalThis.executeTurnAction = executeTurnAction;
globalThis.isMyTurn = isMyTurn;
globalThis.checkTurnBeforeAction = checkTurnBeforeAction;
globalThis.setupTurnListener = setupTurnListener;
globalThis.broadcastAction = broadcastAction;
globalThis.ACTION_TYPES = ACTION_TYPES;
globalThis.loadPocketSets = loadPocketSets;
globalThis.parseDecklist = parseDecklist;
globalThis.fetchCardData = fetchCardData;
globalThis.renderHand = renderHand;
globalThis.renderAllHands = renderAllHands;
globalThis.renderDiscard = renderDiscard;
globalThis.renderEnergyZone = renderEnergyZone;
globalThis.showPopup = showPopup;
globalThis.closeAttackMenu = closeAttackMenu;
globalThis.openToolModal = openToolModal;
globalThis.countPipsOn = countPipsOn;
globalThis.getToolDataFromSlot = getToolDataFromSlot;
globalThis.extractAbilities = extractAbilities;
globalThis.canAttack = canAttack;
globalThis.isActiveBlockedFromAttacking = isActiveBlockedFromAttacking;
globalThis.getFightingCoachBoost = getFightingCoachBoost;
globalThis.getThickFatReduction = getThickFatReduction;
globalThis.applyGuardedGrill = applyGuardedGrill;
globalThis.shouldBlockDamageFromEx = shouldBlockDamageFromEx;
globalThis.getCounterattackDamage = getCounterattackDamage;
globalThis.applyTypesToAttackMenu = applyTypesToAttackMenu;
globalThis.applyAbilityEffect = applyAbilityEffect;
globalThis.populateAbilityCache = populateAbilityCache;
globalThis.hasArceusInPlay = hasArceusInPlay;
globalThis.getAbilityRow = getAbilityRow;
globalThis.getPassiveDamageReduction = getPassiveDamageReduction;
globalThis.checkPassiveAbility = checkPassiveAbility;
globalThis.getPassiveAbility = getPassiveAbility;
globalThis.hasCrystalBody = hasCrystalBody;
globalThis.hasLevitateZeroRetreat = hasLevitateZeroRetreat;
globalThis.canUseSupporter = canUseSupporter;
globalThis.trainerColor = trainerColor;
globalThis.isGengarBlocking = isGengarBlocking;
globalThis.setToolDataOnSlot = setToolDataOnSlot;
globalThis.ensureToolThumb = ensureToolThumb;
globalThis.removeToolThumb = removeToolThumb;
globalThis.attachToolToSlot = attachToolToSlot;
globalThis.applyTrainerEffect = applyTrainerEffect;
globalThis.addTrainerToDiscard = addTrainerToDiscard;
</script>
<script src="./effects.js"></script>

</head>
<body>
<h1>Pokmon TCG Pocket Battle - Online</h1>
<div id="connectionStatus" style="position: fixed; top: 60px; right: 10px; background: #2a2f36; padding: 0.5rem 1rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000; display: none;">
  <div style="display: flex; align-items: center; gap: 0.5rem; color: #e5e7eb;">
    <div id="connectionDot" style="width: 10px; height: 10px; border-radius: 50%; background: #f87171;"></div>
    <span id="connectionText">Disconnected</span>
  </div>
</div>
<div id="opponentInfo" style="position: fixed; top: 60px; left: 10px; background: #2a2f36; padding: 0.75rem 1rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000; display: none;">
  <div style="color: #e5e7eb; font-size: 0.9rem;">
    <div style="font-weight: 600; color: #facc15; margin-bottom: 0.25rem;">Opponent</div>
    <div id="opponentName">Waiting for opponent...</div>
    <div id="opponentStatus" style="font-size: 0.8rem; color: #9ca3af; margin-top: 0.25rem;"></div>
  </div>
</div>

<!-- Lobby Screen -->
<div id="lobbyScreen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center;">
  <div style="background: #2a2f36; padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; box-shadow: 0 8px 32px rgba(0,0,0,0.5);">
    <h2 style="margin-top: 0; text-align: center; color: #facc15;">Online Battle Lobby</h2>
    
    <div id="lobbyError" style="color: #f87171; margin: 0.5rem 0; min-height: 1.5rem; text-align: center;"></div>
    
    <div id="lobbyTabs" style="display: flex; gap: 0.5rem; margin-bottom: 1.5rem;">
      <button id="createRoomTab" style="flex: 1; padding: 0.75rem; background: #0074d9; border: none; color: white; border-radius: 8px; font-weight: 600; cursor: pointer;">Create Room</button>
      <button id="joinRoomTab" style="flex: 1; padding: 0.75rem; background: #3f444b; border: none; color: #e5e7eb; border-radius: 8px; font-weight: 600; cursor: pointer;">Join Room</button>
      <button id="quickMatchTab" style="flex: 1; padding: 0.75rem; background: #3f444b; border: none; color: #e5e7eb; border-radius: 8px; font-weight: 600; cursor: pointer;">Quick Match</button>
    </div>
    
    <!-- Create Room Panel -->
    <div id="createRoomPanel" style="display: block;">
      <div style="margin-bottom: 1rem;">
        <label style="color: #e5e7eb; margin-bottom: 0.5rem; display: block;">Your Deck</label>
        <textarea id="createRoomDeckInput" placeholder="Paste your decklist here...&#10;Example:&#10;2 Eevee B1 184&#10;2 Jolteon ex B1 81&#10;Energy: Lightning" style="width: 100%; min-height: 120px; padding: 0.75rem; background: #1e2227; border: 1px solid #3f444b; border-radius: 8px; color: #e5e7eb; font-family: monospace; font-size: 0.9rem; resize: vertical;"></textarea>
        <div style="margin-top: 0.5rem;">
          <label style="color: #e5e7eb; margin-bottom: 0.5rem; display: block; font-size: 0.9rem;">Energy Types (max 3)</label>
          <div id="createRoomEnergyGrid" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
        </div>
        <div id="createRoomDeckStatus" style="color: #9ca3af; font-size: 0.85rem; margin-top: 0.5rem; min-height: 1.2rem;"></div>
      </div>
      <div style="text-align: center; margin-bottom: 1rem;">
        <button id="createRoomBtn" style="padding: 0.75rem 2rem; background: linear-gradient(135deg, #e3350d, #0074d9); border: none; color: white; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 1rem;">Create Room</button>
      </div>
      <div id="roomCreatedInfo" style="display: none; text-align: center; padding: 1rem; background: #1e2227; border-radius: 8px; margin-top: 1rem;">
        <div style="color: #e5e7eb; margin-bottom: 0.5rem;">Room Code:</div>
        <div id="roomCodeDisplay" style="font-size: 2rem; font-weight: 700; color: #facc15; letter-spacing: 0.2rem; margin-bottom: 0.5rem;"></div>
        <div style="color: #9ca3af; font-size: 0.9rem;">Share this code with your opponent</div>
        <div id="roomStatus" style="color: #9ca3af; font-size: 0.85rem; margin-top: 0.5rem;">Waiting for opponent...</div>
      </div>
    </div>
    
    <!-- Join Room Panel -->
    <div id="joinRoomPanel" style="display: none;">
      <div style="margin-bottom: 1rem;">
        <label style="color: #e5e7eb; margin-bottom: 0.5rem; display: block;">Room Code</label>
        <input type="text" id="roomCodeInput" maxlength="6" style="width: 100%; padding: 0.75rem; background: #1e2227; border: 1px solid #3f444b; border-radius: 8px; color: #e5e7eb; font-size: 1.2rem; text-align: center; letter-spacing: 0.2rem; text-transform: uppercase;" placeholder="ABC123">
      </div>
      <div style="margin-bottom: 1rem;">
        <label style="color: #e5e7eb; margin-bottom: 0.5rem; display: block;">Your Deck</label>
        <textarea id="joinRoomDeckInput" placeholder="Paste your decklist here...&#10;Example:&#10;2 Eevee B1 184&#10;2 Jolteon ex B1 81&#10;Energy: Lightning" style="width: 100%; min-height: 120px; padding: 0.75rem; background: #1e2227; border: 1px solid #3f444b; border-radius: 8px; color: #e5e7eb; font-family: monospace; font-size: 0.9rem; resize: vertical;"></textarea>
        <div style="margin-top: 0.5rem;">
          <label style="color: #e5e7eb; margin-bottom: 0.5rem; display: block; font-size: 0.9rem;">Energy Types (max 3)</label>
          <div id="joinRoomEnergyGrid" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
        </div>
        <div id="joinRoomDeckStatus" style="color: #9ca3af; font-size: 0.85rem; margin-top: 0.5rem; min-height: 1.2rem;"></div>
      </div>
      <div style="text-align: center;">
        <button id="joinRoomBtn" style="padding: 0.75rem 2rem; background: linear-gradient(135deg, #e3350d, #0074d9); border: none; color: white; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 1rem;">Join Room</button>
      </div>
    </div>
    
    <!-- Quick Match Panel -->
    <div id="quickMatchPanel" style="display: none;">
      <div style="margin-bottom: 1rem;">
        <label style="color: #e5e7eb; margin-bottom: 0.5rem; display: block;">Your Deck</label>
        <textarea id="quickMatchDeckInput" placeholder="Paste your decklist here...&#10;Example:&#10;2 Eevee B1 184&#10;2 Jolteon ex B1 81&#10;Energy: Lightning" style="width: 100%; min-height: 120px; padding: 0.75rem; background: #1e2227; border: 1px solid #3f444b; border-radius: 8px; color: #e5e7eb; font-family: monospace; font-size: 0.9rem; resize: vertical;"></textarea>
        <div style="margin-top: 0.5rem;">
          <label style="color: #e5e7eb; margin-bottom: 0.5rem; display: block; font-size: 0.9rem;">Energy Types (max 3)</label>
          <div id="quickMatchEnergyGrid" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
        </div>
        <div id="quickMatchDeckStatus" style="color: #9ca3af; font-size: 0.85rem; margin-top: 0.5rem; min-height: 1.2rem;"></div>
      </div>
      <div style="text-align: center;">
      <div id="quickMatchStatus" style="color: #e5e7eb; margin-bottom: 1rem;">Click to find an opponent</div>
      <button id="quickMatchBtn" style="padding: 0.75rem 2rem; background: linear-gradient(135deg, #e3350d, #0074d9); border: none; color: white; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 1rem;">Find Match</button>
      <button id="cancelQuickMatchBtn" style="display: none; padding: 0.75rem 2rem; background: #3f444b; border: none; color: #e5e7eb; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 1rem; margin-top: 0.5rem;">Cancel</button>
      </div>
    </div>
    
    <div style="text-align: center; margin-top: 1.5rem;">
      <button id="backToMenuBtn" style="padding: 0.5rem 1rem; background: transparent; border: 1px solid #3f444b; color: #e5e7eb; border-radius: 6px; cursor: pointer;">Back to Menu</button>
    </div>
  </div>
</div>
<div id="popup"></div>
<div class="main-layout">
  <div class="battlefield">
    <div class="player-area" id="player2">
      <div id="p2Bubble" class="deck-bubble">0</div>
      <div id="p2DeckStack" class="deck-stack"></div>
      <div id="p2HandBubble" class="hand-bubble">0</div>
      <div id="p2DiscardBubble" class="discard-bubble">0</div>
      <div class="points-indicator" id="p2Points">
        <div class="point-bubble" data-i="1"></div>
        <div class="point-bubble" data-i="2"></div>
        <div class="point-bubble" data-i="3"></div>
      </div>
      <div class="hand" id="p2Hand"></div>
      <div class="bench" id="p2Bench">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="active" id="p2Active">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <button class="discard-btn right" id="p2DiscardBtn">View Discard</button>
    </div>

    <div class="player-area" id="player1">
      <div id="p1Bubble" class="deck-bubble">0</div>
      <div id="p1DeckStack" class="deck-stack"></div>
      <div id="p1HandBubble" class="hand-bubble">0</div>
      <div id="p1DiscardBubble" class="discard-bubble">0</div>
      <div class="points-indicator" id="p1Points">
        <div class="point-bubble" data-i="1"></div>
        <div class="point-bubble" data-i="2"></div>
        <div class="point-bubble" data-i="3"></div>
      </div>
      <div class="active" id="p1Active">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="bench" id="p1Bench">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="hand" id="p1Hand"></div>
      <button class="discard-btn" id="p1DiscardBtn">View Discard</button>
    </div>
  </div>

  <div class="side-panel">
    <div class="coin" id="coin">
      <img class="front" crossorigin="anonymous" src="imgs/coin_front.png" alt="Coin front">
      <img class="back" crossorigin="anonymous" src="imgs/Coin_Back_TM.png" alt="Coin back">
    </div>
    <div id="coinResult"></div>
    <button id="mainButton">Flip Coin</button>
    <div class="turnbox">
      <div>Turn</div>
      <div id="turnNum" class="big">1</div>
    </div>
    <h4 style="margin:0 .25rem;">Energy Zone</h4>
    <div class="energy-zone" id="energyZone"></div>
    <button id="logToggleBtn">Show Log</button>
  </div>
</div>

<div id="zoomBackdrop" class="zoom-backdrop">
  <div class="zoom-modal">
    <div style="position: relative;">
      <img id="zoomImg" src="" alt="Card zoom">
      <img id="zoomToolImg" src="" alt="Tool" style="display: none; position: absolute; top: -20px; right: -20px; width: 80px; height: 112px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 2px solid #6e4e9c; z-index: 10;">
    </div>
    <div class="zoom-panel">
<div class="zoom-header">
  <div id="zoomTitle" class="zoom-title"></div>
  <div style="display:flex;align-items:center;gap:8px">
    <div id="zoomStatus" class="zoom-status" style="display:none;"></div>
    <div id="zoomHp" class="zoom-hp"></div>
    <div id="zoomType" class="zoom-type-pill"></div>
  </div>
</div>

      <div class="hpbar-container"><div id="zoomHpBar" class="hpbar-fill"></div></div>
      <div class="zoom-section" id="zoomAttached">
        <div class="row">
          <div><strong>Attached Energy</strong></div>
          <div id="zoomEnergyCount" class="chip">x0</div>
        </div>
        <div id="zoomEnergyIcons" class="icon-row"></div>
        <div class="row" style="margin-top:10px">
          <div><strong>Attached Tools</strong></div>
          <div id="zoomTools" class="icon-row"></div>
        </div>
      </div>
      <div class="zoom-section" id="zoomAbilities" style="display:none"></div>
      <div class="zoom-section">
        <div><strong>Attacks</strong></div>
        <div id="zoomAttacks"></div>
      </div>
      <div class="zoom-section">
        <div class="row">
          <div><strong>Weakness</strong></div>
          <div id="zoomWeakness" class="icon-row"></div>
        </div>
        <div class="row" id="zoomRetreatRow">
          <div><strong>Retreat</strong></div>
          <div id="zoomRetreat" class="icon-row"></div>
        </div>
        <div style="text-align:right;color:#9ca3af;font-size:12px;margin-top:6px">Right-click anywhere or press Esc.</div>
      </div>
    </div>
  </div>
</div>

<div id="toolBackdrop">
  <div id="toolCard">
    <img id="toolImg" src="" alt="Tool Card">
    <div id="toolPanel">
      <h3 id="toolTitle">Tool</h3>
      <div id="toolMeta" class="chip" style="margin-bottom:8px"></div>
      <div class="thin" style="height:1px;background:#3b3f46;margin:8px 0"></div>
      <div id="toolText" style="font-size:13px;color:#cbd5e1;line-height:1.25"></div>
      <div style="margin-top:12px;font-size:12px;color:#9ca3af">Click outside to close.</div>
    </div>
  </div>
</div>

<div id="handBackdrop" class="zoom-backdrop">
  <div class="zoom-modal">
    <div style="position: relative;">
      <img id="handImg" src="" alt="Card image">
      <img id="handToolImg" src="" alt="Tool" style="display: none; position: absolute; top: -20px; right: -20px; width: 80px; height: 112px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 2px solid #6e4e9c; z-index: 10;">
    </div>
    <div class="zoom-panel" id="handPanel">
      <div id="handTitle" class="zoom-title"></div>
      <div id="handType" class="chip" style="margin-top:6px;"></div>
      <div id="handEffect" style="font-size:13px;color:#cbd5e1;margin-top:10px;line-height:1.4"></div>
      <div style="text-align:right;color:#9ca3af;font-size:12px;margin-top:12px">
        Right-click anywhere or press Esc to close.
      </div>
    </div>
  </div>
</div>

<div id="victoryOverlay">
  <div id="victoryCard">
    <h2 id="victoryTitle">Player Wins!</h2>
    <p id="victoryDesc">Game over</p>
    <div style="display:flex;justify-content:center;gap:12px;margin:10px 0 18px 0">
      <div class="chip">P1 Points: <span id="p1Pts">0</span></div>
      <div class="chip">P2 Points: <span id="p2Pts">0</span></div>
    </div>
    <div id="victoryBtns">
      <button id="playAgainBtn">Play again</button>
      <button id="chooseDecksBtn">Choose new decks</button>
      <button id="victoryShowLogBtn">Show Match Log</button>
    </div>
  </div>
</div>

<div id="choiceDialogBackdrop" class="zoom-backdrop">
  <div id="choiceDialogCard" style="width:min(500px,90vw);background:#101418;border:1px solid #334155;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.6);padding:24px;color:#e5e7eb;text-align:center;">
    <h2 id="choiceDialogTitle" style="margin:0 0 12px 0;font-size:20px;font-weight:700;">Choose an Option</h2>
    <p id="choiceDialogDesc" style="margin:0 0 20px 0;color:#cbd5e1;font-size:14px;"></p>
    <div id="choiceDialogButtons" style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
      
    </div>
  </div>
</div>

<div id="hikerReorderBackdrop" class="zoom-backdrop">
  <div id="hikerReorderCard" style="width:min(90vw,1200px);max-width:1200px;background:#101418;border:1px solid #334155;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.6);padding:24px;color:#e5e7eb;">
    <h2 id="hikerReorderTitle" style="margin:0 0 12px 0;font-size:20px;font-weight:700;text-align:center;">Reorder Top Cards</h2>
    <p id="hikerReorderDesc" style="margin:0 0 20px 0;color:#cbd5e1;font-size:14px;text-align:center;">Drag cards to reorder them. The leftmost card will be on top of your deck.</p>
    <div id="hikerReorderCards" style="position:relative;display:flex;gap:12px;justify-content:center;flex-wrap:wrap;min-height:200px;margin-bottom:20px;">
      
    </div>
    <div style="text-align:center;">
      <button id="hikerReorderDone" style="background:#6e4e9c;color:#fff;border:none;padding:10px 24px;border-radius:8px;cursor:pointer;font-size:16px;font-weight:600;">Done</button>
    </div>
  </div>
</div>

<div class="discard-drawer right" id="p1DiscardDrawer"></div>
<div class="discard-drawer right" id="p2DiscardDrawer"></div>

<div id="logPanel">
  <div id="logPanelHeader">Battle Log</div>
  <button id="closeLogBtn" style="margin:8px 14px 10px;width:calc(100% - 28px);background:#e5e7eb;border:1px solid #c2c4c6;color:#111;padding:6px;border-radius:6px;cursor:pointer;">
    Close Log
  </button>
  <div id="logEntries"></div>
</div>

<div id="historyBackdrop">
  <div id="historyCard">
    <h2>Match History</h2>
    <div id="fullHistory"></div>
    <div style="text-align:center;margin-top:14px;">
      <button onclick="document.getElementById('historyBackdrop').classList.remove('show')">
        Close
      </button>
    </div>
  </div>
</div>

<script type="module">
  

  
globalThis.state = { temp: { p1: {}, p2: {} } };

if (!globalThis.__specialEffects) {
  globalThis.__specialEffects = { p1: {}, p2: {} };
}

function canRetreat(pk) {
  
  const img = getActiveImg(pk);
  if (img) {
    const status = (img.dataset.status || '').toLowerCase();
    if (status === 'asleep') {
      return false;
    }
    if (status === 'paralyzed') {
      return false;
    }
  }
  
  if (globalThis.__specialEffects?.[pk]?.retreatLock) {
    return false;
  }
  return true;
}



function applySpecialEffectsToDamage(defendingPk, baseDamage) {
  let damage = baseDamage;
  
  
  const defenderImg = getActiveImg(defendingPk);
  if (defenderImg?.dataset.preventAllNextTurn === 'true') {
    showPopup("All damage and effects prevented!");
    delete defenderImg.dataset.preventAllNextTurn; 
    return 0;
  }
  
  
  if (defenderImg?.dataset.preventDamageAndEffectsNextTurn === 'true') {
    showPopup("All damage and effects prevented!");
    delete defenderImg.dataset.preventDamageAndEffectsNextTurn; 
    return 0;
  }
  
  
  if (globalThis.__specialEffects?.[defendingPk]?.preventDamage) {
    showPopup("Attack prevented!");
    return 0;
  }
  
  
  if (defenderImg?.dataset.incomingDamageIncrease) {
    const increase = parseInt(defenderImg.dataset.incomingDamageIncrease, 10);
    damage += increase;
    showPopup(`Damage increased by ${increase}!`);
    delete defenderImg.dataset.incomingDamageIncrease; 
  }
  
  
  const reduction = globalThis.__specialEffects?.[defendingPk]?.damageReduction || 0;
  if (reduction > 0) {
    damage = Math.max(0, damage - reduction);
    if (damage > 0) {
      showPopup(`Damage reduced by ${reduction}!`);
    } else {
      showPopup(`All damage blocked!`);
    }
  }
  
  return damage;
}

function clearSpecialEffects(pk) {
  if (globalThis.__specialEffects?.[pk]) {
    const had = Object.keys(globalThis.__specialEffects[pk]).length > 0;
    if (had) {
    }
    globalThis.__specialEffects[pk] = {};
  }
}

function clearExpiredEffectsOnTurnStart(pk) {
  
  const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
  
  if (attackLock) {
  }
  
  clearSpecialEffects(pk);
  
  
  if (attackLock && globalThis.__specialEffects?.[pk]) {
    globalThis.__specialEffects[pk].attackLock = attackLock;
  } else if (attackLock) {
    
    if (!globalThis.__specialEffects) globalThis.__specialEffects = { p1: {}, p2: {} };
    if (!globalThis.__specialEffects[pk]) globalThis.__specialEffects[pk] = {};
    globalThis.__specialEffects[pk].attackLock = attackLock;
  }
  
  
  if (globalThis.__specialEffects?.[pk]?.attackLock) {
    const lock = globalThis.__specialEffects[pk].attackLock;
    const currentTurn = globalThis.turnNumber || 0;
    
    if (typeof lock === 'object' && lock.lockedOnTurn !== undefined) {
      
      if (currentTurn > lock.lockedOnTurn + 2) {
        delete globalThis.__specialEffects[pk].attackLock;
      }
    } else if (lock === true) {
      
      delete globalThis.__specialEffects[pk].attackLock;
    }
  }
  
  
  const allPokemon = [getActiveImg(pk), ...getBenchImgs(pk)].filter(Boolean);
  for (const img of allPokemon) {
    if (img.dataset.lockedAttack) {
      delete img.dataset.lockedAttack;
    }
  }
}

globalThis.canRetreat = canRetreat;
globalThis.canAttack = canAttack;
globalThis.applySpecialEffectsToDamage = applySpecialEffectsToDamage;
globalThis.clearSpecialEffects = clearSpecialEffects;
globalThis.clearExpiredEffectsOnTurnStart = clearExpiredEffectsOnTurnStart;

const popupEl = document.getElementById("popup");
globalThis.popupEl = popupEl;

let TRAINER_EFFECT_DATA=[];
fetch('trainer_effects.csv')
  .then(r=>r.text())
  .then(t=>{
    const parseFn = globalThis.parseCSV || window.parseCSV;
    if (!parseFn) {
      console.warn('parseCSV is not available yet, retrying...');
      // Retry after a short delay
      setTimeout(() => {
        const retryParseFn = globalThis.parseCSV || window.parseCSV;
        if (retryParseFn) {
          TRAINER_EFFECT_DATA = retryParseFn(t);
        } else {
          console.error('parseCSV is still not available after retry');
        }
      }, 100);
      return;
    }
    TRAINER_EFFECT_DATA = parseFn(t);
    
    globalThis.TRAINER_EFFECT_DATA = TRAINER_EFFECT_DATA;
    window.TRAINER_EFFECT_DATA = TRAINER_EFFECT_DATA;
  });



const TYPE_HEX={
  fire:'#f08030',water:'#6890f0',grass:'#78c850',lightning:'#f8d030',
  psychic:'#f85888',fighting:'#c03028',darkness:'#705848',
  metal:'#b8b8d0',dragon:'#d3ba30',colorless:'#c6c6a7'
};

const $=s=>document.querySelector(s);
const $$=s=>Array.from(document.querySelectorAll(s));

const popup=$('#popup'),
      energyZoneDiv=$('#energyZone'),
      coinEl=$('#coin'),
      coinResult=$('#coinResult'),
      mainButton=$('#mainButton'),
      turnNumEl=$('#turnNum'),
      turnPlayerEl=$('#turnPlayer');

const p1HandDiv=$('#p1Hand'),
      p2HandDiv=$('#p2Hand'),
      p1Active=$('#p1Active'),
      p2Active=$('#p2Active'),
      p1Bench=$('#p1Bench'),
      p2Bench=$('#p2Bench'),
      p1Bubble=$('#p1Bubble'),
      p2Bubble=$('#p2Bubble');

// Set hand divs globally for render functions (handle jQuery objects)
globalThis.p1HandDiv = p1HandDiv && p1HandDiv.jquery ? p1HandDiv[0] : (p1HandDiv || document.getElementById('p1Hand'));
globalThis.p2HandDiv = p2HandDiv && p2HandDiv.jquery ? p2HandDiv[0] : (p2HandDiv || document.getElementById('p2Hand'));

// Flag to prevent onStateChange from interfering during hand drawing
let isDrawingHands = false;

const zoomBackdrop=$('#zoomBackdrop'),
      zoomImg=$('#zoomImg'),
      zoomToolImg=$('#zoomToolImg'),
      zoomTitle=$('#zoomTitle'),
      zoomHp=$('#zoomHp'),
      zoomHpBar=$('#zoomHpBar'),
      zoomType=$('#zoomType'),
      zoomStatusIcon=$('#zoomStatusIcon'),
      zoomAttacks=$('#zoomAttacks'),
      zoomEnergyCount=$('#zoomEnergyCount'),
      zoomEnergyIcons=$('#zoomEnergyIcons'),
      zoomWeakness=$('#zoomWeakness'),
      zoomRetreat=$('#zoomRetreat'),
      zoomTools=$('#zoomTools'),
      zoomAbilities=$('#zoomAbilities');

const p1DiscardBtn=$('#p1DiscardBtn'),
      p2DiscardBtn=$('#p2DiscardBtn'),
      p1DiscardDrawer=$('#p1DiscardDrawer'),
      p2DiscardDrawer=$('#p2DiscardDrawer');

const victoryOverlay=$('#victoryOverlay'),
      victoryTitle=$('#victoryTitle'),
      victoryDesc=$('#victoryDesc'),
      p1PtsText=$('#p1Pts'),
      p2PtsText=$('#p2Pts'),
      playAgainBtn=$('#playAgainBtn'),
      chooseDecksBtn=$('#chooseDecksBtn');

const toolBackdrop=$('#toolBackdrop'),
      toolImg=$('#toolImg'),
      toolTitle=$('#toolTitle'),
      toolMeta=$('#toolMeta'),
      toolText=$('#toolText');

const handBackdrop=$('#handBackdrop'),
      handImg=$('#handImg'),
      handToolImg=$('#handToolImg'),
      handTitle=$('#handTitle'),
      handType=$('#handType'),
      handEffect=$('#handEffect');

const logPanel=$('#logPanel'),
      logEntriesDiv=$('#logEntries'),
      logToggleBtn=$('#logToggleBtn'),
      historyBackdrop=$('#historyBackdrop'),
      fullHistoryDiv=$('#fullHistory');

globalThis.turnNumber=1;
let currentPlayer=null,firstPlayer=null;
let lastStartTurnTurn = null; // Track last turn number for which startTurn was called
let lastStartTurnPlayer = null; // Track last player for which startTurn was called
let processedActions = new Set(); // Track processed action timestamps to avoid duplicates
let lastDrawTurn = null; // Track last turn number for which drawOne was called
let lastDrawPlayer = null; // Track last player for which drawOne was called

Object.defineProperty(globalThis, 'currentPlayer', {
  get: () => currentPlayer,
  set: (val) => { currentPlayer = val; }
});
let hasAttachedEnergyThisTurn=false,selectedEnergy=null,isSetupPhase=true,selectedEnergyElement=null,selectedToolElement=null;
globalThis.isSetupPhase = true;
globalThis.setSelectedEnergy = (val) => { selectedEnergy = val; };
let isEvoMode=false,evoMeta=null,evoOwner=null,evoHandCard=null;
let isPromotionPhase=false,openAttackMenu=null,gameOver=false,hasRetreatedThisTurn=false,isRetreatSelection=false,lastRetreatTime=0,abilityJustUsed=false,menuJustClosed=false;
globalThis.setMenuJustClosed = (val) => { menuJustClosed = val; };
const hasPlayedSupporterThisTurn={player1:false,player2:false};
let p1Points=0,p2Points=0,toolAttachPending=null,currentZoom={img:null,meta:null};

globalThis.getPoints = function(player) {
  if (player === 'player1' || player === 'p1') return p1Points;
  if (player === 'player2' || player === 'p2') return p2Points;
  return 0;
};
if (!window.usedAbilitiesThisTurn) {
  window.usedAbilitiesThisTurn = {
    p1: {},
    p2: {}
  };
}

let usedAbilitiesThisTurn = window.usedAbilitiesThisTurn;

function typeColorHex(t) {
  const key = (t || '').toLowerCase();
  switch (key) {
    case 'fire':      return '#f97316';
    case 'water':     return '#38bdf8';
    case 'grass':     return '#22c55e';
    case 'lightning': return '#facc15';
    case 'psychic':   return '#a855f7';
    case 'fighting':  return '#f97316';
    case 'metal':
    case 'steel':     return '#9ca3af';
    case 'darkness':  return '#4b5563';
    case 'dragon':    return '#22d3ee';
    case 'colorless': return '#e5e7eb';
    default:          return '#64748b';
  }
}

const playerState={
  player1:{deck:[],hand:[],energyTypes:JSON.parse(localStorage.getItem('player1Energy')||'[]'),currentTurnEnergy:null,nextTurnEnergy:null,discard:{cards:[],energyCounts:{}} },
  player2:{deck:[],hand:[],energyTypes:JSON.parse(localStorage.getItem('player2Energy')||'[]'),currentTurnEnergy:null,nextTurnEnergy:null,discard:{cards:[],energyCounts:{}} }
};

function selectRandomEnergy(energyTypes) {
  if (!energyTypes || energyTypes.length === 0) return null;
  if (energyTypes.length === 1) return energyTypes[0];
  
  return energyTypes[Math.floor(Math.random() * energyTypes.length)];
}

function initializePlayerEnergy(player) {
  const state = playerState[player];
  const energyTypes = state.energyTypes || [];
  
  if (energyTypes.length > 0) {
    
    state.currentTurnEnergy = selectRandomEnergy(energyTypes);
    
    
    state.nextTurnEnergy = selectRandomEnergy(energyTypes);
  }
}

initializePlayerEnergy('player1');
initializePlayerEnergy('player2');

function expandDeck(raw){
  const out=[];
  (raw||[]).forEach(c=>{
    if(!c||!c.name||!c.set||(c.number??c.num)==null)return;
    const n=Number(c.quantity)||1;
    for(let i=0;i<n;i++)out.push({...c,quantity:1});
  });
  return out;
}
// Online mode: decks will be loaded from match state, not localStorage
// playerState.player1.deck=expandDeck(JSON.parse(localStorage.getItem('player1Deck')||'[]'));
// playerState.player2.deck=expandDeck(JSON.parse(localStorage.getItem('player2Deck')||'[]'));

// Initialize deck stacks after globals are set
if (typeof updateDeckStack === 'function') {
  updateDeckStack('player1');
  updateDeckStack('player2');
} else if (globalThis.updateDeckStack) {
  globalThis.updateDeckStack('player1');
  globalThis.updateDeckStack('player2');
}

let fullHistoryLog=[];
let logCounter=1;

function highImgUrl(set,num){
  if(!set || num==null) return null;
  return `https://assets.tcgdex.net/en/tcgp/${set}/${String(num).padStart(3,'0')}/high.png`;
}

function logEvent({ player, text, cardSet = null, cardNum = null }) {
  globalThis.logEvent = logEvent;
  const id = logCounter++;
  const ts = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  const who =
    player === 'player1' ? 'Player 1' :
    player === 'player2' ? 'Player 2' : 'System';

  const cls =
    player === 'player1' ? 'p1' :
    player === 'player2' ? 'p2' : 'sys';
  
  const imgUrl = (cardSet && cardNum) ? highImgUrl(cardSet, cardNum) : null;
  
  const div = document.createElement('div');
  div.className = `log-entry ${cls}`;
  div.dataset.id = id;

  div.innerHTML = `
    <div class="entry-player ${cls}">${who}</div>
    <div class="entry-text">${text}</div>
    ${imgUrl ? `<img class="log-thumb" src="${imgUrl}" alt="card">` : '' }
  `;

  if (logEntriesDiv.firstChild) {
    logEntriesDiv.insertBefore(div, logEntriesDiv.firstChild);
  } else {
  logEntriesDiv.appendChild(div);
  }
  logEntriesDiv.scrollTop = 0;
  
  fullHistoryLog.push({ id, ts, player: who, text, cardSet, cardNum, imgUrl });
}

globalThis.logEvent = logEvent;

logEntriesDiv.addEventListener("click", async (e) => {
  const thumb = e.target.closest(".log-thumb");
  if (!thumb) return;
  
  const match = thumb.src.match(/tcgp\/([^\/]+)\/(\d{3})/i);
  if (!match) return;

  const set = match[1];
  const num = match[2];

  let meta;
  try {
    meta = await fetchCardMeta(set, num);
  } catch (err) {
    console.error("Failed to fetch meta", err);
    showPopup("Unable to load card details.");
    return;
  }

  const category = (meta.category || "").toLowerCase();
  
  const fakeImg = document.createElement("img");
  fakeImg.dataset.set = set;
  fakeImg.dataset.num = num;
  fakeImg.dataset.hp = meta.hp || "0";
  fakeImg.dataset.chp = meta.hp || "0";
  fakeImg.src = thumb.src;
  fakeImg.alt = meta.name;
  
  const fakeSlot = document.createElement("div");
  fakeSlot.className = "card-slot";
  fakeSlot.appendChild(fakeImg);
  
  const fakePips = document.createElement("div");
  fakePips.className = "energy-pips";
  fakeSlot.appendChild(fakePips);

  const fakeHP = document.createElement("div");
  fakeHP.className = "hp-overlay";
  fakeHP.textContent = `${meta.hp} / ${meta.hp}`;
  fakeSlot.appendChild(fakeHP);
  
  if (category === "pokemon") {
    zoomImg.src = thumb.src;
    zoomBackdrop.classList.add("show");
    
    const tempWrap = document.createElement("div");
    tempWrap.style.display = "none";
    tempWrap.appendChild(fakeSlot);
    document.body.appendChild(tempWrap);

    await buildZoomPanel(meta, fakeImg);
    
    zoomBackdrop.addEventListener("transitionend", () => {
      if (!zoomBackdrop.classList.contains("show")) {
        tempWrap.remove();
      }
    }, { once: true });

    return;

  }
  
  handImg.src = thumb.src;
  handBackdrop.classList.add("show");
  handTitle.textContent = meta.name || "Trainer Card";
  handType.textContent = meta.trainerType || "Trainer";
  handType.style.background = trainerColor(meta.trainerType || "trainer");
  handEffect.textContent = meta.effect || meta.description || "No effect listed.";
});

if(logToggleBtn){
  logToggleBtn.onclick = () => {
    logPanel.classList.toggle('show');
  };
}

const closeLogBtn = document.getElementById("closeLogBtn");

if (closeLogBtn) {
  closeLogBtn.onclick = () => {
    logPanel.classList.remove("show");
  };
}

let selectionCancelHandler = null;
function setupSelectionCancelHandler() {
  
  if (selectionCancelHandler) {
    document.removeEventListener('keydown', selectionCancelHandler);
  }
  
  
  selectionCancelHandler = (e) => {
    if (e.key === "Escape") {
      
      if (!logPanel.classList.contains("show")) {
        cancelSelection();
      } else {
        logPanel.classList.remove("show");
      }
    }
  };
  document.addEventListener('keydown', selectionCancelHandler);
}

function cancelSelection() {
  if (selectedEnergy || globalThis.selectedEnergy || toolAttachPending) {
    clearSelectionGlow();
    selectedEnergy = null;
    globalThis.selectedEnergy = null;
    toolAttachPending = null;
    showPopup('Selection cancelled.');
  }
}

function clearSelectionGlow() {
  if (selectedEnergyElement) {
    selectedEnergyElement.classList.remove('selected-glow');
    selectedEnergyElement = null;
  }
  if (selectedToolElement) {
    selectedToolElement.classList.remove('selected-glow');
    selectedToolElement = null;
  }
  
  if (selectionCancelHandler) {
    document.removeEventListener('keydown', selectionCancelHandler);
    selectionCancelHandler = null;
  }
}

document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    
    if (!selectedEnergy && !toolAttachPending) {
    logPanel.classList.remove("show");
    }
  }
});

if(historyBackdrop){
  historyBackdrop.addEventListener('click',e=>{
    if(e.target===historyBackdrop) historyBackdrop.classList.remove('show');
  });
}

function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}


async function animateCardDraw(owner, targetHand, card = null, cardIndex = null, totalCardsBeingDrawn = 1) {
  const stackId = owner === 'player1' ? 'p1DeckStack' : 'p2DeckStack';
  const deckStack = document.getElementById(stackId);
  const handDiv = owner === 'player1' ? p1HandDiv : p2HandDiv;
  
  if (!deckStack || !handDiv) return;
  
  const deckRect = deckStack.getBoundingClientRect();
  const handRect = targetHand.getBoundingClientRect();
  
  
  const currentHandSize = playerState[owner].hand.length;
  const targetIndex = cardIndex !== null ? cardIndex : currentHandSize;
  
  
  const existingHandCard = handDiv.querySelector('.card-img');
  let actualCardWidth = 69.27; 
  let actualCardHeight = 96.47; 
  
  if (existingHandCard) {
    
    const cardRect = existingHandCard.getBoundingClientRect();
    if (cardRect.width > 0 && cardRect.height > 0) {
      actualCardWidth = cardRect.width;
      actualCardHeight = cardRect.height;
    } else {
      
      const computedStyle = window.getComputedStyle(existingHandCard);
      const computedWidth = parseFloat(computedStyle.width);
      const computedHeight = parseFloat(computedStyle.height);
      if (computedWidth && computedHeight) {
        actualCardWidth = computedWidth;
        actualCardHeight = computedHeight;
      }
    }
  }
  
  
  const handCards = handDiv.querySelectorAll('.card-slot');
  const existingCardCount = handCards.length;
  
  
  const finalHandSize = currentHandSize + totalCardsBeingDrawn;
  
  
  let targetX, targetY;
  
  if (handCards.length > 0 && existingHandCard) {
    
    const firstCardRect = existingHandCard.getBoundingClientRect();
    const firstCardCenterX = firstCardRect.left + firstCardRect.width / 2;
    const firstCardCenterY = firstCardRect.top + firstCardRect.height / 2;
    
    
    const secondCard = handDiv.querySelectorAll('.card-img')[1];
    let cardSpacing = actualCardWidth + 8; 
    if (secondCard) {
      const secondCardRect = secondCard.getBoundingClientRect();
      const secondCardCenterX = secondCardRect.left + secondCardRect.width / 2;
      cardSpacing = secondCardCenterX - firstCardCenterX;
    }
    
    
    const indexOffset = targetIndex - (finalHandSize - 1) / 2;
    targetX = firstCardCenterX + (indexOffset * cardSpacing);
    targetY = firstCardCenterY;
  } else {
    
    const cardSlotWidth = 75; 
    const slotGap = 8; 
    const slotSpacing = cardSlotWidth + slotGap;
    
    const handCenterX = handRect.left + handRect.width / 2;
    const slotOffsetFromCenter = (targetIndex - (finalHandSize - 1) / 2) * slotSpacing;
    targetX = handCenterX + slotOffsetFromCenter;
    
    targetY = handRect.top + handRect.height / 2;
    if (handCards.length > 0) {
      const firstSlotRect = handCards[0].getBoundingClientRect();
      targetY = firstSlotRect.top + firstSlotRect.height / 2;
    }
  }
  
  
  let cardImageUrl = null;
  let imageLoaded = false;
  
  if (card) {
    
    
    if (card.imgUrl) {
      cardImageUrl = card.imgUrl;
    } else if (card.set && (card.number || card.num)) {
      
      try {
        const meta = await fetchCardMeta(card.set, card.number || card.num);
        if (meta && meta.image) {
          
          cardImageUrl = meta.image + "/high.png";
        } else {
        }
      } catch (e) {

      }
    } else {
    }
  } else {
  }
  
  
  if (cardImageUrl) {
    await new Promise((resolve) => {
      const img = new Image();
      let resolved = false;
      img.onload = () => {
        if (!resolved) {
          imageLoaded = true;
          resolved = true;
          resolve();
        }
      };
      img.onerror = () => {
        if (!resolved) {
          
          cardImageUrl = null;
          imageLoaded = false;
          resolved = true;
          resolve();
        }
      };
      img.src = cardImageUrl;
      
      if (img.complete && img.naturalWidth > 0) {
        imageLoaded = true;
        resolved = true;
        resolve();
      }
    });
  } else {
  }
  
  
  const animCard = document.createElement('div');
  animCard.setAttribute('data-animated-card', 'true');
  animCard.style.position = 'fixed';
  animCard.style.width = `${actualCardWidth}px`;
  animCard.style.height = `${actualCardHeight}px`;
  
  animCard.style.left = `${deckRect.left + deckRect.width / 2 - actualCardWidth / 2}px`;
  animCard.style.top = `${deckRect.top + deckRect.height / 2 - actualCardHeight / 2}px`;
  animCard.style.transform = 'perspective(700px) rotateX(0deg)'; 
  animCard.style.zIndex = '1000';
  animCard.style.pointerEvents = 'none';
  animCard.style.willChange = 'left, top, transform';
  document.body.appendChild(animCard);
  
  
  if (!cardImageUrl || !imageLoaded) {
    
    return Promise.resolve(null);
  }
  
  
  const cardFront = document.createElement('div');
  cardFront.style.position = 'absolute';
  cardFront.style.width = '100%';
  cardFront.style.height = '100%';
  cardFront.style.backgroundImage = `url('${cardImageUrl}')`;
  cardFront.style.backgroundSize = 'contain'; 
  cardFront.style.backgroundPosition = 'center';
  cardFront.style.backgroundRepeat = 'no-repeat';
  cardFront.style.borderRadius = '6px'; 
  cardFront.style.boxShadow = '0 4px 12px rgba(0,0,0,0.4)';
  cardFront.style.opacity = '1'; 
  cardFront.style.top = '0';
  cardFront.style.left = '0';
  cardFront.style.pointerEvents = 'none';
  cardFront.style.zIndex = '2';
  animCard.appendChild(cardFront);
  
  
  
  
  const animationDuration = 800; 
  
  
  animCard.style.transition = `left ${animationDuration}ms ease-out, top ${animationDuration}ms ease-out, transform ${animationDuration}ms ease-out`;
  
  
  void animCard.offsetWidth;
  
  
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      
      const targetLeft = targetX - actualCardWidth / 2;
      const targetTop = targetY - actualCardHeight / 2;
      
      
      animCard.style.left = `${targetLeft}px`;
      animCard.style.top = `${targetTop}px`;
      
      animCard.style.transform = `perspective(700px) rotateX(3deg)`;
      
      
    });
  });
  
  
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(animCard); 
    }, animationDuration);
  });
}

function animateDeckShuffle(owner) {
  const stackId = owner === 'player1' ? 'p1DeckStack' : 'p2DeckStack';
  const deckStack = document.getElementById(stackId);
  
  if (!deckStack) return;
  
  deckStack.classList.add('shuffling');
  
  setTimeout(() => {
    deckStack.classList.remove('shuffling');
    
    (globalThis.updateDeckStack || updateDeckStack)(owner);
  }, 600);
}

const activeFor=p=>p==='player1'?p1Active:p2Active;
const benchFor=p=>p==='player1'?p1Bench:p2Bench;
const handDivFor=p=>p==='player1'?p1HandDiv:p2HandDiv;
const opponentOf=p=>p==='player1'?'player2':'player1';

let damageBoostThisTurn = {
  player1: { flatAll: 0, flatByName: {} },
  player2: { flatAll: 0, flatByName: {} }
};
globalThis.damageBoostThisTurn = damageBoostThisTurn;
globalThis.resetDamageBoostsFor = function (playerKey) {
  const slot = damageBoostThisTurn[playerKey];
  if (!slot) return;
  slot.flatAll = 0;
  slot.flatByName = {};
};

function markSlot(slot,has){
  const lab=slot.querySelector('.slot-label');
  slot.dataset.empty=has?'0':'1';
  if(lab)lab.style.display=has?'none':'block';
}
globalThis.markSlot = markSlot;

const metaCache={};
async function fetchCardMeta(set,num){
  const key=`${set}-${num}`;
  if(metaCache[key])return metaCache[key];
  const r=await fetch(`https://api.tcgdex.net/v2/en/sets/${set}/${num}`);
  if(!r.ok)throw new Error('meta');
  const d=await r.json();
  metaCache[key]=d;
  return d;
}
async function isBasicPokemon(set,num){
  try{
    const d=await fetchCardMeta(set,num);
    return String(d.category||'').toLowerCase()==='pokemon' &&
           String(d.stage||'').toLowerCase()==='basic';
  }catch{return false}
}

function removeFromHand(owner,set,num){
  const h=playerState[owner].hand;
  const i=h.findIndex(c=>c.set===set&&String(c.number||c.num)===String(num));
  if(i>=0) {
    h.splice(i,1);
    
    // Update globalThis.playerState as well
    if (globalThis.playerState && globalThis.playerState[owner] && globalThis.playerState[owner].hand) {
      const globalHand = globalThis.playerState[owner].hand;
      const globalI = globalHand.findIndex(c=>c.set===set&&String(c.number||c.num)===String(num));
      if(globalI>=0) {
        globalHand.splice(globalI,1);
      }
    }
    
    // Sync to Firebase for online mode
    const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
    const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
    const isOnline = matchId && window.firebaseDatabase;
    if (isOnline) {
      const updateGameStatePartialFn = updateGameStatePartial || globalThis.updateGameStatePartial;
      const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
      if (updateGameStatePartialFn && isCurrentPlayer1Fn) {
        const isP1 = isCurrentPlayer1Fn();
        // Map UI player to match player
        const matchPlayerKey = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
          ? 'player1' 
          : 'player2';
        
        // Get the updated hand from playerState
        const updatedHand = playerState[owner].hand || [];
        
        updateGameStatePartialFn({
          [`${matchPlayerKey}/hand`]: [...updatedHand] // Sync a copy
        }).catch(error => {
          console.error('Error syncing hand removal to Firebase:', error);
        });
      }
    }
  }
}
  
  if (!window.dropHandlersSetup) {
    setupDropHandlers();
    window.dropHandlersSetup = true;
}

function setupDropHandlers() {
  
  const setupSlotsForPlayer = (playerDiv) => {
    const bench = playerDiv.querySelector('.bench');
    const active = playerDiv.querySelector('.active');
    
    [bench, active].forEach(container => {
      if (!container) return;
      
      const slots = container.querySelectorAll('.card-slot');
      slots.forEach(slot => {
        
        if (slot.dataset.dropHandlersSetup === 'true') return;
        slot.dataset.dropHandlersSetup = 'true';
        
        slot.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          
          const slotOwner = slot.closest('#player1') ? 'player1' : 'player2';
          
          if (!isSetupPhase && slotOwner !== currentPlayer) return;
          
          
          slot.classList.add('drag-over');
        });
        
        slot.addEventListener('dragleave', (e) => {
          if (!slot.contains(e.relatedTarget)) {
            slot.classList.remove('drag-over');
          }
        });
        
        slot.addEventListener('drop', async (e) => {
          
          const targetImg = e.target.closest('img.card-img');
          if (targetImg && targetImg.closest('.card-slot') === slot) {
            
            try {
              const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
              if (dragData) {
                const { set, num } = dragData;
                
                const meta = await fetchCardMeta(set, num);
                if (meta && String(meta.trainerType || '').toLowerCase() === 'tool') {
                  
                  e.stopImmediatePropagation();
                  return;
                }
              }
            } catch {}
          }
          
          e.preventDefault();
          e.stopPropagation();
          
          slot.classList.remove('drag-over');
          
          const slotOwner = slot.closest('#player1') ? 'player1' : 'player2';
          
          if (!isSetupPhase && slotOwner !== currentPlayer) return;
          
          try {
            const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
            if (!dragData || dragData.owner !== slotOwner) return;
            
            const { set, num } = dragData;
            
            
            const handCard = playerState[slotOwner].hand.find(c => 
              c.set === set && String(c.number || c.num) === String(num)
            );
            
            if (!handCard) {
              showPopup('Card not found in hand.');
              return;
            }
            
            
            let meta = null;
            try {
              meta = await fetchCardMeta(set, num);
            } catch (err) {
              showPopup('Error loading card data.');
              return;
            }
            
            if (!meta) return;
            
            
            const ttype = String(meta.trainerType || '').toLowerCase();
            if (ttype === 'tool') {
              
              return;
            }
            
            const slotImg = slot.querySelector('img');
            const isActive = slot.closest('.active');
            const isBench = slot.closest('.bench');
            
            
            if (slotImg) {
              
              if (meta.evolveFrom) {
                
                const targetName = (slotImg.alt || '').toLowerCase();
                const evolveFromLower = String(meta.evolveFrom).toLowerCase();
                
                let canEvolve = targetName.includes(evolveFromLower);
                
                
                const FOSSIL_MAP = {
                  'helix fossil': 'omanyte',
                  'dome fossil': 'kabuto',
                  'old amber': 'aerodactyl',
                  'skull fossil': 'cranidos',
                  'armor fossil': 'shieldon'
                };
                
                if (!canEvolve && FOSSIL_MAP[targetName]) {
                  const fossilPokemon = FOSSIL_MAP[targetName];
                  canEvolve = fossilPokemon === evolveFromLower || evolveFromLower.includes(fossilPokemon);
                }
                
                
                if (!canEvolve && targetName.includes('eevee ex')) {
                  const EEVEELUTIONS = [
                    'vaporeon', 'jolteon', 'flareon', 'espeon', 'umbreon',
                    'leafeon', 'glaceon', 'sylveon'
                  ];
                  const evoCardName = (meta.name || '').toLowerCase();
                  canEvolve = EEVEELUTIONS.some(e => evoCardName.includes(e));
                }
                
                if (canEvolve) {
                  
                  const handCardElement = document.querySelector(`.hand img[data-set="${set}"][data-num="${num}"][data-owner="${slotOwner}"]`);
                  if (handCardElement) {
                    
                    const clickEvent = new MouseEvent('click', {
                      bubbles: true,
                      cancelable: true,
                      view: window
                    });
                    handCardElement.dispatchEvent(clickEvent);
                    
                    
                    setTimeout(() => {
                      slotImg.click();
                    }, 100);
                  }
                } else {
                  showPopup(`Cannot evolve ${slotImg.alt} into ${meta.name}.`);
                }
              } else {
                showPopup('This slot is already occupied.');
              }
            } else {
              
              if (String(meta.category || '').toLowerCase() !== 'pokemon') {
                showPopup('Only Pokmon can be placed on the bench.');
                return;
              }
              
              if (String(meta.stage || '').toLowerCase() !== 'basic') {
                showPopup('Only Basic Pokmon can be placed.');
                return;
              }
              
              
              if (isActive) {
                const act = slotOwner === 'player1' ? p1Active : p2Active;
                if (act.querySelector('img')) {
                  showPopup('Active slot is already occupied.');
                  return;
                }
              }
              
              
              if (isBench) {
                const bench = slotOwner === 'player1' ? p1Bench : p2Bench;
                const benchSlots = bench.querySelectorAll('.card-slot');
                const occupiedSlots = Array.from(benchSlots).filter(s => s.querySelector('img'));
                if (occupiedSlots.length >= 3) {
                  showPopup('Bench is full.');
                  return;
                }
              }
              
              
              const handCardElement = document.querySelector(`.hand img[data-set="${set}"][data-num="${num}"][data-owner="${slotOwner}"]`);
              if (!handCardElement) {
                showPopup('Card not found in hand.');
                return;
              }
              
              
              const clone = handCardElement.cloneNode(true);
              clone.dataset.playedTurn = globalThis.turnNumber || 0;
              
              
              if (!window.pokemonInstanceCounter) window.pokemonInstanceCounter = 0;
              clone.dataset.instanceId = ++window.pokemonInstanceCounter;
              clone.dataset.set = set;
              clone.dataset.num = num;
              
              
              slot.innerHTML = '';
              slot.appendChild(clone);
              markSlot(slot, true);
              
              
              if (handCardElement) {
                animateSlideFromHand(handCardElement, slot, clone);
              }
              
              
              removeFromHand(slotOwner, set, num);
              
              
              try {
                const baseHp = parseInt(meta.hp || '0', 10) || 0;
                setHpOnImage(clone, baseHp, baseHp);
              } catch {}
              
              
              if (isActive) {
                const playerNum = slotOwner === 'player1' ? 1 : 2;
                updatePlayerTypeBackground(playerNum);
              }
              
              renderAllHands();
              
              const placedTo = isActive ? 'active' : 'bench';
              logEvent({
                player: slotOwner,
                text: `Played Basic Pokmon to ${placedTo === 'active' ? 'Active' : 'Bench'}: ${meta.name}.`,
                cardSet: set,
                cardNum: num
              });
              
              // Sync card placement to Firebase
              (async () => {
                try {
                  const updateGameStatePartialFn = updateGameStatePartial || globalThis.updateGameStatePartial;
                  const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
                  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
                  const broadcastActionFn = broadcastAction || globalThis.broadcastAction;
                  const ACTION_TYPES_OBJ = ACTION_TYPES || globalThis.ACTION_TYPES;
                  
                  if (!window.firebaseDatabase || !updateGameStatePartialFn) return;
                  
                  const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
                  // Map UI player to match player
                  // If current user is player1 in match: UI player1 = match player1, UI player2 = match player2
                  // If current user is player2 in match: UI player1 = match player2, UI player2 = match player1
                  const matchPlayerKey = (isP1 && slotOwner === 'player1') || (!isP1 && slotOwner === 'player2') 
                    ? 'player1' 
                    : 'player2';
                  
                  if (!meta || !meta.name) {
                    console.error('Error: meta is missing or invalid:', meta);
                    throw new Error('Card metadata is missing or invalid');
                  }
                  
                  const cardData = {
                    set: set,
                    num: num,
                    name: meta.name,
                    hp: parseInt(meta.hp || '0', 10) || 0,
                    instanceId: clone.dataset.instanceId,
                    playedTurn: globalThis.turnNumber || 0
                  };
                  
                  // Update hand in game state first (stateRef already points to gameState, so path is just matchPlayerKey/hand)
                  if (!playerState || !playerState[slotOwner]) {
                    console.error('Error: playerState is missing or invalid:', { playerState, slotOwner });
                    throw new Error('Player state is missing or invalid');
                  }
                  const handToSync = playerState[slotOwner].hand ? [...playerState[slotOwner].hand] : [];
                  await updateGameStatePartialFn({ 
                    [`${matchPlayerKey}/hand`]: handToSync
                  });
                  // Hand synced to Firebase
                  
                  if (placedTo === 'active') {
                    // Update active slot (stateRef already points to gameState, so path is just matchPlayerKey/active)
                    await updateGameStatePartialFn({ 
                      [`${matchPlayerKey}/active`]: cardData 
                    });
                    // Active Pokemon synced to Firebase
                  } else {
                    // For bench, add to array
                    const { getMatchRef } = await import('./js/online/schema.js');
                    const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
                    if (matchId) {
                      const matchRef = getMatchRef(matchId);
                      const snapshot = await matchRef.child(`gameState/${matchPlayerKey}/bench`).once('value');
                      const currentBench = snapshot.val() || [];
                      const newBench = [...currentBench, cardData];
                      // stateRef already points to gameState, so path is just matchPlayerKey/bench
                      await updateGameStatePartialFn({ 
                        [`${matchPlayerKey}/bench`]: newBench 
                      });
                      // Bench Pokemon synced to Firebase
                    }
                  }
                  
                  // Broadcast action for logging
                  if (broadcastActionFn && ACTION_TYPES_OBJ) {
                    broadcastActionFn(ACTION_TYPES_OBJ.PROMOTE, {
                      player: matchPlayerKey,
                      card: cardData,
                      placedTo: placedTo
                    });
                  }
                } catch (error) {
                  console.error('Error syncing card placement:', error);
                }
              })();
            }
          } catch (err) {
            console.error('[drop] Error handling drop:', err);
            showPopup('Error placing card.');
          }
        });
      });
    });
  };
  
  
  const player1Div = document.getElementById('player1');
  const player2Div = document.getElementById('player2');
  if (player1Div) setupSlotsForPlayer(player1Div);
  if (player2Div) setupSlotsForPlayer(player2Div);
  
  
  globalThis.reSetupDropHandlers = () => {
    if (player1Div) setupSlotsForPlayer(player1Div);
    if (player2Div) setupSlotsForPlayer(player2Div);
    
    if (globalThis.reSetupToolDropHandlers) {
      globalThis.reSetupToolDropHandlers();
    }
  };
  
  
  setupToolDropHandlers();
}

function setupToolDropHandlers() {
  
  const setupPokemonForPlayer = (playerDiv) => {
    const bench = playerDiv.querySelector('.bench');
    const active = playerDiv.querySelector('.active');
    
    [bench, active].forEach(container => {
      if (!container) return;
      
      const pokemonImgs = container.querySelectorAll('.card-slot img.card-img');
      pokemonImgs.forEach(img => {
        
        if (img.dataset.toolDropHandlersSetup === 'true') return;
        img.dataset.toolDropHandlersSetup = 'true';
        
        
        img.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          
          const pokemonOwner = img.closest('#player1') ? 'player1' : 'player2';
          
          if (!isSetupPhase && pokemonOwner !== currentPlayer) return;
          
          
          img.style.border = '2px solid #9d7dd4';
          img.style.boxShadow = '0 0 16px rgba(157, 125, 212, 0.6)';
        });
        
        img.addEventListener('dragleave', (e) => {
          if (!img.contains(e.relatedTarget)) {
            img.style.border = '';
            img.style.boxShadow = '';
          }
        });
        
        
        img.addEventListener('drop', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation(); 
          
          img.style.border = '';
          img.style.boxShadow = '';
          
          const pokemonOwner = img.closest('#player1') ? 'player1' : 'player2';
          
          if (!isSetupPhase && pokemonOwner !== currentPlayer) return;
          
          try {
            const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
            if (!dragData || dragData.owner !== pokemonOwner) return;
            
            const { set, num } = dragData;
            
            
            const handCard = playerState[pokemonOwner].hand.find(c => 
              c.set === set && String(c.number || c.num) === String(num)
            );
            
            if (!handCard) {
              showPopup('Card not found in hand.');
              return;
            }
            
            
            let meta = null;
            try {
              meta = await fetchCardMeta(set, num);
            } catch (err) {
              showPopup('Error loading card data.');
              return;
            }
            
            if (!meta) return;
            
            
            const ttype = String(meta.trainerType || '').toLowerCase();
            if (ttype !== 'tool') {
              showPopup('Only Tool cards can be attached to Pokmon.');
              return;
            }
            
            
            const targetSlot = img.closest('.card-slot');
            if (!targetSlot) {
              showPopup('Invalid target.');
              return;
            }
            
            if (getToolDataFromSlot(targetSlot)) {
              showPopup('This Pokmon already has a Tool attached.');
              return;
            }
            
            
            // Don't attach tool visually yet - wait until effect succeeds
            // This prevents the tool from being attached if the effect fails
            
            const cardId = csvIdFor(set, num);
            const effect = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
            
            // [TOOL-ATTACH] Track tool attachment and effect application
            console.log('[TOOL-ATTACH] Tool attachment attempt:', {
              tool: `${set}-${num}`,
              target: img.alt,
              owner: pokemonOwner,
              effectFound: !!effect,
              effectType: effect?.effect_type,
              effectName: effect?.name || effect?.trainerName,
              isRareCandy: effect?.effect_type === 'evolve_basic_to_stage2'
            });
            
            if (effect && effect.effect_type) {
              globalThis.toolAttachTarget = img;
              
              try {
                console.log('[TOOL-ATTACH] Applying tool effect:', {
                  effectType: effect.effect_type,
                  param1: effect.param1,
                  param2: effect.param2,
                  toolAttachTarget: !!globalThis.toolAttachTarget
                });
                await (globalThis.applyTrainerEffect || applyTrainerEffect)(effect, pokemonOwner, null);
                console.log('[TOOL-ATTACH] Tool effect applied successfully');
                
                // Only attach tool and remove from hand if effect succeeded
                await attachToolToSlot(pokemonOwner, targetSlot, {
                  set: set,
                  num: num,
                  src: handCard.image || `https://assets.tcgdex.net/en/tcgp/${set}/${String(num).padStart(3, '0')}/high.png`
                });
                
                removeFromHand(pokemonOwner, set, num);
                renderAllHands();

                logEvent({
                  player: pokemonOwner,
                  text: 'Attached Tool.',
                  cardSet: set,
                  cardNum: num
                });
                
              } catch (err) {
                // Effect failed - don't attach tool and don't remove from hand
                console.error('[TOOL-ATTACH] Tool effect failed:', {
                  error: err.message,
                  effectType: effect?.effect_type,
                  tool: `${set}-${num}`
                });
                showPopup(err.message || 'Cannot attach this Tool here.');
                // Tool is NOT removed from hand when effect fails
              } finally {
                globalThis.toolAttachTarget = null;
                console.log('[TOOL-ATTACH] Cleared toolAttachTarget');
              }
            } else {
              // Tool with no effect - safe to attach and remove from hand
              await attachToolToSlot(pokemonOwner, targetSlot, {
                set: set,
                num: num,
                src: handCard.image || `https://assets.tcgdex.net/en/tcgp/${set}/${String(num).padStart(3, '0')}/high.png`
              });
              
              removeFromHand(pokemonOwner, set, num);
              renderAllHands();

              logEvent({
                player: pokemonOwner,
                text: 'Attached Tool.',
                cardSet: set,
                cardNum: num
              });
            }
          } catch (err) {
            console.error('[tool-drop] Error handling drop:', err);
            showPopup('Error attaching tool.');
          }
        });
      });
    });
  };
  
  
  const player1Div = document.getElementById('player1');
  const player2Div = document.getElementById('player2');
  if (player1Div) setupPokemonForPlayer(player1Div);
  if (player2Div) setupPokemonForPlayer(player2Div);
  
  
  globalThis.reSetupToolDropHandlers = () => {
    
    document.querySelectorAll('.card-slot img.card-img').forEach(img => {
      delete img.dataset.toolDropHandlersSetup;
    });
    setupToolDropHandlers();
  };
}


globalThis.setMaxHp = function(img, newMax) {
  if (!img) return;
  const slot = img.closest('.card-slot');
  if (!slot) return;
  
  const owner = img.closest('#player1') ? 'player1' : 'player2';
  
  const oldMaxHp = parseInt(img.dataset.hp, 10) || 0;
  const oldCurrentHp = parseInt(img.dataset.chp || img.dataset.hp, 10) || oldMaxHp;
  
  const hpIncrease = newMax - oldMaxHp;
  
  const newCurrentHp = oldCurrentHp + hpIncrease;
  
  slot.dataset.maxHp = String(newMax);
  
  img.dataset.chp = String(newCurrentHp);
  
  // Sync HP change to Firebase
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
  if (isOnline && typeof updateGameStatePartial === 'function') {
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
    const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
      ? 'player1' 
      : 'player2';
    
    (async () => {
      try {
        const isActive = slot.closest('.active-slot') !== null;
        if (isActive) {
          const activeData = {
            set: img.dataset.set,
            num: img.dataset.num,
            name: img.alt,
            instanceId: img.dataset.instanceId,
            hp: parseInt(img.dataset.hp || '0', 10),
            chp: newCurrentHp,
            maxHp: newMax,
            playedTurn: parseInt(img.dataset.playedTurn || '0', 10)
          };
          await updateGameStatePartial({
            [`${matchOwner}/active`]: activeData
          });
        } else {
          // Update bench Pokemon
          const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
          if (benchDiv) {
            const benchSlots = Array.from(benchDiv.querySelectorAll('.card-slot'));
            const benchIndex = benchSlots.indexOf(slot);
            if (benchIndex >= 0) {
              const currentBench = playerState[owner]?.bench || [];
              const benchArray = Array.isArray(currentBench) ? [...currentBench] : [];
              if (benchArray[benchIndex]) {
                benchArray[benchIndex] = {
                  ...benchArray[benchIndex],
                  hp: parseInt(img.dataset.hp || '0', 10),
                  chp: newCurrentHp,
                  maxHp: newMax
                };
                await updateGameStatePartial({
                  [`${matchOwner}/bench`]: benchArray
                });
              }
            }
          }
        }
      } catch (error) {
        console.error('Error syncing HP change to Firebase:', error);
      }
    })();
  }
  
  let hpDiv = slot.querySelector('.hp-overlay');
  if (!hpDiv) {
    hpDiv = document.createElement('div');
    hpDiv.className = 'hp-overlay';
    slot.appendChild(hpDiv);
  }
  
  
  hpDiv.textContent = `${newCurrentHp} / ${newMax}`;
  
  
  hpDiv.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
  hpDiv.style.fontWeight = '900';
  
};

globalThis.forceSwitchSpecific = function(state, pk, benchImg) {
  if (!benchImg) return;
  
  const owner = pkToPlayer(pk);
  
  
  const activeDiv = owner === 'player1' ? document.getElementById('p1Active') : document.getElementById('p2Active');
  const activeSlot = activeDiv?.querySelector('.card-slot');
  const benchSlot = benchImg.closest('.card-slot');

  
  if (!activeSlot || !benchSlot) {
    console.error('[forceSwitchSpecific] Could not find slots', { activeSlot, benchSlot });
    return;
  }
  
  
  const activeImg = activeSlot.querySelector('img');
  if (!activeImg) {
    console.error('[forceSwitchSpecific] No active Pokemon to swap');
    return;
  }

  // Swap maxHp
  const activeMaxHp = activeSlot.dataset.maxHp;
  const benchMaxHp = benchSlot.dataset.maxHp;
  delete activeSlot.dataset.maxHp;
  delete benchSlot.dataset.maxHp;
  if (benchMaxHp) {
    activeSlot.dataset.maxHp = benchMaxHp;
  }
  if (activeMaxHp) {
    benchSlot.dataset.maxHp = activeMaxHp;
  }
  
  
  const activeInstanceId = activeImg.dataset.instanceId;
  const ownerPk = owner === 'player1' ? 'p1' : 'p2';
  if (activeInstanceId && globalThis.__moveLocks?.[ownerPk]?.[activeInstanceId]) {
    delete globalThis.__moveLocks[ownerPk][activeInstanceId];
  }
  
  
  const activeRect = activeImg.getBoundingClientRect();
  const benchRect = benchImg.getBoundingClientRect();
  
  
  activeImg.style.opacity = '0';
  benchImg.style.opacity = '0';
  
  // Use innerHTML swap like battle.html for proper swap
  const activeHTML = activeSlot.innerHTML;
  const benchHTML = benchSlot.innerHTML;
  
  activeSlot.innerHTML = benchHTML;
  benchSlot.innerHTML = activeHTML;
  
  const newActiveImg = activeSlot.querySelector('img');
  const newBenchImg = benchSlot.querySelector('img');
  
  
  if (newActiveImg && newBenchImg) {
    animateSlideSwap(benchImg, activeSlot, newActiveImg, benchRect);
    animateSlideSwap(activeImg, benchSlot, newBenchImg, activeRect);
  } else if (newActiveImg) {
    animateSlideSwap(benchImg, activeSlot, newActiveImg, benchRect);
  }

  
  
  
  if (newActiveImg) {
    const baseHp = parseInt(newActiveImg.dataset.hp, 10) || 0;
    const curHp = parseInt(newActiveImg.dataset.chp || newActiveImg.dataset.hp, 10) || baseHp;
    setHpOnImage(newActiveImg, baseHp, curHp);
  }
  
  if (newBenchImg) {
    const baseHp = parseInt(newBenchImg.dataset.hp, 10) || 0;
    const curHp = parseInt(newBenchImg.dataset.chp || newBenchImg.dataset.hp, 10) || baseHp;
    setHpOnImage(newBenchImg, baseHp, curHp);
  }
  
  // Mark slots after swap
  if (typeof markSlot === 'function') {
    markSlot(activeSlot, !!newActiveImg);
    markSlot(benchSlot, !!newBenchImg);
  }
  
  // Sync to Firebase in online mode
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
  if (isOnline && typeof updateGameStatePartial === 'function') {
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
    const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
      ? 'player1' 
      : 'player2';
    
    (async () => {
      try {
        if (newActiveImg) {
          const activeData = {
            set: newActiveImg.dataset.set,
            num: newActiveImg.dataset.num,
            name: newActiveImg.alt,
            instanceId: newActiveImg.dataset.instanceId,
            hp: parseInt(newActiveImg.dataset.hp || '0', 10),
            chp: parseInt(newActiveImg.dataset.chp || newActiveImg.dataset.hp || '0', 10),
            playedTurn: parseInt(newActiveImg.dataset.playedTurn || '0', 10)
          };
          // Only include maxHp if it exists (Firebase doesn't allow undefined)
          if (activeSlot.dataset.maxHp) {
            activeData.maxHp = parseInt(activeSlot.dataset.maxHp, 10);
          }
          await updateGameStatePartial({
            [`${matchOwner}/active`]: activeData
          });
        }
        
        // Update bench
        const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
        if (benchDiv) {
          const benchArray = Array.from(benchDiv.querySelectorAll('.card-slot img'))
            .filter(img => img.dataset.set && img.dataset.num)
            .map(img => {
              const slot = img.closest('.card-slot');
              const cardData = {
                set: img.dataset.set,
                num: img.dataset.num,
                name: img.alt,
                instanceId: img.dataset.instanceId,
                hp: parseInt(img.dataset.hp || '0', 10),
                chp: parseInt(img.dataset.chp || img.dataset.hp || '0', 10),
                playedTurn: parseInt(img.dataset.playedTurn || '0', 10)
              };
              // Only include maxHp if it exists (Firebase doesn't allow undefined)
              if (slot?.dataset.maxHp) {
                cardData.maxHp = parseInt(slot.dataset.maxHp, 10);
              }
              return cardData;
            });
          await updateGameStatePartial({
            [`${matchOwner}/bench`]: benchArray
          });
        }
        
        // Broadcast force switch action
        if (typeof broadcastAction === 'function' && ACTION_TYPES) {
          await broadcastAction(ACTION_TYPES.PROMOTE, {
            owner: matchOwner,
            promoted: newActiveImg ? {
              set: newActiveImg.dataset.set,
              num: newActiveImg.dataset.num,
              name: newActiveImg.alt,
              instanceId: newActiveImg.dataset.instanceId
            } : null,
            benched: newBenchImg ? {
              set: newBenchImg.dataset.set,
              num: newBenchImg.dataset.num,
              name: newBenchImg.alt,
              instanceId: newBenchImg.dataset.instanceId
            } : null,
            isForcedSwitch: true,
            turnNumber: globalThis.turnNumber || 0
          });
        }
      } catch (error) {
        console.error('Error syncing force switch to Firebase:', error);
      }
    })();
  }
  
  if (typeof updateAllEnergyVisuals === 'function') {
    updateAllEnergyVisuals();
  }
};

if(handBackdrop){
  handBackdrop.addEventListener('click',e=>{
    if(e.target===handBackdrop){
      handBackdrop.classList.remove('show');
      if(handToolImg) handToolImg.style.display = 'none';
    }
  });
  document.addEventListener('keydown',e=>{
    if(e.key==='Escape'){
      handBackdrop.classList.remove('show');
      if(handToolImg) handToolImg.style.display = 'none';
    }
  });
}

function satisfiedFlags(pips, costArr, pokemonImg = null) {
  const cnt = {...pips};
  const keys = Object.keys(cnt).filter(k => k !== 'total');
  const f = [];
  
  
  let costIncrease = 0;
  if (pokemonImg) {
    let pk = null;
    if (pokemonImg.closest('#player1')) pk = 'p1';
    else if (pokemonImg.closest('#player2')) pk = 'p2';
    
    if (pk && globalThis.__specialEffects?.[pk]?.attackCostIncrease) {
      costIncrease = globalThis.__specialEffects[pk].attackCostIncrease;
    }
    
    
    const oppPk = pk === 'p1' ? 'p2' : 'p1';
    const oppActive = oppPk === 'p1' ? p1Active : p2Active;
    const oppActiveImg = oppActive?.querySelector('img');
    
    if (oppActiveImg) {
      try {
        const cacheKey = `${oppActiveImg.dataset.set}-${oppActiveImg.dataset.num}`;
        const abilityRow = globalThis.abilityCache?.[cacheKey];
        
        if (abilityRow?.effect_type === 'increase_opponent_cost') {
          const increase = parseInt(abilityRow.param1 || '1', 10);
          costIncrease += increase;
        }
      } catch (err) {
        console.error('[canAfford] Guard Dog Visage check failed:', err);
      }
    }
  }
  
  
  let colorlessReduction = 0;
  if (pokemonImg && pokemonImg.dataset.set && pokemonImg.dataset.num) {
    try {
      const cacheKey = `${pokemonImg.dataset.set}-${pokemonImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_attack_cost_if_arceus') {
        
        let pk = null;
        if (pokemonImg.closest('#player1')) pk = 'p1';
        else if (pokemonImg.closest('#player2')) pk = 'p2';
        
        if (pk && typeof hasArceusInPlay === 'function' && hasArceusInPlay(pk)) {
          colorlessReduction = parseInt(abilityRow.param1 || '1', 10);
        }
      }
    } catch (e) {
      
    }
  }
  
  
  if (pokemonImg) {
    const pokemonName = (pokemonImg.alt || '').toLowerCase();
    const barryCostReduction = globalThis.attackCostReduction?.[pokemonName] || 0;
    if (barryCostReduction > 0) {
      colorlessReduction += barryCostReduction;
    }
  }
  
  
  const modifiedCostArr = [...(costArr || [])];
  for (let i = 0; i < costIncrease; i++) {
    modifiedCostArr.push('colorless');
  }
  
  modifiedCostArr.forEach(t => {
    const k = String(t || '').toLowerCase();
    if (k === 'colorless') {
      
      if (colorlessReduction > 0) {
        colorlessReduction--;
        f.push(true);
        return;
      }
      
      
      let ok = false;
      for (const tp of keys) {
        if ((cnt[tp] || 0) > 0) {
          cnt[tp]--;
          cnt.total--;
          ok = true;
          break;
        }
      }
      f.push(ok);
    } else {
      if ((cnt[k] || 0) > 0) {
        cnt[k]--;
        cnt.total--;
        f.push(true);
      } else {
        f.push(false);
      }
    }
  });
  return f;
}

function canPayCostFromAPI(slot, costArr, pokemonImg = null) {
  return satisfiedFlags(countPipsOn(slot), costArr || [], pokemonImg).every(Boolean);
}

function makeCostIcons(costArr, slot, pokemonImg = null) {
  const wrap = document.createElement('div');
  wrap.className = 'attack-cost';
  const flags = satisfiedFlags(countPipsOn(slot), costArr || [], pokemonImg);
  (costArr || []).forEach((t, i) => {
    const ic = document.createElement('div');
    ic.className = 'cost-icon';
    ic.style.backgroundImage = `url('${energyIconUrl(String(t || '').toLowerCase())}')`;
    if (!flags[i]) ic.classList.add('missing');
    wrap.appendChild(ic);
  });
  return wrap;
}

const parseDamage=v=>{const m=String(v??'').match(/\d+/);return m?parseInt(m[0],10):0};
const getActiveImage=p=>activeFor(p).querySelector('img')||null;

function pushCardToDiscard(owner,img){
  if (!playerState[owner]) {
    playerState[owner] = {};
  }
  if (!playerState[owner].discard) {
    playerState[owner].discard = { cards: [], energyCounts: {} };
  }
  if (!playerState[owner].discard.cards) {
    playerState[owner].discard.cards = [];
  }
  playerState[owner].discard.cards.push({set:img.dataset.set,num:img.dataset.num,src:img.src});
  
  // Sync globalThis.playerState
  if (globalThis.playerState && globalThis.playerState[owner]) {
    if (!globalThis.playerState[owner].discard) {
      globalThis.playerState[owner].discard = { cards: [], energyCounts: {} };
    }
    globalThis.playerState[owner].discard.cards = [...playerState[owner].discard.cards];
  }
  
  // Sync to Firebase in online mode
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
  if (isOnline && typeof updateGameStatePartial === 'function') {
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
    const matchPlayer = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
      ? 'player1' 
      : 'player2';
    
    (async () => {
      try {
        await updateGameStatePartial({
          [`${matchPlayer}/discard`]: {
            cards: [...playerState[owner].discard.cards],
            energyCounts: { ...playerState[owner].discard.energyCounts }
          }
        });
      } catch (error) {
        console.error('Error syncing discard to Firebase:', error);
      }
    })();
  }
  
  // Always update discard bubbles to show correct count
  if (typeof updateDiscardBubbles === 'function') {
    updateDiscardBubbles();
  }
}
function moveCardToDiscard(owner,img){
  const slot=img.closest('.card-slot');
  const tool=getToolDataFromSlot(slot);
  if(tool){
    playerState[owner].discard.cards.push({set:tool.set,num:tool.num,src:tool.src});
    if (slot) {
      removeToolThumb(slot);
      setToolDataOnSlot(slot,null);
    }
  }
  const drawer=owner==='player1'?p1DiscardDrawer:p2DiscardDrawer;
  pushCardToDiscard(owner,img);
  
  // Only count pips if slot exists and energy hasn't been counted yet for THIS specific Pokemon
  // (energy may have been counted before calling this function, e.g. in handleKnockOut)
  // Use a flag on the slot to track if energy was already counted
  if (slot) {
    // Check if energy was already counted for this specific Pokemon
    const energyAlreadyCounted = slot.dataset.energyCounted === 'true';
    
    if (!energyAlreadyCounted) {
      const pips=countPipsOn(slot);
      if (!playerState[owner].discard.energyCounts) {
        playerState[owner].discard.energyCounts = {};
      }
      Object.keys(pips).forEach(k=>{
        if(k==='total')return;
        playerState[owner].discard.energyCounts[k]=(playerState[owner].discard.energyCounts[k]||0)+pips[k];
      });
      
      // Mark that energy was counted for this slot
      slot.dataset.energyCounted = 'true';
      
      // Sync energy to globalThis.playerState
      if (globalThis.playerState && globalThis.playerState[owner]) {
        if (!globalThis.playerState[owner].discard) {
          globalThis.playerState[owner].discard = { cards: [], energyCounts: {} };
        }
        globalThis.playerState[owner].discard.energyCounts = { ...playerState[owner].discard.energyCounts };
      }
    }
  }
  
  // Sync globalThis.playerState discard
  if (globalThis.playerState && globalThis.playerState[owner]) {
    if (!globalThis.playerState[owner].discard) {
      globalThis.playerState[owner].discard = { cards: [], energyCounts: {} };
    }
    globalThis.playerState[owner].discard.cards = [...playerState[owner].discard.cards];
    globalThis.playerState[owner].discard.energyCounts = { ...playerState[owner].discard.energyCounts };
  }
  
  // Sync to Firebase in online mode
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
  if (isOnline && typeof updateGameStatePartial === 'function') {
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
    const matchPlayer = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
      ? 'player1' 
      : 'player2';
    
    (async () => {
      try {
        await updateGameStatePartial({
          [`${matchPlayer}/discard`]: {
            cards: [...playerState[owner].discard.cards],
            energyCounts: { ...playerState[owner].discard.energyCounts }
          }
        });
      } catch (error) {
        console.error('Error syncing discard to Firebase:', error);
      }
    })();
  }
  
  // Only clear slot if it exists
  if (slot) {
    slot.innerHTML='';
    slot.classList.remove('damage-flash');
    const lab=document.createElement('span');
    lab.className='slot-label';
    lab.textContent='Empty';
    slot.appendChild(lab);
    if (typeof markSlot === 'function') {
      markSlot(slot,false);
    }
  }
  // Always update renderDiscard if drawer exists (even if not shown, to keep state in sync)
  if(drawer && typeof renderDiscard === 'function') {
    renderDiscard(owner);
  }
  
  // Always update discard bubbles to show correct count
  if (typeof updateDiscardBubbles === 'function') {
    updateDiscardBubbles();
  }
}

async function pointsForCard(set,num){
  console.log('[POINTS-CALC] Starting points calculation:', { set, num });
  try{
    const meta=await fetchCardMeta(set,num);
    const s=(meta.suffix||'').toUpperCase();
    const name=(meta.name||'').toLowerCase();
    console.log('[POINTS-CALC] Card metadata:', {
      set,
      num,
      name: meta.name,
      suffix: meta.suffix,
      suffixUpper: s,
      nameLower: name,
      hasMega: name.includes('mega')
    });
    
    if(s==='EX'&&name.includes('mega')){
      console.log('[POINTS-CALC] Mega EX detected - awarding 3 points');
      return 3;
    }
    if(s==='EX'){
      console.log('[POINTS-CALC] EX detected - awarding 2 points');
      return 2;
    }
    console.log('[POINTS-CALC] Regular Pokemon - awarding 1 point');
  }catch(err){
    console.error('[POINTS-CALC] Error fetching card meta:', err);
  }
  return 1;
}
const checkBenchOut=owner=>[...benchFor(owner).querySelectorAll('img')].length===0;

function showVictory(winnerKey,reason){
  if(gameOver)return;
  gameOver=true;
  $('.main-layout')?.classList.add('disable-clicks');
  $('.side-panel')?.classList.add('disable-clicks');
  victoryTitle.textContent=winnerKey==='player1'?'Player 1 Wins!':'Player 2 Wins!';
  victoryDesc.textContent=reason||'Game over';
  p1PtsText.textContent=String(p1Points);
  p2PtsText.textContent=String(p2Points);
  victoryOverlay.style.display='flex';
}

async function handleKnockOut(owner, img, wasActive = false){
  const set=img.dataset.set,
        num=img.dataset.num;
  const foe=owner==='player1'?'player2':'player1';
  
  
  const activeImg = getActiveImage(owner);
  const isActive = wasActive || (activeImg === img);
  

  if (typeof getAbilityRow === 'function') {
    try {
      const pk = owner === 'player1' ? 'p1' : 'p2';
      const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
      
      if (abilityRow && typeof globalThis.applyAbilityEffectFromCsv === 'function') {
        
        if (abilityRow.effect_type === 'counter_on_knockout' && isActive) {
          await globalThis.applyAbilityEffectFromCsv(abilityRow, pk, { 
            attacker: foe,
            knockedPokemon: img 
          });
        }
        
        
        if (abilityRow.effect_type === 'flip_ko_attacker_on_ko' && isActive) {
          const effectState = {
            p1: playerState.player1,
            p2: playerState.player2
          };
          await globalThis.applyAbilityEffectFromCsv(effectState, pk, abilityRow, { 
            attacker: foe,
            knockedPokemon: img 
          });
        }
        
        
        if (abilityRow.effect_type === 'move_energy_on_knockout' && isActive) {
          await globalThis.applyAbilityEffectFromCsv(abilityRow, pk, { 
            knockedPokemon: img 
          });
        }
      }
    } catch (err) {
    }
  }
  
  
  if (isActive) {
    const slot = img.closest('.card-slot');
    const tool = getToolDataFromSlot(slot);
    
    if (tool && tool.num === '065' && tool.set === 'A3a') {
      
      
      try {
        const meta = await fetchCardMeta(img.dataset.set, img.dataset.num);
        const isLightningType = meta.types?.some(t => t.toLowerCase() === 'lightning');
        
        if (isLightningType) {
          
          const energyBox = slot?.querySelector('.energy-pips');
          const pips = energyBox?.querySelectorAll('.energy-pip');
          const lightningPips = Array.from(pips || []).filter(p => p.dataset.type === 'lightning');

          
          if (lightningPips.length >= 2) {
            
            const energyBox = slot?.querySelector('.energy-pips');
            const pips = energyBox?.querySelectorAll('.energy-pip');
            const lightningPipsArray = Array.from(pips || []).filter(p => p.dataset.type === 'lightning');
            
            
            const toRemove = Math.min(2, lightningPipsArray.length);
            for (let i = 0; i < toRemove; i++) {
              lightningPipsArray[i].remove();
            }

            
            
            const pk = owner === 'player1' ? 'p1' : 'p2';
            const bench = [...benchFor(owner).querySelectorAll('img')];
            
            if (bench.length >= 2) {
              showPopup('Electrical Cord: Select 2 Benched Pokmon to receive Lightning Energy');
              
              
              const first = await new Promise(resolve => {
                bench.forEach(b => b.classList.add('selectable'));
                const handler = (e) => {
                  const clicked = e.target.closest('img');
                  if (clicked && bench.includes(clicked)) {
                    bench.forEach(b => {
                      b.classList.remove('selectable');
                      b.removeEventListener('click', handler);
                    });
                    resolve(clicked);
                  }
                };
                bench.forEach(b => b.addEventListener('click', handler));
              });
              
              if (first) {
                
                const remaining = bench.filter(b => b !== first);
                const second = await new Promise(resolve => {
                  remaining.forEach(b => b.classList.add('selectable'));
                  const handler = (e) => {
                    const clicked = e.target.closest('img');
                    if (clicked && remaining.includes(clicked)) {
                      remaining.forEach(b => {
                        b.classList.remove('selectable');
                        b.removeEventListener('click', handler);
                      });
                      resolve(clicked);
                    }
                  };
                  remaining.forEach(b => b.addEventListener('click', handler));
                });
                
                if (second) {
                  
                  attachEnergy(first, 'lightning');
                  attachEnergy(second, 'lightning');
                  showPopup(`Electrical Cord: Distributed Lightning Energy to ${first.alt} and ${second.alt}!`);
                }
              }
            } else if (bench.length === 1) {
              
              attachEnergy(bench[0], 'lightning');
              attachEnergy(bench[0], 'lightning');
              showPopup(`Electrical Cord: Attached 2 Lightning Energy to ${bench[0].alt}!`);
            } else {
            }
          } else {
          }
        }
      } catch (err) {
      }
    }
  }
  
  
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.koLastTurn) globalThis.state.koLastTurn = {};
  
  const ownerPk = owner === 'player1' ? 'p1' : 'p2';
  globalThis.state.koLastTurn[ownerPk] = true;
  
  
  const pokemonName = (img.alt || '').toLowerCase();
  if (pokemonName.includes('serperior')) {
    
    setTimeout(() => {
      if (typeof globalThis.updateAllEnergyVisuals === 'function') {
        globalThis.updateAllEnergyVisuals();
      }
    }, 100); 
  }
  
  logEvent({
    player: foe,
    text:`Knocked out ${img.alt || 'a Pokmon'}.`,
    cardSet:set,cardNum:num
  });

  // Count energy BEFORE moving to discard (while slot still exists)
  const slot = img.closest('.card-slot');
  if (slot) {
    // Mark that energy will be counted for this slot to prevent double counting in moveCardToDiscard
    slot.dataset.energyCounted = 'true';
    
    const pips = countPipsOn(slot);
    Object.keys(pips).forEach(k => {
      if (k === 'total') return;
      if (!playerState[owner].discard.energyCounts) {
        playerState[owner].discard.energyCounts = {};
      }
      playerState[owner].discard.energyCounts[k] = (playerState[owner].discard.energyCounts[k] || 0) + pips[k];
    });
    
    // Sync energy discard to globalThis.playerState
    if (globalThis.playerState && globalThis.playerState[owner]) {
      if (!globalThis.playerState[owner].discard) {
        globalThis.playerState[owner].discard = { cards: [], energyCounts: {} };
      }
      globalThis.playerState[owner].discard.energyCounts = { ...playerState[owner].discard.energyCounts };
    }
    
    // Sync energy discard to Firebase immediately
    const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
    const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
    const isOnline = matchId && window.firebaseDatabase;
    if (isOnline && typeof updateGameStatePartial === 'function') {
      const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
      const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
      const matchPlayer = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
        ? 'player1' 
        : 'player2';
      
      (async () => {
        try {
          await updateGameStatePartial({
            [`${matchPlayer}/discard`]: {
              cards: [...(playerState[owner].discard.cards || [])],
              energyCounts: { ...(playerState[owner].discard.energyCounts || {}) }
            }
          });
        } catch (error) {
          console.error('Error syncing energy discard to Firebase in handleKnockOut:', error);
        }
      })();
    }
  }
  
  // Move to discard with error handling
  try {
    moveCardToDiscard(owner,img);
    
    // Ensure globalThis.playerState is updated after moveCardToDiscard
    if (globalThis.playerState && globalThis.playerState[owner]) {
      if (!globalThis.playerState[owner].discard) {
        globalThis.playerState[owner].discard = { cards: [], energyCounts: {} };
      }
      globalThis.playerState[owner].discard.cards = [...playerState[owner].discard.cards];
      globalThis.playerState[owner].discard.energyCounts = { ...playerState[owner].discard.energyCounts };
    }
    
    // Final sync to Firebase after moveCardToDiscard (which may have added more cards/energy)
    const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
    const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
    const isOnline = matchId && window.firebaseDatabase;
    if (isOnline && typeof updateGameStatePartial === 'function') {
      const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
      const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
      const matchPlayer = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
        ? 'player1' 
        : 'player2';
      
      (async () => {
        try {
          await updateGameStatePartial({
            [`${matchPlayer}/discard`]: {
              cards: [...playerState[owner].discard.cards],
              energyCounts: { ...playerState[owner].discard.energyCounts }
            }
          });
          // Final discard sync after KO
        } catch (error) {
          console.error('Error in final sync of discard to Firebase:', error);
        }
      })();
    }
  } catch (error) {
    console.error('Error moving card to discard in handleKnockOut:', error);
    // Try to push to discard even if moveCardToDiscard fails
    if (typeof pushCardToDiscard === 'function') {
      pushCardToDiscard(owner, img);
    }
  }
  
  // [KNOCKOUT-POINTS] Award points
  const pts=await pointsForCard(set,num);
  console.log('[KNOCKOUT-POINTS] Points calculation result:', {
    owner,
    foe,
    pokemon: img.alt,
    set,
    num,
    pointsAwarded: pts,
    p1PointsBefore: p1Points,
    p2PointsBefore: p2Points,
    pointsGoTo: foe // Points go to the attacker (foe)
  });
  
  // [POINTS-FIX] Award points to the attacker (foe), not the owner of the knocked out Pokemon
  // foe is the player who knocked out the Pokemon (the attacker)
  if(foe==='player1') {
    p1Points+=pts;
  } else {
    p2Points+=pts;
  }
  
  // Update globalThis.points immediately so updatePointsUI can read them
  globalThis.p1Points = p1Points;
  globalThis.p2Points = p2Points;
  
  // Update points UI immediately
  if (typeof updatePointsUI === 'function') {
  updatePointsUI();
    console.log('[KNOCKOUT-POINTS] Called updatePointsUI()');
  } else {
    console.warn('[KNOCKOUT-POINTS] updatePointsUI function not found');
  }
  
  console.log('[KNOCKOUT-POINTS] Points after KO:', {
    p1Points,
    p2Points,
    globalP1Points: globalThis.p1Points,
    globalP2Points: globalThis.p2Points
  });
  
  // Sync points to Firebase if in online mode
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
  
  if (isOnline && typeof updateGameStatePartial === 'function') {
    // [POINTS-SYNC-FIX] Map foe (attacker in UI terms) to match player correctly
    // foe is the attacker who gets the points
    // If isP1 is true: UI player1 = match player1, UI player2 = match player2
    // If isP1 is false: UI player1 = match player2, UI player2 = match player1
    const matchFoe = (isP1 && foe === 'player1') || (!isP1 && foe === 'player2') 
      ? 'player1' 
      : 'player2';
    
    // The points value should be the attacker's points
    const attackerPoints = foe === 'player1' ? p1Points : p2Points;
    
    try {
      // Update points in Firebase - sync to the attacker's match player
      await updateGameStatePartial({
        [`${matchFoe}/points`]: attackerPoints
      });
      console.log('[KNOCKOUT-POINTS] Points synced to Firebase:', {
        foe,
        isP1,
        matchFoe,
        path: `${matchFoe}/points`,
        attackerPoints,
        p1Points,
        p2Points
      });
    } catch (error) {
      console.error('[KNOCKOUT-POINTS] Error syncing points to Firebase:', error);
    }
  }
  
  if(p1Points>=3||p2Points>=3){
    showVictory(p1Points>=3?'player1':'player2','Reached 3 points');
    return true;
  }
  
  // Sync KO to Firebase if in online mode
  if (isActive) {
    if (isOnline && typeof updateGameStatePartial === 'function') {
      const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
        ? 'player1' 
        : 'player2';
      
      try {
        // Clear active slot in Firebase
        await updateGameStatePartial({
          [`${matchOwner}/active`]: null
        });
        
        // Broadcast KO action
        if (typeof broadcastAction === 'function' && ACTION_TYPES) {
          await broadcastAction(ACTION_TYPES.KNOCK_OUT, {
            owner: matchOwner,
            pokemon: {
              set: set,
              num: num,
              name: img.alt,
              instanceId: img.dataset.instanceId
            },
            points: pts,
            turnNumber: globalThis.turnNumber || 0
          });
        }
        
        console.log('[ISSUE-5] KO synced to Firebase:', {
          matchOwner,
          pokemonName: img.alt,
          points: pts
        });
      } catch (error) {
        console.error('Error syncing KO to Firebase:', error);
      }
    }
  }
  
  if(isActive && checkBenchOut(owner)){
    showVictory(foe,'Bench out');
    return true;
  }
  
  return false;
}

async function damageActiveOf(player, amount, options = {}) {
  const img = getActiveImage(player);
  if (!img) return { knocked: false, hpText: '' };
  
  const pk = player === 'player1' ? 'p1' : 'p2';
  
  
  const isDirectAttack = options.isDirectAttack !== false; 
  const attackerImg = options.attackerImg; 

  amount = applySpecialEffectsToDamage(pk, amount);

  
  
  const reduction = getPassiveDamageReduction(pk);
  if (reduction > 0) {
    amount = Math.max(0, amount - reduction);
    showPopup(`Ability reduced damage by ${reduction}!`);
  }
  
  
  const slot = img.closest('.card-slot');
  const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  
  const base = modifiedMaxHp || parseInt(img.dataset.hp || '0', 10) || 0;
  let chp = parseInt(img.dataset.chp || base || '0', 10) || base;
  
  
  if (isDirectAttack && attackerImg && shouldBlockDamageFromEx(pk, attackerImg)) {
    
    const shield = document.createElement('div');
    shield.className = 'safeguard-shield';
    shield.innerHTML = '';
    shield.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 60px;
      z-index: 9999;
      animation: safeguardPulse 0.8s ease-out;
      pointer-events: none;
    `;
    slot.appendChild(shield);
    
    
    if (!document.getElementById('safeguard-animation-style')) {
      const style = document.createElement('style');
      style.id = 'safeguard-animation-style';
      style.textContent = `
        @keyframes safeguardPulse {
          0% {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.3);
            filter: drop-shadow(0 0 10px rgba(59, 130, 246, 0.8));
          }
          50% {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
            filter: drop-shadow(0 0 20px rgba(59, 130, 246, 1));
          }
          100% {
            opacity: 0;
            transform: translate(-50%, -50%) scale(1.5);
            filter: drop-shadow(0 0 30px rgba(59, 130, 246, 0.4));
          }
        }
      `;
      document.head.appendChild(style);
    }
    
    
    setTimeout(() => shield.remove(), 800);
    
    showPopup(`Safeguard: ${img.alt} takes no damage from ${attackerImg.alt}!`);
    return { knocked: false, hpText: `${chp} / ${base}` };
  }
  
  chp = Math.max(0, chp - amount);
  setHpOnImage(img, base, chp);
  
  // [ISSUE-5] Track when Pokemon reaches 0 HP
  if (chp <= 0) {
    console.log('[ISSUE-5] Pokemon reached 0 HP:', {
      player,
      pokemonName: img.alt,
      base,
      chp,
      amount,
      willKnockout: true
    });
  }
  
  slot.classList.add('damage-flash');
  setTimeout(() => slot.classList.remove('damage-flash'), 400);

  if (currentZoom.img && currentZoom.img === img) {
    const pct = base > 0 ? Math.round((chp / base) * 100) : 0;
    zoomHp.textContent = `HP: ${chp} / ${base}`;
    zoomHpBar.style.width = pct + "%";
    zoomHpBar.style.background = (chp === base)
      ? 'linear-gradient(90deg,#22c55e,#16a34a)'
      : 'linear-gradient(90deg,#f43f5e,#ef4444)';
  }
  
  if (amount > 0 && isDirectAttack) {
    const counterDmg = getCounterattackDamage(pk);
    if (counterDmg > 0) {
      const attacker = player === 'player1' ? 'player2' : 'player1';
      showPopup(`Counterattack: Dealt ${counterDmg} damage back!`);
      setTimeout(async () => {
        const counterResult = await damageActiveOf(attacker, counterDmg, { isDirectAttack: false });
        
        if (counterResult.knocked && typeof handleKnockOut === 'function') {
          const attackerImg = getActiveImage(attacker);
          if (attackerImg) {
            const gameEnded = await handleKnockOut(attacker, attackerImg, true);
            if (!gameEnded && typeof beginPromotionFlow === 'function') {
              await beginPromotionFlow(attacker);
            }
          }
        }
      }, 600);
    }
    
    
    if (img.dataset.counterDamageNextTurn) {
      const counterDamage = parseInt(img.dataset.counterDamageNextTurn, 10);
      const attacker = player === 'player1' ? 'player2' : 'player1';
      showPopup(`Counter activated: Dealt ${counterDamage} damage back!`);
      delete img.dataset.counterDamageNextTurn; 
      
      setTimeout(async () => {
        const counterResult = await damageActiveOf(attacker, counterDamage, { isDirectAttack: false });
        
        if (counterResult.knocked && typeof handleKnockOut === 'function') {
          const attackerImg = getActiveImage(attacker);
          if (attackerImg) {
            const gameEnded = await handleKnockOut(attacker, attackerImg, true);
            if (!gameEnded && typeof beginPromotionFlow === 'function') {
              await beginPromotionFlow(attacker);
            }
          }
        }
      }, 800);
    }
    
    
    const tool = getToolDataFromSlot(slot);
    if (tool && tool.set && tool.num) {
      const cardId = `${tool.set}-${tool.num}`;
      
      
      if (cardId === 'A2-148') {
        const helmetDamage = 20;
        const attacker = player === 'player1' ? 'player2' : 'player1';
        showPopup(`Rocky Helmet: Dealt ${helmetDamage} damage back!`);
        setTimeout(async () => {
          const helmetResult = await damageActiveOf(attacker, helmetDamage, { isDirectAttack: false });
          
          if (helmetResult.knocked && typeof handleKnockOut === 'function') {
            const attackerImg = getActiveImage(attacker);
            if (attackerImg) {
              const gameEnded = await handleKnockOut(attacker, attackerImg, true);
              if (!gameEnded && typeof beginPromotionFlow === 'function') {
                beginPromotionFlow(attacker);
              }
            }
          }
        }, 800);
      }
      
      
      if (cardId === 'A3-146') {
        const attacker = player === 'player1' ? 'player2' : 'player1';
        const attackerPk = attacker === 'player1' ? 'p1' : 'p2';
        if (typeof setStatus === 'function') {
          setStatus(attackerPk, 'poisoned');
          showPopup(`Poison Barb: Poisoned the attacker!`);
        }
      }
    }
  }

  if (chp <= 0) {
    
    if (typeof getAbilityRow === 'function' && typeof globalThis.applyAbilityEffectFromCsv === 'function') {
      try {
        const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
        
        if (abilityRow?.effect_type === 'flip_avoid_knockout') {
          const pk = player === 'player1' ? 'p1' : 'player2';
          const result = await globalThis.applyAbilityEffectFromCsv(abilityRow, pk, { targetImg: img });
          
          if (result?.avoided) {

            return { knocked: false, owner: player };
          }
        }
      } catch (err) {
      }
    }
    
    const owner = img.closest('#player1') ? 'player1' : 'player2';
    return { knocked: true, owner };
  }
  
  return { knocked: false };
}
function showTrainerCardAnimation(cardImg, cardName) {
  // Create a large version of the card in the center of the screen
  const cardRect = cardImg.getBoundingClientRect();
  const cardSrc = cardImg.src;
  
  const overlay = document.createElement('div');
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 20000;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  `;
  
  const cardClone = document.createElement('img');
  cardClone.src = cardSrc;
  cardClone.alt = cardName;
  cardClone.style.cssText = `
    width: 300px;
    height: auto;
    max-height: 80vh;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    transform: scale(0.8);
    transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
    opacity: 0;
  `;
  
  overlay.appendChild(cardClone);
  document.body.appendChild(overlay);
  
  // Fade in
  requestAnimationFrame(() => {
    overlay.style.opacity = '1';
    cardClone.style.opacity = '1';
    cardClone.style.transform = 'scale(1)';
  });
  
  // Fade out after 1 second
  setTimeout(() => {
    overlay.style.opacity = '0';
    cardClone.style.opacity = '0';
    cardClone.style.transform = 'scale(0.8)';
    
    setTimeout(() => {
      overlay.remove();
    }, 300);
  }, 1000);
}

function animateCardToHand(pk, cardObj) {
  
  const img = document.createElement('img');
  img.src = cardObj.image;
  img.style.position = 'fixed';
  img.style.width = '48px';
  img.style.height = '67px';
  img.style.pointerEvents = 'none';
  img.style.zIndex = 99999;
  img.style.borderRadius = '6px';
  img.style.left = '50%';
  img.style.top = '50%';
  img.style.transform = 'translate(-50%, -50%) scale(2)';
  img.style.opacity = '1';
  img.style.transition = 'all .4s ease-out';

  document.body.appendChild(img);
  
  const handElm = pk === 'p1' ? document.getElementById('p1Hand') : document.getElementById('p2Hand');
  const rect = handElm.getBoundingClientRect();

  setTimeout(() => {
    img.style.left = rect.left + 40 + 'px';
    img.style.top = rect.top + 10 + 'px';
    img.style.transform = 'translate(0,0) scale(.6)';
    img.style.opacity = '0';
  }, 20);

  setTimeout(() => img.remove(), 420);
}

function animateSlideFromHand(sourceImg, targetSlot, targetCard) {
  if (!sourceImg || !targetSlot) return;
  
  
  if (typeof sourceImg.getBoundingClientRect !== 'function') {
    return;
  }
  
  
  if (targetCard) {
    targetCard.style.opacity = '0';
  }
  
  
  const sourceRect = sourceImg.getBoundingClientRect();
  const animationDuration = 250; 
  
  
  requestAnimationFrame(() => {
    const targetRect = targetSlot.getBoundingClientRect();
    
    
    const clone = sourceImg.cloneNode(true);
    clone.style.cssText = `
      position: fixed;
      left: ${sourceRect.left}px;
      top: ${sourceRect.top}px;
      width: ${sourceRect.width}px;
      height: ${sourceRect.height}px;
      z-index: 10000;
      pointer-events: none;
      transition: all ${animationDuration}ms cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 1;
    `;
    document.body.appendChild(clone);
    
    
    void clone.offsetWidth;
    
    
    requestAnimationFrame(() => {
      clone.style.left = `${targetRect.left}px`;
      clone.style.top = `${targetRect.top}px`;
      clone.style.width = `${targetRect.width}px`;
      clone.style.height = `${targetRect.height}px`;
      clone.style.opacity = '0.8';
    });
    
    
    setTimeout(() => {
      clone.remove();
      if (targetCard) {
        targetCard.style.opacity = '1';
        targetCard.style.transition = 'opacity 0.1s ease';
      }
    }, animationDuration);
  });
}

function animateSlideSwap(sourceImg, targetSlot, targetCard, sourceRect) {
  if (!sourceImg || !targetSlot) return;
  
  
  if (targetCard) {
    targetCard.style.opacity = '0';
  }
  
  
  const sourcePosition = sourceRect || sourceImg.getBoundingClientRect();
  const animationDuration = 250; 
  
  
  requestAnimationFrame(() => {
    const targetRect = targetSlot.getBoundingClientRect();
    
    
    const clone = sourceImg.cloneNode(true);
    clone.style.cssText = `
      position: fixed;
      left: ${sourcePosition.left}px;
      top: ${sourcePosition.top}px;
      width: ${sourcePosition.width}px;
      height: ${sourcePosition.height}px;
      z-index: 10000;
      pointer-events: none;
      transition: all ${animationDuration}ms cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 1;
    `;
    document.body.appendChild(clone);
    
    
    void clone.offsetWidth;
    
    
    requestAnimationFrame(() => {
      clone.style.left = `${targetRect.left}px`;
      clone.style.top = `${targetRect.top}px`;
      clone.style.width = `${targetRect.width}px`;
      clone.style.height = `${targetRect.height}px`;
      clone.style.opacity = '0.8';
    });
    
    
    setTimeout(() => {
      clone.remove();
      if (targetCard) {
        targetCard.style.opacity = '1';
        targetCard.style.transition = 'opacity 0.1s ease';
      }
    }, animationDuration);
  });
}


async function calculatePreviewDamage(attack, attackerImg, meta, pk) {
  if (!attack || !attackerImg || !meta) {
    const baseDmg = attack?.damage || '';
    return { damage: baseDmg, hasWeakness: false, hasOtherBoosts: false };
  }
  
  
  let damage = 0;
  let isMultiplicative = false;
  let multiplier = 1;
  if (attack.damage) {
    const dmgStr = String(attack.damage).toLowerCase();
    
    if (dmgStr.includes('x') || dmgStr.includes('')) {
      isMultiplicative = true;
      
      const multMatch = dmgStr.match(/(\d+)\s*[x]/);
      if (multMatch) {
        multiplier = parseInt(multMatch[1], 10);
      } else {
        multiplier = 1; 
      }
      damage = 0; 
    } else {
      
      const match = dmgStr.match(/\d+/);
      if (match) damage = parseInt(match[0], 10);
    }
  }
  
  
  try {
    if (typeof globalThis.getMoveRow === 'function' && typeof globalThis.loadMoveEffects === 'function') {
      await globalThis.loadMoveEffects();
      const moveRow = globalThis.getMoveRow(attackerImg.alt, attack.name);
      if (moveRow?.effect_type === 'bonus_damage_per_energy_on_opponent_all') {
        damage = 0; 
      } else if (moveRow?.effect_type === 'bonus_damage_for_each_bench') {
        damage = 0; 
      }
    }
  } catch (err) {
    console.error('[preview] Error checking move row for base damage:', err);
  }
  
  const foePk = pk === 'p1' ? 'p2' : 'p1';
  const foe = foePk === 'p1' ? 'player1' : 'player2';
  
  
  let hasWeakness = false;
  let hasOtherBoosts = false;
  const baseDamage = damage;
  let totalBonuses = 0; 
  
  
  const effectState = {
    p1: typeof playerState !== 'undefined' ? playerState.player1 : {},
    p2: typeof playerState !== 'undefined' ? playerState.player2 : {},
    activeFor: typeof activeFor === 'function' ? activeFor : () => null,
    benchFor: typeof benchFor === 'function' ? benchFor : () => null,
    opponentOf: typeof opponentOf === 'function' ? opponentOf : (p) => p === 'player1' ? 'player2' : 'player1',
    fetchCardMeta: typeof fetchCardMeta === 'function' ? fetchCardMeta : async () => ({}),
    damageActiveOf: typeof damageActiveOf === 'function' ? damageActiveOf : () => ({ knocked: false }),
    beginPromotionFlow: typeof beginPromotionFlow === 'function' ? beginPromotionFlow : () => {},
    showPopup: () => {}, 
    logEvent: () => {}
  };
  
  try {
      if (typeof applyMoveEffectFromCsv === 'function') {
      const result = await applyMoveEffectFromCsv(effectState, pk, attack.name, damage, { 
        moveName: attack.name,
        isFinal: false, 
        isMultiplicative: isMultiplicative,
        multiplier: multiplier,
        attackCost: attack.cost || [] 
      });
      
      if (typeof result === 'object' && result.damage !== undefined) {
        
        damage = result.damage;
        
        if (isMultiplicative && result.totalBonuses !== undefined) {
          totalBonuses = result.totalBonuses;
        }
      } else {
        
        damage = result;
        
        if (isMultiplicative) {
          totalBonuses = damage;
          damage = 0;
        }
      }
      
      
      
      
      try {
        
        if (typeof globalThis.loadMoveEffects === 'function') {
          await globalThis.loadMoveEffects();
        }
        
        if (typeof globalThis.getMoveRow === 'function') {
          const moveRow = globalThis.getMoveRow(attackerImg.alt, attack.name);
          if (moveRow?.effect_type === 'bonus_damage_if_last_move_name_used') {
            const moveName = moveRow.param1 || 'Sweets Relay';
            const bonus = parseInt(moveRow.param2 || '20', 10);
            
            
            if (!globalThis.__moveHistory) globalThis.__moveHistory = { p1: [], p2: [] };
            const lastTurnMoves = globalThis.__moveHistory[pk] || [];
            const usedLastTurn = lastTurnMoves.some(move => 
              move.name && move.name.toLowerCase() === moveName.toLowerCase()
            );
            
            if (usedLastTurn) {
              if (isMultiplicative) {
                totalBonuses += bonus;
              } else {
                damage += bonus;
              }
              hasOtherBoosts = true;
            }
          }
        }
      } catch (err) {
        console.error('[preview] Sweets Relay check failed:', err);
      }
      
      
      const boost = (globalThis.state?.temp?.[pk]?.globalDamageBoost ?? 0);
      if (boost) {
        if (isMultiplicative) {
          totalBonuses += boost;
        } else {
          damage += boost;
        }
        hasOtherBoosts = true;
      }
      
      
      const nextTurnBonus = (globalThis.state?.temp?.[pkToPlayer(pk)]?.nextTurnDamageBonus ?? 0);
      if (nextTurnBonus > 0) {
        if (isMultiplicative) {
          totalBonuses += nextTurnBonus;
        } else {
          damage += nextTurnBonus;
        }
        hasOtherBoosts = true;
      }
      
      
      const bonusKey = `${attackerImg.dataset.instanceId || attackerImg.alt}_${attack.name}`;
      const nextTurnBonus2 = globalThis.__attackBonuses?.[bonusKey] || 0;
      if (nextTurnBonus2 > 0) {
        if (isMultiplicative) {
          totalBonuses += nextTurnBonus2;
        } else {
          damage += nextTurnBonus2;
        }
        hasOtherBoosts = true;
      }
      
      
      const attackerSlot = attackerImg.closest('.card-slot');
      const tool = getToolDataFromSlot(attackerSlot);
      if (tool && tool.num === '066' && tool.set === 'A3a') {
        const ULTRA_BEASTS = [
          'nihilego', 'buzzwole', 'pheromosa', 'xurkitree', 'celesteela',
          'kartana', 'guzzlord', 'poipole', 'naganadel', 'stakataka', 'blacephalon'
        ];
        const attackerName = (attackerImg.alt || '').toLowerCase();
        const isUltraBeast = ULTRA_BEASTS.some(ub => attackerName.includes(ub));
        if (isUltraBeast) {
          const attackerPlayer = attackerImg.closest('#player1') ? 'player1' : 'player2';
          const points = attackerPlayer === 'player1' ? p1Points : p2Points;
          const bonus = points * 10;
          if (isMultiplicative) {
            totalBonuses += bonus;
          } else {
            damage += bonus;
          }
          hasOtherBoosts = true;
        }
      }
      
      
      if (globalThis.state?.damageBoost?.[pk]) {
        const boostData = globalThis.state.damageBoost[pk];
        if (boostData.target === 'eeveelution' && boostData.duration === 'this_turn') {
          const attackerName = (attackerImg.alt || '').toLowerCase();
          const isEeveelution = boostData.targetNames?.some(ee => attackerName.includes(ee));
          if (isEeveelution) {
            if (isMultiplicative) {
              totalBonuses += boostData.amount;
            } else {
              damage += boostData.amount;
            }
            hasOtherBoosts = true;
          }
        }
      }
      
      
      if (isMultiplicative) {
        damage = totalBonuses * multiplier;
      }
    }
  } catch (err) {
    console.error('[preview] Move effect error:', err);
  }
  
  
  try {
    const effectiveDamage = isMultiplicative ? totalBonuses : damage;
    if (effectiveDamage > 0 && typeof getActiveImage === 'function') {
      const foeImg = getActiveImage(foe);
      if (foeImg && typeof fetchCardMeta === 'function') {
        const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const wk = metaFoe?.weaknesses?.[0];
        if (wk) {
          const wkType = (wk.type || '').toLowerCase();
          if (wkType !== 'colorless') {
            const atkType = (meta.types?.[0] || '').toLowerCase();
            if (atkType === wkType) {
              damage += 20;
              hasWeakness = true;
            }
          }
        }
      }
    }
  } catch (err) {
    console.error('[preview] Weakness check failed:', err);
  }
  
  
  try {
    const attackerType = (meta.types?.[0] || '').toLowerCase();
    if (attackerType) {
      const fightingCoachBoost = getFightingCoachBoost(pk, attackerType);
      if (fightingCoachBoost > 0) {
        damage += fightingCoachBoost;
        hasOtherBoosts = true;
      }
    }
  } catch (err) {
    console.error('[preview] Fighting Coach check failed:', err);
  }
  
  
  try {
    const exBonus = globalThis.state?.temp?.[pk]?.damageVsEx || 0;
    if (exBonus > 0) {
      const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
      if (foeImg && typeof fetchCardMeta === 'function') {
        const foeMeta = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const isEx = foeMeta.suffix?.toUpperCase() === 'EX';
        if (isEx) {
          damage += exBonus;
          hasOtherBoosts = true;
        }
      }
    }
  } catch (err) {
    console.error('[preview] Red ex bonus check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg) {
      const attackerType = (meta.types?.[0] || '').toLowerCase();
      const thickFatReduction = getThickFatReduction(foeImg, attackerType);
      if (thickFatReduction > 0) damage = Math.max(0, damage - thickFatReduction);
    }
  } catch (err) {
    console.error('[preview] Thick Fat check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      const foePk2 = foe === 'player1' ? 'p1' : 'p2';
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      if (abilityRow?.effect_type === 'reduce_damage_if_arceus' && hasArceusInPlay(foePk2)) {
        const reduction = parseInt(abilityRow.param1 || '30', 10);
        damage = Math.max(0, damage - reduction);
      }
    }
  } catch (err) {
    console.error('[preview] reduce_damage_if_arceus check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      if (abilityRow?.effect_type === 'reduce_opponent_damage') {
        const reduction = parseInt(abilityRow.param1 || '20', 10);
        damage = Math.max(0, damage - reduction);
      }
    }
  } catch (err) {
    console.error('[preview] reduce_opponent_damage check failed:', err);
  }
  
  return { damage, hasWeakness, hasOtherBoosts };
}

async function handleAttackClick(attack, meta, ownerKey, activeDiv) {
  // Check if we're in online mode and if it's the current user's turn
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
  if (isOnline) {
    // In online mode, the current user is always UI player1
    // So only allow attacks from UI player1's Pokmon when it's their turn
    const uiOwner = ownerKey === 'p1' || ownerKey === 'player1' ? 'player1' : 'player2';
    if (uiOwner !== 'player1' || currentPlayer !== 'player1') {
      showPopup('Not your turn!');
      return;
    }
  }
  
  if (!activeDiv) {
    console.error('[attack] No active Pokemon found');
    return;
  }
  
  const pk = ownerKey === 'p1' || ownerKey === 'p2' ? ownerKey : (ownerKey === 'player1' ? 'p1' : 'p2');
  const slot = activeDiv.querySelector('.card-slot');
  if (!slot) {
    console.error('[attack] No card slot found');
    return;
  }
  
  let effectContext = null;
  
  const cost = attack.cost || [];
  
  
  if (typeof isActiveBlockedFromAttacking === 'function' && isActiveBlockedFromAttacking(pk)) {
    const imgBlocked = typeof getActiveImg === 'function' ? getActiveImg(pk) : null;
    const st = (imgBlocked?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      showPopup('This Pokmon is asleep and can\'t attack.');
    } else if (st === 'paralyzed') {
      showPopup('This Pokmon is paralyzed and can\'t attack.');
    }
    return;
  }
  
  
  const attackerImg = typeof getActiveImg === 'function' ? getActiveImg(pk) : null;
  if (globalThis.__specialEffects?.[pk]?.attackLockSelf) {
    showPopup('This Pokmon can\'t attack this turn!');
    delete globalThis.__specialEffects[pk].attackLockSelf;
    return;
  }
  
  
  const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
  if (attackLock) {
    let isLocked = false;
    const currentTurn = globalThis.turnNumber || 0;

    
    
    if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
      
      isLocked = currentTurn === attackLock.lockedOnTurn + 2;
    } else if (typeof attackLock === 'object' && attackLock.locked !== undefined) {
      
      if (attackLock.lockedOnTurn !== undefined) {
        isLocked = currentTurn === attackLock.lockedOnTurn + 2;
      } else {
        isLocked = attackLock.locked === true;
      }
    } else if (attackLock === true) {
      
      isLocked = true;
    }
    
    if (isLocked) {
      showPopup('This Pokmon can\'t attack this turn!');
      return;
    }
  }
  
  
  if (attackerImg) {
    const instanceId = attackerImg.dataset.instanceId;
    const moveName = attack.name?.toLowerCase();
    const moveLock = globalThis.__moveLocks?.[pk]?.[instanceId]?.[moveName];
    if (instanceId && moveName && moveLock) {
      
      const currentTurn = globalThis.turnNumber || 0;
      let isLocked = false;
      
      if (typeof moveLock === 'object' && moveLock.lockedOnTurn !== undefined) {
        
        isLocked = currentTurn === moveLock.lockedOnTurn + 2;
      } else {
        
        isLocked = moveLock === true;
      }
      
      if (isLocked) {
        showPopup(`This Pokmon can't use ${attack.name} this turn!`);
        return;
      }
    }
  }
  
  
  if (globalThis.__specialEffects?.[pk]?.attackLockFlip) {
    showPopup('Must flip to attack...');
    
    const flip = Math.random() < 0.5;
    
    if (flip) {
      
      showPopup('Heads! Attack proceeds.');
      delete globalThis.__specialEffects[pk].attackLockFlip;
    } else {
      
      showPopup('Tails! Attack failed!');
      delete globalThis.__specialEffects[pk].attackLockFlip;
      closeAttackMenu();
      return;
    }
  }
  
  
  if (attackerImg && attackerImg.dataset.status?.toLowerCase() === 'confusion') {
    
    const flip = Math.random() < 0.5;
    
    if (flip) {
      
      showPopup('Confusion: Heads! Attack succeeds.');
      delete attackerImg.dataset.status;
    } else {
      
      showPopup('Confusion: Tails! This Pokmon hurt itself in confusion!');
      
      const player = pk === 'p1' ? 'player1' : 'player2';
      if (typeof damageActiveOf === 'function') {
        setTimeout(async () => {
          await damageActiveOf(player, 20, { isDirectAttack: false });
        }, 500);
      }
      
      
      delete attackerImg.dataset.status;
      
      
      closeAttackMenu();
      return;
    }
  }
  
  
  const foePk = pk === 'p1' ? 'p2' : 'p1';
  const foe = foePk === 'p1' ? 'player1' : 'player2';  
  
  
  let damage = 0;
  let isMultiplicative = false;
  let multiplier = 1;
  let totalBonuses = 0;
  if (attack.damage) {
    const dmgStr = String(attack.damage).toLowerCase();
    
    if (dmgStr.includes('x') || dmgStr.includes('')) {
      isMultiplicative = true;
      
      const multMatch = dmgStr.match(/(\d+)\s*[x]/);
      if (multMatch) {
        multiplier = parseInt(multMatch[1], 10);
      } else {
        multiplier = 1; 
      }
      damage = 0; 
    } else {
      
    const match = dmgStr.match(/\d+/);
      if (match) damage = parseInt(match[0], 10);
    }
  }
  
  
  try {
    if (typeof globalThis.getMoveRow === 'function' && typeof globalThis.loadMoveEffects === 'function') {
      await globalThis.loadMoveEffects();
      const moveRow = globalThis.getMoveRow(attackerImg.alt, attack.name);
      if (moveRow?.effect_type === 'bonus_damage_per_energy_on_opponent_all') {
        damage = 0; 
      } else if (moveRow?.effect_type === 'bonus_damage_for_each_bench') {
        damage = 0; 
      }
    }
  } catch (err) {
    console.error('[attack] Error checking move row for base damage:', err);
  }
  
  
  const effectState = {
    p1: typeof playerState !== 'undefined' ? playerState.player1 : {},
    p2: typeof playerState !== 'undefined' ? playerState.player2 : {},
    activeFor: typeof activeFor === 'function' ? activeFor : () => null,
    benchFor: typeof benchFor === 'function' ? benchFor : () => null,
    opponentOf: typeof opponentOf === 'function' ? opponentOf : (p) => p === 'player1' ? 'player2' : 'player1',
    fetchCardMeta: typeof fetchCardMeta === 'function' ? fetchCardMeta : async () => ({}),
    damageActiveOf: typeof damageActiveOf === 'function' ? damageActiveOf : () => ({ knocked: false }),
    beginPromotionFlow: typeof beginPromotionFlow === 'function' ? beginPromotionFlow : () => {},
    showPopup: showPopup,
    logEvent: typeof logEvent === 'function' ? logEvent : () => {}
  };
  
  try {
    if (typeof applyMoveEffectFromCsv === 'function') {
      const result = await applyMoveEffectFromCsv(effectState, pk, attack.name, damage, { 
        moveName: attack.name,
        isFinal: true, 
        isMultiplicative: isMultiplicative,
        multiplier: multiplier,
        attackCost: attack.cost || [] 
      });
      
      
      if (typeof result === 'object' && result.damage !== undefined) {
        damage = result.damage;
        effectContext = result.context;
        
        if (isMultiplicative && result.totalBonuses !== undefined) {
          totalBonuses = result.totalBonuses;
        }
      } else {
        damage = result;
        
        if (isMultiplicative) {
          totalBonuses = damage;
          damage = 0;
        }
      }
      
      
      const boost = (globalThis.state?.temp?.[pk]?.globalDamageBoost ?? 0);
      if (boost) {
        if (isMultiplicative) {
          totalBonuses += boost;
        } else {
        damage += boost;
        }
      }
      
      
      const nextTurnBonus = (globalThis.state?.temp?.[pkToPlayer(pk)]?.nextTurnDamageBonus ?? 0);
      if (nextTurnBonus > 0) {
        if (isMultiplicative) {
          totalBonuses += nextTurnBonus;
        } else {
        damage += nextTurnBonus;
        }
        
        if (globalThis.state?.temp?.[pkToPlayer(pk)]) {
          globalThis.state.temp[pkToPlayer(pk)].nextTurnDamageBonus = 0;
        }
      }
      
      
      if (attackerImg) {
        const bonusKey = `${attackerImg.dataset.instanceId || attackerImg.alt}_${attack.name}`;
        const nextTurnBonus = globalThis.__attackBonuses?.[bonusKey] || 0;
        
        if (nextTurnBonus > 0) {
          if (isMultiplicative) {
            totalBonuses += nextTurnBonus;
          } else {
          damage += nextTurnBonus;
          }
          showPopup(`+${nextTurnBonus} bonus damage!`);
          
          
          delete globalThis.__attackBonuses[bonusKey];
        }
      }
      
      
      if (attackerImg) {
        const attackerSlot = attackerImg.closest('.card-slot');
        const tool = getToolDataFromSlot(attackerSlot);
        
        if (tool && tool.num === '066' && tool.set === 'A3a') {
          
          const ULTRA_BEASTS = [
            'nihilego', 'buzzwole', 'pheromosa', 'xurkitree', 'celesteela',
            'kartana', 'guzzlord', 'poipole', 'naganadel', 'stakataka', 'blacephalon'
          ];
          
          const attackerName = (attackerImg.alt || '').toLowerCase();
          const isUltraBeast = ULTRA_BEASTS.some(ub => attackerName.includes(ub));
          
          if (isUltraBeast) {
            
            const attackerPlayer = attackerImg.closest('#player1') ? 'player1' : 'player2';
            const points = attackerPlayer === 'player1' ? p1Points : p2Points;
            
            const beastiteBonus = points * 10;
            if (beastiteBonus > 0) {
              if (isMultiplicative) {
                totalBonuses += beastiteBonus;
              } else {
              damage += beastiteBonus;
              }
              showPopup(`Beastite: +${beastiteBonus} damage! (${points} points  10)`);
            }
          }
        }
      }
      
      
      if (attackerImg && globalThis.state?.damageBoost?.[pk]) {
        const boostData = globalThis.state.damageBoost[pk];
        if (boostData.target === 'eeveelution' && boostData.duration === 'this_turn') {
          const attackerName = (attackerImg.alt || '').toLowerCase();
          const isEeveelution = boostData.targetNames?.some(ee => attackerName.includes(ee));
          
          if (isEeveelution) {
            if (isMultiplicative) {
              totalBonuses += boostData.amount;
            } else {
              damage += boostData.amount;
            }
            showPopup(`Eevee Bag: +${boostData.amount} damage!`);
          }
        }
      }
      
      
      if (isMultiplicative) {
        damage = totalBonuses * multiplier;
      }
    }
  } catch (err) {
    console.error('[attack] Move effect error:', err);
  }
  
  
  try {
    if (damage > 0 && typeof getActiveImage === 'function') {
      const foeImg = getActiveImage(foe);
      if (foeImg && typeof fetchCardMeta === 'function') {
        const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const wk = metaFoe?.weaknesses?.[0];
        
        if (wk) {
          const wkType = (wk.type || '').toLowerCase();
          if (wkType !== 'colorless') {
            const atkType = (meta.types?.[0] || '').toLowerCase();
            if (atkType === wkType) {
              damage += 20;
            }
          }
        }
      }
    }
  } catch (err) {
    console.error('[attack] Weakness check failed:', err);
  }
  
  
  try {
    const attackerType = (meta.types?.[0] || '').toLowerCase();
    if (attackerType) {
      const fightingCoachBoost = getFightingCoachBoost(pk, attackerType);
      if (fightingCoachBoost > 0) {
        damage += fightingCoachBoost;
      }
    }
  } catch (err) {
    console.error('[attack] Fighting Coach check failed:', err);
  }
  
  
  try {
    const exBonus = globalThis.state?.temp?.[pk]?.damageVsEx || 0;
    if (exBonus > 0) {
      
      const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
      if (foeImg && typeof fetchCardMeta === 'function') {
        const foeMeta = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const isEx = foeMeta.suffix?.toUpperCase() === 'EX';
        
        if (isEx) {
          damage += exBonus;
        }
      }
    }
  } catch (err) {
    console.error('[attack] Red ex bonus check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg) {
      const attackerType = (meta.types?.[0] || '').toLowerCase();
      const thickFatReduction = getThickFatReduction(foeImg, attackerType);
      if (thickFatReduction > 0) {
        damage = Math.max(0, damage - thickFatReduction);
        showPopup(`Thick Fat: Reduced ${thickFatReduction} damage!`);
      }
    }
  } catch (err) {
    console.error('[attack] Thick Fat check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      damage = applyGuardedGrill(foeImg, damage);
    }
  } catch (err) {
    console.error('[attack] Guarded Grill check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      const foePk = foe === 'player1' ? 'p1' : 'p2';
      
      
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_damage_if_arceus' && hasArceusInPlay(foePk)) {
        const reduction = parseInt(abilityRow.param1 || '30', 10);
        damage = Math.max(0, damage - reduction);
        showPopup(`${abilityRow.abilityName}: Reduced ${reduction} damage!`);
      }
    }
  } catch (err) {
    console.error('[attack] reduce_damage_if_arceus check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_opponent_damage') {
        const reduction = parseInt(abilityRow.param1 || '20', 10);
        damage = Math.max(0, damage - reduction);
        showPopup(`${abilityRow.abilityName}: Reduced ${reduction} damage!`);
      }
    }
  } catch (err) {
    console.error('[attack] reduce_opponent_damage check failed:', err);
  }
  
  
  let knocked = false;
  if (typeof damageActiveOf === 'function') {
    const result = await damageActiveOf(foe, damage, { attackerImg: attackerImg });
    knocked = result.knocked;
    showPopup(`${meta.name} used ${attack.name}${damage > 0 ? ` for ${damage} damage!` : '!'}`);
    if (typeof logEvent === 'function') {
      const owner = pk === 'p1' ? 'player1' : 'player2';
      logEvent({
        player: owner,
        text: `${meta.name} used ${attack.name}${damage > 0 ? ` for ${damage} damage` : ''}`,
        cardSet: attackerImg?.dataset?.set,
        cardNum: attackerImg?.dataset?.num
      });
    }
    
    // Sync attack to Firebase
    const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
    const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
    const isOnline = matchId && window.firebaseDatabase;
    if (isOnline && typeof broadcastAction === 'function') {
      const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
      const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
      const owner = pk === 'p1' ? 'player1' : 'player2';
      const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
        ? 'player1' 
        : 'player2';
      const matchFoe = matchOwner === 'player1' ? 'player2' : 'player1';
      
      try {
        await broadcastAction(ACTION_TYPES.ATTACK, {
          attacker: {
            owner: matchOwner,
            set: attackerImg?.dataset?.set,
            num: attackerImg?.dataset?.num,
            name: meta.name,
            instanceId: attackerImg?.dataset?.instanceId
          },
          attack: {
            name: attack.name,
            damage: damage,
            cost: attack.cost || []
          },
          target: {
            owner: matchFoe,
            position: 'active'
          },
          knocked: knocked,
          turnNumber: globalThis.turnNumber || 0
        });
        // Attack synced to Firebase
      } catch (error) {
        console.error('Error syncing attack to Firebase:', error);
      }
    }
  } else {
    showPopup(`${meta.name} used ${attack.name}!`);
    if (typeof logEvent === 'function') {
      const owner = pk === 'p1' ? 'player1' : 'player2';
      logEvent({
        player: owner,
        text: `${meta.name} used ${attack.name}`,
        cardSet: attackerImg?.dataset?.set,
        cardNum: attackerImg?.dataset?.num
      });
    }
  }
  
  
  closeAttackMenu();
  
  
  // Handle KO - check knocked status immediately after damage
  // Reuse getCurrentMatchIdFn and isOnline from above if they were declared
  if (knocked) {
        // [ISSUE-5] Knockout detected
    
    // Get the active image again after damage - it might have changed
    let foeImg = null;
    if (typeof getActiveImage === 'function') {
      foeImg = getActiveImage(foe);
    }
    // Fallback: find the active image directly from DOM
    if (!foeImg) {
      const activeArea = typeof activeFor === 'function' ? activeFor(foe) : null;
      if (activeArea) {
        const activeSlot = activeArea.querySelector('.card-slot');
        foeImg = activeSlot?.querySelector('img');
      }
    }
    
    if (foeImg && typeof handleKnockOut === 'function') {
      console.log('[ISSUE-5] Handling knockout:', {
        foe,
        pokemonName: foeImg.alt,
        hp: foeImg.dataset.chp || foeImg.dataset.hp
      });
      // Check if the knocked out pokemon was active
      const wasActivePokemon = foeImg && foeImg.closest('.active') !== null;
      
      const ended = await handleKnockOut(foe, foeImg, wasActivePokemon);
      if (ended) return;
      
      // In online mode, only the opponent (owner of knocked out pokemon) should trigger promotion
      // The attacker's side should NOT trigger promotion - let the opponent handle it via handleOpponentKnockOut
      // In local mode, the owner of the knocked out pokemon should trigger promotion
      if (!isOnline && typeof beginPromotionFlow === 'function' && wasActivePokemon) {
        // Only trigger promotion locally if not in online mode and pokemon was active
        await beginPromotionFlow(foe);
      }
      
      // If active pokemon was knocked out by an attack, end the turn
      if (wasActivePokemon) {
        // End turn after KO - this will be handled by the turn ending logic below
        // [ISSUE-5] Active pokemon KOed, turn should end
      }
    } else {
      console.error('[ISSUE-5] Could not find active pokemon or handleKnockOut function!', { 
        foe, 
        knocked,
        foeImg: !!foeImg,
        hasHandleKnockOut: typeof handleKnockOut === 'function'
      });
    }
  }
  
  // Update energy visuals after attack to sync across both players
  if (typeof updateAllEnergyVisuals === 'function') {
    updateAllEnergyVisuals();
  }
  
  
  if (knocked && effectContext?.checkKoForRecoil) {
    const recoilDamage = effectContext.checkKoForRecoil;
    const attacker = pk === 'p1' ? 'player1' : 'player2'; 
    setTimeout(async () => {
      if (typeof damageActiveOf === 'function') {
        await damageActiveOf(attacker, recoilDamage, { isDirectAttack: false });
        showPopup(`Rampardos took ${recoilDamage} recoil damage!`);
      }
    }, 800);
  }
  
  
  
  // In online mode, end the turn after attacking (which will sync to Firebase)
  // If active pokemon was KOed by an attack, always end the turn
  // In local mode, start the next player's turn
  // Reuse getCurrentMatchIdFn, matchId, and isOnline from the top of the function
  // Check if active pokemon was KOed
  const foeImgForKo = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
  const wasActiveKo = knocked && foeImgForKo && foeImgForKo.closest && foeImgForKo.closest('.active') !== null;
  
  if (isOnline || wasActiveKo) {
    // In online mode or if active pokemon was KOed, sync turn change to Firebase after attack
    setTimeout(async () => {
      const updateGameStatePartialFn = updateGameStatePartial || globalThis.updateGameStatePartial;
      const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
      if (updateGameStatePartialFn) {
        try {
          const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
          const owner = pk === 'p1' ? 'player1' : 'player2';
          // Map UI player to match player
          const matchCurrentPlayer = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
            ? 'player1' 
            : 'player2';
          const matchNextPlayer = matchCurrentPlayer === 'player1' ? 'player2' : 'player1';
          
          // Increment turn number
          const newTurnNumber = (globalThis.turnNumber || 0) + 1;
          
          // Sync to Firebase
          await updateGameStatePartialFn({
            'currentPlayer': matchNextPlayer,
            'turnNumber': newTurnNumber
          });
          // Turn change synced to Firebase
          
          // Update local turn number
          globalThis.turnNumber = newTurnNumber;
        } catch (error) {
          console.error('Error syncing turn change after attack:', error);
        }
      }
    }, 500);
  } else {
    // Local mode: start the next player's turn
  if (typeof startTurn === 'function') {
    setTimeout(() => startTurn(foe), 300);
    }
  }

}

async function handleRetreat(activeDiv, meta, retreatCost) {


  if (hasRetreatedThisTurn) {
    showPopup('You can only retreat once per turn!');
    return;
  }
  
  
  if (!activeDiv) {
    console.error('[RETREAT] ERROR - activeDiv is null!');
    showPopup('Cannot retreat - invalid active area');
    return;
  }
  
  const slot = activeDiv.querySelector('.card-slot');
  if (!slot) {
    console.error('[retreat] No card slot found');
    return;
  }
  
  
  if (retreatCost > 0) {
    const energyPipsContainer = slot.querySelector('.energy-pips');
    if (!energyPipsContainer) {
      console.error('[retreat] No energy pips found');
      return;
    }
    
    const pips = energyPipsContainer.querySelectorAll('.energy-pip');
    if (pips.length < retreatCost) {
      showPopup(`Not enough energy to retreat! Need ${retreatCost}, have ${pips.length}`);
      return;
    }
  } else {
  }
  
  
  let ownerKey = null;
  if (activeDiv.closest('#player1')) ownerKey = 'player1';
  else if (activeDiv.closest('#player2')) ownerKey = 'player2';
  
  if (!ownerKey) {
    console.error('[retreat] Could not determine owner');
    return;
  }
  
  
  let hasBench = false;
  if (typeof benchFor === 'function') {
    const benchDiv = benchFor(ownerKey);
    if (benchDiv) {
      const benchSlots = benchDiv.querySelectorAll('.card-slot');
      const occupied = Array.from(benchSlots).filter(s => {
        const img = s.querySelector('img');
        return img && img.dataset.set && img.dataset.num;
      });
      hasBench = occupied.length > 0;
    }
  } else {
    
    const pk = ownerKey === 'player1' ? 'p1' : 'p2';
    const bench = document.querySelector(`#${pk}-bench`);
    if (bench) {
      const benchSlots = bench.querySelectorAll('.card-slot');
      const occupied = Array.from(benchSlots).filter(s => {
        const img = s.querySelector('img');
        return img && img.dataset.set && img.dataset.num;
      });
      hasBench = occupied.length > 0;
    }
  }
  
  if (!hasBench) {
    showPopup('No bench Pokemon to retreat to!');
    return;
  }
  
  
  const storedRetreatCost = retreatCost;
  

  closeAttackMenu();
    isRetreatSelection,

  isRetreatSelection = true;
  
  
  showPopup(`${meta.name} retreated! Choose new active Pokemon (or click anywhere to cancel).`);
  
  
  const benchDiv = typeof benchFor === 'function' ? benchFor(ownerKey) : 
    document.querySelector(`#${ownerKey === 'player1' ? 'p1' : 'p2'}-bench`);
  
  if (!benchDiv) {
    console.error('[retreat] Could not find bench div');
    return;
  }
  
  
  const benchImgs = benchDiv.querySelectorAll('img');
  benchImgs.forEach(img => {
    if (img.dataset.set && img.dataset.num) {
      img.classList.add('promote-glow');
    }
  });
  
  
  const selectReplacement = (e) => {
    if (e.target.closest('#zoomBackdrop') || e.target.closest('.attack-menu') || e.target.closest('#handBackdrop') || e.target.closest('#toolBackdrop')) {
      return;
    }
    
    if (!isRetreatSelection) {
      document.body.removeEventListener('click', selectReplacement, true);
      return;
    }

    
    
    const chosenImg = e.target.closest(`#${ownerKey} .bench img`);
    
    if (chosenImg && chosenImg.dataset.set && chosenImg.dataset.num) {
      
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      document.body.removeEventListener('click', selectReplacement, true);
      
      
      isRetreatSelection = false;
      
      
      benchImgs.forEach(img => img.classList.remove('promote-glow'));
      
      
      if (typeof activeFor === 'function') {
        const activeDiv = activeFor(ownerKey);
        const activeSlot = activeDiv.querySelector('.card-slot');
        const benchSlot = chosenImg.closest('.card-slot');
        const activeImg = activeSlot.querySelector('img');
        
        
        // [RETREAT-LOGGING] Log bench state before retreat
        const benchDiv = benchFor(ownerKey);
        const benchBefore = Array.from(benchDiv.querySelectorAll('.card-slot img'))
          .filter(img => !img.classList.contains('tool-thumb'))
          .map(img => ({
            name: img.alt,
            set: img.dataset.set,
            num: img.dataset.num,
            instanceId: img.dataset.instanceId,
            hp: img.dataset.chp || img.dataset.hp,
            maxHp: img.dataset.hp
          }));
        
        console.log('[RETREAT-ENERGY-DEBUG-PLAYER] Step 1: Before detaching attachments', {
          owner: ownerKey,
          activePokemon: activeImg?.alt,
          benchPokemon: chosenImg?.alt,
          activeHasEnergy: !!activeSlot.querySelector('.energy-pips'),
          activePipCount: activeSlot.querySelectorAll('.energy-pip').length,
          benchHasEnergy: !!benchSlot.querySelector('.energy-pips'),
          benchPipCount: benchSlot.querySelectorAll('.energy-pip').length,
          benchBefore: benchBefore
        });
        
        const activePack = typeof detachAttachments === 'function' ? 
          detachAttachments(activeSlot) : { energy: [], tool: null };
        const benchPack = typeof detachAttachments === 'function' ? 
          detachAttachments(benchSlot) : { energy: [], tool: null };
        
        console.log('[RETREAT-ENERGY-DEBUG-PLAYER] Step 2: After detaching attachments', {
          activePack: {
            hasEnergy: !!activePack.energy,
            energyPipCount: activePack.energy ? activePack.energy.querySelectorAll('.energy-pip').length : 0
          },
          benchPack: {
            hasEnergy: !!benchPack.energy,
            energyPipCount: benchPack.energy ? benchPack.energy.querySelectorAll('.energy-pip').length : 0
          }
        });
        
        
        if (activeImg) {
          
          if (typeof clearStatusOnImg === 'function') {
            clearStatusOnImg(activeImg);
          }
          
          
          const activeInstanceId = activeImg.dataset.instanceId;
          const ownerPk = ownerKey === 'player1' ? 'p1' : 'p2';
          if (activeInstanceId && globalThis.__moveLocks?.[ownerPk]?.[activeInstanceId]) {
            delete globalThis.__moveLocks[ownerPk][activeInstanceId];
          }
          
          
          const activeRect = activeImg.getBoundingClientRect();
          const chosenRect = chosenImg.getBoundingClientRect();
          
          // [ISSUE-1: RETREAT DOUBLING] Track swap to detect duplicates
          console.log('[ISSUE-1] Retreat swap START:', {
            owner: ownerKey,
            activeBefore: activeImg.alt,
            benchBefore: chosenImg.alt,
            activeSlotHasImg: !!activeSlot.querySelector('img'),
            benchSlotHasImg: !!benchSlot.querySelector('img')
          });
          
          // Check if nodes are children before removing to prevent errors
          if (activeImg.parentNode === activeSlot) {
            activeSlot.removeChild(activeImg);
          }
          if (chosenImg.parentNode === benchSlot) {
            benchSlot.removeChild(chosenImg);
          }
          
          // [RETREAT-TOOL-FIX] Remove tool thumbs and energy pips before swapping to prevent duplicates
          const activeToolThumb = activeSlot.querySelector('.tool-thumb');
          const benchToolThumb = benchSlot.querySelector('.tool-thumb');
          const activeEnergyPips = activeSlot.querySelector('.energy-pips');
          const benchEnergyPips = benchSlot.querySelector('.energy-pips');
          
          if (activeToolThumb && activeToolThumb.parentNode === activeSlot) {
            activeToolThumb.remove();
          }
          if (benchToolThumb && benchToolThumb.parentNode === benchSlot) {
            benchToolThumb.remove();
          }
          if (activeEnergyPips && activeEnergyPips.parentNode === activeSlot) {
            activeEnergyPips.remove();
          }
          if (benchEnergyPips && benchEnergyPips.parentNode === benchSlot) {
            benchEnergyPips.remove();
          }
          
          // [RETREAT-DUPLICATE-FIX] Clear ALL images (including tool thumbs) from both slots before appending to prevent duplicates
          // Tool thumbs are also <img> elements, so we need to remove them too
          const allActiveImgs = activeSlot.querySelectorAll('img');
          const allBenchImgs = benchSlot.querySelectorAll('img');
          for (const img of allActiveImgs) {
            // Remove all images except the one we're about to append (chosenImg)
            // This includes tool thumbs (.tool-thumb) and the actual card image
            if (img !== chosenImg && img.parentNode === activeSlot) {
              activeSlot.removeChild(img);
            }
          }
          for (const img of allBenchImgs) {
            // Remove all images except the one we're about to append (activeImg)
            if (img !== activeImg && img.parentNode === benchSlot) {
              benchSlot.removeChild(img);
            }
          }
          
          // [RETREAT-DUPLICATE-FIX] Double-check: ensure slots are completely clear of images before appending
          const remainingActiveImgs = activeSlot.querySelectorAll('img');
          const remainingBenchImgs = benchSlot.querySelectorAll('img');
          if (remainingActiveImgs.length > 0 || remainingBenchImgs.length > 0) {
            console.warn('[RETREAT-DUPLICATE-FIX] Images still present after removal attempt:', {
              activeCount: remainingActiveImgs.length,
              benchCount: remainingBenchImgs.length,
              activeImgs: Array.from(remainingActiveImgs).map(img => ({ alt: img.alt, className: img.className })),
              benchImgs: Array.from(remainingBenchImgs).map(img => ({ alt: img.alt, className: img.className }))
            });
            // Force remove all remaining images
            remainingActiveImgs.forEach(img => {
              if (img !== chosenImg && img.parentNode === activeSlot) {
                activeSlot.removeChild(img);
              }
            });
            remainingBenchImgs.forEach(img => {
              if (img !== activeImg && img.parentNode === benchSlot) {
                benchSlot.removeChild(img);
              }
            });
          }
          
          // [RETREAT-DUPLICATE-FIX] Only append if not already in target slot
          if (chosenImg && chosenImg.parentNode !== activeSlot) {
          activeSlot.appendChild(chosenImg);
          }
          if (activeImg && activeImg.parentNode !== benchSlot) {
          benchSlot.appendChild(activeImg);
          }
          
          // [RETREAT-DUPLICATE-FIX] Verify no duplicates after swap
          const activeAfter = activeSlot.querySelectorAll('img');
          const benchAfter = benchSlot.querySelectorAll('img');
          if (activeAfter.length > 1 || benchAfter.length > 1) {
            console.error('[RETREAT-DUPLICATE-FIX] DUPLICATE DETECTED after retreat swap!', {
              activeCount: activeAfter.length,
              benchCount: benchAfter.length,
              activeImgs: Array.from(activeAfter).map(img => img.alt),
              benchImgs: Array.from(benchAfter).map(img => img.alt)
            });
            // Emergency cleanup: remove all but the first image
            while (activeAfter.length > 1) {
              activeSlot.removeChild(activeAfter[activeAfter.length - 1]);
            }
            while (benchAfter.length > 1) {
              benchSlot.removeChild(benchAfter[benchAfter.length - 1]);
            }
          }
          
          animateSlideSwap(activeImg, benchSlot, activeImg, activeRect);
          animateSlideSwap(chosenImg, activeSlot, chosenImg, chosenRect);
        } else {
          
          const chosenRect = chosenImg.getBoundingClientRect();
          
          benchSlot.removeChild(chosenImg);
          activeSlot.appendChild(chosenImg);
          
          
          animateSlideSwap(chosenImg, activeSlot, chosenImg, chosenRect);
        }
        
        
        console.log('[RETREAT-ENERGY-DEBUG-PLAYER] Step 3: Before attaching attachments', {
          activeSlot: {
            pokemon: chosenImg?.alt,
            hasEnergy: !!activeSlot.querySelector('.energy-pips')
          },
          benchSlot: {
            pokemon: activeImg?.alt,
            hasEnergy: !!benchSlot.querySelector('.energy-pips')
          },
          benchPackEnergy: benchPack.energy,
          activePackEnergy: activePack.energy
        });
        
        // [RETREAT-TOOL-FIX] Remove any remaining energy pips or tool thumbs before attaching to prevent duplicates
        const activeEnergyPipsAfter = activeSlot.querySelector('.energy-pips');
        const benchEnergyPipsAfter = benchSlot.querySelector('.energy-pips');
        const activeToolThumbAfter = activeSlot.querySelector('.tool-thumb');
        const benchToolThumbAfter = benchSlot.querySelector('.tool-thumb');
        if (activeEnergyPipsAfter && activeEnergyPipsAfter.parentNode === activeSlot) {
          activeEnergyPipsAfter.remove();
        }
        if (benchEnergyPipsAfter && benchEnergyPipsAfter.parentNode === benchSlot) {
          benchEnergyPipsAfter.remove();
        }
        if (activeToolThumbAfter && activeToolThumbAfter.parentNode === activeSlot) {
          activeToolThumbAfter.remove();
        }
        if (benchToolThumbAfter && benchToolThumbAfter.parentNode === benchSlot) {
          benchToolThumbAfter.remove();
        }
        
        if (typeof attachAttachments === 'function') {
          attachAttachments(activeSlot, benchPack);
          if (activeImg) {
            attachAttachments(benchSlot, activePack);
          }
        }
        
        // [RETREAT-LOGGING] Log bench state after retreat
        const benchAfter = Array.from(benchDiv.querySelectorAll('.card-slot img'))
          .filter(img => !img.classList.contains('tool-thumb'))
          .map(img => ({
            name: img.alt,
            set: img.dataset.set,
            num: img.dataset.num,
            instanceId: img.dataset.instanceId,
            hp: img.dataset.chp || img.dataset.hp,
            maxHp: img.dataset.hp
          }));
        
        console.log('[RETREAT-ENERGY-DEBUG-PLAYER] Step 4: After attaching attachments', {
          newActive: {
            pokemon: chosenImg?.alt,
            hasEnergy: !!activeSlot.querySelector('.energy-pips'),
            pipCount: activeSlot.querySelectorAll('.energy-pip').length
          },
          newBench: {
            pokemon: activeImg?.alt,
            hasEnergy: !!benchSlot.querySelector('.energy-pips'),
            pipCount: benchSlot.querySelectorAll('.energy-pip').length
          },
          benchAfter: benchAfter,
          benchComparison: {
            beforeCount: benchBefore.length,
            afterCount: benchAfter.length,
            before: benchBefore.map(p => p.name),
            after: benchAfter.map(p => p.name)
          }
        });
        
        
        if (typeof markSlot === 'function') {
          markSlot(activeSlot, true);
          markSlot(benchSlot, !!benchSlot.querySelector('img'));
        }
        
        // Update playerState.bench immediately
        if (playerState[ownerKey] && !playerState[ownerKey].bench) {
          playerState[ownerKey].bench = [];
        }
        const benchArray = Array.from(benchDiv.querySelectorAll('.card-slot img'))
          .filter(img => img.dataset.set && img.dataset.num) // Filter out empty slots
          .map(img => ({
            set: img.dataset.set,
            num: img.dataset.num,
            name: img.alt,
            instanceId: img.dataset.instanceId,
            hp: parseInt(img.dataset.hp || '0', 10),
            playedTurn: parseInt(img.dataset.playedTurn || '0', 10)
          }));
        playerState[ownerKey].bench = benchArray;
        
        // Sync globalThis.playerState
        if (globalThis.playerState && globalThis.playerState[ownerKey]) {
          globalThis.playerState[ownerKey].bench = [...benchArray];
        }
        
        if (typeof updatePlayerTypeBackground === 'function') {
          const playerNum = activeDiv.id.includes('p1') ? 1 : 2;
          updatePlayerTypeBackground(playerNum);
        }
        
        // Sync retreat to Firebase
        (async () => {
          const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
          const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
          const isOnline = matchId && window.firebaseDatabase;
          if (isOnline && typeof updateGameStatePartial === 'function') {
            const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
            const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
            const matchOwner = (isP1 && ownerKey === 'player1') || (!isP1 && ownerKey === 'player2') 
              ? 'player1' 
              : 'player2';
            
            try {
              const newActiveImg = activeSlot.querySelector('img');
              const newBenchImg = benchSlot.querySelector('img');
              
              if (newActiveImg) {
                const activeData = {
                  set: newActiveImg.dataset.set,
                  num: newActiveImg.dataset.num,
                  name: newActiveImg.alt,
                  instanceId: newActiveImg.dataset.instanceId,
                  hp: parseInt(newActiveImg.dataset.hp || '0', 10),
                  playedTurn: globalThis.turnNumber || 0
                };
                
                await updateGameStatePartial({
                  [`${matchOwner}/active`]: activeData
                });
                
                // Update bench - use ownerKey directly (the actual owner of the retreating pokemon)
                const benchOwnerKey = matchOwner;
                // Use the already-updated benchArray from playerState
                const benchArray = playerState[ownerKey]?.bench || [];
                
                await updateGameStatePartial({
                  [`${benchOwnerKey}/bench`]: benchArray
                });
                
                // Collect energy types discarded for retreat
                const energyTypesDiscarded = {};
                if (storedRetreatCost > 0 && benchSlot) {
                  const energyPipsContainer = benchSlot.querySelector('.energy-pips');
                  if (energyPipsContainer) {
                    const pips = Array.from(energyPipsContainer.querySelectorAll('.energy-pip:not(.phantom-pip)'));
                    for (let i = 0; i < storedRetreatCost && i < pips.length; i++) {
                      const energyType = (pips[i].dataset.type || 'colorless').toLowerCase();
                      energyTypesDiscarded[energyType] = (energyTypesDiscarded[energyType] || 0) + 1;
                    }
                  }
                }
                
                if (typeof broadcastAction === 'function' && ACTION_TYPES) {
                  await broadcastAction(ACTION_TYPES.RETREAT, {
                    owner: matchOwner,
                    retreated: newBenchImg ? {
                      set: newBenchImg.dataset.set,
                      num: newBenchImg.dataset.num,
                      name: newBenchImg.alt,
                      instanceId: newBenchImg.dataset.instanceId
                    } : null,
                    promoted: activeData,
                    retreatCost: storedRetreatCost,
                    energyDiscarded: energyTypesDiscarded,
                    turnNumber: globalThis.turnNumber || 0
                  });
                }
                
                console.log('Synced retreat to Firebase:', {
                  matchOwner,
                  promotedName: activeData.name
                });
              }
            } catch (error) {
              console.error('Error syncing retreat to Firebase:', error);
            }
          }
        })();
        
        if (storedRetreatCost > 0) {
          
          const retreatedSlot = benchSlot; 
          const energyPipsContainer = retreatedSlot.querySelector('.energy-pips');
          
          // Mark slot to prevent double counting
          if (retreatedSlot) {
            retreatedSlot.dataset.energyCounted = 'true';
          }
          
          if (energyPipsContainer) {
            const pips = Array.from(energyPipsContainer.querySelectorAll('.energy-pip:not(.phantom-pip)'));
            
            // Remove energy pips from DOM and count them
            for (let i = 0; i < storedRetreatCost && i < pips.length; i++) {
              const energyType = (pips[i].dataset.type || 'colorless').toLowerCase();
              if (!playerState[ownerKey].discard.energyCounts) {
                playerState[ownerKey].discard.energyCounts = {};
              }
              playerState[ownerKey].discard.energyCounts[energyType] = 
                (playerState[ownerKey].discard.energyCounts[energyType] || 0) + 1;
              
              // Sync to globalThis.playerState
              if (globalThis.playerState && globalThis.playerState[ownerKey]) {
                if (!globalThis.playerState[ownerKey].discard) {
                  globalThis.playerState[ownerKey].discard = { cards: [], energyCounts: {} };
                }
                if (!globalThis.playerState[ownerKey].discard.energyCounts) {
                  globalThis.playerState[ownerKey].discard.energyCounts = {};
                }
                globalThis.playerState[ownerKey].discard.energyCounts[energyType] =
                  (globalThis.playerState[ownerKey].discard.energyCounts[energyType] || 0) + 1;
              }
              
              pips[i].remove(); // Remove from DOM
            }
            
            // Sync discard to Firebase
            (async () => {
              if (typeof updateGameStatePartial === 'function') {
                const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
                const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
                const isOnline = matchId && window.firebaseDatabase;
                if (isOnline) {
                  const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
                  const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
                  const matchPlayer = (isP1 && ownerKey === 'player1') || (!isP1 && ownerKey === 'player2') 
                    ? 'player1' 
                    : 'player2';
                  try {
                    await updateGameStatePartial({
                      [`${matchPlayer}/discard`]: playerState[ownerKey].discard
                    });
                  } catch (error) {
                    console.error('Error syncing retreat energy discard to Firebase:', error);
                  }
                }
              }
            })();
            
            // Update discard bubbles
            if (typeof updateDiscardBubbles === 'function') {
              updateDiscardBubbles();
            }
            
            
            const phantomPips = energyPipsContainer.querySelectorAll('.energy-pip.phantom-pip');
            for (let i = 0; i < storedRetreatCost && i < phantomPips.length; i++) {
              phantomPips[i].remove();
            }
          }
        } else {
        }
        
        showPopup('Promoted to Active.');

        
        
        if (typeof closeAttackMenu === 'function') {
          closeAttackMenu();
        }
        
        
        document.querySelectorAll('.card-slot.menu-open').forEach(slot => {
          slot.classList.remove('menu-open');
        });
        
        
        document.querySelectorAll('.attack-menu').forEach(menu => {
          menu.remove();
        });
        
        
        const background = document.querySelector('.board') || document.body;
        const clickEvent = new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
          view: window,
          clientX: 10,
          clientY: 10
        });
        background.dispatchEvent(clickEvent);

        
        
        lastRetreatTime = Date.now();  
        
        
        hasRetreatedThisTurn = true;
      }
    } else {
      
      document.body.removeEventListener('click', selectReplacement, true);
      
      
      isRetreatSelection = false;
      
      benchImgs.forEach(img => img.classList.remove('promote-glow'));
      showPopup('Retreat canceled (no replacement selected).');
    }
  };
  
  
  setTimeout(() => {
    document.body.addEventListener('click', selectReplacement, true);
  }, 100);
  
}



function computeRetreatCost(activeDiv, meta) {
  const base = Number(meta.retreat || meta.retreatCost || 0) || 0;
  
  if (!activeDiv) return base;
  
  
  const activeImg = activeDiv.querySelector('img');
  if (activeImg && typeof hasLevitateZeroRetreat === 'function' && hasLevitateZeroRetreat(activeImg)) {
    return 0;
  }
  
  
  if (activeImg && activeImg.dataset.set && activeImg.dataset.num) {
    try {
      
      const cacheKey = `${activeImg.dataset.set}-${activeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      
      if (abilityRow?.effect_type === 'zero_retreat_if_arceus') {
        
        const pk = activeDiv.closest('#player1') ? 'p1' : 'p2';

        
        
        if (typeof hasArceusInPlay === 'function' && hasArceusInPlay(pk)) {
          return 0;
        } else {
        }
      }
    } catch (e) {
      console.error('[retreat-debug] Error checking Arceus retreat:', e);
      
    }
  }
  
  
  if (activeImg && meta.stage?.toLowerCase() === 'basic') {
    
    const pk = activeDiv.closest('#player1') ? 'p1' : 'p2';
    const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
    const benchImgs = benchDiv ? [...benchDiv.querySelectorAll('img')] : [];

    
    
    for (const benchImg of benchImgs) {
      const name = (benchImg.alt || '').toLowerCase();
      
      if (name.includes('shaymin')) {
        
        try {
          const cacheKey = `${benchImg.dataset.set}-${benchImg.dataset.num}`;
          const abilityRow = globalThis.abilityCache?.[cacheKey];
          
          
          if (abilityRow?.effect_type === 'reduce_active_basic_retreat_cost') {
            const reduction = parseInt(abilityRow.param1 || '1', 10);
            return Math.max(0, base - reduction);
          }
        } catch (e) {
          console.error(`[shaymin-debug] Error checking Shaymin:`, e);
          
        }
      }
    }
  }

  const abs = activeDiv.dataset.tempRetreat;
  const red = Number(activeDiv.dataset.tempRetreatReduce || '0') || 0;

  if (abs != null) return Math.max(0, Number(abs));
  return Math.max(0, base - red);
}

globalThis.setTempRetreatFor = function(pk, amount, mode = 'reduce') {
  const activeDiv = pk === 'p1' ? p1Active : p2Active;
  if (!activeDiv) {
    return;
  }
  
  if (mode === 'reduce') {
    activeDiv.dataset.tempRetreatReduce = String(amount || 0);
  } else if (mode === 'set') {
    activeDiv.dataset.tempRetreat = String(amount || 0);
  }
};

globalThis.clearTempRetreatFor = function(pk) {
  const activeDiv = pk === 'p1' ? p1Active : p2Active;
  if (!activeDiv) return;
  
  delete activeDiv.dataset.tempRetreat;
  delete activeDiv.dataset.tempRetreatReduce;
};

function addRetreatRow(menu, activeDiv, meta){
  const slot = activeDiv.querySelector('.card-slot');
  const costCount = computeRetreatCost(activeDiv, meta);
  const row = document.createElement('div');
  row.style.marginTop = '6px';
  row.innerHTML = '<div class="thin"></div>';

  const btn = document.createElement('div');
  btn.className = 'attack-item';

  const left = document.createElement('div');
  left.style.display = 'flex';
  left.style.alignItems = 'center';
  left.style.gap = '6px';
  const nm = document.createElement('div');
  nm.className = 'attack-name';
  nm.textContent = 'Retreat';
  left.appendChild(nm);

  const icons = document.createElement('div');
  icons.className = 'attack-cost';
  if (costCount > 0) {
    const flags = satisfiedFlags(countPipsOn(slot), Array(costCount).fill('colorless'));
    for (let i = 0; i < costCount; i++) {
      const ic = document.createElement('div');
      ic.className = 'cost-icon';
      ic.style.backgroundImage = `url('${ENERGY_ICONS.colorless}')`;
      if (!flags[i]) ic.classList.add('missing');
      icons.appendChild(ic);
    }
  }
  left.appendChild(icons);

  const arrow = document.createElement('div');
  arrow.style.fontWeight = '900';
  arrow.textContent = '';
  btn.appendChild(left);
  btn.appendChild(arrow);

    const canPay = costCount === 0 || canPayCostFromAPI(slot, Array(costCount).fill('colorless'));
  const hasBench = [...benchFor(currentPlayer).querySelectorAll('img')].length > 0;

  const activeImg = activeDiv.querySelector('img');
  const st = (activeImg?.dataset.status || '').toLowerCase();
  const blockedByStatus = st === 'asleep' || st === 'paralyzed';

  const pk = currentPlayer === 'player1' ? 'p1' : 'p2';

if (!canRetreat(pk)) {
  btn.classList.add('muted');
  btn.onclick = () => {
    const activeImg = activeDiv.querySelector('img');
    const st = (activeImg?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      showPopup("Can't retreat - this Pokmon is asleep!");
    } else if (st === 'paralyzed') {
      showPopup("Can't retreat - this Pokmon is paralyzed!");
    } else {
      showPopup("Can't retreat - this Pokmon is locked!");
    }
  };
  return;
}

const canRetreatNormally = hasBench && canPay && !hasRetreatedThisTurn && !blockedByStatus;

if (canRetreatNormally) {
  btn.classList.add('payable');
  
  
  const mainType = (meta.types && meta.types[0]) ? String(meta.types[0]).toLowerCase() : null;
  if (mainType) {
    btn.setAttribute('data-type', mainType);
  }
} else {
  btn.classList.add('muted');
}
btn.onclick = () => {
  
  if (!canRetreatNormally) {
    if (hasRetreatedThisTurn) {
      showPopup('You can only retreat once per turn.');
    } else if (blockedByStatus) {
      showPopup('Cannot retreat while Asleep or Paralyzed.');
    } else {
      showPopup('Cannot retreat.');
    }
    return;
  }
  
  
  
  let toDiscard = costCount;
  const energyBox = slot.querySelector('.energy-pips');
  
  // Mark slot to prevent double counting
  if (slot) {
    slot.dataset.energyCounted = 'true';
  }
  
  if (energyBox && toDiscard > 0) {
    const pips = Array.from(energyBox.querySelectorAll('.energy-pip:not(.phantom-pip)'));
    for (const pip of pips) {
      if (toDiscard <= 0) break;
      const type = (pip.dataset.type || 'colorless').toLowerCase();
      if (!playerState[currentPlayer].discard.energyCounts) {
        playerState[currentPlayer].discard.energyCounts = {};
      }
      playerState[currentPlayer].discard.energyCounts[type] =
        (playerState[currentPlayer].discard.energyCounts[type] || 0) + 1;
      
      // Sync to globalThis.playerState
      if (globalThis.playerState && globalThis.playerState[currentPlayer]) {
        if (!globalThis.playerState[currentPlayer].discard) {
          globalThis.playerState[currentPlayer].discard = { cards: [], energyCounts: {} };
        }
        if (!globalThis.playerState[currentPlayer].discard.energyCounts) {
          globalThis.playerState[currentPlayer].discard.energyCounts = {};
        }
        globalThis.playerState[currentPlayer].discard.energyCounts[type] =
          (globalThis.playerState[currentPlayer].discard.energyCounts[type] || 0) + 1;
      }
      
      pip.remove(); // Remove from DOM
      toDiscard--;
    }
    
    // Sync discard to Firebase
    (async () => {
      if (typeof updateGameStatePartial === 'function') {
        const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
        const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
        const isOnline = matchId && window.firebaseDatabase;
        if (isOnline) {
          const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
          const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
          const matchPlayer = (isP1 && currentPlayer === 'player1') || (!isP1 && currentPlayer === 'player2') 
            ? 'player1' 
            : 'player2';
          try {
            await updateGameStatePartial({
              [`${matchPlayer}/discard`]: playerState[currentPlayer].discard
            });
          } catch (error) {
            console.error('Error syncing retreat button energy discard to Firebase:', error);
          }
        }
      }
    })();
    
    // Update discard bubbles
    if (typeof updateDiscardBubbles === 'function') {
      updateDiscardBubbles();
    }
  }
    
    // Sync discard to Firebase
    (async () => {
      if (typeof updateGameStatePartial === 'function') {
        const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
        const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
        const isOnline = matchId && window.firebaseDatabase;
        if (isOnline) {
          const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
          const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
          const matchPlayer = (isP1 && currentPlayer === 'player1') || (!isP1 && currentPlayer === 'player2') 
            ? 'player1' 
            : 'player2';
          try {
            await updateGameStatePartial({
              [`${matchPlayer}/discard`]: playerState[currentPlayer].discard
            });
          } catch (error) {
            console.error('Error syncing energy discard to Firebase:', error);
          }
        }
      }
    })();
    
    // Update discard bubbles
    if (typeof updateDiscardBubbles === 'function') {
      updateDiscardBubbles();
    }
  }
  
  if (activeDiv.dataset.tempRetreatReduce != null) {
    delete activeDiv.dataset.tempRetreatReduce;
  }
  
  hasRetreatedThisTurn = true;
  
  const activeSlot = activeDiv.querySelector('.card-slot');
  const benchDiv = benchFor(currentPlayer);
  const emptyBenchSlot = benchDiv.querySelector('.card-slot[data-empty="1"]');
  
  if (emptyBenchSlot && activeSlot) {
    
    const attachments = detachAttachments(activeSlot);
    
    
    const activeImg = activeSlot.querySelector('img');
    if (activeImg) {
      emptyBenchSlot.innerHTML = '';
      emptyBenchSlot.appendChild(activeImg.cloneNode(true));
      emptyBenchSlot.dataset.empty = '0';
      
      
      attachAttachments(emptyBenchSlot, attachments);
    }
    
    
    activeSlot.innerHTML = '';
    markSlot(activeSlot, false);
    markSlot(emptyBenchSlot, true);
  }
  
  logEvent({
    player: currentPlayer,
    text: 'Retreated their Active Pokmon.'
  });
  
  // Update energy visuals after retreat to sync across both players
  if (typeof updateAllEnergyVisuals === 'function') {
    updateAllEnergyVisuals();
  }
  
  closeAttackMenu();
  
  beginPromotionFlow(currentPlayer);
}

function onPokemonClick(player, slot) {
    const card = (slot === "active")
        ? activePokemon[player]
        : benchPokemon[player][slot];
    
    if (card && ABILITY_EFFECTS[card.id]) {
        openAbilityUI(player, card);
        return; 
    }
    
    showAttackMenuFor(player, slot);
}

async function buildZoomPanel(meta,img){
  currentZoom={img,meta};

  zoomTitle.textContent=meta.name||'Pokmon';

  const mainType=(meta.types&&meta.types[0])?String(meta.types[0]).toLowerCase():null;
  zoomType.style.display=mainType?"block":"none";
  if(mainType)zoomType.style.backgroundImage=`url('${energyIconUrl(mainType)}')`;
  
  const slot = img.closest('.card-slot');
  const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  
  const base = modifiedMaxHp || parseInt(img.dataset.hp||meta.hp||'0',10)||0;
  const chp=parseInt(img.dataset.chp||base||'0',10)||base;

  zoomHp.textContent=`HP: ${chp} / ${base}`;
  
  
  if (modifiedMaxHp) {
    zoomHp.style.color = '#22c55e';
    zoomHp.style.fontWeight = '700';
  } else {
    zoomHp.style.color = '';
    zoomHp.style.fontWeight = '';
  }
  
  const pct=base>0?Math.round((chp/base)*100):0;

  zoomHpBar.style.width=pct+'%';
  zoomHpBar.style.background=
    (chp===base)
      ?'linear-gradient(90deg,#22c55e,#16a34a)'
      :'linear-gradient(90deg,#f43f5e,#ef4444)';

        
  if (zoomStatusIcon) {
    const sKey = (img.dataset.status || '').toLowerCase();
    const url = STATUS_ICON_URLS[sKey];
    if (url) {
      zoomStatusIcon.style.display = 'inline-block';
      zoomStatusIcon.style.backgroundImage = `url('${url}')`;
    } else {
      zoomStatusIcon.style.display = 'none';
      zoomStatusIcon.style.backgroundImage = '';
    }
  }

  
  const pips=countPipsOn(slot);

  zoomEnergyCount.textContent=`x${pips.total||0}`;
  zoomEnergyIcons.innerHTML='';

  Object.keys(pips).filter(k=>k!=='total').forEach(k=>{
    for(let i=0;i<pips[k];i++){
      const ico=document.createElement('span');
      ico.className='mini-icon';
      ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;
      zoomEnergyIcons.appendChild(ico);
    }
  });

  
  zoomTools.innerHTML='';
  const tool=getToolDataFromSlot(slot);

  if(tool){
    
    if (zoomToolImg) {
      zoomToolImg.src = tool.src;
      zoomToolImg.style.display = 'block';
    }
    
    
    const tImg=document.createElement('img');
    tImg.src=tool.src;
    tImg.alt='Tool';
    tImg.style.borderRadius='4px';
    tImg.style.boxShadow='0 2px 6px rgba(0,0,0,.6)';
    tImg.style.cursor='pointer';
    tImg.onclick=async ev=>{
      ev.stopPropagation();
      await openToolModal(tool.set,tool.num,tool.src);
    };
    zoomTools.appendChild(tImg);
  }else{
    
    if (zoomToolImg) {
      zoomToolImg.style.display = 'none';
    }
    
    const none=document.createElement('div');
    none.className='chip';
    none.textContent='none';
    zoomTools.appendChild(none);
  }

  
  
  zoomAbilities.style.display = 'none';
  zoomAbilities.innerHTML = '';
  
  if (typeof ensureAbilityEffectsLoaded === 'function') {
    await ensureAbilityEffectsLoaded();
  }
  
  const metaAbilities = extractAbilities(meta);
  const abilityRows = (window.ABILITY_EFFECT_ROWS || []);

  
  
  const setId = img.dataset.set;
  const numId = img.dataset.num;
  const csvAbilities = abilityRows.filter(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === String(numId).padStart(3, '0')
  );

  
  
  const allAbilities = [...metaAbilities];
  csvAbilities.forEach(csvAb => {
    const alreadyHas = metaAbilities.some(metaAb => 
      (metaAb.name || '').toLowerCase() === (csvAb.abilityName || '').toLowerCase()
    );
    if (!alreadyHas) {
      
      allAbilities.push({
        name: csvAb.abilityName,
        effect: csvAb.text || '',
        type: csvAb.abilityType
      });
    }
  });

  if (allAbilities.length) {
    const bandClr = (TYPE_HEX[mainType || 'colorless'] || '#94a3b8');

  let ownerKey = null;
  if (img.closest("#player1") && !img.closest(".hand")) ownerKey = "player1";
  else if (img.closest("#player2") && !img.closest(".hand")) ownerKey = "player2";

    allAbilities.forEach(ab => {
      const box = document.createElement('div');
      box.className = 'ability-box';

      const head = document.createElement('div');
      head.className = 'ability-head';
      head.style.background = bandClr;
      head.style.color = '#0b0f14';

      const badge = document.createElement('img');
      badge.src = ABILITY_BADGE;
      badge.alt = '';

      const nm = document.createElement('div');
      nm.className = 'ability-name';
      nm.textContent = ab.name || 'Ability';

      head.appendChild(badge);
      head.appendChild(nm);

      const tx = document.createElement('div');
      tx.className = 'ability-text';
      tx.textContent = ab.effect || '';

      box.appendChild(head);
      box.appendChild(tx);
      zoomAbilities.appendChild(box);
      
      if (!ownerKey || !currentPlayer) {
        box.classList.add('ability-disabled');
        return;
      }
      const isCurrentPlayersCard = (ownerKey === currentPlayer);
      const setId  = img.dataset.set;
      const numId  = img.dataset.num;
      
      
      const actualPokemonImg = img;
      const cardKey = getAbilityCardKey(setId, numId, actualPokemonImg);
      
      const row = abilityRows.find(r =>
        r.set === setId &&
        String(r.number).padStart(3, '0') === String(numId).padStart(3, '0') &&
        (r.abilityName || '').toLowerCase() === (ab.name || '').toLowerCase()
      );
      
      
      const ownerPk = (ownerKey === 'p1' || ownerKey === 'p2') ? ownerKey : (ownerKey === 'player1' ? 'p1' : 'p2');
      
      
      const isUnlimited = row && (
        (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
        (row.text && /as often as you like/i.test(row.text))
      );
      
      const alreadyUsed = !isUnlimited && !!window.usedAbilitiesThisTurn[ownerPk]?.[cardKey];
      
      const isActiveSlot = img.closest('.active') !== null;
      const requiresActive = row ? abilityRequiresActive(row) : false;
      
      
      const isPassive = row && row.abilityType === 'passive';
      
      if (isPassive) {
        
        
        const passiveLabel = document.createElement('span');
        passiveLabel.textContent = 'PASSIVE';
        passiveLabel.style.cssText = `
          display: inline-block;
          padding: 2px 6px;
          background: rgba(0, 0, 0, 0.4);
          border-radius: 3px;
          font-size: 9px;
          font-weight: bold;
          color: rgba(255, 255, 255, 0.9);
          margin-left: 6px;
          letter-spacing: 0.5px;
          vertical-align: middle;
        `;
        nm.appendChild(passiveLabel);
        
        
        box.classList.add('ability-disabled');
        
        
        return;
      }
      
      if (!row || row.abilityType !== 'active' ||
          !isCurrentPlayersCard || alreadyUsed || gameOver ||
          (requiresActive && !isActiveSlot)) {
        box.classList.add('ability-disabled');
        return;
      }

      box.classList.add('ability-glow');

      box.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        
        
        const isUnlimitedAbility = 
          (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
          (row.text && /as often as you like/i.test(row.text));
        
        if (!isUnlimitedAbility && window.usedAbilitiesThisTurn[ownerPk]?.[cardKey]) return;
        
        if (zoomBackdrop && zoomBackdrop.classList.contains('show')) {
          zoomBackdrop.classList.remove('show');
          currentZoom = { img: null, meta: null };
        }

        if (typeof globalThis.applyAbilityEffectFromCsv !== 'function') {
          showPopup('Ability engine not available.');
          return;
        }
        
        const pk = ownerPk;
        
        const effectState = {
          p1: playerState.player1,
          p2: playerState.player2,
          activeFor,
          benchFor,
          opponentOf,
          fetchCardMeta,
          damageActiveOf,
          beginPromotionFlow,
          showPopup,
          logEvent,
          attachEnergyToSlot,
          energyZoneDiv,
          renderEnergyZone,
          getActiveImage
        };

try {
          const result = await globalThis.applyAbilityEffectFromCsv(effectState, pk, row, { abilityPokemon: actualPokemonImg });
          
          // Sync ability use to Firebase
          const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
          const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
          const isOnline = matchId && window.firebaseDatabase;
          if (isOnline && typeof broadcastAction === 'function' && ACTION_TYPES) {
            const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
            const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
            // Map pk (p1/p2) to owner (player1/player2)
            const owner = pk === 'p1' ? 'player1' : 'player2';
            const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
              ? 'player1' 
              : 'player2';
            
            try {
              await broadcastAction(ACTION_TYPES.USE_ABILITY, {
                owner: matchOwner,
                source: {
                  set: actualPokemonImg.dataset.set,
                  num: actualPokemonImg.dataset.num,
                  name: actualPokemonImg.alt,
                  instanceId: actualPokemonImg.dataset.instanceId
                },
                ability: {
                  name: row.abilityName,
                  effectType: row.effect_type,
                  param1: row.param1,
                  param2: row.param2
                },
                turnNumber: globalThis.turnNumber || 0
              });
              console.log('Synced ability use to Firebase:', {
                matchOwner,
                abilityName: row.abilityName
              });
            } catch (error) {
              console.error('Error syncing ability use to Firebase:', error);
            }
          }
          
          const isUnlimited = 
            (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
            (row.text && /as often as you like/i.test(row.text));
          
          if (!isUnlimited) {
            if (!window.usedAbilitiesThisTurn[ownerPk]) {
              window.usedAbilitiesThisTurn[ownerPk] = {};
            }
            window.usedAbilitiesThisTurn[ownerPk][cardKey] = true;
            

            box.classList.remove('ability-glow');
            box.classList.add('ability-disabled');
          } else {
            
          }
          
          if (openAttackMenu) {
            const abilityRow = openAttackMenu.querySelector('.attack-ability-row');
            if (abilityRow) {
              abilityRow.classList.add('used');
            }
          }
          

          if (result && result.knocked) {
            const foePk = ownerPk === 'p1' ? 'p2' : 'p1';
            const foe = foePk === 'p1' ? 'player1' : 'player2';
            
            
            const foeImg = result.knockedImg || getActiveImage(foe);
            
            if (foeImg && typeof handleKnockOut === 'function') {
              
              
              const foeActive = getActiveImage(foe);
              const wasActive = (foeImg === foeActive);
              
              const ended = await handleKnockOut(foe, foeImg, wasActive);
              if (!ended && typeof beginPromotionFlow === 'function') {
                
                if (wasActive) {
                  beginPromotionFlow(foe);
                }
              }
            }
          }

        } catch (err) {
          console.error('Ability effect error:', err);
          showPopup('Ability failed.');
        }
      });
    });

    zoomAbilities.style.display = 'block';
  }

  
  zoomAttacks.innerHTML='';
  
  
  const isFossil = img.dataset.isFossil === 'true';
  
  if (isFossil) {
    const discardCard = document.createElement('div');
    discardCard.className = 'zoom-attack';
    discardCard.style.cursor = 'pointer'; 
    
    const top = document.createElement('div');
    top.className = 'top';
    top.style.background = '#94a3b8'; 
    top.style.color = '#fff';
    
    const nm = document.createElement('div');
    nm.className = 'name';
    nm.textContent = 'Discard';
    
    top.appendChild(nm);
    discardCard.appendChild(top);
    
    const divider = document.createElement('div');
    divider.className = 'thin';
    const eff = document.createElement('div');
    eff.className = 'effect';
    eff.textContent = 'Discard this Fossil from play. Does not give opponent a point.';
    
    discardCard.appendChild(divider);
    discardCard.appendChild(eff);
    
    
    discardCard.addEventListener('click', async (e) => {
      e.stopPropagation();
      
      
      const ownerDiv = img.closest('#player1, #player2');
      const pk = ownerDiv?.id === 'player1' ? 'p1' : 'p2';
      
      
      if (zoomBackdrop) {
        zoomBackdrop.classList.remove('show');
      }
      currentZoom = { img: null, meta: null };
      
      
      const isActive = !!img.closest('.active');
      
      
      if (globalThis.discardPokemon) {
        await globalThis.discardPokemon(img, pk, false);
      }
      
      showPopup(`${meta.name || 'Fossil'} was discarded.`);
      
      
      if (isActive) {
        const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
        const benchImgs = Array.from(benchDiv?.querySelectorAll('img') ?? []);
        
        if (benchImgs.length === 0) {
          
          const winner = pk === 'p1' ? 'player2' : 'player1';
          showVictory(winner, 'Opponent has no Pokmon left!');
          return;
        }
        
        
        if (globalThis.promoteFromBench) {
          await globalThis.promoteFromBench(null, pk); 
        }
      }
    });
    
    zoomAttacks.appendChild(discardCard);

  } else {
  
  let ownerKey = null;
  let pk = null;
  if (img.closest("#player1") && !img.closest(".hand")) {
    ownerKey = "player1";
    pk = "p1";
  } else if (img.closest("#player2") && !img.closest(".hand")) {
    ownerKey = "player2";
    pk = "p2";
  }
  
  let attacks = meta.attacks || [];
  
  const slot = img.closest('.card-slot');
  
  const toolData = getToolDataFromSlot(slot);
  
  if (toolData && toolData.set && toolData.num) {
    try {
      const toolCardId = csvIdFor(toolData.set, toolData.num);
      
      const toolEffect = TRAINER_EFFECT_DATA.find(x => x.id === toolCardId);
      
      if (toolEffect?.effect_type === 'use_previous_evolution_attacks') {
        
        
        async function buildEvolutionChain(currentMeta, owner, visited = new Set(), skipFirstLevel = false) {
          const chain = [];
          const currentKey = `${currentMeta.id || currentMeta.name}`;
          if (visited.has(currentKey)) return chain; 
          visited.add(currentKey);
          
          
          let evolveFrom = currentMeta.evolvesFrom || currentMeta.evolveFrom || [];
          
          
          if (typeof evolveFrom === 'string' && evolveFrom.trim()) {
            const evolveFromLower = evolveFrom.toLowerCase();
            const matchingCards = [];
            
            
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
            const pokemonInPlay = [
              ...(activeDiv?.querySelectorAll('img') || []),
              ...(benchDiv?.querySelectorAll('img') || [])
            ];
            
            for (const pokemonImg of pokemonInPlay) {
              const pokemonName = (pokemonImg.alt || '').toLowerCase();
              
              if (pokemonName === evolveFromLower) {
                const set = pokemonImg.dataset.set;
                const num = pokemonImg.dataset.num;
                if (set && num) matchingCards.push({ set, number: num });
              }
            }
            
            if (matchingCards.length === 0) {
              const hand = playerState[owner]?.hand || [];
              for (const card of hand) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  matchingCards.push({ set: card.set, number: card.number || card.num });
                }
              }
            }
            
            if (matchingCards.length === 0) {
              const deck = playerState[owner]?.deck || [];
              for (const card of deck) {
                try {
                  const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                  const cardName = (cardMeta.name || '').toLowerCase();
                  
                  if (cardMeta.category === 'Pokemon' && cardName === evolveFromLower) {
                    matchingCards.push({ set: card.set, number: card.number || card.num });
                  }
                } catch {}
              }
            }
            
            if (matchingCards.length === 0) {
              const discard = playerState[owner]?.discard?.cards || [];
              for (const card of discard) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  
                  try {
                    const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                    if (cardMeta && cardMeta.category === 'Pokemon' && cardMeta.name && cardMeta.name.toLowerCase() === evolveFromLower) {
                      matchingCards.push({ set: card.set, number: card.number || card.num });
                    }
                  } catch (err) {
                  }
                }
              }
            }
            
            if (matchingCards.length === 0) {
              
              const commonSets = ['A1', 'A1a', 'A2', 'A2a', 'A2b', 'A3', 'A3a', 'A3b', 'A4', 'A4a'];
              for (const set of commonSets) {
                try {
                  const setResponse = await fetch(`https://api.tcgdex.net/v2/en/sets/${set}`);
                  if (!setResponse.ok) continue;
                  const setData = await setResponse.json();
                  if (setData?.cards) {
                    for (const card of setData.cards) {
                      const cardName = (card.name || '').toLowerCase();
                      if (cardName === evolveFromLower || cardName.includes(evolveFromLower) || evolveFromLower.includes(cardName)) {
                        const localId = card.localId || card.number;
                        if (localId) {
                          matchingCards.push({ set, number: localId });
                          break;
                        }
                      }
                    }
                  }
                  if (matchingCards.length > 0) break;
                } catch (err) {
                }
              }
            }
            
            evolveFrom = matchingCards;
          }
          
          
          if (Array.isArray(evolveFrom) && evolveFrom.length > 0) {
            for (const prevEvo of evolveFrom) {
              try {
                const prevEvoMeta = await fetchCardMeta(prevEvo.set, prevEvo.number);
                if (prevEvoMeta) {
                  
                  if (!skipFirstLevel) {
                    chain.push(prevEvoMeta);
                  } else {
                  }
                  
                  const deeperChain = await buildEvolutionChain(prevEvoMeta, owner, visited, false);
                  chain.push(...deeperChain);
                }
              } catch (err) {
                console.error(`[Memory Light Zoom] Error fetching evolution ${prevEvo.set}-${prevEvo.number}:`, err);
              }
            }
          }
          
          return chain;
        }
        
        
        const evolvedViaRareCandy = img.dataset.evolvedViaRareCandy === 'true';
        
        
        const ownerDiv = img.closest('#player1, #player2');
        const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
        const fullChain = await buildEvolutionChain(meta, owner, new Set(), evolvedViaRareCandy);
        
        if (fullChain.length > 0) {
          if (evolvedViaRareCandy) {
            
            const basicMeta = fullChain[fullChain.length - 1]; 
            if (basicMeta?.attacks) {
              attacks = [...attacks, ...basicMeta.attacks];
            } else {
            }
          } else {

            for (const prevEvoMeta of fullChain) {
              if (prevEvoMeta?.attacks) {
                attacks = [...attacks, ...prevEvoMeta.attacks];
              } else {
              }
            }
          }
        } else {
        }
      } else {
      }
    } catch (err) {
      console.error('[Memory Light Zoom]  Error checking tool:', err);
    }
  } else {
  }
  

  attacks.forEach(atk=>{
    const card=document.createElement('div');
    card.className='zoom-attack';

    const top=document.createElement('div');
    top.className='top';

    const left=document.createElement('div');
    left.style.display='flex';
    left.style.alignItems='center';
    left.style.gap='6px';

    const nm=document.createElement('div');
    nm.className='name';
    nm.textContent=atk.name||'Attack';

    const cost=makeCostIcons(atk.cost||[], slot, img);
    left.appendChild(nm);
    left.appendChild(cost);

    const dmg=document.createElement('div');
    dmg.className='dmg';
    dmg.textContent = (atk.damage || '').toString(); 
    
    (async () => {
      try {
        const previewResult = await calculatePreviewDamage(atk, img, meta, pk);
        let previewDamage = typeof previewResult === 'object' ? previewResult.damage : previewResult;
        
        if (typeof previewDamage === 'object') previewDamage = '';
        dmg.textContent = String(previewDamage || '');
        
        
        if (typeof previewResult === 'object') {
          
          dmg.style.setProperty('color', '', 'important');
          dmg.style.setProperty('text-shadow', '', 'important');
          
          if (previewResult.hasWeakness) {
            
            dmg.style.setProperty('color', '#22c55e', 'important');
            dmg.style.setProperty('text-shadow', '0 0 8px rgba(34, 197, 94, 0.6), 0 0 4px rgba(34, 197, 94, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else if (previewResult.hasOtherBoosts) {
            
            dmg.style.setProperty('color', '#fbbf24', 'important');
            dmg.style.setProperty('text-shadow', '0 0 8px rgba(251, 191, 36, 0.6), 0 0 4px rgba(251, 191, 36, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else {
            
            dmg.style.setProperty('color', '#000000', 'important');
            dmg.style.setProperty('text-shadow', '0 1px 3px rgba(0,0,0,0.5)', 'important');
          }
        }
      } catch (err) {
        console.error('[preview] Error calculating damage:', err);
        
      }
    })();

    top.appendChild(left);
    top.appendChild(dmg);
    card.appendChild(top);

    
    const divider=document.createElement('div');
    divider.className='thin';
    const eff=document.createElement('div');
    eff.className='effect';
    eff.textContent=atk.effect?String(atk.effect):'';

    card.appendChild(divider);
    card.appendChild(eff);
    
    let isMoveLocked = false;
    const instanceId = img.dataset.instanceId;
    const moveName = atk.name?.toLowerCase();
    const currentTurn = globalThis.turnNumber || 0;
    
    if (instanceId && moveName && pk && globalThis.__moveLocks?.[pk]?.[instanceId]?.[moveName]) {
      const moveLock = globalThis.__moveLocks[pk][instanceId][moveName];
      
      if (typeof moveLock === 'object' && moveLock.lockedOnTurn !== undefined) {
        
        isMoveLocked = currentTurn === moveLock.lockedOnTurn + 2;
      } else {
        
        isMoveLocked = moveLock === true;
      }
    }
    
    
    const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
    let isAllAttacksLocked = false;
    if (attackLock) {
      const currentTurn = globalThis.turnNumber || 0;
      if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
        isAllAttacksLocked = currentTurn === attackLock.lockedOnTurn + 2;
      } else if (attackLock === true) {
        isAllAttacksLocked = true; 
      }
    }

    const payable=canPayCostFromAPI(slot,atk.cost||[], img) && !isMoveLocked && !isAllAttacksLocked;
    
    if (isMoveLocked || isAllAttacksLocked) {
      card.classList.add('muted');
      card.style.opacity = '0.5';
      card.style.cursor = 'not-allowed';
      if (isMoveLocked) {
        card.title = `This Pokmon can't use ${atk.name} this turn!`;
      } else if (isAllAttacksLocked) {
        card.title = `This Pokmon can't attack this turn!`;
      }
    }

    if(payable&&mainType){
      top.style.background=TYPE_HEX[mainType]||'#94a3b8';
      top.style.color='#fff';
      nm.style.color='#fff';
      dmg.style.color='#fff';
    }else{
      top.style.background='#2a2f36';
      top.style.color='#e5e7eb';
      if (!isMoveLocked && !isAllAttacksLocked) {
      card.classList.add('muted');
      }
    }

    // Check if we're in online mode
    const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
    const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
    const isOnline = matchId && window.firebaseDatabase;
    
    // In online mode, the current user is always UI player1 (bottom)
    // So check if it's UI player1's active Pokmon when it's their turn
    // In local mode, check if it's the current player's active Pokmon
    let isActiveCurrent = false;
    if (isOnline) {
      // In online mode, check if it's UI player1's active and it's their turn
      const uiPlayer1Active = activeFor('player1').querySelector('img');
      isActiveCurrent = (currentPlayer === 'player1' && uiPlayer1Active === img);
    } else {
      // Local mode: check if it's the current player's active
      isActiveCurrent = (currentPlayer && activeFor(currentPlayer).querySelector('img') === img);
    }

    if (isActiveCurrent) {
      card.onclick = async () => {
        // In online mode, the current user is always UI player1, so pk is always 'p1'
        // In local mode, use currentPlayer to determine pk
        const pk = isOnline ? 'p1' : (currentPlayer === 'player1' ? 'p1' : 'p2');
        
        if (isActiveBlockedFromAttacking(pk)) {
          const imgBlocked = getActiveImg(pk);
          const st = (imgBlocked?.dataset.status || '').toLowerCase();
          if (st === 'asleep') {
            showPopup('This Pokmon is asleep and cant attack.');
          } else if (st === 'paralyzed') {
            showPopup('This Pokmon is paralyzed and cant attack.');
          }
          return;
        }
        
        const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
        if (attackLock) {
          const currentTurn = globalThis.turnNumber || 0;
          let isLocked = false;
          if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
            isLocked = currentTurn === attackLock.lockedOnTurn + 2;
          } else if (attackLock === true) {
            isLocked = true; 
          }
          
          if (isLocked) {
            showPopup('This Pokmon can\'t attack this turn!');
            return;
          }
        }
        
        
        let isLockedNow = false;
        const instanceIdCheck = img.dataset.instanceId;
        const moveNameCheck = atk.name?.toLowerCase();
        const currentTurnCheck = globalThis.turnNumber || 0;
        if (instanceIdCheck && moveNameCheck && globalThis.__moveLocks?.[pk]?.[instanceIdCheck]?.[moveNameCheck]) {
          const moveLockCheck = globalThis.__moveLocks[pk][instanceIdCheck][moveNameCheck];
          if (typeof moveLockCheck === 'object' && moveLockCheck.lockedOnTurn !== undefined) {
            isLockedNow = currentTurnCheck === moveLockCheck.lockedOnTurn + 2;
          } else {
            isLockedNow = moveLockCheck === true;
          }
        }
        
        if (isLockedNow) {
          showPopup(`This Pokmon can't use ${atk.name} this turn!`);
          return;
        }

        if (!payable) {
          showPopup('Not enough energy to use this attack.');
          return;
        }

        const foe = opponentOf(currentPlayer);

        let damage = parseDamage(atk.damage);

        const effectState = {
          p1: playerState.player1,
          p2: playerState.player2,
          activeFor,
          benchFor,
          opponentOf,
          fetchCardMeta,
          damageActiveOf,
          beginPromotionFlow,
          showPopup,
          logEvent
        };
        
        try {
          damage = await applyMoveEffectFromCsv(
            effectState,
            pk,
            atk.name,
            damage
          );
          
          const boost = (globalThis.state?.temp?.[pk]?.globalDamageBoost ?? 0);
          if (boost) {
            damage += boost;
          }
          
          
          const nextTurnBonus = (globalThis.state?.temp?.[pkToPlayer(pk)]?.nextTurnDamageBonus ?? 0);
          if (nextTurnBonus > 0) {
            damage += nextTurnBonus;
            
            if (globalThis.state?.temp?.[pkToPlayer(pk)]) {
              globalThis.state.temp[pkToPlayer(pk)].nextTurnDamageBonus = 0;
            }
          }

        } catch (err) {
          console.error('Move effect error (zoom):', err);
        }
        
        try {
          const foeImg = getActiveImage(foe);
          if (foeImg) {
            const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
            const wk = metaFoe?.weaknesses?.[0];

            if (wk) {
              const wkType = (wk.type || '').toLowerCase();
              if (wkType !== 'colorless') {
                const atkType = (meta.types?.[0] || '').toLowerCase();
                if (atkType === wkType) {
                  damage += 20;
                }
              }
            }
          }
        } catch (err) {
          console.error('Weakness check failed (zoom):', err);
        }

        const result = await damageActiveOf(foe, damage, { attackerImg: img });
        
        const st = (img.dataset.status || "").toLowerCase();
        if (st && STATUS_ICON_URLS[st]) {
          zoomStatus.style.display = "block";
          zoomStatus.style.backgroundImage = `url('${STATUS_ICON_URLS[st]}')`;
        } else {
          zoomStatus.style.display = "none";
          zoomStatus.style.backgroundImage = "";
        }
        
        zoomBackdrop.classList.remove('show');
        currentZoom = { img: null, meta: null };
        
        if (result.knocked) {
          const foeImg2 = getActiveImage(foe);
          if (foeImg2) {
            const ended = await handleKnockOut(foe, foeImg2);
            if (ended) return;
            await beginPromotionFlow(foe);
          }
        }

        setTimeout(() => startTurn(foe), 300);
      };
    } else {
      
      card.classList.add('muted');
    }

    zoomAttacks.appendChild(card);
  });
  
  } 

  
  zoomWeakness.innerHTML='';
  {
    const wk=(meta.weaknesses&&meta.weaknesses[0])||null;
    if(wk){
      const k=String(wk.type||'').toLowerCase();
      if(k==='colorless'){
        zoomWeakness.textContent='';
      }else{
        const ico=document.createElement('span');
        ico.className='mini-icon';
        ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;

        const val=document.createElement('span');
        val.className='mini-badge';
        val.textContent=wk.value||'';

        zoomWeakness.appendChild(ico);
        zoomWeakness.appendChild(val);
      }
    }else zoomWeakness.textContent='';
  }

  
  zoomRetreat.innerHTML='';
  const rcost=computeRetreatCost(img.closest('.active'),meta);

  for(let i=0;i<rcost;i++){
    const ico=document.createElement('span');
    ico.className='mini-icon';
    ico.style.backgroundImage=`url('${ENERGY_ICONS.colorless}')`;
    zoomRetreat.appendChild(ico);
  }
}

if(toolBackdrop){
  toolBackdrop.addEventListener('click',e=>{
    if(e.target===toolBackdrop)toolBackdrop.classList.remove('show');
  });
  document.addEventListener('keydown',e=>{
    if(e.key==='Escape')toolBackdrop.classList.remove('show');
  });
}

function clearGlow(){
  $$('.glow-evo,.promote-glow').forEach(el=>el.classList.remove('glow-evo','promote-glow'));
  isEvoMode=false;evoMeta=null;evoOwner=null;evoHandCard=null;
}

async function evolveCard(target,meta,handCard,owner,set,num){
  const pk = owner === 'player1' ? 'p1' : 'p2';
  const oppPk = pk === 'p1' ? 'p2' : 'p1';
  const activeDiv = owner === 'player1' ? p1Active : p2Active;
  const activeImg = activeDiv?.querySelector('img');
  const isTargetActive = target === activeImg;
  
  
  let hasBoostedEvolution = false;
  if (isTargetActive) {
    const cacheKey = `${target.dataset.set}-${target.dataset.num}`;
    const numPadded = String(target.dataset.num || '').padStart(3, '0');
    const numUnpadded = String(parseInt(target.dataset.num || '0', 10));
    const abilityRow = globalThis.abilityCache?.[cacheKey] || 
                      globalThis.abilityCache?.[`${target.dataset.set}-${numPadded}`] || 
                      globalThis.abilityCache?.[`${target.dataset.set}-${numUnpadded}`];
    
    if (abilityRow?.effect_type === 'allow_evolution_first_turn') {
      hasBoostedEvolution = true;
    }
  }
  
  
  if(globalThis.turnNumber<=2){
    if (!hasBoostedEvolution) {
      showPopup('You cannot evolve during the first two turns.');
      clearGlow();
      return;
    }
  }
  
  
  const playedTurn=parseInt(target.dataset.playedTurn||'0',10);
  if(playedTurn===globalThis.turnNumber){
    if (!hasBoostedEvolution) {
      showPopup('Cannot evolve the turn it was played.');
      clearGlow();
      return;
    }
  }
  
  
  if (isTargetActive) {
    
    const oppActive = oppPk === 'p1' ? p1Active : p2Active;
    const oppBench = oppPk === 'p1' ? p1Bench : p2Bench;
    const oppPokemon = [
      ...(oppActive?.querySelectorAll('img') || []),
      ...(oppBench?.querySelectorAll('img') || [])
    ];
    
    for (const oppImg of oppPokemon) {
      const cacheKey = `${oppImg.dataset.set}-${oppImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'block_evolution') {
        const targetParam = abilityRow.param1 || 'opponent';
        if (targetParam === 'opponent' || targetParam === 'all') {
          showPopup('Cannot evolve Active Pokmon - blocked by Primeval Law!');
          clearGlow();
          return;
        }
      }
    }
  }

  const slot=target.closest('.card-slot');
  
  // Validate that the slot belongs to the correct owner
  const slotOwnerDiv = slot?.closest('#player1, #player2');
  const slotOwner = slotOwnerDiv?.id === 'player1' ? 'player1' : 'player2';
  if (slotOwner !== owner) {
    console.error('[evolveCard] Slot owner mismatch:', { slotOwner, owner, target: target.alt });
    showPopup('Cannot evolve - slot belongs to different player.');
    clearGlow();
    return;
  }
  
  // Note: Evolution always replaces the Pokemon in the same slot, so bench being full doesn't matter
  
  const prevBaseHp = parseInt(target.dataset.hp||'0',10);
  const prevSlotMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  const prevHp = prevSlotMaxHp || prevBaseHp; 
  // [EVOLUTION-HP] Get current HP - ALWAYS try to read from HP overlay first if it exists
  // The HP overlay is the source of truth for current HP
  let prevChp = parseInt(target.dataset.chp || '0', 10);
  console.log('[EVOLUTION-HP] Initial HP reading:', {
    pokemon: target.alt,
    datasetChp: target.dataset.chp,
    prevChp,
    prevBaseHp,
    prevHp
  });
  
  // Always try to read from HP overlay if it exists (it's more reliable than dataset.chp)
    const hpOverlay = slot?.querySelector('.hp-overlay');
  console.log('[EVOLUTION-HP] HP overlay check:', {
    hasSlot: !!slot,
    hasHpOverlay: !!hpOverlay,
    slotId: slot?.id
  });
  
    if (hpOverlay) {
      const hpText = hpOverlay.textContent || '';
      const hpMatch = hpText.match(/(\d+)\s*\/\s*(\d+)/);
    console.log('[EVOLUTION-HP] HP overlay parsing:', {
      hpText,
      hasMatch: !!hpMatch,
      matchResult: hpMatch
    });
    
      if (hpMatch) {
      // Parse the current HP from the overlay (first number)
      const parsedChp = parseInt(hpMatch[1], 10);
      const parsedMax = parseInt(hpMatch[2], 10);
      prevChp = parsedChp;
      console.log('[EVOLUTION-HP] Successfully read HP from overlay:', {
        hpText,
        parsedChp,
        parsedMax,
        prevChp
      });
      } else {
      console.warn('[EVOLUTION-HP] HP overlay exists but could not parse:', hpText);
      }
    } else {
    console.log('[EVOLUTION-HP] No HP overlay found, using dataset.chp or fallback');
  }
  
  // If we still don't have a valid prevChp, fall back to dataset.chp or assume full HP
  if (!prevChp || prevChp <= 0) {
    const fallbackChp = parseInt(target.dataset.chp || '0', 10) || prevHp;
    console.log('[EVOLUTION-HP] Using fallback HP:', {
      prevChp,
      fallbackChp,
      usingFullHp: fallbackChp === prevHp
    });
    prevChp = fallbackChp;
    }
  
  // Ensure prevChp doesn't exceed prevHp
  const actualPrevChp = Math.min(prevChp, prevHp);
  
  console.log('[EVOLUTION-HP] Final HP calculation:', {
    pokemon: target.alt,
    prevBaseHp,
    prevHp,
    prevChp,
    actualPrevChp,
    newHp: parseInt(meta.hp||'0',10)
  });

  const padded=String(num).padStart(3,'0');
  const evolvedImage=`https://assets.tcgdex.net/en/tcgp/${set}/${padded}/high.png`;
  const evo=document.createElement('img');
  evo.className='card-img';
  evo.alt=meta.name;
  evo.src=evolvedImage;
  evo.dataset.playedTurn=globalThis.turnNumber;
  
  
  if (target.dataset.instanceId) {
    evo.dataset.instanceId = target.dataset.instanceId;
  }
  
  if (target.dataset.evolvedViaRareCandy === 'true') {
    evo.dataset.evolvedViaRareCandy = 'true';
  }
  evo.dataset.evolvedFrom=(meta.evolveFrom||'').toLowerCase();
  evo.dataset.set=set;
  evo.dataset.num=num;

  

  clearStatusOnImg(target);

const energyBox = slot.querySelector('.energy-pips');
// Reuse hpOverlay that was already queried above for HP calculation
const toolThumb = slot.querySelector('.tool-thumb');

const oldImg = slot.querySelector('img'); 
const hadEnergy = !!energyBox;
const hadHP     = !!hpOverlay;
const hadTool   = !!toolThumb;

let handCardForAnimation = null;

if (handCard && typeof handCard.getBoundingClientRect === 'function') {
  handCardForAnimation = handCard;
} else if (evoHandCard && typeof evoHandCard.getBoundingClientRect === 'function') {
  
  handCardForAnimation = evoHandCard;
} else {
  
  const handCardElement = document.querySelector(`.hand img[data-set="${set}"][data-num="${num}"]`);
  if (handCardElement && typeof handCardElement.getBoundingClientRect === 'function') {
    handCardForAnimation = handCardElement;
  } else if (handCard && handCard.set && handCard.number) {
    
    const cardElement = document.querySelector(`.hand img[data-set="${handCard.set}"][data-num="${handCard.number || handCard.num}"]`);
    if (cardElement && typeof cardElement.getBoundingClientRect === 'function') {
      handCardForAnimation = cardElement;
    }
  }
}

if (oldImg) oldImg.remove();

slot.insertBefore(evo, slot.firstChild);

if (handCardForAnimation) {
  animateSlideFromHand(handCardForAnimation, slot, evo);
} else {
  
  evo.style.opacity = '0';
  evo.style.transition = 'opacity 0.2s ease';
  requestAnimationFrame(() => {
    evo.style.opacity = '1';
  });
}

if (hadEnergy) slot.appendChild(energyBox);
if (hadHP)     slot.appendChild(hpOverlay);
if (hadTool && toolThumb) {
  // Only append tool if it doesn't already exist to prevent double image
  const existingTool = slot.querySelector('.tool-thumb');
  if (!existingTool) {
    slot.appendChild(toolThumb);
  }
}

const toolObj = getToolDataFromSlot(slot);
if (toolObj) {
  setToolDataOnSlot(slot, toolObj);
}
  
  const newHp = parseInt(meta.hp||'0',10) || prevHp || 0;
  
  
  const toolData = getToolDataFromSlot(slot);
  const isGiantCape = toolData && (toolData.set === 'A2' && toolData.num === '147');
  const isLeafCape = toolData && (toolData.set === 'A3' && toolData.num === '147');
  const hasHpBoostingTool = isGiantCape || isLeafCape;
  const hpBonus = isGiantCape ? 20 : (isLeafCape ? 30 : 0);
  
  
  const hpIncrease = newHp - prevBaseHp;
  
  // Calculate newMaxHp first (before using it)
  const newMaxHp = newHp + hpBonus;
  
  // Calculate newChp: preserve current HP and add the HP increase from evolution
  // This matches battle.html logic
  let newChp = Math.max(0, actualPrevChp + hpIncrease);
  // If there's an HP boosting tool, add the bonus to current HP
  if (hasHpBoostingTool) {
    newChp += hpBonus; 
  }
  // Ensure newChp doesn't exceed newMaxHp
  newChp = Math.min(newChp, newMaxHp);
  
  
  if (hasHpBoostingTool) {
    slot.dataset.maxHp = String(newMaxHp);
  } else {
    
    delete slot.dataset.maxHp;
  }
  
  setHpOnImage(evo, newHp, newChp);
  markSlot(slot,true);
  removeFromHand(owner,set,num);
  renderAllHands();

  const evolvedViaRareCandy = target.dataset.evolvedViaRareCandy === 'true';
  logEvent({
    player: owner,
    text: evolvedViaRareCandy 
      ? `Evolved ${meta.evolveFrom || 'a Pokmon'} into ${meta.name} (via Rare Candy).`
      : `Evolved ${meta.evolveFrom || 'a Pokmon'} into ${meta.name}.`,
    cardSet:set,cardNum:num
  });

  showPopup(`${meta.evolveFrom}  ${meta.name}`);
  
  const isActive = slot.closest('.active');
  if (isActive) {
    const playerNum = owner === 'player1' ? 1 : 2;
    updatePlayerTypeBackground(playerNum);
  }
  
  // Sync evolution to Firebase
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
  if (isOnline && typeof updateGameStatePartial === 'function') {
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
    const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
      ? 'player1' 
      : 'player2';
    
    try {
      const cardData = {
        set: set,
        num: num,
        name: meta.name,
        instanceId: evo.dataset.instanceId,
        hp: newHp,
        chp: parseInt(evo.dataset.chp || newHp, 10),
        playedTurn: globalThis.turnNumber || 0
      };
      
      // Only include maxHp if it exists (Firebase doesn't allow undefined)
      if (slot.dataset.maxHp) {
        cardData.maxHp = parseInt(slot.dataset.maxHp, 10);
      }
      
      if (isActive) {
        // Update active Pokemon
        await updateGameStatePartial({
          [`${matchOwner}/active`]: cardData
        });
      } else {
        // Update bench Pokemon - use owner directly, not benchOwnerKey
        const currentBench = playerState[owner]?.bench || [];
        const benchArray = Array.isArray(currentBench) ? [...currentBench] : [];
        
        // Find and update the evolved Pokemon in bench
        const benchIndex = benchArray.findIndex(c => c && c.instanceId === evo.dataset.instanceId);
        const benchCardData = {
          ...cardData,
          chp: parseInt(evo.dataset.chp || cardData.hp, 10)
        };
        // Only include maxHp if it exists (Firebase doesn't allow undefined)
        if (slot.dataset.maxHp) {
          benchCardData.maxHp = parseInt(slot.dataset.maxHp, 10);
        }
        
        if (benchIndex >= 0) {
          benchArray[benchIndex] = benchCardData;
        } else {
          // If not found, add it (shouldn't happen, but just in case)
          benchArray.push(benchCardData);
        }
        
        await updateGameStatePartial({
          [`${matchOwner}/bench`]: benchArray
        });
      }
      
      // Broadcast evolution action
      if (typeof broadcastAction === 'function' && ACTION_TYPES) {
        await broadcastAction(ACTION_TYPES.EVOLVE, {
          owner: matchOwner,
          pokemon: cardData,
          evolvedFrom: {
            set: target.dataset.set,
            num: target.dataset.num,
            name: target.alt
          },
          isActive: !!isActive,
          turnNumber: globalThis.turnNumber || 0
        });
      }
      
      console.log('Synced evolution to Firebase:', {
        matchOwner,
        pokemonName: meta.name,
        isActive: !!isActive
      });
    } catch (error) {
      console.error('Error syncing evolution to Firebase:', error);
    }
  }
  
  
  try {
    const cacheKey = `${set}-${num}`;
    const abilityRow = globalThis.abilityCache?.[cacheKey];
    
    if (abilityRow?.effect_type === 'draw_on_evolution') {
      const pkForAbility = owner === 'player1' ? 'p1' : 'p2';
      
      const effectState = {
        p1: playerState.player1,
        p2: playerState.player2
      };
      
      if (typeof globalThis.applyAbilityEffectFromCsv === 'function') {
        await globalThis.applyAbilityEffectFromCsv(effectState, pkForAbility, abilityRow, {});
      }
    }
  } catch (err) {
    console.error('[Evolution] Happy Ribbon check failed:', err);
  }
  
  if(currentZoom.img&&currentZoom.img===evo){
    await buildZoomPanel(meta,evo);
  }
}

function handFind(owner,set,num){
  return playerState[owner].hand.find(c=>c.set===set&&String(c.number||c.num)===String(num))||null;
}

async function triggerElectromagneticWall(targetImg) {
  if (!targetImg) return;
  
  try {
    
    const owner = targetImg.closest('#player1') ? 'player1' : 'player2';
    const pk = owner === 'player1' ? 'p1' : 'p2';
    const oppPk = pk === 'p1' ? 'p2' : 'p1';
    
    
    const oppActive = oppPk === 'p1' ? p1Active : p2Active;
    const oppActiveImg = oppActive?.querySelector('img');
    
    if (oppActiveImg) {
      
      const set = oppActiveImg.dataset.set;
      const num = oppActiveImg.dataset.num;
      const numPadded = String(num || '').padStart(3, '0');
      const numUnpadded = String(parseInt(num || '0', 10));
      const cacheKey1 = `${set}-${numPadded}`;
      const cacheKey2 = `${set}-${numUnpadded}`;
      const cacheKey3 = `${set}-${num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey1] || 
                        globalThis.abilityCache?.[cacheKey2] || 
                        globalThis.abilityCache?.[cacheKey3];
      
      if (abilityRow?.effect_type === 'damage_on_opponent_energy_attach') {
        const damage = parseInt(abilityRow.param1 || '20', 10);
        
        
        const damageFn = globalThis.damageImg || window.damageImg || (typeof damageImg !== 'undefined' ? damageImg : null);
        if (damageFn && typeof damageFn === 'function') {
          const result = damageFn(targetImg, damage);
          showPopup(`Electromagnetic Wall: ${oppActiveImg.alt} deals ${damage} damage to ${targetImg.alt}!`);
          
          
          if (result && result.knocked) {
            
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const activeImg = activeDiv?.querySelector('img');
            const wasActive = targetImg === activeImg;
            
            
            if (typeof handleKnockOut === 'function') {
              const gameEnded = await handleKnockOut(owner, targetImg, wasActive);
              if (!gameEnded && wasActive && typeof beginPromotionFlow === 'function') {
                await beginPromotionFlow(owner);
              }
            }
          }
        } else {
        }
      }
    }
  } catch (err) {
  }
}

globalThis.triggerElectromagneticWall = triggerElectromagneticWall;

function attachEnergyToSlot(owner,slot,energyKey){
  if(!slot||!energyKey)return;
  
  // Prevent energy attachment on turn 1
  const currentTurnNumber = globalThis.turnNumber || 0;
  if (currentTurnNumber === 1 && !isSetupPhase) {
    showPopup('You cannot attach Energy on your first turn.');
    return;
  }
  
  const currentHasAttached = hasAttachedEnergyThisTurn || globalThis.hasAttachedEnergyThisTurn;
  if (currentHasAttached && !isSetupPhase) {
    showPopup('You can only attach one Energy per turn.');
    return;
  }
  
  const img=slot.querySelector('img');
  if(!img){showPopup('Select a Pokmon in play.');return}
  
  // Check if we're in online mode
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
  
  // In online mode, the current user is always UI player1 (bottom)
  // So they should only be able to attach to UI player1's Pokmon
  // In local mode, use currentPlayer to determine which area to check
  const area = isOnline ? $('#player1') : (currentPlayer==='player1'?$('#player1'):$('#player2'));
  if(!area.contains(slot)||slot.closest('.hand')){
    showPopup('Attach only to Pokmon in play.');
    return;
  }
  const set=img.dataset.set,num=img.dataset.num;
  
    let box=slot.querySelector('.energy-pips');
    if(!box){
      box=document.createElement('div');
      box.className='energy-pips';
      slot.appendChild(box);
    }
    const pip=document.createElement('div');
    pip.className='energy-pip';
    pip.dataset.type=energyKey;
    pip.style.backgroundImage=`url('${ENERGY_ICONS[energyKey]||''}')`;
    box.appendChild(pip);
    
    
    addDoubledEnergyVisuals(img, box, energyKey);
    
    
    if (typeof triggerNightmareAura === 'function') {
      triggerNightmareAura(img, energyKey);
    }
    
    
    (async () => {
      try {
        const pk = owner === 'player1' ? 'p1' : 'p2';
        const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
        
        if (abilityRow?.effect_type === 'inflict_status_on_energy_attach') {
          if (typeof globalThis.applyAbilityEffectFromCsv === 'function') {
            
            const state = {
              p1: playerState.player1,
              p2: playerState.player2
            };
            await globalThis.applyAbilityEffectFromCsv(state, pk, abilityRow, { targetImg: img });
          }
        }
      } catch (err) {
      }
    })();
    
    
    triggerElectromagneticWall(img);
    
    hasAttachedEnergyThisTurn=true;
  globalThis.hasAttachedEnergyThisTurn=true;
  
  // Sync energy attachment to Firebase
  (async () => {
    const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
    const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
    const isOnline = matchId && window.firebaseDatabase;
    if (isOnline && typeof broadcastAction === 'function') {
      const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
      const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
      const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
        ? 'player1' 
        : 'player2';
      
      // Determine if this is active or bench, and get position
      const isActive = slot.closest('.active-slot') !== null;
      let position = 'active';
      let benchIndex = -1;
      
      if (!isActive) {
        const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
        const benchSlots = Array.from(benchDiv.querySelectorAll('.card-slot'));
        benchIndex = benchSlots.indexOf(slot);
        if (benchIndex >= 0) {
          position = `bench-${benchIndex}`;
        }
      }
      
      try {
        // Build target object - only include benchIndex if it's valid
        const targetObj = {
          set: set,
          num: num,
          name: img.alt,
          instanceId: img.dataset.instanceId,
          position: position
        };
        
        // Only add benchIndex if it's a valid bench position
        if (benchIndex >= 0) {
          targetObj.benchIndex = benchIndex;
        }
        
        await broadcastAction(ACTION_TYPES.ATTACH_ENERGY, {
          owner: matchOwner,
          target: targetObj,
          energy: {
            type: energyKey
          },
          turnNumber: globalThis.turnNumber || 0
        });
        console.log('Synced energy attachment to Firebase:', {
          matchOwner,
          position,
          energyKey,
          targetName: img.alt
        });
      } catch (error) {
        console.error('Error syncing energy attachment to Firebase:', error);
      }
    }
  })();
  
  selectedEnergy = null;
  globalThis.selectedEnergy = null;
  if (globalThis.selectedEnergyElement) {
    globalThis.selectedEnergyElement.classList.remove('selected-glow');
    globalThis.selectedEnergyElement = null;
  }
  
  const renderFn = globalThis.renderEnergyZone || renderEnergyZone;
  if (typeof renderFn === 'function') {
    renderFn();
  }
  
    showPopup('Energy attached');

    logEvent({
      player: owner,
      text:`Attached ${energyKey} Energy.`,
      cardSet:set,cardNum:num
    });

  fetchCardMeta(set,num).then(meta=>{
    const isFossil = img.dataset.isFossil === 'true';
    if(String(meta.category||'').toLowerCase()!=='pokemon' && !isFossil){
      showPopup('Warning: Card may not be a Pokmon.');
    }
    if(currentZoom.img&&slot.contains(currentZoom.img)){
      buildZoomPanel(meta,currentZoom.img);
    }
  }).catch(()=>{
  });
}

function addDoubledEnergyVisuals(img, energyBox, energyKey) {
  if (!img || !energyBox || !energyKey) return;
  
  
  const p1Active = document.querySelector('#player1 .active img');
  const p1Bench = Array.from(document.querySelectorAll('#player1 .bench img'));
  const p2Active = document.querySelector('#player2 .active img');
  const p2Bench = Array.from(document.querySelectorAll('#player2 .bench img'));
  
  let owner = null;
  if (img === p1Active || p1Bench.includes(img)) owner = 'p1';
  else if (img === p2Active || p2Bench.includes(img)) owner = 'p2';
  
  if (!owner) return;
  
  
  const allMyPokemon = owner === 'p1' ? [p1Active, ...p1Bench] : [p2Active, ...p2Bench];
  let hasSerperior = false;
  
  for (const pokemon of allMyPokemon) {
    if (pokemon && pokemon.alt && pokemon.alt.toLowerCase().includes('serperior')) {
      hasSerperior = true;
      break;
    }
  }
  
  
  if (hasSerperior && energyKey.toLowerCase() === 'grass') {
    const types = (img.dataset.pokemonTypes || '').toLowerCase().split(',');
    if (types.includes('grass')) {
      
      const phantomPip = document.createElement('div');
      phantomPip.className = 'energy-pip phantom-pip';
      phantomPip.dataset.type = energyKey;
      phantomPip.dataset.phantom = 'true';  
      phantomPip.style.backgroundImage = `url('${ENERGY_ICONS[energyKey]||''}')`;
      phantomPip.style.opacity = '0.7';
      phantomPip.title = 'Doubled by Jungle Totem';
      energyBox.appendChild(phantomPip);

    }
  }
}

function updateAllEnergyVisuals() {
  console.log('[UPDATE-ENERGY-VISUALS-DEBUG] Called updateAllEnergyVisuals');
  
  const observer = globalThis.pokemonTypeObserver;
  if (observer) {
    observer.disconnect();
  }
  
  
  ['p1', 'p2'].forEach(owner => {
    const area = owner === 'p1' ? document.querySelector('#player1') : document.querySelector('#player2');
    if (!area) return;
    
    const allSlots = Array.from(area.querySelectorAll('.card-slot'));
    
    allSlots.forEach(slot => {
      const img = slot.querySelector('img');
      const energyBox = slot.querySelector('.energy-pips');
      if (!img || !energyBox) return;
      
      const pokemonName = img.alt;
      const slotType = slot.closest('.active') ? 'active' : 'bench';
      const pipCount = energyBox.querySelectorAll('.energy-pip:not(.phantom-pip)').length;
      
      console.log('[UPDATE-ENERGY-VISUALS-DEBUG] Processing', {
        pokemon: pokemonName,
        slotType,
        pipCount,
        energyTypes: Array.from(energyBox.querySelectorAll('.energy-pip:not(.phantom-pip)')).map(p => p.dataset.type)
      });
      
      
      energyBox.querySelectorAll('.phantom-pip').forEach(p => p.remove());
      
      
      const realPips = Array.from(energyBox.querySelectorAll('.energy-pip:not(.phantom-pip)'));
      
      
      realPips.forEach(pip => {
        const energyType = pip.dataset.type;
        if (energyType) {
          addDoubledEnergyVisuals(img, energyBox, energyType);
        }
      });
    });
  });
  
  
  if (observer && document.body) {
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }

}

globalThis.updateAllEnergyVisuals = updateAllEnergyVisuals;

document.body.addEventListener('click', async e => {
  if (menuJustClosed) {
    return;
  }
  
  if (e.target.closest('#zoomBackdrop') || e.target.closest('.attack-menu') || e.target.closest('#handBackdrop') || e.target.closest('#toolBackdrop')) {
    return;
  }
  
  const isPlayerArea = e.target.closest('#player1') || e.target.closest('#player2');
  if (isPlayerArea && !e.target.closest('img') && !e.target.closest('.card-slot') && !e.target.closest('button') && !e.target.closest('.energy-zone') && !e.target.closest('.hand')) {
    if (!isPromotionPhase && !isRetreatSelection) {
      return;
    }
  }
  
  if (e.button !== 0) {
    return;
  }

  
  const toolThumb = e.target.closest('.tool-thumb');
  if (toolThumb) {
    e.stopPropagation();
    e.preventDefault();
    
    const slot = toolThumb.closest('.card-slot');
    const toolData = getToolDataFromSlot(slot);
    const pokemonImg = slot.querySelector('img:not(.tool-thumb)');
    
    if (toolData && toolData.set && toolData.num) {
      try {
        const meta = await fetchCardMeta(toolData.set, toolData.num);
        
        
        if (handBackdrop && handImg && handToolImg) {
          
          if (pokemonImg) {
            handImg.src = pokemonImg.src;
          }
          
          
          handToolImg.src = toolData.src || toolThumb.src;
          handToolImg.style.display = 'block';
          
          handBackdrop.classList.add('show');
          handTitle.textContent = meta.name || 'Tool';
          
          if (handType) {
            handType.textContent = 'Tool';
            handType.style.background = trainerColor('tool');
          }
          if (handEffect) {
            handEffect.textContent = meta.effect || meta.description || 'No effect listed.';
          }
        }

      } catch (err) {
        showPopup('Could not load tool data.');
        console.error('[tool-click] Error:', err);
      }
    }
    
    return;
  }

  
  if (toolAttachPending) {
    const targetImg = e.target.closest('.active img, .bench img');
    
    if (!targetImg) {
      cancelSelection();
      return;
    }
    if (targetImg) {
      const owner = targetImg.closest('#player1') ? 'player1' : 'player2';
      if (owner !== toolAttachPending.owner) {
        showPopup('Attach Tools to your own Pokmon.');
      } else {
        const targetSlot = targetImg.closest('.card-slot');
        if (getToolDataFromSlot(targetSlot)) {
          showPopup('This Pokmon already has a Tool attached.');
        } else {
          
          // Don't attach tool visually yet - wait until effect succeeds
          // This prevents the tool from being attached if the effect fails
          
          const cardId = csvIdFor(toolAttachPending.set, toolAttachPending.num);
          const effect = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
          
          // [TOOL-ATTACH] Track tool attachment
          console.log('[TOOL-ATTACH] Tool attachment (click):', {
            tool: `${toolAttachPending.set}-${toolAttachPending.num}`,
            target: targetImg.alt,
            owner,
            effectFound: !!effect,
            effectType: effect?.effect_type,
            isRareCandy: effect?.effect_type === 'evolve_basic_to_stage2'
          });
          
          if (effect && effect.effect_type) {
            // Set toolAttachTarget BEFORE calling applyTrainerEffect so Rare Candy can detect it
            globalThis.toolAttachTarget = targetImg;
            console.log('[TOOL-ATTACH] Set toolAttachTarget:', {
              target: targetImg.alt,
              toolAttachTarget: !!globalThis.toolAttachTarget
            });
            
            try {
              console.log('[TOOL-ATTACH] Applying tool effect (click):', {
                effectType: effect.effect_type,
                param1: effect.param1,
                param2: effect.param2,
                toolAttachTarget: !!globalThis.toolAttachTarget
              });
              await (globalThis.applyTrainerEffect || applyTrainerEffect)(effect, owner, null);
              console.log('[TOOL-ATTACH] Tool effect applied successfully (click)'); 
              
              // Only attach tool and remove from hand if effect succeeded
              await attachToolToSlot(owner, targetSlot, {
                set: toolAttachPending.set,
                num: toolAttachPending.num,
                src: toolAttachPending.src
              });
              
              removeFromHand(owner, toolAttachPending.set, toolAttachPending.num);
              renderAllHands();

              logEvent({
                player: owner,
                text: 'Attached Tool.',
                cardSet: toolAttachPending.set,
                cardNum: toolAttachPending.num
              });

              toolAttachPending = null;
              clearSelectionGlow();
              
            } catch (err) {
              // Effect failed - don't attach tool and don't remove from hand
              console.error('[TOOL-ATTACH] Tool effect failed (click):', {
                error: err.message,
                effectType: effect?.effect_type,
                tool: `${toolAttachPending?.set}-${toolAttachPending?.num}`
              });
              showPopup(err.message || 'Cannot attach this Tool here.');
              // Tool is NOT removed from hand when effect fails
            } finally {
              globalThis.toolAttachTarget = null;
              console.log('[TOOL-ATTACH] Cleared toolAttachTarget (click)');
            }
          } else {
            // Tool with no effect - safe to attach and remove from hand
            await attachToolToSlot(owner, targetSlot, {
              set: toolAttachPending.set,
              num: toolAttachPending.num,
              src: toolAttachPending.src
            });
            
            removeFromHand(owner, toolAttachPending.set, toolAttachPending.num);
            renderAllHands();

            logEvent({
              player: owner,
              text: 'Attached Tool.',
              cardSet: toolAttachPending.set,
              cardNum: toolAttachPending.num
            });

            toolAttachPending = null;
            clearSelectionGlow();
          }
        }
      }
      e.stopPropagation();
      return;
    }
  }

  
  const currentSelectedEnergy = selectedEnergy || globalThis.selectedEnergy;
  if (currentSelectedEnergy) {
    const isEnergyZoneClick = e.target.closest('.energy-zone') || e.target.classList.contains('energy');
    if (isEnergyZoneClick) {
      e.stopPropagation();
      e.preventDefault();
      return;
    }
    
    let img = e.target.closest('img');
    if (!img && e.target.closest('.card-slot')) {
      const slot = e.target.closest('.card-slot');
      img = slot.querySelector('img');
    }
    
    if (!img || img.closest('.hand')) {
      e.stopPropagation();
      e.preventDefault();
      cancelSelection();
      return;
    }
    
    const slot = img.closest('.card-slot');
    
    if (!slot) {
      e.stopPropagation();
      e.preventDefault();
      cancelSelection();
      return;
    }
    
    const owner = img.closest('#player1') ? 'player1' : 'player2';
    
    // Check if we're in online mode
    const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
    const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
    const isOnline = matchId && window.firebaseDatabase;
    
    // In online mode, the current user is always UI player1 (bottom)
    // So they should only be able to attach to UI player1's Pokmon
    // In local mode, check if owner matches currentPlayer (whose turn it is)
    if (isOnline) {
      if (owner !== 'player1') {
        e.stopPropagation();
        e.preventDefault();
        e.stopImmediatePropagation();
        showPopup('Attach Energy to your own Pokmon.');
        return;
      }
    } else {
      // Local mode: check if owner matches currentPlayer
    if (owner !== currentPlayer) {
      e.stopPropagation();
      e.preventDefault();
      e.stopImmediatePropagation();
      showPopup('Attach Energy to your own Pokmon.');
      return;
      }
    }
    
    e.stopPropagation();
    e.preventDefault();
    e.stopImmediatePropagation();
    attachEnergyToSlot(owner, slot, currentSelectedEnergy);
    selectedEnergy = null;
    globalThis.selectedEnergy = null;
    clearSelectionGlow();
    return;
  }

  
  

  const benchImg = e.target.closest('.bench img');
  if (benchImg && !benchImg.closest('.hand')) {
    const isInSelectionMode = isEvoMode || 
                              toolAttachPending || 
                              selectedEnergy || 
                              isPromotionPhase || 
                              isRetreatSelection || 
                              abilityJustUsed ||
                              globalThis.__selectionActive ||
                              globalThis.__pokemonCommActive ||
                              globalThis.__rareCandyActive ||
                              globalThis.__silverSelectionActive ||
                              globalThis.isSelectingPokemon;

    if (!isInSelectionMode) {
      e.preventDefault();
      e.stopPropagation();
      
      zoomImg.src = benchImg.src;
      zoomBackdrop.classList.add('show');
      
      try {
        const set = benchImg.dataset.set;
        const num = benchImg.dataset.num;
        const meta = await fetchCardMeta(set, num);
        await buildZoomPanel(meta, benchImg);
      } catch {
        zoomTitle.textContent = 'Pokmon';
        zoomHp.textContent = '';
        zoomAttacks.innerHTML = '<div style="color:#cbd5e1">No data</div>';
        zoomEnergyCount.textContent = 'x0';
        zoomEnergyIcons.innerHTML = '';
        zoomWeakness.textContent = '';
        zoomRetreat.innerHTML = '';
        zoomTools.innerHTML = '<div class="chip">none</div>';
        zoomAbilities.style.display = 'none';
      }
      
      return;
    }
  }

  
  

  let clickedImg = e.target.closest('img');
  if (!clickedImg && e.target.closest('.card-slot')) {
    const slot = e.target.closest('.card-slot');
    clickedImg = slot.querySelector('img');
  }
  
  if (clickedImg && !clickedImg.closest('.hand')) {
    const activeArea = currentPlayer ? activeFor(currentPlayer) : null;
    
    if (activeArea && activeArea.contains(clickedImg)) {
      if (isEvoMode && clickedImg.classList.contains('glow-evo')) {
        return;
      }

      const currentSelectedEnergy = selectedEnergy || globalThis.selectedEnergy;
      if (isEvoMode || toolAttachPending || currentSelectedEnergy || isPromotionPhase || isRetreatSelection || abilityJustUsed) {
        e.stopPropagation();
        e.preventDefault();
        e.stopImmediatePropagation();
        return;
      }

      const set = clickedImg.dataset.set;
      const num = clickedImg.dataset.num;

      
      if (!set || !num) {
        console.error('[attack-menu] Missing set/num:', { set, num });
        closeAttackMenu();
        return;
      }

      try {
        const meta = await fetchCardMeta(set, num);
        
        if (!meta) {
          showPopup('Could not load card data.');
          return;
        }
        
        
        const category = String(meta.category || '').toLowerCase();
        const isFossil = clickedImg.dataset.isFossil === 'true';
        
        if (category !== 'pokemon' && !isFossil) {
          showPopup('This is not a Pokmon card.');
          return;
        }
        
        
        showAttackMenuFor(clickedImg, meta);
        
      } catch (err) {
        console.error('[attack-menu] Error loading card:', err);
        showPopup('No attacks available.');
      }
      
      return;
    }
  }

  

if (e.target.tagName !== 'IMG') return;
const inHand = e.target.closest('.hand');
if (!inHand) return;

if (globalThis.__selectionActive) {
  
  e.stopPropagation();
  e.preventDefault();
  showPopup('Cannot select cards in hand. Please select a Pokmon in play.');
  return;
}

const owner = e.target.dataset.owner;
const set = e.target.dataset.set;
const num = e.target.dataset.num;
const trainerCardImg = e.target; 

// During setup phase, allow clicks on both players' cards (both local and online)
const isSetupPhase = globalThis.isSetupPhase !== undefined ? globalThis.isSetupPhase : true;
const getCurrentMatchIdFn = globalThis.getCurrentMatchId;
const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
const isOnline = matchId && (typeof window !== 'undefined' && window.firebaseDatabase);
const isLocalSetup = !isOnline && isSetupPhase;
const isOnlineSetup = isOnline && isSetupPhase;

// Allow clicks during setup phase (both local and online), or if it's the current player's turn
// In online mode, the current user is always UI player1, so check if owner === 'player1' when it's their turn
// In local mode, check if owner === currentPlayer
if (!isLocalSetup && !isOnlineSetup && !globalThis.__silverSelectionActive) {
  if (isOnline) {
    // In online mode, only allow clicks on UI player1's cards when it's their turn
    if (currentPlayer !== 'player1' || owner !== 'player1') {
      return;
    }
  } else {
    // Local mode: check if owner matches currentPlayer
    if (currentPlayer && owner !== currentPlayer) {
      return;
    }
  }
}

if (globalThis.__silverSelectionActive && owner !== currentPlayer) {
  
  return;
}

if (globalThis.__pokemonCommActive) {
  const selData = globalThis.__pokemonCommSelection;
  if (selData) {
    
    const clickedCard = selData.hand.find(c => 
      (c.set === set && String(c.number || c.num) === String(num))
    );
    
    if (clickedCard && selData.pokemonInHand.includes(clickedCard)) {
      
      globalThis.__pokemonCommActive = false;
      globalThis.__pokemonCommSelection = null;
      
      if (globalThis.__pokemonCommResolve) {
        globalThis.__pokemonCommResolve(clickedCard);
        globalThis.__pokemonCommResolve = null;
      }

      return;
    }
  }
}

if (globalThis.__rareCandyActive) {
  const rareCandyData = globalThis.__rareCandySelection;
  if (rareCandyData) {
    // Determine the actual owner based on which player's Pokemon is being evolved
    // The owner should match the player who owns the basic Pokemon being evolved
    const basicOwner = rareCandyData.chosenBasic.closest('#player1') ? 'player1' : 'player2';
    
    if (rareCandyData.owner === basicOwner && owner === basicOwner) {
      const clickedPair = rareCandyData.pairsForBasic.find(p => 
        p.handCard.set === set && String(p.handCard.number || p.handCard.num) === String(num)
      );
      
      if (clickedPair) {
        // Ensure we use the correct owner from the basic Pokemon's location
        clickedPair.actualOwner = basicOwner;
        
        if (globalThis.__rareCandyResolve) {
          globalThis.__rareCandyResolve(clickedPair);
          globalThis.__rareCandyResolve = null;
        }

        return;
      }
    }
  }
}

let meta = null;
try {
  meta = await fetchCardMeta(set, num);
} catch {}

if (meta && String(meta.category || '').toLowerCase() === 'trainer') {
  if (isSetupPhase) {
    showPopup("You can't play Trainer cards during setup.");
    return;
  }
  
  const ttype = String(meta.trainerType || '').toLowerCase();
  const cardId = csvIdFor(set, num);
  const effect = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
  
  async function validateTrainerEffect(effect, owner) {
    if (!effect || !effect.effect_type) return { valid: true };
    
    const pk = owner === 'player1' ? 'p1' : 'p2';
    const effectType = effect.effect_type;
    const param1 = effect.param1 || '';
    const param2 = effect.param2 || '';
    
    if (effectType === 'heal') {
      const activeImg = globalThis.getActiveImg?.(pk);
      if (!activeImg) return { valid: false, message: 'No Active Pokmon to heal.' };
      
      const slot = activeImg.closest('.card-slot');
      const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
      const maxHp = modifiedMaxHp || parseInt(activeImg.dataset.hp || '0', 10);
      const curHp = parseInt(activeImg.dataset.chp || maxHp, 10);
      
      if (curHp >= maxHp) {
        return { valid: false, message: 'Your Active Pokmon is already at full health.' };
      }
    }
    
    if (effectType === 'heal_type') {
      const type = (param2 || 'grass').toLowerCase();
      const allImgs = globalThis.getAllPokemonImgs?.(pk) || [];
      let hasValidTarget = false;
      
      for (const img of allImgs) {
        try {
          const imgMeta = await fetchCardMeta(img.dataset.set, img.dataset.num);
          if (imgMeta.types?.some(t => t.toLowerCase() === type)) {
            const slot = img.closest('.card-slot');
            const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
            const maxHp = modifiedMaxHp || parseInt(img.dataset.hp || '0', 10);
            const curHp = parseInt(img.dataset.chp || maxHp, 10);
            
            if (curHp < maxHp) {
              hasValidTarget = true;
              break;
            }
          }
        } catch {}
      }
      
      if (!hasValidTarget) {
        return { valid: false, message: `No damaged ${type}-type Pokmon to heal.` };
      }
    }
    
    if (effectType === 'heal_all_with_type_energy') {
      const energyType = (param2 || 'water').toLowerCase();
      const allImgs = globalThis.getAllPokemonImgs?.(pk) || [];
      let hasValidTarget = false;
      
      for (const img of allImgs) {
        const slot = img.closest('.card-slot');
        const energyBox = slot?.querySelector('.energy-pips');
        const pips = Array.from(energyBox?.querySelectorAll('.energy-pip:not(.phantom-pip)') ?? []);
        const hasType = pips.some(pip => (pip.dataset.type || '').toLowerCase() === energyType);
        
        if (hasType) {
          const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
          const maxHp = modifiedMaxHp || parseInt(img.dataset.hp || '0', 10);
          const curHp = parseInt(img.dataset.chp || maxHp, 10);
          
          if (curHp < maxHp) {
            hasValidTarget = true;
            break;
          }
        }
      }
      
      if (!hasValidTarget) {
        return { valid: false, message: `No damaged Pokmon with ${energyType} energy to heal.` };
      }
    }
    
    if (effectType === 'heal_and_cure_status') {
      const allImgs = globalThis.getAllPokemonImgs?.(pk) || [];
      let hasValidTarget = false;
      
      for (const img of allImgs) {
        const hasStatus = !!img.dataset.status;
        const slot = img.closest('.card-slot');
        const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
        const maxHp = modifiedMaxHp || parseInt(img.dataset.hp || '0', 10);
        const curHp = parseInt(img.dataset.chp || maxHp, 10);
        const hasDamage = curHp < maxHp;
        
        if (hasStatus || hasDamage) {
          hasValidTarget = true;
          break;
        }
      }
      
      if (!hasValidTarget) {
        return { valid: false, message: 'No Pokmon with damage or status conditions to heal.' };
      }
    }
    
    if (effectType === 'flip_attach_energy') {
      const type = (param1 || 'water').toLowerCase();
      const allImgs = globalThis.getAllPokemonImgs?.(pk) || [];
      let hasValidTarget = false;
      
      for (const img of allImgs) {
        try {
          const imgMeta = await fetchCardMeta(img.dataset.set, img.dataset.num);
          if (imgMeta.types?.some(t => t.toLowerCase() === type)) {
            hasValidTarget = true;
            break;
          }
        } catch {}
      }
      
      if (!hasValidTarget) {
        return { valid: false, message: `No ${type}-type Pokmon in play to attach energy to.` };
      }
    }
    
    if (effectType === 'search_pokemon_type_random') {
      const requiredType = (param1 || '').toLowerCase().trim();
      const deck = playerState[owner]?.deck || [];
      
      if (deck.length === 0) {
        return { valid: false, message: 'Deck is empty.' };
      }
      
      let hasValidCard = false;
      for (const card of deck.slice(0, Math.min(deck.length, 20))) {
        try {
          const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
          if (cardMeta.category === 'Pokemon') {
            if (requiredType) {
              if (cardMeta.types?.some(t => t.toLowerCase() === requiredType)) {
                hasValidCard = true;
                break;
              }
            } else {
              hasValidCard = true;
              break;
            }
          }
        } catch {}
      }
      
      if (!hasValidCard) {
        return { valid: false, message: requiredType ? `No ${requiredType}-type Pokmon in deck.` : 'No Pokmon in deck.' };
      }
    }
    
    if (effectType === 'search_basic_pokemon') {
      const deck = playerState[owner]?.deck || [];
      
      if (deck.length === 0) {
        return { valid: false, message: 'Deck is empty.' };
      }
      
      let hasValidCard = false;
      for (const card of deck.slice(0, Math.min(deck.length, 20))) {
        try {
          const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
          if (cardMeta.category === 'Pokemon' && cardMeta.stage?.toLowerCase() === 'basic') {
            hasValidCard = true;
            break;
          }
        } catch {}
      }
      
      if (!hasValidCard) {
        return { valid: false, message: 'No Basic Pokmon in deck.' };
      }
    }
    
    if (effectType === 'search_named_random') {
      const name = (param2 || '').toLowerCase().trim();
      if (!name) return { valid: true };
      
      const deck = playerState[owner]?.deck || [];
      
      if (deck.length === 0) {
        return { valid: false, message: 'Deck is empty.' };
      }
      
      let hasValidCard = false;
      for (const card of deck.slice(0, Math.min(deck.length, 20))) {
        try {
          const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
          if (cardMeta.category === 'Pokemon' && (cardMeta.name || '').toLowerCase().includes(name)) {
            hasValidCard = true;
            break;
          }
        } catch {}
      }
      
      if (!hasValidCard) {
        return { valid: false, message: `No ${name} in deck.` };
      }
    }
  
  // Validate Rare Candy (evolve_basic_to_stage2)
  if (effectType === 'evolve_basic_to_stage2') {
    // Check if turn number allows Rare Candy
    if (globalThis.turnNumber <= 2) {
      return { valid: false, message: "You can't use Rare Candy during the first two turns." };
    }
    
    // Check for eligible Basic Pokemon in play
    const allPokemon = globalThis.getAllPokemonImgs?.(pk) || [];
    const eligibleBasics = [];
    
    for (const img of allPokemon) {
      try {
        const playedTurn = parseInt(img.dataset.playedTurn || '0', 10);
        const isFossil = img.dataset.isFossil === 'true';
        const meta = await fetchCardMeta(img.dataset.set, img.dataset.num);
        const stage = (meta.stage || '').toLowerCase();
        
        // Basic Pokemon that wasn't played this turn
        if (stage === 'basic' && playedTurn !== globalThis.turnNumber) {
          eligibleBasics.push({ img, meta, isFossil });
        }
      } catch {}
    }
    
    if (!eligibleBasics.length) {
      return { valid: false, message: 'No eligible Basic Pokmon. (Basics cannot be evolved the turn they are played)' };
    }
    
    // Check for Stage 2 Pokemon in hand
    const hand = playerState[owner]?.hand || [];
    let hasStage2 = false;
    
    for (const handCard of hand) {
      try {
        const cardMeta = await fetchCardMeta(handCard.set, handCard.number || handCard.num);
        const cardStage = (cardMeta.stage || '').toLowerCase();
        if (cardStage === 'stage2') {
          hasStage2 = true;
          break;
        }
      } catch {}
    }
    
    if (!hasStage2) {
      return { valid: false, message: 'No Stage 2 Pokmon in hand.' };
      }
    }
    
    return { valid: true };
  }
  
  const doEffect = async () => {
    if (effect) {
      await (globalThis.applyTrainerEffect || applyTrainerEffect)(effect, owner, trainerCardImg, true); 
    } else {
    }
  };

  if (ttype === 'supporter') {
    
        const pk = owner === 'player1' ? 'p1' : 'p2';

    if (!canUseSupporter(pk)) {
      showPopup("Can't use Supporter cards this turn!");
      return;
    }
    
    if (isGengarBlocking(owner)) {
      showPopup('Shadowy Spellbind: You cannot play Supporter cards!');
      return;
    }
    
    if (hasPlayedSupporterThisTurn[owner]) {
      showPopup('Only one Supporter per turn.');
      return;
    }
    
    
    if (!effect) {
      showPopup(`${meta.name || 'This Supporter'} is not yet implemented.`);
      return;
    }

    const validation = await validateTrainerEffect(effect, owner);
    if (!validation.valid) {
      showPopup(validation.message || 'This card would have no effect.');
      return;
    }
    
    logEvent({
      player: owner,
      text: `Played Supporter: ${meta.name}.`,
      cardSet: set,
      cardNum: num
    });
    
    try {
      await doEffect();
      
      // Sync supporter play to Firebase
      const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
      const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
      const isOnline = matchId && window.firebaseDatabase;
      if (isOnline && typeof broadcastAction === 'function') {
        const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
        const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
        const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
          ? 'player1' 
          : 'player2';
        
        try {
          await broadcastAction(ACTION_TYPES.PLAY_TRAINER, {
            owner: matchOwner,
            trainer: {
              set: set,
              num: num,
              name: meta.name,
              type: 'supporter',
              effectType: effect?.effect_type,
              param1: effect?.param1,
              param2: effect?.param2
            },
            turnNumber: globalThis.turnNumber || 0
          });
          console.log('Synced supporter play to Firebase:', {
            matchOwner,
            trainerName: meta.name
          });
        } catch (error) {
          console.error('Error syncing supporter play to Firebase:', error);
        }
      }
      
    // Show large trainer card animation in center of screen
    showTrainerCardAnimation(e.target, meta.name);
      
    addTrainerToDiscard(owner, e.target);
    removeFromHand(owner, set, num);
    renderAllHands();
    hasPlayedSupporterThisTurn[owner] = true;
    
    
    const pkForSilvally = owner === 'player1' ? 'p1' : 'p2';
    if (!globalThis.__supporterPlayedThisTurn) globalThis.__supporterPlayedThisTurn = { p1: false, p2: false };
    globalThis.__supporterPlayedThisTurn[pkForSilvally] = true;
      
    showPopup('Supporter played');
    } catch (err) {
      
      if (err.message === 'SELECTION_CANCELLED') {
        showPopup('Supporter use cancelled.');
      } else if (err.message === 'No valid target') {
        showPopup('No valid target');
      } else {
        showPopup(err.message || 'Supporter effect failed.');
      }
      
    }

    return;
  } else if (ttype === 'tool') {
    // Tools must be attached to Pokemon, not played as items
    // Set toolAttachPending and wait for user to click a Pokemon
    toolAttachPending = {
      owner: owner,
      set: set,
      num: num,
      src: trainerCardImg.src || `https://assets.tcgdx.net/en/tcgp/${set}/${String(num).padStart(3, '0')}/high.png`
    };
    
    // Add glow to all Pokemon that can have tools attached
    const pk = owner === 'player1' ? 'p1' : 'p2';
    const allPokemon = globalThis.getAllPokemonImgs?.(pk) || [];
    allPokemon.forEach(img => {
      const slot = img.closest('.card-slot');
      if (slot && !getToolDataFromSlot(slot)) {
        // Use promote-glow class for visual feedback
        img.classList.add('promote-glow');
      }
    });
    
    showPopup('Click a Pokmon to attach this Tool.');
    return;
  } else if (ttype === 'item') {
    // [RARE-CANDY] For items with evolve_basic_to_stage2 effect (like Rare Candy),
    // set a flag so the effect knows it's being played as an item, not attached as a tool
    if (effect && effect.effect_type === 'evolve_basic_to_stage2') {
      // Set a flag to indicate this is an item play, not a tool attachment
      globalThis.__rareCandyItemPlay = true;
      console.log('[RARE-CANDY] Playing Rare Candy as item - setting flag');
    }
    
    if (effect) {
      const validation = await validateTrainerEffect(effect, owner);
      if (!validation.valid) {
        showPopup(validation.message || 'This card would have no effect.');
        return;
      }
    }
    
    logEvent({
      player: owner,
      text: `Played Item: ${meta.name}.`,
      cardSet: set,
      cardNum: num
    });
    
    try {
      await doEffect();
      
      // Sync item play to Firebase
      const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
      const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
      const isOnline = matchId && window.firebaseDatabase;
      if (isOnline && typeof broadcastAction === 'function') {
        const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
        const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
        const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
          ? 'player1' 
          : 'player2';
        
        try {
          await broadcastAction(ACTION_TYPES.PLAY_TRAINER, {
            owner: matchOwner,
            trainer: {
              set: set,
              num: num,
              name: meta.name,
              type: 'item',
              effectType: effect?.effect_type,
              param1: effect?.param1,
              param2: effect?.param2
            },
            turnNumber: globalThis.turnNumber || 0
          });
          console.log('Synced item play to Firebase:', {
            matchOwner,
            trainerName: meta.name
          });
        } catch (error) {
          console.error('Error syncing item play to Firebase:', error);
        }
      }
      
      // Show large trainer card animation in center of screen
      showTrainerCardAnimation(e.target, meta.name);
      
      
      addTrainerToDiscard(owner, e.target);
      removeFromHand(owner, set, num);
      renderAllHands();
      showPopup('Item played');
    } catch (err) {
      // Clear the Rare Candy item play flag even on error
      if (globalThis.__rareCandyItemPlay) {
        globalThis.__rareCandyItemPlay = false;
        console.log('[RARE-CANDY] Cleared item play flag (error case)');
      }

      showPopup(err.message || 'Cannot use this Item right now.');
    }

    return;
  } else if (ttype === 'tool') {
    
    if (selectedEnergyElement) {
      selectedEnergyElement.classList.remove('selected-glow');
      selectedEnergy = null;
    }
    if (selectedToolElement) {
      selectedToolElement.classList.remove('selected-glow');
    }
    
    toolAttachPending = { owner, set, num, src: e.target.src };
    selectedToolElement = e.target;
    selectedEnergyElement = null;
    e.target.classList.add('selected-glow');
    showPopup('Select a Pokmon in play to attach this Tool, or press Escape to cancel.');

    logEvent({
      player: owner,
      text: `Played Tool: ${meta.name}.`,
      cardSet: set,
      cardNum: num
    });
    
    
    setupSelectionCancelHandler();

    return;
  } else {
    showPopup('Unknown Trainer type.');
    return;
  }
}

if (meta && meta.evolveFrom) {
  isEvoMode = true;
  evoMeta = meta;
  evoOwner = owner;
  evoHandCard = e.target;
  
  let glow = 0;
  const evolveFromLower = String(meta.evolveFrom).toLowerCase();
  
  
  const FOSSIL_MAP = {
    'helix fossil': 'omanyte',
    'dome fossil': 'kabuto',
    'old amber': 'aerodactyl',
    'skull fossil': 'cranidos',
    'armor fossil': 'shieldon'
  };
  
  $$('#' + owner + ' .active img, #' + owner + ' .bench img').forEach(img => {
    const cardNameLower = (img.alt || '').toLowerCase();
    
    
    let matches = cardNameLower.includes(evolveFromLower);
    
    
    if (!matches && FOSSIL_MAP[cardNameLower]) {
      const fossilPokemon = FOSSIL_MAP[cardNameLower];
      matches = fossilPokemon === evolveFromLower || evolveFromLower.includes(fossilPokemon);
    }
    
    
    if (!matches && cardNameLower.includes('eevee ex')) {
      const EEVEELUTIONS = [
        'vaporeon', 'jolteon', 'flareon', 'espeon', 'umbreon',
        'leafeon', 'glaceon', 'sylveon'
      ];
      
      const evoCardName = (meta.name || '').toLowerCase();
      if (EEVEELUTIONS.some(e => evoCardName.includes(e))) {
        matches = true;
      }
    }
    
    if (matches) {
      img.classList.add('glow-evo');
      glow++;
    }
  });
  
  if (glow === 0) {
    showPopup(`No valid ${meta.evolveFrom} to evolve.`);
    isEvoMode = false;
    return;
  }
  
  showPopup(`Select ${meta.evolveFrom} to evolve.`);
  return;
}

if (!(meta && String(meta.category || '').toLowerCase() === 'pokemon' &&
     String(meta.stage || '').toLowerCase() === 'basic')) {
  showPopup('Only Basic Pokmon can be placed.');
  return;
}

const clone = e.target.cloneNode(true);
clone.dataset.playedTurn = globalThis.turnNumber;
  
  
  if (!window.pokemonInstanceCounter) window.pokemonInstanceCounter = 0;
  clone.dataset.instanceId = ++window.pokemonInstanceCounter;
clone.dataset.set = set;
clone.dataset.num = num;

const act = owner === 'player1' ? p1Active : p2Active;
const bench = owner === 'player1' ? p1Bench : p2Bench;

let placedTo = 'bench';
let targetSlot = null;

if (!act.querySelector('img')) {
  targetSlot = act.querySelector('.card-slot');
  placedTo = 'active';
} else {
  
  const empty = [...bench.querySelectorAll('.card-slot')].find(s => !s.querySelector('img'));
  if (!empty) {
    showPopup('Bench full.');
    return;
  }
  targetSlot = empty;
  placedTo = 'bench';
}

if (placedTo === 'active') {
  const slot = act.querySelector('.card-slot');
  slot.innerHTML = '';
  slot.appendChild(clone);
  markSlot(slot, true);
  
  
  if (targetSlot) {
    animateSlideFromHand(e.target, targetSlot, clone);
  }
  
  
  const playerNum = owner === 'player1' ? 1 : 2;
  updatePlayerTypeBackground(playerNum);
} else {
  const empty = [...bench.querySelectorAll('.card-slot')].find(s => !s.querySelector('img'));
  empty.innerHTML = '';
  empty.appendChild(clone);
  markSlot(empty, true);
  
  
  if (targetSlot) {
    animateSlideFromHand(e.target, targetSlot, clone);
  }
}

removeFromHand(owner, set, num);

try {
  const baseHp = parseInt(meta.hp || '0', 10) || 0;
  setHpOnImage(clone, baseHp, baseHp);
} catch {}

renderAllHands();

logEvent({
  player: owner,
  text: `Played Basic Pokmon to ${placedTo === 'active' ? 'Active' : 'Bench'}: ${meta.name}.`,
  cardSet: set,
  cardNum: num
});

// Sync card placement to Firebase (same as drag-and-drop handler)
(async () => {
  try {
    const updateGameStatePartialFn = updateGameStatePartial || globalThis.updateGameStatePartial;
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
    const broadcastActionFn = broadcastAction || globalThis.broadcastAction;
    const ACTION_TYPES_OBJ = ACTION_TYPES || globalThis.ACTION_TYPES;
    
    if (!window.firebaseDatabase || !updateGameStatePartialFn) return;
    
    const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
    // Map UI player to match player
    const matchPlayerKey = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
      ? 'player1' 
      : 'player2';
    
    if (!meta || !meta.name) {
      console.error('Error: meta is missing or invalid:', meta);
      return;
    }
    
    const cardData = {
      set: set,
      num: num,
      name: meta.name,
      hp: parseInt(meta.hp || '0', 10) || 0,
      instanceId: clone.dataset.instanceId,
      playedTurn: globalThis.turnNumber || 0
    };
    
    // Update hand in game state first
    if (!playerState || !playerState[owner]) {
      console.error('Error: playerState is missing or invalid:', { playerState, owner });
      return;
    }
    const handToSync = playerState[owner].hand ? [...playerState[owner].hand] : [];
    await updateGameStatePartialFn({ 
      [`${matchPlayerKey}/hand`]: handToSync
    });
    // Hand synced to Firebase (click)
    
    if (placedTo === 'active') {
      // Update active slot
      await updateGameStatePartialFn({ 
        [`${matchPlayerKey}/active`]: cardData 
      });
      // Active Pokemon synced to Firebase (click)
    } else {
      // For bench, add to array
      const { getMatchRef } = await import('./js/online/schema.js');
      const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
      if (matchId) {
        const matchRef = getMatchRef(matchId);
        const snapshot = await matchRef.child(`gameState/${matchPlayerKey}/bench`).once('value');
        const currentBench = snapshot.val() || [];
        const newBench = [...currentBench, cardData];
        await updateGameStatePartialFn({ 
          [`${matchPlayerKey}/bench`]: newBench 
        });
        // Bench Pokemon synced to Firebase (click)
      }
    }
    
    // Broadcast action for logging
    if (broadcastActionFn && ACTION_TYPES_OBJ) {
      broadcastActionFn(ACTION_TYPES_OBJ.PROMOTE, {
        player: matchPlayerKey,
        card: cardData,
        placedTo: placedTo
      });
    }
  } catch (error) {
    console.error('Error syncing card placement (click):', error);
  }
})();
  
});

async function showAttackMenuFor(cardImg, meta) {
  
  
  if (isRetreatSelection) {
    return;
  }

  closeAttackMenu();

  const slot = cardImg.closest('.card-slot');

  if (!slot || !cardImg || !meta) {
    return;
  }
  
  const activeDiv = cardImg.closest('.active, .bench');
  
  const pk = currentPlayer === 'player1' ? 'p1' : 'p2';
  const ownerKey = pk;  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const cardSet = cardImg.dataset.set;
  const cardNum = cardImg.dataset.num;
  const type0 = ((meta.types && meta.types[0]) || 'colorless').toLowerCase();
  
  const cardSlot = cardImg.closest('.card-slot');
  
  const menu = document.createElement('div');
  menu.className = 'attack-menu ptcgl-style';
  
  
  const timeSinceRetreat = Date.now() - lastRetreatTime;
  const delayForRetreat = (isRetreatSelection || timeSinceRetreat < 1000) ? 500 : 100;
  
  
  menu.addEventListener('click', (e) => {
    if (e.target === menu) {
      e.stopPropagation();
      e.stopImmediatePropagation();
      if (typeof globalThis.setMenuJustClosed === 'function') {
        globalThis.setMenuJustClosed(true);
      }
      closeAttackMenu();
      setTimeout(() => {
        if (typeof globalThis.setMenuJustClosed === 'function') {
          globalThis.setMenuJustClosed(false);
        }
      }, 150);
    }
  });
  
  
  if (cardSlot) {
    cardSlot.classList.add('menu-open');
  }
  
  const cardContainer = document.createElement('div');
  cardContainer.className = 'ptcgl-card-container';
  cardContainer.style.position = 'relative'; 
  
  const cardImgClone = document.createElement('img');
  cardImgClone.src = cardImg.src;
  cardImgClone.alt = meta.name || 'Pokemon';
  cardContainer.appendChild(cardImgClone);
  
  
  const toolData = getToolDataFromSlot(cardSlot);
  if (toolData && toolData.src) {
    const toolThumb = document.createElement('img');
    toolThumb.src = toolData.src;
    toolThumb.alt = 'Tool';
    toolThumb.style.cssText = `
      position: absolute;
      top: 120px;
      left: 8px;
      width: 80px;
      height: 112px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,.6);
      border: 1px solid #6e4e9c;
      background-color: #0b0f14;
      z-index: 10;
      object-fit: cover;
      object-position: center 15%;
      clip-path: inset(15% 5% 45% 5%);
      pointer-events: none;
    `;
    cardContainer.appendChild(toolThumb);
  }
  
  const closeBtn = document.createElement('button');
  closeBtn.className = 'ptcgl-close-btn';
  closeBtn.innerHTML = '';
  closeBtn.addEventListener('click', (e) => {
    
    e.stopPropagation();
    e.stopImmediatePropagation();
    e.preventDefault();
    
    const cardRect = cardImg.getBoundingClientRect();
    const returnX = cardRect.left + cardRect.width / 2;
    const returnY = cardRect.top + cardRect.height / 2;
    
    menu.style.transition = 'all 0.25s ease-in';
    menu.style.left = returnX + 'px';
    menu.style.top = returnY + 'px';
    menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
    menu.style.opacity = '0';
    
    setTimeout(() => {
      closeAttackMenu();
    }, 500);  
  });
  cardContainer.appendChild(closeBtn);
  
  const modifiedMaxHp = cardSlot?.dataset.maxHp ? parseInt(cardSlot.dataset.maxHp, 10) : null;
  const baseHp = parseInt(cardImg.dataset.hp || meta.hp || '0', 10);
  const maxHp = modifiedMaxHp || baseHp;
  const chp = parseInt(cardImg.dataset.chp || maxHp || '0', 10);
  
  const hpTypeBar = document.createElement('div');
  hpTypeBar.className = 'ptcgl-hp-type-bar';
  
  
  const hpStyle = modifiedMaxHp ? 'color: #22c55e; font-weight: 700;' : '';
  
  hpTypeBar.innerHTML = `
    <span class="ptcgl-hp-number" style="${hpStyle}">${chp} / ${maxHp}</span>
    <div class="ptcgl-type-icon-inline" style="background-image: url('${energyIconUrl(type0)}')"></div>
  `;
  cardContainer.appendChild(hpTypeBar);
  
  const energyPipsContainer = document.createElement('div');
  energyPipsContainer.className = 'ptcgl-energy-pips';

  
  if (cardSlot) {
    const energyBox = cardSlot.querySelector('.energy-pips');
    
    if (energyBox) {
      const energyPips = energyBox.querySelectorAll('.energy-pip');
      
      energyPips.forEach(pip => {
        const pipClone = document.createElement('div');
        pipClone.className = 'ptcgl-energy-pip';
        const energyType = pip.dataset.type || 'colorless';
        pipClone.style.backgroundImage = `url('${energyIconUrl(energyType)}')`;
        pipClone.dataset.type = energyType;
        energyPipsContainer.appendChild(pipClone);
      });
    }
  }
  
  if (energyPipsContainer.children.length > 0) {
    cardContainer.appendChild(energyPipsContainer);
  } else {
  }
  
  const actionsOverlay = document.createElement('div');
  actionsOverlay.className = 'ptcgl-actions-overlay';
  
  
  
  const allAbilityRows = abilityRows.filter(r => {
    const matches = r.set === cardSet &&
      String(r.number).padStart(3, '0') === String(cardNum).padStart(3, '0');
    
    return matches;
  });
  
  allAbilityRows.forEach(abilityRow => {
    const isPassive = abilityRow.abilityType === 'passive';
    
    
    const isUnlimited = 
      (abilityRow.param2 && abilityRow.param2.toLowerCase() === 'unlimited') ||
      (abilityRow.text && /as often as you like/i.test(abilityRow.text));
    
    const usedMap = window.usedAbilitiesThisTurn;
    usedMap[ownerKey] = usedMap[ownerKey] || {};
    
    
    const pokemonImg = cardImg;
    const cardKey = getAbilityCardKey(abilityRow.set, abilityRow.number, pokemonImg);
    const alreadyUsed = !isUnlimited && !!usedMap[ownerKey][cardKey];

    const abilityBox = document.createElement('div');
    abilityBox.className = 'ptcgl-ability-overlay';
    
    
    const pokemonType = (type0 || 'colorless').toLowerCase();
    abilityBox.classList.add(`type-${pokemonType}`);
    
    
    if (isPassive) {
      abilityBox.classList.add('passive-ability');
      abilityBox.style.opacity = '1';  
      abilityBox.style.pointerEvents = 'none';
      abilityBox.style.cursor = 'default';
    } else if (alreadyUsed) {
      abilityBox.classList.add('used');
      abilityBox.style.pointerEvents = 'none';
      abilityBox.style.opacity = '0.5';
      abilityBox.style.cursor = 'not-allowed';
    }

    const abilityHeader = document.createElement('div');
    abilityHeader.className = 'ptcgl-ability-header';
    
    const abilityLeft = document.createElement('div');
    abilityLeft.className = 'ptcgl-ability-left';
    
    
    const labelText = isPassive ? 'PASSIVE' : 'ABILITY';
    abilityLeft.innerHTML = `
      <img src="${ABILITY_BADGE}" style="width:60px"  />      
      <span class="ptcgl-ability-name">${abilityRow.abilityName || 'Ability'}</span>
    `;
    
    abilityHeader.appendChild(abilityLeft);
    abilityBox.appendChild(abilityHeader);
    
    const abilityText = document.createElement('div');
    abilityText.className = 'ptcgl-ability-text';
    abilityText.textContent = abilityRow.text || '';
    abilityBox.appendChild(abilityText);
    
    
    if (!isPassive && !alreadyUsed) {
      abilityBox.addEventListener('click', async (e) => {
        e.stopPropagation();
        e.preventDefault();
        
        
        if (!isUnlimited && usedMap[ownerKey]?.[cardKey]) {
          showPopup('This ability has already been used this turn.');
          return;
        }
        
        
        if (!isUnlimited) {
          if (!usedMap[ownerKey]) usedMap[ownerKey] = {};
          usedMap[ownerKey][cardKey] = true;
          
          
          abilityBox.classList.add('used');
          abilityBox.style.pointerEvents = 'none';
          abilityBox.style.opacity = '0.5';
          abilityBox.style.cursor = 'not-allowed';
        }
        
        
        abilityJustUsed = true;
        
        
        if (typeof closeAttackMenu === 'function') {
          closeAttackMenu();
        }
        
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
        
        await applyAbilityEffect(abilityRow, ownerKey, pokemonImg);
        
        
        setTimeout(() => {
          abilityJustUsed = false;
        }, 300);
      });
    }

    actionsOverlay.appendChild(abilityBox);
  });
  
  const isFossil = cardImg.dataset.isFossil === 'true';
  
  if (isFossil) {
    
    const discardBox = document.createElement('div');
    discardBox.className = 'ptcgl-attack-overlay payable';
    discardBox.classList.add('type-colorless'); 
    
    const discardHeader = document.createElement('div');
    discardHeader.className = 'ptcgl-attack-header';
    
    const discardLeft = document.createElement('div');
    discardLeft.className = 'ptcgl-attack-left';
    
    const discardName = document.createElement('span');
    discardName.className = 'ptcgl-attack-name type-colorless';
    discardName.textContent = 'Discard';
    
    discardLeft.appendChild(discardName);
    discardHeader.appendChild(discardLeft);
    discardBox.appendChild(discardHeader);
    
    const discardEffect = document.createElement('div');
    discardEffect.className = 'ptcgl-attack-effect';
    discardEffect.textContent = 'Discard this Fossil from play. Does not give opponent a point.';
    discardBox.appendChild(discardEffect);
    
    
    discardBox.addEventListener('click', async () => {
      closeAttackMenu();
      
      
      const isActive = !!cardImg.closest('#p1Active, #p2Active');
      
      
      if (globalThis.discardPokemon) {
        await globalThis.discardPokemon(cardImg, pk, false); 
      } else {
        
        slot.innerHTML = '';
        globalThis.markSlot?.(slot, false);
      }
      
      showPopup(`${meta.name} was discarded.`);
      
      
      if (isActive) {
        const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
        const benchImgs = Array.from(benchDiv?.querySelectorAll('img') ?? []);
        
        if (benchImgs.length === 0) {
          
          const winner = pk === 'p1' ? 'player2' : 'player1';
          showVictory(winner, 'Opponent has no Pokmon left!');
          return;
        }
        
        
        if (globalThis.promoteFromBench) {
          await globalThis.promoteFromBench(null, pk); 
        }
      }
    });
    
    actionsOverlay.appendChild(discardBox);
  }
  
  let attacks = meta.attacks || [];
  

  
  if (toolData && toolData.set && toolData.num) {
    try {
      const toolCardId = csvIdFor(toolData.set, toolData.num);
      
      const toolEffect = TRAINER_EFFECT_DATA.find(x => x.id === toolCardId);
      
      if (toolEffect?.effect_type === 'use_previous_evolution_attacks') {
        
        
        async function buildEvolutionChain(currentMeta, owner, visited = new Set(), skipFirstLevel = false) {
          const chain = [];
          const currentKey = `${currentMeta.id || currentMeta.name}`;
          if (visited.has(currentKey)) return chain; 
          visited.add(currentKey);
          
          
          let evolveFrom = currentMeta.evolvesFrom || currentMeta.evolveFrom || [];
          
          
          if (typeof evolveFrom === 'string' && evolveFrom.trim()) {
            const evolveFromLower = evolveFrom.toLowerCase();
            const matchingCards = [];
            
            
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
            const pokemonInPlay = [
              ...(activeDiv?.querySelectorAll('img') || []),
              ...(benchDiv?.querySelectorAll('img') || [])
            ];
            
            for (const pokemonImg of pokemonInPlay) {
              const pokemonName = (pokemonImg.alt || '').toLowerCase();
              
              if (pokemonName === evolveFromLower) {
                const set = pokemonImg.dataset.set;
                const num = pokemonImg.dataset.num;
                if (set && num) matchingCards.push({ set, number: num });
              }
            }
            
            if (matchingCards.length === 0) {
              const hand = playerState[owner]?.hand || [];
              for (const card of hand) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  matchingCards.push({ set: card.set, number: card.number || card.num });
                }
              }
            }
            
            if (matchingCards.length === 0) {
              const deck = playerState[owner]?.deck || [];
              for (const card of deck) {
                try {
                  const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                  const cardName = (cardMeta.name || '').toLowerCase();
                  
                  if (cardMeta.category === 'Pokemon' && cardName === evolveFromLower) {
                    matchingCards.push({ set: card.set, number: card.number || card.num });
                  }
                } catch {}
              }
            }
            
            if (matchingCards.length === 0) {
              const discard = playerState[owner]?.discard?.cards || [];
              for (const card of discard) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  
                  try {
                    const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                    if (cardMeta && cardMeta.category === 'Pokemon' && cardMeta.name && cardMeta.name.toLowerCase() === evolveFromLower) {
                      matchingCards.push({ set: card.set, number: card.number || card.num });
                    }
                  } catch (err) {
                  }
                }
              }
            }
            
            if (matchingCards.length === 0) {
              
              const commonSets = ['A1', 'A1a', 'A2', 'A2a', 'A2b', 'A3', 'A3a', 'A3b', 'A4', 'A4a'];
              for (const set of commonSets) {
                try {
                  const setResponse = await fetch(`https://api.tcgdex.net/v2/en/sets/${set}`);
                  if (!setResponse.ok) continue;
                  const setData = await setResponse.json();
                  if (setData?.cards) {
                    for (const card of setData.cards) {
                      const cardName = (card.name || '').toLowerCase();
                      if (cardName === evolveFromLower || cardName.includes(evolveFromLower) || evolveFromLower.includes(cardName)) {
                        const localId = card.localId || card.number;
                        if (localId) {
                          matchingCards.push({ set, number: localId });
                          break;
                        }
                      }
                    }
                  }
                  if (matchingCards.length > 0) break;
                } catch (err) {
                }
              }
            }
            
            evolveFrom = matchingCards;
          }
          
          
          if (Array.isArray(evolveFrom) && evolveFrom.length > 0) {
            for (const prevEvo of evolveFrom) {
              try {
                const prevEvoMeta = await fetchCardMeta(prevEvo.set, prevEvo.number);
                if (prevEvoMeta) {
                  
                  if (!skipFirstLevel) {
                    chain.push(prevEvoMeta);
                  } else {
                  }
                  
                  const deeperChain = await buildEvolutionChain(prevEvoMeta, owner, visited, false);
                  chain.push(...deeperChain);
                }
              } catch (err) {
                console.error(`[Memory Light Menu] Error fetching evolution ${prevEvo.set}-${prevEvo.number}:`, err);
              }
            }
          }
          
          return chain;
        }
        
        
        const evolvedViaRareCandy = cardImg.dataset.evolvedViaRareCandy === 'true';
        
        
        let evolveFrom = meta.evolvesFrom || meta.evolveFrom || [];
        
        
        if (typeof evolveFrom === 'string' && evolveFrom.trim()) {
          
          try {
            const ownerDiv = cardImg.closest('#player1, #player2');
            const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
            const evolveFromLower = evolveFrom.toLowerCase();
            const matchingCards = [];
            
            
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
            const pokemonInPlay = [
              ...(activeDiv?.querySelectorAll('img') || []),
              ...(benchDiv?.querySelectorAll('img') || [])
            ];
            
            for (const pokemonImg of pokemonInPlay) {
              const pokemonName = (pokemonImg.alt || '').toLowerCase();
              if (pokemonName === evolveFromLower || pokemonName.includes(evolveFromLower) || evolveFromLower.includes(pokemonName)) {
                const set = pokemonImg.dataset.set;
                const num = pokemonImg.dataset.num;
                if (set && num) {
                  matchingCards.push({ set, number: num });
                }
              }
            }
            
            
            if (matchingCards.length === 0) {
              const hand = playerState[owner]?.hand || [];
              for (const card of hand) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  matchingCards.push({ set: card.set, number: card.number || card.num });
                }
              }
            }
            
            
            if (matchingCards.length === 0) {
              const deck = playerState[owner]?.deck || [];
              for (const card of deck) {
                try {
                  const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                  const cardName = (cardMeta.name || '').toLowerCase();
                  
                  if (cardMeta.category === 'Pokemon' && cardName === evolveFromLower) {
                    matchingCards.push({ set: card.set, number: card.number || card.num });
                  }
                } catch {}
              }
            }
            
            
            if (matchingCards.length === 0) {
              const discard = playerState[owner]?.discard?.cards || [];
              for (const card of discard) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  
                  try {
                    const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                    if (cardMeta && cardMeta.category === 'Pokemon' && cardMeta.name && cardMeta.name.toLowerCase() === evolveFromLower) {
                      matchingCards.push({ set: card.set, number: card.number || card.num });
                    }
                  } catch (err) {
                  }
                }
              }
            }
            
            if (matchingCards.length > 0) {
              evolveFrom = matchingCards; 
            } else {

              try {
                
                const commonSets = ['A1', 'A1a', 'A2', 'A2a', 'A2b', 'A3', 'A3a', 'A3b', 'A4', 'A4a'];
                const evolveFromLower = evolveFrom.toLowerCase();
                
                for (const set of commonSets) {
                  try {
                    
                    const setResponse = await fetch(`https://api.tcgdex.net/v2/en/sets/${set}`);
                    if (!setResponse.ok) continue;
                    const setData = await setResponse.json();
                    if (setData?.cards) {
                      for (const card of setData.cards) {
                        const cardName = (card.name || '').toLowerCase();
                        if (cardName === evolveFromLower || cardName.includes(evolveFromLower) || evolveFromLower.includes(cardName)) {
                          const localId = card.localId || card.number;
                          if (localId) {
                            matchingCards.push({ set, number: localId });
                            break;
                          }
                        }
                      }
                    }
                    if (matchingCards.length > 0) break;
                  } catch (err) {
                  }
                }
                
                if (matchingCards.length > 0) {
                  evolveFrom = matchingCards;
                } else {
                  evolveFrom = [];
                }
              } catch (err) {
                console.error('[Memory Light Menu]  Error in API search:', err);
                evolveFrom = [];
              }
            }
          } catch (err) {
            console.error('[Memory Light Menu]  Error looking up evolution:', err);
            evolveFrom = [];
          }
        }
        
        
        
        const ownerDiv = cardImg.closest('#player1, #player2');
        const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
        const fullChain = await buildEvolutionChain(meta, owner, new Set(), evolvedViaRareCandy);
        
        if (fullChain.length > 0) {
          if (evolvedViaRareCandy) {
            
            const basicMeta = fullChain[fullChain.length - 1]; 
            if (basicMeta?.attacks) {
              attacks = [...attacks, ...basicMeta.attacks];
            } else {
            }
          } else {

            for (const prevEvoMeta of fullChain) {
              if (prevEvoMeta?.attacks) {
                attacks = [...attacks, ...prevEvoMeta.attacks];
              } else {
              }
            }
          }
        } else {
        }
      } else {
      }
    } catch (err) {
      console.error('[Memory Light Menu]  Error checking tool:', err);
    }
  } else {
  }

  
  
  for (const atk of attacks) {
    
    const isLocked = cardImg.dataset.lockedAttack === atk.name;
    
    
    let isMoveLocked = false;
    const instanceId = cardImg.dataset.instanceId;
    const moveName = atk.name?.toLowerCase();
    const currentTurn = globalThis.turnNumber || 0;

    
    if (instanceId && moveName && globalThis.__moveLocks?.[pk]?.[instanceId]?.[moveName]) {
      const moveLock = globalThis.__moveLocks[pk][instanceId][moveName];
      
      if (typeof moveLock === 'object' && moveLock.lockedOnTurn !== undefined) {
        
        isMoveLocked = currentTurn === moveLock.lockedOnTurn + 2;
      } else {
        
        isMoveLocked = moveLock === true;
      }
    } else {
    }
    
    
    const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
    let isAllAttacksLocked = false;
    if (attackLock) {
      const currentTurn = globalThis.turnNumber || 0;
      if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
        isAllAttacksLocked = currentTurn === attackLock.lockedOnTurn + 2;
      } else if (attackLock === true) {
        isAllAttacksLocked = true; 
      }
    }
    
    
    let actualCost = atk.cost || [];
    if (typeof globalThis.getMoveRow === 'function') {
      try {
        const moveRow = globalThis.getMoveRow(cardImg.alt, atk.name);
        
        if (moveRow?.effect_type === 'reduce_energy_cost_if_damaged') {
          
          const maxHp = parseInt(cardImg.dataset.hp || '0', 10);
          const curHp = parseInt(cardImg.dataset.chp || maxHp, 10);
          if (curHp < maxHp) {
            
            const reduceAmount = parseInt(moveRow.param1 || '1', 10);
            
            actualCost = [...actualCost];
            for (let i = 0; i < reduceAmount && actualCost.length > 0; i++) {
              actualCost.pop(); 
            }
          }
        }
      } catch (err) {
        console.error('[reduce_energy_cost_if_damaged] Error:', err);
      }
    }
    
    const pips = countPipsOn(slot);
    
    const canPay = !isLocked && !isMoveLocked && !isAllAttacksLocked && canPayCostFromAPI(slot, actualCost, cardImg);

    const attackBox = document.createElement('div');
    attackBox.className = 'ptcgl-attack-overlay';
    
    
    if (isLocked || isMoveLocked || isAllAttacksLocked) {
      attackBox.classList.add('locked');
      attackBox.style.opacity = '0.5';
      attackBox.style.cursor = 'not-allowed';
      if (isMoveLocked) {
        attackBox.title = `This Pokmon can't use ${atk.name} this turn!`;
      } else if (isAllAttacksLocked) {
        attackBox.title = `This Pokmon can't attack this turn!`;
      }
    }
    
    
    const pokemonType = (type0 || 'colorless').toLowerCase();
    attackBox.classList.add('type-' + pokemonType);
    
    if (canPay) attackBox.classList.add('payable');
    
    const costHTML = actualCost.map(energyType => {
      const type = String(energyType).toLowerCase();
      return `<div class="ptcgl-cost-icon" style="background-image: url('${energyIconUrl(type)}')"></div>`;
    }).join('');

    const attackHeader = document.createElement('div');
    attackHeader.className = 'ptcgl-attack-header';
    
    const attackLeft = document.createElement('div');
    attackLeft.className = 'ptcgl-attack-left';
    
    const attackName = document.createElement('span');
    attackName.className = 'ptcgl-attack-name';
    attackName.textContent = atk.name || 'Attack';
    
    
    if (canPay) {
      attackName.classList.add(`type-${type0.toLowerCase()}`);
    }
    
    
    const attackInfo = document.createElement('div');
    attackInfo.style.display = 'flex';
    attackInfo.style.alignItems = 'center';
    attackInfo.style.gap = '6px';
    
    attackInfo.appendChild(attackName);
    
    const attackCost = document.createElement('div');
    attackCost.className = 'ptcgl-attack-cost';
    attackCost.innerHTML = costHTML;
    attackInfo.appendChild(attackCost);
    
    attackLeft.appendChild(attackInfo);
    
    
    const damageBox = document.createElement('div');
    damageBox.className = 'ptcgl-attack-damage-box';
    
    const attackDamage = document.createElement('span');
    attackDamage.className = 'ptcgl-attack-damage';
    attackDamage.textContent = atk.damage || ''; 
    
    (async () => {
      try {
        const previewResult = await calculatePreviewDamage(atk, cardImg, meta, pk);
        let previewDamage = typeof previewResult === 'object' ? previewResult.damage : previewResult;
        
        if (typeof previewDamage === 'object') previewDamage = '';
        attackDamage.textContent = String(previewDamage || '');
        
        
        if (typeof previewResult === 'object') {
          
          attackDamage.style.setProperty('color', '', 'important');
          attackDamage.style.setProperty('text-shadow', '', 'important');
          
          if (previewResult.hasWeakness) {
            
            attackDamage.style.setProperty('color', '#22c55e', 'important');
            attackDamage.style.setProperty('text-shadow', '0 0 8px rgba(34, 197, 94, 0.6), 0 0 4px rgba(34, 197, 94, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else if (previewResult.hasOtherBoosts) {
            
            attackDamage.style.setProperty('color', '#fbbf24', 'important');
            attackDamage.style.setProperty('text-shadow', '0 0 8px rgba(251, 191, 36, 0.6), 0 0 4px rgba(251, 191, 36, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else {
            
            attackDamage.style.setProperty('color', '#000000', 'important');
            attackDamage.style.setProperty('text-shadow', '0 1px 3px rgba(0,0,0,0.5)', 'important');
          }
        }
      } catch (err) {
        console.error('[preview] Error calculating damage:', err);
        
      }
    })();
    damageBox.appendChild(attackDamage);
    
    attackLeft.appendChild(damageBox);
    
    attackHeader.appendChild(attackLeft);
    
    attackBox.appendChild(attackHeader);

    if (atk.effect) {
      const attackEffect = document.createElement('div');
      attackEffect.className = 'ptcgl-attack-effect';
      attackEffect.textContent = atk.effect;
      attackBox.appendChild(attackEffect);
    }
    
    if (canPay) {
      attackBox.addEventListener('click', () => {
        handleAttackClick(atk, meta, ownerKey, activeDiv);
        closeAttackMenu();
      });
    }

    actionsOverlay.appendChild(attackBox);
  }
  
  cardContainer.appendChild(actionsOverlay);
  
  const retreatCost = computeRetreatCost(activeDiv, meta);
  const pips = countPipsOn(slot);
  
  
  const retreatAllowed = typeof canRetreat === 'function' ? canRetreat(pk) : true;
  const canPayCost = !isFossil && pips.total >= retreatCost && !hasRetreatedThisTurn;
  const canRetreatFinal = retreatAllowed && canPayCost;

  const retreatCorner = document.createElement('div');
  retreatCorner.className = 'ptcgl-retreat-corner';
  if (!canRetreatFinal) retreatCorner.classList.add('disabled');
  
  
  if (isFossil) {
    retreatCorner.title = "Fossils cannot retreat";
  }
  
  
  if (!retreatAllowed && !isFossil) {
    const activeImg = activeDiv.querySelector('img');
    const st = (activeImg?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      retreatCorner.title = "Can't retreat - Pokmon is asleep";
    } else if (st === 'paralyzed') {
      retreatCorner.title = "Can't retreat - Pokmon is paralyzed";
    } else {
      retreatCorner.title = "Can't retreat - Pokmon is locked";
    }
  }
  
  
  if (canRetreatFinal) {
    const mainType = (meta.types && meta.types[0]) ? String(meta.types[0]).toLowerCase() : null;
    if (mainType) {
      retreatCorner.setAttribute('data-type', mainType);
    }
  }

  const costIcons = Array(retreatCost).fill(0).map(() => 
    `<div class="ptcgl-cost-icon" style="background-image: url('${energyIconUrl('colorless')}')"></div>`
  ).join('');

  retreatCorner.innerHTML = `
    <div class="ptcgl-retreat-label">Retreat</div>
    <div class="ptcgl-retreat-cost">${costIcons}</div>
    <div class="ptcgl-retreat-icon"></div>
  `;
  
  if (canRetreatFinal) {
    retreatCorner.addEventListener('click', () => {
      handleRetreat(activeDiv, meta, retreatCost);
      
    });
  }

  cardContainer.appendChild(retreatCorner);
  
  if (meta.weaknesses && meta.weaknesses.length > 0) {
    const wk = meta.weaknesses[0];
    const wkType = String(wk.type || '').toLowerCase();
    const weaknessCorner = document.createElement('div');
    weaknessCorner.className = 'ptcgl-weakness-corner';
    weaknessCorner.innerHTML = `
      <span class="ptcgl-weakness-label">WEAKNESS</span>
      <div class="ptcgl-weakness-icon" style="background-image: url('${energyIconUrl(wkType)}')"></div>
      <span class="ptcgl-weakness-value">${wk.value || '2'}</span>
    `;
    cardContainer.appendChild(weaknessCorner);
  }

  menu.appendChild(cardContainer);
  
  document.body.appendChild(menu);

  let closeHandlerActive = false;
    const closeOnClickOutside = (e) => {
    if (closeHandlerActive) {
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      return;
    }
    
    if (!menu.contains(e.target) && !e.target.closest('.attack-menu')) {
        if (abilityJustUsed) {
        return;
      }
      
      closeHandlerActive = true;
      
      const clickedCardSlot = e.target.closest('.card-slot');
      const clickedCardImg = clickedCardSlot?.querySelector('img');
      const isClickingOnSameCard = clickedCardImg === cardImg;
      
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      
      if (isClickingOnSameCard) {
        // Clicked on same card, just closing menu
      }
      
      if (!cardImg || !cardImg.parentElement) {
        console.error('[MENU-CLOSE] Card image no longer exists! Cannot close menu properly.');
        closeHandlerActive = false;
          return;
        }
        
      document.removeEventListener('click', closeOnClickOutside, true);
        
        if (!cardImg || !cardImg.parentElement) {
          console.error('[MENU-CLOSE] Card image no longer exists! Cannot close menu properly.');
          closeHandlerActive = false;
          return;
        }
        
        const cardRect = cardImg.getBoundingClientRect();
        const returnX = cardRect.left + cardRect.width / 2;
        const returnY = cardRect.top + cardRect.height / 2;
        
        menu.style.willChange = 'transform, opacity, left, top';
        menu.style.transition = 'all 0.25s cubic-bezier(0.4, 0, 0.2, 1)';
        menu.style.left = returnX + 'px';
        menu.style.top = returnY + 'px';
        menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
        menu.style.opacity = '0';
        
        setTimeout(() => {
          menu.style.willChange = 'auto';
          console.log('[MENU-CLOSE] About to call closeAttackMenu, cardImg still exists:', !!cardImg?.parentElement);
          if (typeof globalThis.setMenuJustClosed === 'function') {
            globalThis.setMenuJustClosed(true);
          }
          closeAttackMenu();
          console.log('[MENU-CLOSE] closeAttackMenu completed, cardImg still exists:', !!cardImg?.parentElement);
          setTimeout(() => {
            if (typeof globalThis.setMenuJustClosed === 'function') {
              globalThis.setMenuJustClosed(false);
            }
            closeHandlerActive = false;
          }, 150);
        }, 250);
      }
    };
    
    
    menu._clickOutsideHandler = closeOnClickOutside;
    setTimeout(() => {
      document.addEventListener('click', closeOnClickOutside, true);
  }, delayForRetreat);  
  
  const cardRect = cardImg.getBoundingClientRect();
  const startX = cardRect.left + cardRect.width / 2;
  const startY = cardRect.top + cardRect.height / 2;
  
  
  const targetX = window.innerWidth * 0.30;
  const targetY = window.innerHeight * 0.50;
  
  
  menu.style.position = 'fixed';
  menu.style.left = startX + 'px';
  menu.style.top = startY + 'px';
  menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
  menu.style.opacity = '0';
  
  
  void menu.offsetHeight;
  
  
  menu.style.willChange = 'transform, opacity, left, top';
  requestAnimationFrame(() => {
    menu.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
    
    
    requestAnimationFrame(() => {
      
      menu.style.left = targetX + 'px';
      menu.style.top = targetY + 'px';
      menu.style.transform = 'translate(-50%, -50%) scale(1)';
      menu.style.opacity = '1';
      menu.classList.add('show');
      
      
      setTimeout(() => {
        
        menu.style.position = 'fixed';
        menu.style.left = targetX + 'px';
        menu.style.top = targetY + 'px';
        menu.style.willChange = 'auto';
      }, 350);
    });
  });

  openAttackMenu = menu;
  globalThis.openAttackMenu = menu;
  
  
  const escapeHandler = (e) => {
    if (e.key === 'Escape') {
      
      const cardRect = cardImg.getBoundingClientRect();
      const returnX = cardRect.left + cardRect.width / 2;
      const returnY = cardRect.top + cardRect.height / 2;
      
      menu.style.transition = 'all 0.25s ease-in';
      menu.style.left = returnX + 'px';
      menu.style.top = returnY + 'px';
      menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
      menu.style.opacity = '0';
      
      setTimeout(() => {
        if (typeof globalThis.setMenuJustClosed === 'function') {
          globalThis.setMenuJustClosed(true);
        }
        closeAttackMenu();
        document.removeEventListener('keydown', escapeHandler);
        setTimeout(() => {
          if (typeof globalThis.setMenuJustClosed === 'function') {
            globalThis.setMenuJustClosed(false);
          }
        }, 150);
      }, 250);
    }
  };
  document.addEventListener('keydown', escapeHandler);
  menu._escapeHandler = escapeHandler;
}


const zoomStatus = document.getElementById("zoomStatus");

document.body.addEventListener('click',async e=>{
  if(!isEvoMode)return;
  
  const target=e.target.closest('img.glow-evo') || (e.target.classList.contains('glow-evo') ? e.target : null);
  
  if(target){
    e.stopPropagation();
    e.stopImmediatePropagation();
    e.preventDefault();
    await evolveCard(target,evoMeta,evoHandCard,evoOwner,evoHandCard.dataset.set,evoHandCard.dataset.num);
    clearGlow();
    return;
  }
  
  const isClickOnModal = e.target.closest('#zoomBackdrop') || 
                         e.target.closest('.attack-menu') || 
                         e.target.closest('#handBackdrop') || 
                         e.target.closest('#toolBackdrop');
  
  if(isClickOnModal)return;
  
  const isClickOnHand = e.target.closest('.hand');
  if(isClickOnHand)return;
  
  const isClickOnButton = e.target.tagName === 'BUTTON' || e.target.closest('button');
  if(isClickOnButton)return;
  
  e.stopPropagation();
  e.preventDefault();
  clearGlow();
  showPopup('Evolution cancelled.');
}, true);

document.addEventListener('keydown', e => {
  if(!isEvoMode)return;
  if(e.key === 'Escape'){
    e.preventDefault();
  e.stopPropagation();
  clearGlow();
    showPopup('Evolution cancelled.');
  }
});

globalThis.abilityCache = {};

if (window.ABILITY_EFFECT_ROWS) {
  if (typeof globalThis.populateAbilityCache === 'function') {
  globalThis.populateAbilityCache();
  }
} else {
  let retries = 0;
  const maxRetries = 20;
  const retryInterval = setInterval(() => {
    retries++;
    if (typeof globalThis.populateAbilityCache === 'function') {
      globalThis.populateAbilityCache().then(() => {
      clearInterval(retryInterval);
      }).catch(() => {
        if (retries >= maxRetries) {
          clearInterval(retryInterval);
        }
      });
    } else if (retries >= maxRetries) {
      clearInterval(retryInterval);
    }
  }, 500);
}

function triggerNightmareAura(pokemonImg, energyType) {
  if (!pokemonImg || !energyType) return;
  
  const aura = globalThis.getPassiveAbility?.(pokemonImg, 'damage_on_energy_attach');
  if (!aura) return;
  
  const triggerType = (aura.param1 || '').toLowerCase();
  const damage = parseInt(aura.param2 || '0', 10);
  
  if (energyType.toLowerCase() === triggerType) {
    
    
    const ownerDiv = pokemonImg.closest('#player1, #player2');
    const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
    const opponent = owner === 'player1' ? 'player2' : 'player1';
    
    setTimeout(async () => {
      const result = await damageActiveOf(opponent, damage, { isDirectAttack: false });
      showPopup(`Nightmare Aura: ${damage} damage!`);
      
      
      if (result.knocked && typeof handleKnockOut === 'function') {
        const oppImg = getActiveImage(opponent);
        if (oppImg) {
          const gameEnded = await handleKnockOut(opponent, oppImg, true);
          if (!gameEnded && typeof beginPromotionFlow === 'function') {
            await beginPromotionFlow(opponent);
          }
        }
      }
    }, 300);
  }
}


globalThis.getActiveImg = getActiveImg;
globalThis.getPassiveDamageReduction = getPassiveDamageReduction;
globalThis.getCounterattackDamage = getCounterattackDamage;

function detachAttachments(slot){
  if (!slot) return { energy: null, hp: null, toolThumb: null, toolData: null, maxHp: null, chp: null, baseHp: null };
  const energy    = slot.querySelector('.energy-pips');
  const hp        = slot.querySelector('.hp-overlay');
  const toolThumb = slot.querySelector('.tool-thumb');
  
  const pokemonImg = slot.querySelector('img');
  const pokemonName = pokemonImg?.alt || 'unknown';
  const slotType = slot.closest('.active') ? 'active' : 'bench';
  
  // [HP-PRESERVATION] Preserve HP values from dataset and overlay before removing
  let chp = pokemonImg ? parseInt(pokemonImg.dataset.chp || '0', 10) : null;
  let baseHp = pokemonImg ? parseInt(pokemonImg.dataset.hp || '0', 10) : null;
  let maxHpFromOverlay = null;
  
  // Try to parse HP from overlay text (format: "currentHP / maxHP")
  if (hp && hp.textContent) {
    const hpMatch = hp.textContent.match(/(\d+)\s*\/\s*(\d+)/);
    if (hpMatch) {
      const parsedChp = parseInt(hpMatch[1], 10);
      const parsedMax = parseInt(hpMatch[2], 10);
      chp = parsedChp; // Use overlay value as it's more accurate
      maxHpFromOverlay = parsedMax;
      console.log('[DETACH-ATTACHMENTS-DEBUG] Parsed HP from overlay:', {
        chp: parsedChp,
        maxHp: parsedMax,
        overlayText: hp.textContent
      });
    }
  }

  console.log('[DETACH-ATTACHMENTS-DEBUG] Detaching from', {
    pokemon: pokemonName,
    slotType,
    hasEnergy: !!energy,
    energyPipCount: energy ? energy.querySelectorAll('.energy-pip').length : 0,
    energyTypes: energy ? Array.from(energy.querySelectorAll('.energy-pip')).map(p => p.dataset.type) : [],
    hasHp: !!hp,
    hasTool: !!toolThumb,
    chp,
    baseHp
  });

  if (energy)    energy.remove();
  if (hp)        hp.remove();
  if (toolThumb) toolThumb.remove();

  const toolData = getToolDataFromSlot(slot);
  if (toolData) setToolDataOnSlot(slot, null);
  
  
  const maxHp = slot.dataset.maxHp || null;
  if (maxHp) delete slot.dataset.maxHp;

  const result = { energy, hp, toolThumb, toolData, maxHp: maxHp || maxHpFromOverlay, chp, baseHp };
  console.log('[DETACH-ATTACHMENTS-DEBUG] Detached result', {
    pokemon: pokemonName,
    hasEnergy: !!result.energy,
    energyIsNull: result.energy === null,
    energyPipCount: result.energy ? result.energy.querySelectorAll('.energy-pip').length : 0,
    chp: result.chp,
    baseHp: result.baseHp
  });

  return result;
}
globalThis.detachAttachments = detachAttachments;

function attachAttachments(slot, pack){
  if (!slot || !pack) return;
  const { energy, hp, toolThumb, toolData, maxHp } = pack;
  
  const pokemonImg = slot.querySelector('img');
  const pokemonName = pokemonImg?.alt || 'unknown';
  const slotType = slot.closest('.active') ? 'active' : 'bench';
  
  console.log('[ATTACH-ATTACHMENTS-DEBUG] Attaching to', {
    pokemon: pokemonName,
    slotType,
    energy: {
      value: energy,
      isNull: energy === null,
      isTruthy: !!energy,
      type: energy?.constructor?.name,
      pipCount: energy ? energy.querySelectorAll('.energy-pip').length : 0
    },
    hasHp: !!hp,
    hasTool: !!toolThumb,
    hasToolData: !!toolData
  });
  
  // Only attach energy if it's not null (null means it was explicitly cleared)
  if (energy !== null && energy) {
    console.log('[ATTACH-ATTACHMENTS-DEBUG] ATTACHING ENERGY to', pokemonName, {
      pipCount: energy.querySelectorAll('.energy-pip').length,
      energyTypes: Array.from(energy.querySelectorAll('.energy-pip')).map(p => p.dataset.type)
    });
    slot.appendChild(energy);
  } else {
    console.log('[ATTACH-ATTACHMENTS-DEBUG] NOT attaching energy (null or falsy) to', pokemonName);
  }
  
  // [HP-PRESERVATION] Restore HP overlay and update dataset values
  // [HP-FIX] Use the pokemonImg we already queried at the start of the function
  if (pokemonImg && pack.chp !== null && pack.chp !== undefined) {
    // [HP-FIX] Always set dataset.chp to preserve damage - do this BEFORE appending HP overlay
    pokemonImg.dataset.chp = String(pack.chp);
    if (pack.baseHp !== null && pack.baseHp !== undefined) {
      pokemonImg.dataset.hp = String(pack.baseHp);
    }
    
    // Update HP overlay if it exists
    if (hp) {
      slot.appendChild(hp);
      // Update HP overlay text to match preserved values
      // Use maxHp if available (from tool or overlay), otherwise use baseHp, otherwise use chp
      const displayMaxHp = pack.maxHp || pack.baseHp || pack.chp;
      const hpText = `${pack.chp} / ${displayMaxHp}`;
      hp.textContent = hpText;
      
      // [HP-FIX] Call setHpOnImage to ensure HP overlay is correctly displayed
      // This ensures the HP is visually correct and dataset is in sync
      const baseHpForDisplay = pack.maxHp || pack.baseHp || pack.chp;
      if (typeof setHpOnImage === 'function') {
        setHpOnImage(pokemonImg, baseHpForDisplay, pack.chp);
      }
    } else {
      // [HP-FIX] Even if no HP overlay, still call setHpOnImage to create/update it
      const baseHpForDisplay = pack.maxHp || pack.baseHp || pack.chp;
      if (typeof setHpOnImage === 'function') {
        setHpOnImage(pokemonImg, baseHpForDisplay, pack.chp);
      }
    }
    
    console.log('[ATTACH-ATTACHMENTS-DEBUG] Restored HP values:', {
      pokemon: pokemonImg.alt,
      chp: pack.chp,
      baseHp: pack.baseHp,
      maxHp: pack.maxHp,
      datasetChp: pokemonImg.dataset.chp,
      datasetHp: pokemonImg.dataset.hp,
      hasHpOverlay: !!hp
    });
  } else if (pokemonImg && hp) {
    // [HP-FIX] If we have HP overlay but no pack.chp, try to preserve existing HP
    slot.appendChild(hp);
    const existingChp = pokemonImg.dataset.chp || pokemonImg.dataset.hp;
    if (existingChp) {
      pokemonImg.dataset.chp = String(existingChp);
      console.log('[ATTACH-ATTACHMENTS-DEBUG] Preserved existing HP:', {
        pokemon: pokemonImg.alt,
        existingChp
      });
    }
  }
  
  // [TOOL-DUPLICATE-FIX] Only append tool thumb if it doesn't already exist in the slot
  // This prevents duplicates when attachAttachments is called multiple times
  if (toolThumb) {
    const existingToolThumb = slot.querySelector('.tool-thumb');
    if (existingToolThumb && existingToolThumb !== toolThumb) {
      existingToolThumb.remove(); // Remove any existing tool thumb first
    }
    if (toolThumb.parentNode !== slot) {
      slot.appendChild(toolThumb);
    }
  }
  if (toolData)  setToolDataOnSlot(slot, toolData);
  
  
  if (maxHp) {
    slot.dataset.maxHp = maxHp;
  } else {
    
    delete slot.dataset.maxHp;
  }
}
globalThis.attachAttachments = attachAttachments;

function beginPromotionFlow(owner){
  console.log('[PROMOTION-FLOW] beginPromotionFlow called:', {
    owner,
    isPromotionPhase: isPromotionPhase,
    benchForType: typeof benchFor
  });
  
  return new Promise((resolve) => {
  isPromotionPhase = true;

  const benchDiv = benchFor(owner);
  console.log('[PROMOTION-FLOW] Bench div lookup:', {
    owner,
    benchDivExists: !!benchDiv,
    benchDivId: benchDiv?.id,
    benchDivClasses: benchDiv ? Array.from(benchDiv.classList) : []
  });
  
  const benchImgs = [...benchDiv.querySelectorAll('img')];
  console.log('[PROMOTION-FLOW] Bench images found:', {
    count: benchImgs.length,
    pokemon: benchImgs.map(img => ({
      alt: img.alt,
      id: img.id,
      classes: Array.from(img.classList)
    }))
  });
  
  if (!benchImgs.length) {
    const foe = owner === 'player1' ? 'player2' : 'player1';
    console.log('[PROMOTION-FLOW] No bench Pokemon - game over');
    showVictory(foe, 'Bench out');
    isPromotionPhase = false;
      resolve();
    return;
  }

  console.log('[PROMOTION-FLOW] Adding promote-glow to bench images');
  benchImgs.forEach((img, idx) => {
    img.classList.add('promote-glow');
    console.log('[PROMOTION-FLOW] Added glow to image:', {
      index: idx,
      alt: img.alt,
      hasGlow: img.classList.contains('promote-glow'),
      allClasses: Array.from(img.classList)
    });
  });
  
  // Verify glow was added
  const glowCheck = benchDiv.querySelectorAll('img.promote-glow');
  console.log('[PROMOTION-FLOW] Glow verification:', {
    expectedCount: benchImgs.length,
    actualGlowCount: glowCheck.length,
    glowImages: Array.from(glowCheck).map(img => img.alt)
  });
  
  showPopup('Choose a Benched Pokmon to promote.');

  const clickOnce = (e) => {
    
    if (!isPromotionPhase) {
      return;
    }
    
    if (e.target.closest('#zoomBackdrop') || e.target.closest('.attack-menu') || e.target.closest('#handBackdrop') || e.target.closest('#toolBackdrop')) {
      return;
    }
    
    const forcedImg = globalThis.__forcedPromotion;
    let chosenImg;
    
    if (forcedImg) {
      
      chosenImg = forcedImg;
      globalThis.__forcedPromotion = null;
    } else {
      
      chosenImg = e.target.closest(`#${owner} .bench img`);
      if (!chosenImg) {
        e.stopPropagation();
        e.stopImmediatePropagation();
        return;
      }
    }

    e.stopPropagation();
    document.body.removeEventListener('click', clickOnce, true);

    const activeDiv  = activeFor(owner);
    const activeSlot = activeDiv.querySelector('.card-slot');
    const benchSlot  = chosenImg.closest('.card-slot');
    const activeImg  = activeSlot.querySelector('img');

    if (activeImg) {
      clearStatusOnImg(activeImg);
    }
    
    if (!activeImg) {
      // Clear active slot completely to prevent energy/tool carryover from KO'd Pokemon
      const existingEnergy = activeSlot.querySelector('.energy-pips');
      const existingTool = activeSlot.querySelector('.tool-thumb');
      const existingHp = activeSlot.querySelector('.hp-overlay');
      if (existingEnergy) existingEnergy.remove();
      if (existingTool) existingTool.remove();
      if (existingHp) existingHp.remove();
      
      const benchPack = detachAttachments(benchSlot);
        
        const chosenRect = chosenImg.getBoundingClientRect();

      // [RETREAT-DUPLICATE-FIX] Clear active slot completely before appending to prevent duplicates
      const allActiveImgs = activeSlot.querySelectorAll('img');
      for (const img of allActiveImgs) {
        if (img !== chosenImg && img.parentNode === activeSlot) {
          activeSlot.removeChild(img);
        }
      }
      
      // [RETREAT-DUPLICATE-FIX] Ensure chosenImg is removed from benchSlot before appending to activeSlot
      if (chosenImg.parentNode === benchSlot) {
      benchSlot.removeChild(chosenImg);
      }
      
      // [RETREAT-DUPLICATE-FIX] Only append if not already in activeSlot
      if (chosenImg.parentNode !== activeSlot) {
      activeSlot.appendChild(chosenImg);
      }
        
        
        animateSlideSwap(chosenImg, activeSlot, chosenImg, chosenRect);

      attachAttachments(activeSlot, benchPack);

      markSlot(activeSlot, true);
      markSlot(benchSlot, !!benchSlot.querySelector('img'));

      benchImgs.forEach(x => x.classList.remove('promote-glow'));
      isPromotionPhase = false;

      showPopup(forcedImg ? 'Forced to Active.' : 'Promoted to Active.');
      
      const playerNum = activeDiv === p1Active ? 1 : 2;
      updatePlayerTypeBackground(playerNum);
      
      // Sync promotion to Firebase (no active Pokemon case)
      (async () => {
        const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
        const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
        const isOnline = matchId && window.firebaseDatabase;
        if (isOnline && typeof updateGameStatePartial === 'function') {
          const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
          const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
          const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
            ? 'player1' 
            : 'player2';
          
          try {
            const promotedImg = activeSlot.querySelector('img');
            if (promotedImg) {
              const cardData = {
                set: promotedImg.dataset.set,
                num: promotedImg.dataset.num,
                name: promotedImg.alt,
                instanceId: promotedImg.dataset.instanceId,
                hp: parseInt(promotedImg.dataset.hp || '0', 10),
                playedTurn: globalThis.turnNumber || 0
              };
              
              await updateGameStatePartial({
                [`${matchOwner}/active`]: cardData
              });
              
              // Update bench in Firebase - get current bench from DOM to avoid duplicates
              const benchDiv = benchFor(owner);
              const benchArray = Array.from(benchDiv.querySelectorAll('.card-slot img'))
                .filter(img => img.dataset.set && img.dataset.num) // Filter out empty slots
                .map(img => ({
                  set: img.dataset.set,
                  num: img.dataset.num,
                  name: img.alt,
                  instanceId: img.dataset.instanceId,
                  hp: parseInt(img.dataset.hp || '0', 10),
                  playedTurn: parseInt(img.dataset.playedTurn || '0', 10)
                }));
              
              // Update local playerState
              if (playerState[owner] && !playerState[owner].bench) {
                playerState[owner].bench = [];
              }
              playerState[owner].bench = benchArray;
              
              // Sync globalThis.playerState
              if (globalThis.playerState && globalThis.playerState[owner]) {
                globalThis.playerState[owner].bench = [...benchArray];
              }
              
              await updateGameStatePartial({
                [`${matchOwner}/bench`]: benchArray
              });
              
              if (typeof broadcastAction === 'function' && ACTION_TYPES) {
                await broadcastAction(ACTION_TYPES.PROMOTE, {
                  owner: matchOwner,
                  promoted: cardData,
                  benched: null,
                  turnNumber: globalThis.turnNumber || 0
                });
              }
            }
          } catch (error) {
            console.error('Error syncing promotion to Firebase:', error);
          }
        }
      })();
      
        resolve();
      return;
    }

    
      
      const activeInstanceId = activeImg.dataset.instanceId;
      const ownerPk = owner === 'player1' ? 'p1' : 'p2';
      if (activeInstanceId && globalThis.__moveLocks?.[ownerPk]?.[activeInstanceId]) {
        delete globalThis.__moveLocks[ownerPk][activeInstanceId];
      }
      
      const activeRect = activeImg.getBoundingClientRect();
      const chosenRect = chosenImg.getBoundingClientRect();

    // [SABRINA-RETREAT-PATTERN] Use retreat handler pattern instead of innerHTML swap
    // [SABRINA-LOGGING] Log bench state before Sabrina forced switch
    const benchDiv = benchFor(owner);
    const benchBefore = Array.from(benchDiv.querySelectorAll('.card-slot img'))
      .filter(img => !img.classList.contains('tool-thumb'))
      .map(img => ({
        name: img.alt,
        set: img.dataset.set,
        num: img.dataset.num,
        instanceId: img.dataset.instanceId,
        hp: img.dataset.chp || img.dataset.hp,
        maxHp: img.dataset.hp
      }));
    
    console.log('[SABRINA-RETREAT] ===== SABRINA SWAP START =====');
    console.log('[SABRINA-RETREAT] Before swap:', {
      owner,
      activeBefore: activeImg?.alt,
      benchBefore: chosenImg?.alt,
      activeSlotImgCount: activeSlot.querySelectorAll('img').length,
      benchSlotImgCount: benchSlot.querySelectorAll('img').length,
      benchBefore: benchBefore
    });
    
    // [SABRINA-RETREAT-PATTERN] Detach attachments first (like retreat)
    const activePack = typeof detachAttachments === 'function' ? 
      detachAttachments(activeSlot) : { energy: null, tool: null };
    const benchPack = typeof detachAttachments === 'function' ? 
      detachAttachments(benchSlot) : { energy: null, tool: null };
    
    // [SABRINA-RETREAT-PATTERN] Remove tool thumbs before swapping (like retreat)
    const activeToolThumb = activeSlot.querySelector('.tool-thumb');
    const benchToolThumb = benchSlot.querySelector('.tool-thumb');
    if (activeToolThumb && activeToolThumb.parentNode === activeSlot) {
      activeToolThumb.remove();
    }
    if (benchToolThumb && benchToolThumb.parentNode === benchSlot) {
      benchToolThumb.remove();
    }
    
    // [SABRINA-RETREAT-PATTERN] Remove images from slots (like retreat)
    if (activeImg && activeImg.parentNode === activeSlot) {
      activeSlot.removeChild(activeImg);
    }
    if (chosenImg && chosenImg.parentNode === benchSlot) {
      benchSlot.removeChild(chosenImg);
    }

    // [SABRINA-RETREAT-PATTERN] Clear ALL images (including tool thumbs) from both slots (safety check)
    // Tool thumbs are also <img> elements, so we need to remove them too
    const allActiveImgs = activeSlot.querySelectorAll('img');
    const allBenchImgs = benchSlot.querySelectorAll('img');
    for (const img of allActiveImgs) {
      // Remove all images except the one we're about to append (chosenImg)
      if (img !== chosenImg && img.parentNode === activeSlot) {
        activeSlot.removeChild(img);
      }
    }
    for (const img of allBenchImgs) {
      // Remove all images except the one we're about to append (activeImg)
      if (img !== activeImg && img.parentNode === benchSlot) {
        benchSlot.removeChild(img);
      }
    }
    
    // [SABRINA-DUPLICATE-FIX] Double-check: ensure slots are completely clear of images before appending
    const remainingActiveImgs = activeSlot.querySelectorAll('img');
    const remainingBenchImgs = benchSlot.querySelectorAll('img');
    if (remainingActiveImgs.length > 0 || remainingBenchImgs.length > 0) {
      console.warn('[SABRINA-DUPLICATE-FIX] Images still present after removal attempt:', {
        activeCount: remainingActiveImgs.length,
        benchCount: remainingBenchImgs.length,
        activeImgs: Array.from(remainingActiveImgs).map(img => ({ alt: img.alt, className: img.className })),
        benchImgs: Array.from(remainingBenchImgs).map(img => ({ alt: img.alt, className: img.className }))
      });
      // Force remove all remaining images
      remainingActiveImgs.forEach(img => {
        if (img !== chosenImg && img.parentNode === activeSlot) {
          activeSlot.removeChild(img);
        }
      });
      remainingBenchImgs.forEach(img => {
        if (img !== activeImg && img.parentNode === benchSlot) {
          benchSlot.removeChild(img);
        }
      });
    }
    
    // [SABRINA-RETREAT-PATTERN] Append images to new slots (like retreat)
    if (chosenImg && chosenImg.parentNode !== activeSlot) {
      activeSlot.appendChild(chosenImg);
    }
    if (activeImg && activeImg.parentNode !== benchSlot) {
      benchSlot.appendChild(activeImg);
    }
    
    // [SABRINA-RETREAT-PATTERN] Remove energy pips before attaching to prevent duplicates
    const activeEnergyPipsAfter = activeSlot.querySelector('.energy-pips');
    const benchEnergyPipsAfter = benchSlot.querySelector('.energy-pips');
    if (activeEnergyPipsAfter && activeEnergyPipsAfter.parentNode === activeSlot) {
      activeEnergyPipsAfter.remove();
    }
    if (benchEnergyPipsAfter && benchEnergyPipsAfter.parentNode === benchSlot) {
      benchEnergyPipsAfter.remove();
    }
    
    // [SABRINA-RETREAT-PATTERN] Attach attachments (like retreat)
    if (typeof attachAttachments === 'function') {
    attachAttachments(activeSlot, benchPack);
      if (activeImg) {
    attachAttachments(benchSlot, activePack);
      }
    }
    
    // [SABRINA-RETREAT-PATTERN] Animate the swap
    const newActiveImg = activeSlot.querySelector('img');
    const newBenchImg = benchSlot.querySelector('img');
    if (newActiveImg && newBenchImg) {
      animateSlideSwap(chosenImg, activeSlot, newActiveImg, chosenRect);
      animateSlideSwap(activeImg, benchSlot, newBenchImg, activeRect);
    } else if (newActiveImg) {
      animateSlideSwap(chosenImg, activeSlot, newActiveImg, chosenRect);
    }
    
    // [SABRINA-LOGGING] Log bench state after Sabrina forced switch
    const benchAfter = Array.from(benchDiv.querySelectorAll('.card-slot img'))
      .filter(img => !img.classList.contains('tool-thumb'))
      .map(img => ({
        name: img.alt,
        set: img.dataset.set,
        num: img.dataset.num,
        instanceId: img.dataset.instanceId,
        hp: img.dataset.chp || img.dataset.hp,
        maxHp: img.dataset.hp
      }));
    
    console.log('[SABRINA-RETREAT] After swap:', {
      activeSlotImgCount: activeSlot.querySelectorAll('img').length,
      benchSlotImgCount: benchSlot.querySelectorAll('img').length,
      newActiveImg: newActiveImg?.alt,
      newBenchImg: newBenchImg?.alt,
      benchAfter: benchAfter,
      benchComparison: {
        beforeCount: benchBefore.length,
        afterCount: benchAfter.length,
        before: benchBefore.map(p => p.name),
        after: benchAfter.map(p => p.name)
      }
    });

    markSlot(activeSlot, true);
    markSlot(benchSlot, !!benchSlot.querySelector('img'));

    benchImgs.forEach(x => x.classList.remove('promote-glow'));
    isPromotionPhase = false;

    showPopup(forcedImg ? 'Forced to Active.' : 'Promoted to Active.');
      
      const playerNum = activeDiv === p1Active ? 1 : 2;
      updatePlayerTypeBackground(playerNum);
      
      // Sync promotion to Firebase
      (async () => {
        const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
        const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
        const isOnline = matchId && window.firebaseDatabase;
        if (isOnline && typeof updateGameStatePartial === 'function') {
          const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
          const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
          const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
            ? 'player1' 
            : 'player2';
          
          try {
            // Get promoted Pokemon data
            const promotedImg = activeSlot.querySelector('img');
            if (promotedImg) {
              const cardData = {
                set: promotedImg.dataset.set,
                num: promotedImg.dataset.num,
                name: promotedImg.alt,
                instanceId: promotedImg.dataset.instanceId,
                hp: parseInt(promotedImg.dataset.hp || '0', 10),
                playedTurn: globalThis.turnNumber || 0
              };
              
              // Update active in Firebase
              await updateGameStatePartial({
                [`${matchOwner}/active`]: cardData
              });
              
              // Update bench in Firebase - get current bench from DOM to avoid duplicates
              const benchDiv = benchFor(owner);
              const benchArray = Array.from(benchDiv.querySelectorAll('.card-slot img'))
                .filter(img => img.dataset.set && img.dataset.num) // Filter out empty slots
                .map(img => ({
                  set: img.dataset.set,
                  num: img.dataset.num,
                  name: img.alt,
                  instanceId: img.dataset.instanceId,
                  hp: parseInt(img.dataset.hp || '0', 10),
                  playedTurn: parseInt(img.dataset.playedTurn || '0', 10)
                }));
              
              // Update local playerState
              if (playerState[owner] && !playerState[owner].bench) {
                playerState[owner].bench = [];
              }
              playerState[owner].bench = benchArray;
              
              // Sync globalThis.playerState
              if (globalThis.playerState && globalThis.playerState[owner]) {
                globalThis.playerState[owner].bench = [...benchArray];
              }
              
              await updateGameStatePartial({
                [`${matchOwner}/bench`]: benchArray
              });
              
              // Broadcast promotion action
              if (typeof broadcastAction === 'function' && ACTION_TYPES) {
                await broadcastAction(ACTION_TYPES.PROMOTE, {
                  owner: matchOwner,
                  promoted: cardData,
                  benched: activeImg ? {
                    set: activeImg.dataset.set,
                    num: activeImg.dataset.num,
                    name: activeImg.alt,
                    instanceId: activeImg.dataset.instanceId
                  } : null,
                  turnNumber: globalThis.turnNumber || 0
                });
              }
              
              console.log('Synced promotion to Firebase:', {
                matchOwner,
                promotedName: cardData.name
              });
            }
          } catch (error) {
            console.error('Error syncing promotion to Firebase:', error);
          }
        }
      })();
      
      resolve();
    };

    document.body.addEventListener('click', clickOnce, true);
  });
}

globalThis.benchFor           = benchFor;
globalThis.activeFor          = activeFor;
globalThis.beginPromotionFlow = beginPromotionFlow;
globalThis.fetchCardMeta      = fetchCardMeta;
globalThis.ENERGY_ICONS       = ENERGY_ICONS;
globalThis.attachEnergyToSlot = attachEnergyToSlot;
globalThis.energyZoneDiv      = energyZoneDiv;
globalThis.renderEnergyZone   = renderEnergyZone;
globalThis.getActiveImage     = getActiveImage;
globalThis.applyAbilityEffectFromCsv = window.applyAbilityEffectFromCsv;

globalThis.evolveCard         = evolveCard;
globalThis.handleKnockOut     = handleKnockOut;
globalThis.damageActiveOf     = damageActiveOf;
globalThis.startTurn          = startTurn;
globalThis.pushCardToDiscard  = pushCardToDiscard;
globalThis.moveCardToDiscard  = moveCardToDiscard;

async function updatePlayerTypeBackground(playerNum) {
  const playerId = `player${playerNum}`;
  const playerDiv = document.getElementById(playerId);
  
  
  const activeDiv = playerNum === 1 ? p1Active : p2Active;
  const activeSlot = activeDiv?.querySelector('.card-slot');
  const activeImg = activeSlot?.querySelector('img');
  
  if (!playerDiv) return;
  
  
  if (!activeImg) {
    
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    
    const overlay = playerDiv.querySelector('.type-overlay');
    if (overlay) {
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 600);
    }
    return;
  }
  
  
  const set = activeImg.dataset.set;
  const num = activeImg.dataset.num;
  
  if (!set || !num) {
    
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    
    const overlay = playerDiv.querySelector('.type-overlay');
    if (overlay) {
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 600);
    }
    return;
  }
  
  try {
    
    const meta = await fetchCardMeta(set, num);
    
    
    let pokemonType = 'colorless';
    if (meta.types && meta.types[0]) {
      pokemonType = String(meta.types[0]).toLowerCase();
    }
    
    
    let overlay = playerDiv.querySelector('.type-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.className = 'type-overlay';
      overlay.style.position = 'absolute';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.right = '0';
      overlay.style.bottom = '0';
      overlay.style.borderRadius = '16px';
      overlay.style.pointerEvents = 'none';
      overlay.style.zIndex = '0';
      overlay.style.transition = 'opacity 0.6s ease';
      overlay.style.opacity = '0';
      
      playerDiv.insertBefore(overlay, playerDiv.firstChild);
    }
    
    
    const typeGradients = {
      grass: 'linear-gradient(180deg, rgba(34, 197, 94, 0.3) 0%, rgba(22, 163, 74, 0.5) 50%, rgba(21, 128, 61, 0.4) 100%)',
      fire: 'linear-gradient(180deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.5) 50%, rgba(185, 28, 28, 0.4) 100%)',
      water: 'linear-gradient(180deg, rgba(59, 130, 246, 0.3) 0%, rgba(37, 99, 235, 0.5) 50%, rgba(29, 78, 216, 0.4) 100%)',
      lightning: 'linear-gradient(180deg, rgba(234, 179, 8, 0.3) 0%, rgba(202, 138, 4, 0.5) 50%, rgba(161, 98, 7, 0.4) 100%)',
      psychic: 'linear-gradient(180deg, rgba(168, 85, 247, 0.3) 0%, rgba(147, 51, 234, 0.5) 50%, rgba(126, 34, 206, 0.4) 100%)',
      fighting: 'linear-gradient(180deg, rgba(249, 115, 22, 0.3) 0%, rgba(234, 88, 12, 0.5) 50%, rgba(194, 65, 12, 0.4) 100%)',
      darkness: 'linear-gradient(180deg, rgba(100, 116, 139, 0.3) 0%, rgba(71, 85, 105, 0.5) 50%, rgba(51, 65, 85, 0.4) 100%)',
      metal: 'linear-gradient(180deg, rgba(148, 163, 184, 0.3) 0%, rgba(100, 116, 139, 0.5) 50%, rgba(71, 85, 105, 0.4) 100%)',
      dragon: 'linear-gradient(180deg, rgba(211, 186, 48, 0.3) 0%, rgba(184, 158, 32, 0.5) 50%, rgba(169, 142, 28, 0.4) 100%)',
      fairy: 'linear-gradient(180deg, rgba(236, 72, 153, 0.3) 0%, rgba(219, 39, 119, 0.5) 50%, rgba(190, 24, 93, 0.4) 100%)',
      colorless: 'linear-gradient(180deg, rgba(156, 163, 175, 0.3) 0%, rgba(107, 114, 128, 0.5) 50%, rgba(75, 85, 99, 0.4) 100%)'
    };
    
    const typeShadows = {
      grass: '0 0 30px rgba(34, 197, 94, 0.3)',
      fire: '0 0 30px rgba(239, 68, 68, 0.3)',
      water: '0 0 30px rgba(59, 130, 246, 0.3)',
      lightning: '0 0 30px rgba(234, 179, 8, 0.3)',
      psychic: '0 0 30px rgba(168, 85, 247, 0.3)',
      fighting: '0 0 30px rgba(249, 115, 22, 0.3)',
      darkness: '0 0 30px rgba(100, 116, 139, 0.3)',
      metal: '0 0 30px rgba(148, 163, 184, 0.3)',
      dragon: '0 0 30px rgba(211, 186, 48, 0.3)',
      fairy: '0 0 30px rgba(236, 72, 153, 0.3)',
      colorless: '0 0 30px rgba(156, 163, 175, 0.3)'
    };
    
    const typeBorders = {
      grass: '1px solid rgba(34, 197, 94, 0.3)',
      fire: '1px solid rgba(239, 68, 68, 0.3)',
      water: '1px solid rgba(59, 130, 246, 0.3)',
      lightning: '1px solid rgba(234, 179, 8, 0.3)',
      psychic: '1px solid rgba(168, 85, 247, 0.3)',
      fighting: '1px solid rgba(249, 115, 22, 0.3)',
      darkness: '1px solid rgba(100, 116, 139, 0.3)',
      metal: '1px solid rgba(148, 163, 184, 0.3)',
      dragon: '1px solid rgba(211, 186, 48, 0.3)',
      fairy: '1px solid rgba(236, 72, 153, 0.3)',
      colorless: '1px solid rgba(156, 163, 175, 0.3)'
    };
    
    
    if (overlay.style.opacity !== '0') {
      overlay.style.opacity = '0';
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    
    overlay.style.background = typeGradients[pokemonType] || typeGradients.colorless;
    overlay.style.boxShadow = typeShadows[pokemonType] || typeShadows.colorless;
    overlay.style.border = typeBorders[pokemonType] || typeBorders.colorless;
    
    
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    playerDiv.classList.add(`type-${pokemonType}`);
    
    
    void overlay.offsetWidth;
    requestAnimationFrame(() => {
      overlay.style.opacity = '1';
    });
    
  } catch (error) {
    console.error('Error updating player background:', error);
    
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    
    const overlay = playerDiv.querySelector('.type-overlay');
    if (overlay) {
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 600);
    }
  }
}

globalThis.updatePlayerTypeBackground = updatePlayerTypeBackground;

function updateAllPlayerBackgrounds() {
  updatePlayerTypeBackground(1);
  updatePlayerTypeBackground(2);
}
globalThis.updateAllPlayerBackgrounds = updateAllPlayerBackgrounds;

async function drawOne(player){
  // Prevent duplicate draws in the same turn
  const currentTurn = globalThis.turnNumber || 0;
  const drawKey = `${currentTurn}-${player}`;
  if (lastDrawTurn === currentTurn && lastDrawPlayer === player) {
    // Skipping duplicate drawOne call
    return false;
  }
  
  const d=playerState[player].deck,
        h=playerState[player].hand;
  if(!d.length) {
    return false;
  }
  
  // Mark that we've drawn for this turn/player
  lastDrawTurn = currentTurn;
  lastDrawPlayer = player;
  
  const handDiv = player === 'player1' ? p1HandDiv : p2HandDiv;
  animateCardDraw(player, handDiv);
  
  h.push(d.shift());
  
  // Sync globalThis.playerState with playerState
  if (globalThis.playerState && globalThis.playerState[player]) {
    globalThis.playerState[player].deck = [...d];
    globalThis.playerState[player].hand = [...h];
  }
  
  updateDeckBubbles();
  
  // Sync deck and hand to Firebase in online mode
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
  if (isOnline) {
    const updateGameStatePartialFn = updateGameStatePartial || globalThis.updateGameStatePartial;
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    if (updateGameStatePartialFn) {
      try {
        const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
        // Map UI player to match player
        const matchPlayer = (isP1 && player === 'player1') || (!isP1 && player === 'player2') 
          ? 'player1' 
          : 'player2';
        
        await updateGameStatePartialFn({
          [`${matchPlayer}/deck`]: [...d],
          [`${matchPlayer}/hand`]: [...h]
        });
        console.log('Synced card draw to Firebase:', {
          matchPlayer,
          deckLength: d.length,
          handLength: h.length
        });
      } catch (error) {
        console.error('Error syncing card draw to Firebase:', error);
      }
    }
  }
  
  return true;
}

async function runStatusStartOfTurn(pk) {
  const img = getActiveImg(pk);
  if (!img) return;

  const status = (img.dataset.status || "").toLowerCase();
  
  if (status === "paralyzed") {
    clearStatus(pk);
    showPopup("The Active Pokmon is no longer paralyzed.", 1800);
  }
  
}

async function checkSleepEndOfTurn() {
  
  for (const pk of ['p1', 'p2']) {
    const img = getActiveImg(pk);
    if (!img) continue;
    
    const status = (img.dataset.status || "").toLowerCase();
    
    if (status === "asleep") {
      const pokemonName = img.alt || "Active Pokmon";
      showPopup(`${pokemonName} is asleep. Flipping coin...`, 2000);
      await new Promise(resolve => setTimeout(resolve, 500));
      
      
      coinEl.classList.add('flip');
      const isHeads = Math.random() < 0.5;
      const front = coinEl.querySelector('.front');
      const back = coinEl.querySelector('.back');
      
      await new Promise(resolve => setTimeout(() => {
        coinEl.classList.remove('flip');
        
        
        if (front && back) {
          if (isHeads) {
            front.style.transform = 'rotateY(0deg)';
            back.style.transform = 'rotateY(180deg)';
          } else {
            front.style.transform = 'rotateY(180deg)';
            back.style.transform = 'rotateY(0deg)';
          }
        }
        
        
        if (coinResult) {
          coinResult.textContent = isHeads ? "Heads" : "Tails";
        }
        
        resolve();
      }, 1500));
      
      if (isHeads) {
        clearStatus(pk);
        showPopup(`${pokemonName} woke up!`, 1800);
      } else {
        showPopup(`${pokemonName} is still asleep.`, 1800);
      }
      
      
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}

async function runStatusStartOfOpponentTurn(pk) {
    const opp = pk === "p1" ? "p2" : "p1";
    const img = getActiveImg(opp);
    if (!img) return;

    const status = (img.dataset.status || "").toLowerCase();

    const base = parseInt(img.dataset.hp || 0, 10);
    let cur = parseInt(img.dataset.chp || base, 10);

    if (status === "poisoned") {
        cur = Math.max(0, cur - 10);
        setHpOverlayForImg(img, base, cur);
        showPopup("Poison deals 10 damage!");
    }

    if (status === "burned") {
        cur = Math.max(0, cur - 20);
        setHpOverlayForImg(img, base, cur);
        showPopup("Burn deals 20 damage!");

        let flip = Math.random() < 0.5 ? "heads" : "tails";
        if (flip === "heads") {
            img.dataset.status = "";
            removeStatusMarker(img);
            showPopup("Burn was healed!");
        } else {
            showPopup("Burn remains.");
        }
    }

    if (cur <= 0) {
        await handleKnockout(opp);
    }
}

async function startTurn(player, previousPlayer = null, turnNumber = undefined) {
  
  await checkSleepEndOfTurn();
  
  
  // Use provided previousPlayer parameter, or derive from currentPlayer if not provided
  const actualPreviousPlayer = previousPlayer !== null ? previousPlayer : currentPlayer;
  const previousPk = actualPreviousPlayer === 'player1' ? 'p1' : 'p2';
  
  if (actualPreviousPlayer) {
    try {
      const prevActiveDiv = actualPreviousPlayer === 'player1' ? p1Active : p2Active;
      const prevBenchDiv = actualPreviousPlayer === 'player1' ? p1Bench : p2Bench;
      const prevPokemon = [
        ...(prevActiveDiv?.querySelectorAll('img') || []),
        ...(prevBenchDiv?.querySelectorAll('img') || [])
      ];
      
      
      const prevActiveImg = prevActiveDiv?.querySelector('img');
      if (prevActiveImg) {
        const cacheKey = `${prevActiveImg.dataset.set}-${prevActiveImg.dataset.num}`;
        const abilityRow = globalThis.abilityCache?.[cacheKey];
        
        if (abilityRow?.effect_type === 'heal_active_end_of_turn') {
          const effectState = {
            p1: playerState.player1,
            p2: playerState.player2
          };
          
          if (typeof globalThis.applyAbilityEffectFromCsv === 'function') {
            await globalThis.applyAbilityEffectFromCsv(effectState, previousPk, abilityRow, { 
              abilityPokemon: prevActiveImg 
            });
          }
        }
        
        
        const slot = prevActiveImg.closest('.card-slot');
        if (slot) {
          const tool = getToolDataFromSlot(slot);
          
          if (tool && tool.num === '067' && tool.set === 'A3b') {
            const maxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : parseInt(prevActiveImg.dataset.hp, 10);
            const curHp = parseInt(prevActiveImg.dataset.chp, 10);
            
            if (curHp < maxHp) {
              const healAmount = 10;
              const newHp = Math.min(maxHp, curHp + healAmount);
              prevActiveImg.dataset.chp = String(newHp);
              
              
              if (typeof setHpOnImage === 'function') {
                setHpOnImage(prevActiveImg, maxHp, newHp);
              }
              
              showPopup(`Leftovers: Healed 10 damage from ${prevActiveImg.alt}!`);
            }
          }
        }
      }
      
      
      if (globalThis.turnNumber === 1 || globalThis.turnNumber === 2) {
        
        // Get firstPlayer from global scope - use globalThis.firstPlayer or the module-level firstPlayer
        const currentFirstPlayer = globalThis.firstPlayer || firstPlayer || 'player1';
        
        let firstTurnPk, firstTurnPlayer;
        if (globalThis.turnNumber === 1) {
          
          firstTurnPlayer = currentFirstPlayer; 
          firstTurnPk = firstTurnPlayer === 'player1' ? 'p1' : 'p2';
        } else {
          
          firstTurnPlayer = currentFirstPlayer === 'player1' ? 'player2' : 'player1';
          firstTurnPk = firstTurnPlayer === 'player1' ? 'p1' : 'p2';
        }
        const firstTurnActiveDiv = firstTurnPlayer === 'player1' ? p1Active : p2Active;
        const firstTurnBenchDiv = firstTurnPlayer === 'player1' ? p1Bench : p2Bench;
        const activePokemon = firstTurnActiveDiv?.querySelectorAll('img') || [];
        const benchPokemon = firstTurnBenchDiv?.querySelectorAll('img') || [];
        const firstTurnPokemon = [...activePokemon, ...benchPokemon];
        
        
        for (const img of firstTurnPokemon) {
          
          const set = img.dataset.set;
          const num = img.dataset.num;
          const cacheKeyPadded = `${set}-${String(num).padStart(3, '0')}`; 
          const cacheKeyUnpadded = `${set}-${parseInt(num, 10)}`; 
          const cacheKey = `${set}-${num}`; 

          
          
          const abilityRow = globalThis.abilityCache?.[cacheKeyPadded] || 
                           globalThis.abilityCache?.[cacheKeyUnpadded] || 
                           globalThis.abilityCache?.[cacheKey];
          
          if (abilityRow?.effect_type === 'attach_energy_end_of_first_turn') {
            const effectState = {
              p1: playerState.player1,
              p2: playerState.player2
            };
            
            if (typeof globalThis.applyAbilityEffectFromCsv === 'function') {
              await globalThis.applyAbilityEffectFromCsv(effectState, firstTurnPk, abilityRow, { 
                abilityPokemon: img 
              });
            } else {
              console.error(`[Thunderclap Flash] applyAbilityEffectFromCsv is not a function!`);
            }
          } else {
          }
        }
      }
    } catch (err) {
      console.error('[startTurn] End of turn abilities failed:', err);
    }
  }

  logEvent({
    player,
    text: `Turn ${globalThis.turnNumber} started for ${player === 'player1' ? 'Player 1' : 'Player 2'}.`
  });

  const pk = player === 'player1' ? 'p1' : 'p2';
  
  
  if (!globalThis.__supporterPlayedThisTurn) globalThis.__supporterPlayedThisTurn = { p1: false, p2: false };
  globalThis.__supporterPlayedThisTurn[pk] = false;
  
  
  if (globalThis.__moveLocks?.[pk]) {
    const currentTurn = globalThis.turnNumber || 0;
    
    for (const instanceId in globalThis.__moveLocks[pk]) {
      for (const moveName in globalThis.__moveLocks[pk][instanceId]) {
        const lock = globalThis.__moveLocks[pk][instanceId][moveName];
        if (typeof lock === 'object' && lock.lockedOnTurn) {
          
          if (currentTurn > lock.lockedOnTurn + 2) {
            delete globalThis.__moveLocks[pk][instanceId][moveName];
          }
        }
      }
    }
  }
  
  
  clearExpiredEffectsOnTurnStart(previousPk);
  
  
  clearExpiredEffectsOnTurnStart(pk);
  
  
  if (typeof clearTurnEffects === 'function') {
    
    if (!globalThis.state) {
      globalThis.state = { temp: { p1: {}, p2: {} } };
    }
    clearTurnEffects(globalThis.state, previousPk);
  }
  
  
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.koLastTurn) globalThis.state.koLastTurn = {};
  
  
  if (globalThis.state.koLastTurn[pk]) {
    globalThis.state.koLastTurn[pk] = false;
  }

  // Don't increment turn number here - it's managed by endTurn and synced from Firebase
  // Only set initial turn number if it hasn't been set yet
  if (!globalThis.turnNumber) {
    globalThis.turnNumber = 1;
  }

  // In online mode, currentPlayer should already be set correctly from Firebase
  // Only set it if it's not already set or if we're in local mode
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
  
  if (!isOnline) {
    // Local mode: set currentPlayer normally
  currentPlayer = player;
    globalThis.currentPlayer = player;
  } else {
    // Online mode: currentPlayer should already be set from Firebase in onStateChange
    // It should match the player parameter passed to startTurn
    // If it doesn't match, that means another Firebase update changed it, which is a race condition
    if (currentPlayer !== player) {
      console.warn('startTurn: currentPlayer mismatch in online mode (race condition detected):', {
        currentPlayerFromFirebase: currentPlayer,
        playerParameter: player,
        turnNumber: globalThis.turnNumber,
        note: 'Another Firebase update may have changed currentPlayer. startTurn will be skipped or retried.'
      });
      // Don't update currentPlayer - trust Firebase value
      // Return early to prevent incorrect turn processing
      return;
    }
    // currentPlayer already matches player, so we're good to proceed
  }
  
  // Sync currentPlayer and turnNumber to Firebase (if not already synced by endTurn or game start)
  // Reuse getCurrentMatchIdFn, matchId, and isOnline from above (already declared)
  if (isOnline && !actualPreviousPlayer) {
    // Don't sync the first turn from startTurn - it's already synced when the game starts
    // (game start sync happens in onStateChange when both players are ready)
    // The first turn is synced with turnNumber: 1, so if we're here with turnNumber: 1 and not in setup,
    // the game start was already synced
    // Skipping first turn sync - game start already synced
  }
  
  // In online mode, DON'T update energy types in startTurn - they should be synced from Firebase
  // Energy types are set during coin flip and should not be changed by startTurn
  // Only update energy types in local mode
  if (!isOnline) {
  const state = playerState[player];
  const energyTypes = state.energyTypes || [];
  
  if (energyTypes.length > 1) {
    
    const oldNextTurnEnergy = state.nextTurnEnergy;
    
    
    if (oldNextTurnEnergy) {
      state.currentTurnEnergy = oldNextTurnEnergy;
    } else {
      
      state.currentTurnEnergy = selectRandomEnergy(energyTypes);
    }
    
    
    state.nextTurnEnergy = selectRandomEnergy(energyTypes);
    
  } else if (energyTypes.length === 1) {
    
    state.currentTurnEnergy = energyTypes[0];
    state.nextTurnEnergy = energyTypes[0];
    }
  }
  
  // Always render energy zone - it will use the correct player's energy based on online mode
  renderEnergyZone();

  const turnLabel = `Turn ${globalThis.turnNumber}  ${player === 'player1' ? 'Player 1' : 'Player 2'}`;

  const bar = document.createElement("div");
  bar.className = "turn-bar";
  bar.innerHTML = `
      <div class="turn-icon">${globalThis.turnNumber}</div>
      ${turnLabel}
    `;
  if (logEntriesDiv.firstChild) {
    logEntriesDiv.insertBefore(bar, logEntriesDiv.firstChild);
  } else {
  logEntriesDiv.appendChild(bar);
  }

  
  hasAttachedEnergyThisTurn = false;
  globalThis.hasAttachedEnergyThisTurn = false;
  selectedEnergy = null;
  hasRetreatedThisTurn = false;
  closeAttackMenu();
  hasPlayedSupporterThisTurn[player] = false;

  resetDamageBoostsFor("player1");
  resetDamageBoostsFor("player2");
  
  
  window.usedAbilitiesThisTurn[pk] = {};
  
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.temp) globalThis.state.temp = {};
  if (!globalThis.state.temp[player]) globalThis.state.temp[player] = {};
  globalThis.state.temp[player].globalDamageBoost = 0;
  
  
  if (globalThis.state?.damageBoost?.[previousPk]) {
    const boostData = globalThis.state.damageBoost[previousPk];
    if (boostData.duration === 'this_turn') {
      delete globalThis.state.damageBoost[previousPk];
    }
  }

  
    if (globalThis.resetAbilityUsage) {
    globalThis.resetAbilityUsage(pk);
  }

  
  await runStatusBetweenTurns();

  
  
  
  
  if (actualPreviousPlayer && typeof getMoveRow === 'function' && typeof applyMoveEffectFromCsv === 'function') {
    try {
      const prevPk = previousPk;
      const prevActiveImg = getActiveImg(prevPk);
      if (prevActiveImg) {
        
        const prevMeta = await fetchCardMeta(prevActiveImg.dataset.set, prevActiveImg.dataset.num);
        if (prevMeta?.attacks) {
          for (const attack of prevMeta.attacks) {
            const moveRow = await globalThis.getMoveRow(prevActiveImg.alt, attack.name);
            if (moveRow?.effect_type === 'damage_end_of_opponent_turn') {
              const effectState = {
                p1: playerState.player1,
                p2: playerState.player2
              };
              const defendingPk = pk; 
              await applyMoveEffectFromCsv(effectState, prevPk, attack.name, 0, {
                moveName: attack.name,
                isFinal: true,
                defendingPk: defendingPk,
                sourceImg: prevActiveImg
              });
            }
          }
        }
      }
    } catch (err) {
      console.error('[startTurn] damage_end_of_opponent_turn failed:', err);
    }
  }

  
  await runStatusStartOfTurn(pk);

  // [TURN-1-DRAW] Draw card logic - first player should draw on turn 1
  const matchIdForDraw = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnlineForDraw = matchIdForDraw && window.firebaseDatabase;
  // Use the turnNumber parameter if provided (passed from onStateChange)
  // Otherwise fall back to globalThis.turnNumber or 1
  const currentTurnNumber = turnNumber !== undefined ? turnNumber : (globalThis.turnNumber || 1);
  const isTurn1 = currentTurnNumber === 1;
  // Get firstPlayer from global scope - avoid temporal dead zone issues
  const currentFirstPlayer = globalThis.firstPlayer || (typeof getFirstPlayer === 'function' ? getFirstPlayer() : null) || firstPlayer || 'player1';
  
  console.log('[TURN-1-DRAW] Draw decision:', {
    player,
    currentPlayer,
    isOnlineForDraw,
    isTurn1,
    firstPlayer: currentFirstPlayer,
    turnNumber: currentTurnNumber,
    shouldDraw: !isOnlineForDraw || (currentPlayer === player) || (isTurn1 && player === currentFirstPlayer)
  });
  
  if (isOnlineForDraw) {
    // In online mode, draw if:
    // 1. This player is the current player (normal case), OR
    // 2. It's turn 1 and this player is the first player (first player draws on turn 1)
    //    Note: On turn 1, currentPlayer might not be set yet, so we check firstPlayer
    const isCurrentPlayer = currentPlayer === player;
    const isFirstPlayerOnTurn1 = isTurn1 && player === currentFirstPlayer;
    const shouldDraw = isCurrentPlayer || isFirstPlayerOnTurn1;
    
    console.log('[TURN-1-DRAW] Draw check:', {
      isCurrentPlayer,
      isFirstPlayerOnTurn1,
      shouldDraw,
      currentPlayer,
      player,
      currentFirstPlayer,
      isTurn1
    });
    
    if (shouldDraw) {
      console.log('[TURN-1-DRAW] Drawing card for player:', player);
      await drawOne(player);
    } else {
      console.log('[TURN-1-DRAW] Skipping draw - not current player and not first player on turn 1');
    }
  } else {
    // Local mode: always draw
    console.log('[TURN-1-DRAW] Local mode - drawing card for player:', player);
    await drawOne(player);
  }

  
  renderAllHands();
  renderEnergyZone();
  updateTurnBox();

setTimeout(() => {
  showPopup(`Player ${player === 'player1' ? '1' : '2'}'s turn`);
}, 900);

}

async function drawStartingHandForPlayer(key, syncToFirebase = false){
  // Ensure we're working with a copy of the deck, not the original reference
  const deck = [...playerState[key].deck];
  if(deck.length<5)throw new Error('Deck too small');

  let tries=0,hand=[],hasBasic=false;
  const originalDeck = [...deck]; // Keep original for potential sync

  while(tries<10){
    tries++;
    shuffle(deck);
    
    if (tries === 1) {
      animateDeckShuffle(key);
    }

    hand=deck.slice(0,5);

    const flags=await Promise.all(
      hand.map(c=>isBasicPokemon(c.set,c.number||c.num))
    );

    hasBasic=flags.some(Boolean);
    if(hasBasic) break;
  }
  
  deck.splice(0,5);
  
  // Update local playerState with the modified deck (deck is already a copy)
  playerState[key].deck = deck;
  
  // Defensive check: ensure decks are different before updating globalThis
  const otherKey = key === 'player1' ? 'player2' : 'player1';
  const otherDeck = playerState[otherKey].deck;
  if (otherDeck && deck.length > 0 && otherDeck.length > 0) {
    const deckStr = JSON.stringify(deck);
    const otherDeckStr = JSON.stringify(otherDeck);
    if (deckStr === otherDeckStr) {
      console.error(`ERROR in drawStartingHandForPlayer: ${key} deck is identical to ${otherKey} deck!`, {
        key,
        deckFirstCard: deck[0]?.name,
        otherDeckFirstCard: otherDeck[0]?.name,
        deckLength: deck.length,
        otherDeckLength: otherDeck.length
      });
    }
  }
  
  // Update globalThis.playerState to ensure render functions have latest data
  // Create a deep copy to avoid reference issues
  if (globalThis.playerState) {
    globalThis.playerState[key].deck = [...deck];
    globalThis.playerState[key].hand = hand ? [...hand] : (globalThis.playerState[key].hand || []);
    
    // Final check: ensure globalThis.playerState decks are different
    const globalP1Deck = globalThis.playerState.player1.deck;
    const globalP2Deck = globalThis.playerState.player2.deck;
    if (globalP1Deck && globalP2Deck && globalP1Deck.length > 0 && globalP2Deck.length > 0) {
      if (JSON.stringify(globalP1Deck) === JSON.stringify(globalP2Deck)) {
        console.error('ERROR: globalThis.playerState decks became identical after update!', {
          key,
          p1DeckFirst: globalP1Deck[0]?.name,
          p2DeckFirst: globalP2Deck[0]?.name
        });
      }
    }
  } else {
    globalThis.playerState = {
      player1: {
        deck: playerState.player1.deck ? [...playerState.player1.deck] : [],
        hand: playerState.player1.hand ? [...playerState.player1.hand] : [],
        energyTypes: playerState.player1.energyTypes ? [...playerState.player1.energyTypes] : [],
        currentTurnEnergy: playerState.player1.currentTurnEnergy,
        nextTurnEnergy: playerState.player1.nextTurnEnergy,
        discard: playerState.player1.discard || { cards: [], energyCounts: {} }
      },
      player2: {
        deck: playerState.player2.deck ? [...playerState.player2.deck] : [],
        hand: playerState.player2.hand ? [...playerState.player2.hand] : [],
        energyTypes: playerState.player2.energyTypes ? [...playerState.player2.energyTypes] : [],
        currentTurnEnergy: playerState.player2.currentTurnEnergy,
        nextTurnEnergy: playerState.player2.nextTurnEnergy,
        discard: playerState.player2.discard || { cards: [], energyCounts: {} }
      }
    };
  }
  
  // Sync to Firebase if requested
  if (syncToFirebase && window.firebaseDatabase && updateGameStatePartial) {
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    const isP1 = isCurrentPlayer1Fn ? isCurrentPlayer1Fn() : false;
    // Map UI player to match player
    const matchPlayerKey = (isP1 && key === 'player1') || (!isP1 && key === 'player2') 
      ? 'player1' 
      : 'player2';
    
    try {
        firstCard: deck[0]?.name,
        // Syncing deck and hand to Firebase
      await updateGameStatePartial({
        [`${matchPlayerKey}/deck`]: [...deck], // Ensure we sync a copy
        [`${matchPlayerKey}/hand`]: [...hand]  // Ensure we sync a copy
      });
    } catch (error) {
      console.error('Error syncing hand draw:', error);
    }
  }
  
  // Get the correct hand div - handle jQuery objects
  let handDiv = key === 'player1' ? p1HandDiv : p2HandDiv;
  if (handDiv && handDiv.jquery) handDiv = handDiv[0];
  if (!handDiv) handDiv = document.getElementById(key === 'player1' ? 'p1Hand' : 'p2Hand');
  
  // Verify we have the correct div
  const expectedId = key === 'player1' ? 'p1Hand' : 'p2Hand';
  if (handDiv && handDiv.id !== expectedId) {
    console.error(`ERROR: Wrong hand div for ${key}! Expected ${expectedId}, got ${handDiv.id}`);
  }
  
    // Hand div verified
  
  const animationPromises = [];
  for (let i = 0; i < 5; i++) {
    const delay = i * 200; 
    animationPromises.push(
      new Promise(resolve => {
        setTimeout(async () => {
          const animCard = await animateCardDraw(key, handDiv, hand[i], i, 5); 
          resolve(animCard); 
        }, delay);
      })
    );
  }
  
  
  const animatedCards = await Promise.all(animationPromises);
  
  
  playerState[key].hand = hand;
  
  // Update globalThis.playerState hand as well - ensure we create a deep copy
  if (globalThis.playerState) {
    globalThis.playerState[key].hand = hand ? hand.map(c => ({...c})) : [];
  }
  
  updateDeckBubbles();
  updateHandBubbles();
  
  
  // Return a promise that resolves when the animation cleanup is complete
  return new Promise((resolve) => {
  requestAnimationFrame(() => {
    
    let targetWidth = 69.27; 
    let targetHeight = 96.47; 
    
    
    animatedCards.forEach(animCard => {
      if (animCard && animCard.parentNode) {
        
        const currentWidth = parseFloat(animCard.style.width) || 69.27;
        const currentHeight = parseFloat(animCard.style.height) || 96.47;
        
        
        const scaleX = targetWidth / currentWidth;
        const scaleY = targetHeight / currentHeight;
        
        
        void animCard.offsetWidth;
        
        
        animCard.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out, width 0.3s ease-out, height 0.3s ease-out';
        animCard.style.transform = `perspective(700px) rotateX(3deg) scale(${scaleX}, ${scaleY})`;
        animCard.style.opacity = '0';
        animCard.style.width = `${targetWidth}px`;
        animCard.style.height = `${targetHeight}px`;
      }
    });
    
    
    setTimeout(() => {
        // Remove ALL animated cards from the entire document, not just the ones from this function
        // This ensures we don't have leftover animated cards from other draws
        const allAnimatedCards = document.querySelectorAll('[data-animated-card="true"]');
        allAnimatedCards.forEach(card => {
          if (card && card.parentNode) {
            card.remove();
          }
        });
        
        // Also remove the specific animated cards from this draw
      animatedCards.forEach(animCard => {
        if (animCard && animCard.parentNode) {
          animCard.remove();
        }
      });
        
        // Force a reflow to ensure DOM updates are complete
        void document.body.offsetHeight;
        
        // Ensure globalThis.playerState is up to date
        if (globalThis.playerState) {
          // Update both hands to ensure we have the latest data
          if (playerState.player1?.hand) {
            globalThis.playerState.player1.hand = playerState.player1.hand.map(c => ({...c}));
          }
          if (playerState.player2?.hand) {
            globalThis.playerState.player2.hand = playerState.player2.hand.map(c => ({...c}));
          }
        }
        
        // Resolve the promise to indicate this animation is complete
        resolve();
    }, 300);
    });
  });
  
  
  const remainingAnimatedCards = document.querySelectorAll('[data-animated-card="true"]');
  if (remainingAnimatedCards.length > 0) {
    remainingAnimatedCards.forEach(card => {
      if (card && card.parentNode) {
        
        void card.offsetWidth;
        card.style.transition = 'opacity 0.3s ease-out';
        card.style.opacity = '0';
        setTimeout(() => {
          if (card.parentNode) {
            card.remove();
          }
        }, 300);
      }
    });
  }
}


function flipCoin(){
  coinEl.classList.add('flip');

  const res = Math.random() < 0.5 ? 'player1' : 'player2';
  const front = coinEl.querySelector('.front');
  const back  = coinEl.querySelector('.back');

  setTimeout(async () => {
    coinEl.classList.remove('flip');

    if (res === 'player1') {
      front.style.transform = 'rotateY(0deg)';
      back.style.transform  = 'rotateY(180deg)';
    } else {
      front.style.transform = 'rotateY(180deg)';
      back.style.transform  = 'rotateY(0deg)';
    }

    firstPlayer   = res;
    currentPlayer = res;
    globalThis.firstPlayer = res;
    
    // Sync coin flip result to Firebase for online matches
    const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
    const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
    const isOnline = matchId && window.firebaseDatabase;
    if (isOnline) {
      const updateGameStatePartialFn = updateGameStatePartial || globalThis.updateGameStatePartial;
      if (updateGameStatePartialFn) {
        try {
          // Map UI player to match player
          const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
          const isP1 = isCurrentPlayer1Fn ? isCurrentPlayer1Fn() : false;
          // In match terms: if UI player1 won, and current user is player1 in match, then match player1 won
          // If UI player1 won, and current user is player2 in match, then match player2 won
          const matchFirstPlayer = (isP1 && res === 'player1') || (!isP1 && res === 'player2') 
            ? 'player1' 
            : 'player2';
          
          await updateGameStatePartialFn({
            'firstPlayer': matchFirstPlayer
          });
          console.log('Coin flip result synced successfully');
        } catch (error) {
          console.error('Error syncing coin flip:', error);
        }
      }
    }
    
    const firstState = playerState[res];
    const firstEnergyTypes = firstState.energyTypes || [];
    if (firstEnergyTypes.length > 1) {
      firstState.currentTurnEnergy = selectRandomEnergy(firstEnergyTypes);
      firstState.nextTurnEnergy = selectRandomEnergy(firstEnergyTypes);
    } else if (firstEnergyTypes.length === 1) {
      firstState.currentTurnEnergy = firstEnergyTypes[0];
      firstState.nextTurnEnergy = firstEnergyTypes[0];
    }
    
    
    const otherPlayer = res === 'player1' ? 'player2' : 'player1';
    const otherState = playerState[otherPlayer];
    const otherEnergyTypes = otherState.energyTypes || [];
    if (otherEnergyTypes.length > 1) {
      otherState.currentTurnEnergy = selectRandomEnergy(otherEnergyTypes);
      otherState.nextTurnEnergy = selectRandomEnergy(otherEnergyTypes);
    } else if (otherEnergyTypes.length === 1) {
      otherState.currentTurnEnergy = otherEnergyTypes[0];
      otherState.nextTurnEnergy = otherEnergyTypes[0];
    }

    // Show perspective-based message
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    const isP1 = isCurrentPlayer1Fn ? isCurrentPlayer1Fn() : false;
    const isGoingFirst = (isP1 && res === 'player1') || (!isP1 && res === 'player2');
    coinResult.textContent = isGoingFirst ? 'You are going first!' : 'Your opponent is going first!';
    showPopup(isGoingFirst ? 'You are going first!' : 'Your opponent is going first!');

    logEvent({
      player: res,
      text:`Won the coin flip and goes first.`
    });

    updateTurnBox();
    renderEnergyZone();
    
    
    (globalThis.updateDeckStack || updateDeckStack)('player1');
    (globalThis.updateDeckStack || updateDeckStack)('player2');

    // Automatically draw starting hands after coin flip
    // Reuse getCurrentMatchIdFn, matchId, and isOnline from above
    
    if (isOnline) {
      // For online play, only the first player (player1 in match) should trigger
      const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
      const isP1 = isCurrentPlayer1Fn ? isCurrentPlayer1Fn() : false;
      
      if (isP1) {
        // Draw ONLY the host's own hand (player1), not the opponent's
        // The opponent (joiner) will draw their own hand when they receive the game state
        // Verify decks are different before drawing
        const p1DeckFirst = playerState.player1.deck[0]?.name;
        const p2DeckFirst = playerState.player2.deck[0]?.name;
        // Verify decks are different before drawing
        if (JSON.stringify(playerState.player1.deck) === JSON.stringify(playerState.player2.deck)) {
          console.error('ERROR: Both players have the same deck before drawing hands!');
        }
        isDrawingHands = true; // Set flag to prevent onStateChange from interfering
        // Only draw the host's own hand
        drawStartingHandForPlayer('player1', true).then(() => {
          // Animation complete, now render once
          // Remove ALL animated cards first (in case any remain)
          const allAnimatedCards = document.querySelectorAll('[data-animated-card="true"]');
          allAnimatedCards.forEach(card => {
            if (card && card.parentNode) {
              card.remove();
            }
          });
          
          // Force a reflow
          void document.body.offsetHeight;
          
          // Ensure globalThis.playerState is fully updated
          if (globalThis.playerState) {
            if (playerState.player1?.hand) {
              globalThis.playerState.player1.hand = playerState.player1.hand.map(c => ({...c}));
            }
            // Note: player2 hand will be drawn by the joiner when they receive the game state
          }
          
          // Hands drawn
          
          // Ensure isSetupPhase is set on globalThis for render function
          isSetupPhase = true;
          globalThis.isSetupPhase = true;
          
          // Use requestAnimationFrame to ensure rendering happens after all state updates
          requestAnimationFrame(() => {
            // Ensure globalThis.playerState is fully synced before rendering
            if (globalThis.playerState) {
              if (playerState.player1?.hand) {
                globalThis.playerState.player1.hand = playerState.player1.hand.map(c => ({...c}));
              }
              if (playerState.player2?.hand) {
                globalThis.playerState.player2.hand = playerState.player2.hand.map(c => ({...c}));
              }
            }
            
          renderAllHands();
            
            // Verify the rendering was correct
            const p1HandDiv = document.getElementById('p1Hand');
            const p2HandDiv = document.getElementById('p2Hand');
            if (p1HandDiv && p2HandDiv) {
              const p1Cards = Array.from(p1HandDiv.querySelectorAll('.card-img')).map(img => img.alt);
              const p2Cards = Array.from(p2HandDiv.querySelectorAll('.card-img')).map(img => img.alt);
              if (JSON.stringify(p1Cards) === JSON.stringify(p2Cards) && p1Cards.length > 0) {
                console.error('ERROR: After renderAllHands, both hands show the same cards!', {
                  p1Cards,
                  p2Cards,
                  playerStateP1Hand: playerState.player1.hand?.map(c => c?.name),
                  playerStateP2Hand: playerState.player2.hand?.map(c => c?.name),
                  globalThisP1Hand: globalThis.playerState?.player1?.hand?.map(c => c?.name),
                  globalThisP2Hand: globalThis.playerState?.player2?.hand?.map(c => c?.name)
                });
              }
            }
            
            // Clear the flag after a longer delay to allow rendering to complete and prevent onStateChange from interfering
            setTimeout(() => {
              isDrawingHands = false;
            }, 500);
          });
          
          if (mainButton) {
            mainButton.textContent = 'Start Game';
          }
          showPopup('Choose Active & Benched Pokmon');
        });
      }
    } else {
      // Local play - draw for both players
      Promise.all([
        drawStartingHandForPlayer('player1', false),
        drawStartingHandForPlayer('player2', false)
      ]).then(() => {
        // Hands drawn (local play)
        
        // Ensure isSetupPhase is set on globalThis for render function
        isSetupPhase = true;
        globalThis.isSetupPhase = true;
        renderAllHands();
        if (mainButton) {
          mainButton.textContent = 'Start Game';
        }
        showPopup('Choose Active & Benched Pokmon');
      });
    }

    // Keep isSetupPhase true until "Start Game" is clicked
    // isSetupPhase will be set to false when game actually starts
  }, 1500);
}

document.body.addEventListener('contextmenu', async e => {
  const handImgEl = e.target.closest('.hand img');

  
  if (handImgEl) {
    e.preventDefault();

    const set = handImgEl.dataset.set;
    const num = handImgEl.dataset.num;

    try {
      const meta = await fetchCardMeta(set, num);
      const category = (meta.category || '').toLowerCase();

      if (handBackdrop && handImg) {
        handImg.src = handImgEl.src;
        handBackdrop.classList.add('show');
        handTitle.textContent = meta.name || 'Card';
      }

      if (category === 'pokemon') {
        if (handBackdrop) handBackdrop.classList.remove('show');

        zoomImg.src = handImgEl.src;
        zoomBackdrop.classList.add('show');

        await buildZoomPanel(meta, handImgEl);
        zoomAttacks.querySelectorAll('.zoom-attack').forEach(a => a.classList.add('muted'));
        document.getElementById('zoomRetreatRow')?.classList.add('disabled');
      } else {
        if (handType) {
          handType.textContent = meta.trainerType || meta.category || 'Card';
          handType.style.background = trainerColor(meta.trainerType || meta.category);
        }
        if (handEffect) {
          handEffect.textContent = meta.effect || meta.description || 'No effect listed.';
        }
      }

    } catch {
      showPopup('No data available for this card.');
    }

    return;
  }

  
  const img = e.target.closest('.active img, .bench img');
  if (!img) return;

  e.preventDefault();

  zoomImg.src = img.src;
  zoomBackdrop.classList.add('show');

  try {
    const set = img.dataset.set;
    const num = img.dataset.num;
    const meta = await fetchCardMeta(set, num);
    await buildZoomPanel(meta, img);
  } catch {
    zoomTitle.textContent = 'Pokmon';
    zoomHp.textContent = '';
    zoomAttacks.innerHTML = '<div style="color:#cbd5e1">No data</div>';
    zoomEnergyCount.textContent = 'x0';
    zoomEnergyIcons.innerHTML = '';
    zoomWeakness.textContent = '';
    zoomRetreat.innerHTML = '';
    zoomTools.innerHTML = '<div class="chip">none</div>';
    zoomAbilities.style.display = 'none';
  }
});

if (zoomBackdrop) {
  zoomBackdrop.addEventListener('click', e => {
    console.log('[ZOOM-CLOSE] Click on zoom backdrop:', {
      target: e.target,
      isBackdrop: e.target === zoomBackdrop,
      isClosest: !!e.target.closest('.zoom-backdrop'),
      timestamp: new Date().toISOString()
    });
    
    if (e.target === zoomBackdrop || e.target.closest('.zoom-backdrop')) {
      console.log('[ZOOM-CLOSE] Closing zoom backdrop');
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      zoomBackdrop.classList.remove('show');
      currentZoom = { img: null, meta: null };
      console.log('[ZOOM-CLOSE] Zoom backdrop closed');
    }
  });

  document.addEventListener('keydown', e => {
    if (e.key === 'Escape' && zoomBackdrop.classList.contains('show')) {
      console.log('[ZOOM-CLOSE] Escape key pressed, closing zoom');
      e.stopPropagation();
      e.stopImmediatePropagation();
      zoomBackdrop.classList.remove('show');
      currentZoom = { img: null, meta: null };
      console.log('[ZOOM-CLOSE] Zoom backdrop closed via Escape');
    }
  });
}

if (p1DiscardBtn) p1DiscardBtn.onclick = () => {
  renderDiscard('player1');
  p1DiscardDrawer.classList.add('show');
  
  updateDiscardDrawerPositions();
};

if (p2DiscardBtn) p2DiscardBtn.onclick = () => {
  renderDiscard('player2');
  p2DiscardDrawer.classList.add('show');
  
  updateDiscardDrawerPositions();
};

function updateDiscardDrawerPositions() {
  const p1Open = p1DiscardDrawer?.classList.contains('show');
  const p2Open = p2DiscardDrawer?.classList.contains('show');
  
  if (p1Open && p2Open) {
    
    p1DiscardDrawer.style.transform = 'translateX(-340px)';
  } else if (p1Open) {
    
    p1DiscardDrawer.style.transform = 'translateX(0)';
  }
  
}

document.addEventListener('click', e => {
  if (p1DiscardDrawer?.classList.contains('show') &&
      !p1DiscardDrawer.contains(e.target) &&
      e.target !== p1DiscardBtn) {
    p1DiscardDrawer.classList.remove('show');
    updateDiscardDrawerPositions();
  }

  if (p2DiscardDrawer?.classList.contains('show') &&
      !p2DiscardDrawer.contains(e.target) &&
      e.target !== p2DiscardBtn) {
    p2DiscardDrawer.classList.remove('show');
    updateDiscardDrawerPositions();
  }
});

if (mainButton) mainButton.onclick = async () => {
  const label = mainButton.textContent;

  try {
    if (label === 'Flip Coin') {
      // Check if we're in an online match
      const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
      const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
      const isOnline = matchId && window.firebaseDatabase;
      
      if (isOnline) {
        // For online play, only the first player (player1 in match) should trigger
        const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
        const isP1 = isCurrentPlayer1Fn ? isCurrentPlayer1Fn() : false;
        
        if (!isP1) {
          showPopup('Waiting for opponent to flip coin...');
          return;
        }
      }
      
      flipCoin();

    } else if (label === 'Start Game') {
      if (!p1Active.querySelector('img') || !p2Active.querySelector('img')) {
        showPopup('Both players need an Active Pokmon.');
        return;
      }

      const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
      const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
      const isOnline = matchId && window.firebaseDatabase;
      
      if (isOnline) {
        // Online mode: mark this player as ready
        const updateGameStatePartialFn = updateGameStatePartial || globalThis.updateGameStatePartial;
        const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
        if (updateGameStatePartialFn) {
          try {
            const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
            const readyKey = isP1 ? 'player1Ready' : 'player2Ready';
            
            await updateGameStatePartialFn({
              [readyKey]: true
            });
            console.log('Marked player as ready:', readyKey);
            
            // Update button to show waiting state
            if (mainButton) {
              mainButton.textContent = 'Waiting for opponent...';
            }
            showPopup('Waiting for opponent to start game...');
          } catch (error) {
            console.error('Error marking player as ready:', error);
          }
        }
      } else {
        // Local mode: start immediately
      isSetupPhase = false;
      globalThis.isSetupPhase = false;

      // Reset currentPlayer so startTurn knows it's the first turn
      currentPlayer = null;
      globalThis.currentPlayer = null;
      
      // Ensure turn number is 1 for the first turn
      globalThis.turnNumber = 1;

      // Start the first turn for the player who won the coin flip
      if (firstPlayer) {
        startTurn(firstPlayer);
      }
      mainButton.textContent = 'End Turn';
      }

    } else {
      // "End Turn" button - check if it's the current player's turn
      const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
      const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
      const isOnline = matchId && window.firebaseDatabase;
      
      // First check if button is disabled
      if (mainButton && mainButton.disabled) {
        console.log('Turn end blocked - button is disabled:', {
          currentPlayer,
          buttonText: mainButton?.textContent,
          buttonDisabled: mainButton.disabled
        });
        showPopup('Not your turn!');
        return;
      }
      
      if (isOnline) {
        // currentPlayer is in UI terms, and UI player1 is always "you" (bottom)
        // So if currentPlayer === 'player1', it's always the current user's turn
        // Strictly check currentPlayer - don't rely on button text as it might be stale
        const isMyTurn = currentPlayer === 'player1';
        if (!isMyTurn) {
          console.log('Turn end blocked - not current player:', {
            currentPlayer,
            expected: 'player1',
            buttonText: mainButton?.textContent,
            buttonDisabled: mainButton?.disabled
          });
          showPopup('Not your turn!');
          return;
        }
        
        // Double-check that currentPlayer is set correctly
        if (!currentPlayer) {
          console.warn('currentPlayer is null when trying to end turn - this should not happen');
          showPopup('Turn state error - please refresh');
          return;
        }
      }
      
      const currentActiveImg = getActiveImage(currentPlayer);
      
      if (currentActiveImg) {
        const slot = currentActiveImg.closest('.card-slot');
        const tool = getToolDataFromSlot(slot);
        
        if (tool && tool.num === '067' && tool.set === 'A3b') {
          const maxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : parseInt(currentActiveImg.dataset.hp, 10);
          const curHp = parseInt(currentActiveImg.dataset.chp, 10);
          
          if (curHp < maxHp) {
            const healAmount = 10;
            const newHp = Math.min(maxHp, curHp + healAmount);
            currentActiveImg.dataset.chp = String(newHp);
            
            
            if (typeof setHpOnImage === 'function') {
              setHpOnImage(currentActiveImg, maxHp, newHp);
            }
            
            showPopup(`Leftovers: Healed 10 damage from ${currentActiveImg.alt}!`);
          }
        }
      }
      
      const currentPk = currentPlayer === 'player1' ? 'p1' : 'p2';
      
      if (typeof getAbilityRow === 'function' && typeof globalThis.applyAbilityEffectFromCsv === 'function') {
        try {
          if (currentActiveImg) {
            const abilityRow = await getAbilityRow(currentActiveImg.dataset.set, currentActiveImg.dataset.num);
            if (abilityRow?.effect_type === 'draw_card_end_of_turn') {
              const effectState = {
                p1: playerState.player1,
                p2: playerState.player2
              };
              await globalThis.applyAbilityEffectFromCsv(effectState, currentPk, abilityRow, {
                abilityPokemon: currentActiveImg
              });
            }
          }
        } catch (err) {
          console.error('[endTurn] draw_card_end_of_turn failed:', err);
        }
      }
      
      const next = currentPlayer === 'player1' ? 'player2' : 'player1';
      
      // Sync turn change to Firebase BEFORE starting the next turn
      if (isOnline) {
        const updateGameStatePartialFn = updateGameStatePartial || globalThis.updateGameStatePartial;
        const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
        if (updateGameStatePartialFn) {
          try {
            const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
            // Map UI player to match player for currentPlayer
            const matchCurrentPlayer = (isP1 && next === 'player1') || (!isP1 && next === 'player2') 
              ? 'player1' 
              : 'player2';
            
            // Increment turn number
            const newTurnNumber = (globalThis.turnNumber || 0) + 1;
            
            // Sync to Firebase FIRST
            await updateGameStatePartialFn({
              'currentPlayer': matchCurrentPlayer,
              'turnNumber': newTurnNumber
            });
            console.log('Synced turn change to Firebase:', {
              matchCurrentPlayer,
              newTurnNumber,
              uiNextPlayer: next
            });
            
            // Update local turn number AFTER sync
            globalThis.turnNumber = newTurnNumber;
          } catch (error) {
            console.error('Error syncing turn change:', error);
          }
        }
      } else {
        // Local mode: increment turn number and start turn immediately
        globalThis.turnNumber = (globalThis.turnNumber || 0) + 1;
      startTurn(next);
      }
      
      // In online mode, don't call startTurn here - let onStateChange handle it
      // when it receives the Firebase update. This ensures both players have the same turn number.
    }
  } catch (err) {
    console.error('Flow error:', err);
    showPopup('Setup error. Check decks.');
  }
};

if (playAgainBtn)
  playAgainBtn.addEventListener('click', () => {
    window.location.reload();
  });

if (chooseDecksBtn)
  chooseDecksBtn.addEventListener('click', () => {
    window.location.href = 'index.html';
  });

const victoryShowLogBtn = document.getElementById("victoryShowLogBtn");

if (victoryShowLogBtn) {
  victoryShowLogBtn.onclick = () => {
    if (!fullHistoryLog.length) {
      fullHistoryDiv.innerHTML = '<div class="match-log-entry">No actions logged.</div>';
    } else {
      fullHistoryDiv.innerHTML = fullHistoryLog.map(h => `
        <div class="match-log-entry">
          <div>
            <strong>#${h.id}</strong>  ${h.player} 
            <span style="opacity:.6">${h.ts}</span>
          </div>
          <div>${h.text}</div>
          ${
            h.imgUrl
              ? `<img class="log-thumb" src="${h.imgUrl}"
                  style="margin-top:6px;border-radius:6px;width:52px;height:auto;">`
              : ''
          }
        </div>
      `).join('');
    }
    historyBackdrop.classList.add('show');
  };
}

globalThis.selectPokemon = function (_st, pk, _z) {
  const area = pk === 'p1' ? p1Active : p2Active;
  const img  = area?.querySelector('img');
  if (!img) return null;

  return {
    name: img.alt,
    hp:   parseInt(img.dataset.chp || img.dataset.hp || '0', 10) || 0,
    maxHP: parseInt(img.dataset.hp || '0', 10) || 0
  };
};

globalThis.drawCards = async function (_st, pk, n) {
  const owner = pk === 'p1' ? 'player1' : 'player2';
  const drawCount = parseInt(n) || 0;
  const drawnCards = [];
  
  for (let i = 0; i < drawCount; i++) {
    if (playerState[owner].deck.length) {
      const drawnCard = playerState[owner].deck.shift();
      playerState[owner].hand.push(drawnCard);
      drawnCards.push(drawnCard);
    }
  }
  
  if (drawnCards.length > 0 && typeof logEvent === 'function') {
    for (const card of drawnCards) {
      logEvent({
        player: owner,
        text: `Drew ${card.name}`,
        cardSet: card.set,
        cardNum: card.number || card.num
      });
    }
  }
  
  // Sync globalThis.playerState with playerState
  if (globalThis.playerState && globalThis.playerState[owner]) {
    globalThis.playerState[owner].deck = [...playerState[owner].deck];
    globalThis.playerState[owner].hand = [...playerState[owner].hand];
  }
  
  // Sync to Firebase if in online mode
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
  if (isOnline && typeof updateGameStatePartial === 'function') {
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
    const matchOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2') 
      ? 'player1' 
      : 'player2';
    
    try {
      await updateGameStatePartial({
        [`${matchOwner}/deck`]: globalThis.playerState[owner].deck,
        [`${matchOwner}/hand`]: globalThis.playerState[owner].hand
      });
    } catch (error) {
      console.error('[drawCards] Error syncing to Firebase:', error);
    }
  }
  
  updateDeckBubbles();
  updateHandBubbles();
  updateDiscardBubbles();
  renderAllHands();
};

globalThis.shuffleIntoDeck = function (hand, deck) {
  if (!Array.isArray(hand) || !Array.isArray(deck)) return;

  deck.push(...hand);
  hand.length = 0;
  shuffle(deck);
  
  
  const owner = deck === playerState.player1.deck ? 'player1' : 'player2';
  animateDeckShuffle(owner);
};

globalThis.findPokemonByName = function (_st, name) {
  const imgs = $$('#player1 .active img, #player1 .bench img, ' +
                  '#player2 .active img, #player2 .bench img');
  const hit = imgs.find(i => i.alt === name);
  return hit ? { name } : null;
};

globalThis.discardPokemon = async function(pokemonImg, pk, givePoint = false) {
  if (!pokemonImg) return;
  
  const slot = pokemonImg.closest('.card-slot');
  if (!slot) return;
  
  const pokemonName = pokemonImg.alt || 'Pokemon';
  
  
  const owner = pk === 'p1' ? 'player1' : 'player2';
  
  
  const energyBox = slot.querySelector('.energy-pips');
  if (energyBox) energyBox.remove();
  
  const toolThumb = slot.querySelector('.tool-thumb');
  if (toolThumb) toolThumb.remove();
  
  const hpOverlay = slot.querySelector('.hp-overlay');
  if (hpOverlay) hpOverlay.remove();
  
  
  pokemonImg.remove();
  
  
  if (globalThis.markSlot) {
    globalThis.markSlot(slot, false);
  }
  
  
  if (givePoint) {
    const oppPk = pk === 'p1' ? 'p2' : 'p1';
    const oppOwner = oppPk === 'p1' ? 'player1' : 'player2';
    
    if (globalThis.incrementPoints) {
      globalThis.incrementPoints(oppOwner);
      showPopup(`${pokemonName} was knocked out! ${oppOwner === 'player1' ? 'Player 1' : 'Player 2'} takes a point!`);
    }
  }

};

globalThis.promoteFromBench = function (_st, oppKey, requireChoice = true) {
  const owner = oppKey === 'p1' ? 'player1' : 'player2';
  
  // In online mode, check if this is the current player's own Pokemon
  // If it's the opponent's Pokemon, don't trigger promotion flow here
  // (it will be handled by handleOpponentTrainer when the action is received)
  const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
  const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
  const isOnline = matchId && window.firebaseDatabase;
  
  if (isOnline) {
    const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
    const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
    // If owner is the opponent (not the current player), don't trigger promotion flow
    // The opponent will handle it when they receive the action
    const isCurrentPlayer = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2');
    if (!isCurrentPlayer) {
      // This is the opponent's Pokemon, don't trigger promotion flow on this side
      return true; // Return true to indicate the effect was "handled" (will be handled by opponent)
    }
  }
  
  const bench = owner === 'player1' ? p1Bench : p2Bench;
  const imgs  = bench.querySelectorAll('img');

  if (requireChoice && imgs.length === 0) return false;

  beginPromotionFlow(owner);
  showPopup(`${owner === 'player1' ? 'Player 1' : 'Player 2'} choose a Benched Pokmon to promote.`);
  return true;
};

globalThis.shuffle = shuffle;
globalThis.renderAllHands = renderAllHands;
globalThis.renderHand = renderHand;
globalThis.updateDeckBubbles = updateDeckBubbles;
globalThis.animateCardDraw = animateCardDraw;
globalThis.animateDeckShuffle = animateDeckShuffle;
globalThis.showPopup = showPopup;
globalThis.getToolDataFromSlot = getToolDataFromSlot;
globalThis.setHpOnImage = setHpOnImage;
// Initialize globalThis.playerState as a deep copy to avoid reference issues
globalThis.playerState = {
  player1: {
    deck: playerState.player1.deck ? [...playerState.player1.deck] : [],
    hand: playerState.player1.hand ? [...playerState.player1.hand] : [],
    energyTypes: playerState.player1.energyTypes ? [...playerState.player1.energyTypes] : [],
    currentTurnEnergy: playerState.player1.currentTurnEnergy,
    nextTurnEnergy: playerState.player1.nextTurnEnergy,
    discard: playerState.player1.discard || { cards: [], energyCounts: {} }
  },
  player2: {
    deck: playerState.player2.deck ? [...playerState.player2.deck] : [],
    hand: playerState.player2.hand ? [...playerState.player2.hand] : [],
    energyTypes: playerState.player2.energyTypes ? [...playerState.player2.energyTypes] : [],
    currentTurnEnergy: playerState.player2.currentTurnEnergy,
    nextTurnEnergy: playerState.player2.nextTurnEnergy,
    discard: playerState.player2.discard || { cards: [], energyCounts: {} }
  }
}; 

globalThis.animateCardToHand = animateCardToHand;

globalThis.addLog = function (pk, htmlText, _imgUrl, cardObj) {
  const owner = pk === 'p1' ? 'player1' : 'player2';

  logEvent({
    player: owner,
    text: htmlText,
    cardSet: cardObj?.set,
    cardNum: cardObj?.number || cardObj?.num
  });
};


function getActiveImg(pk) {
  const area = pk === 'p1' ? p1Active : p2Active;
  return area ? area.querySelector('img') : null;
}


function doCoinFlip(pk = null) {
  
  let isHeads = Math.random() < 0.5;
  
  if (pk && globalThis.state?.guaranteedHeads?.[pk]) {
    isHeads = true;
    
    globalThis.state.guaranteedHeads[pk] = false;
  }
  
  const resultStr = isHeads ? 'heads' : 'tails';

  try {
    if (coinEl) {
      const front = coinEl.querySelector('.front');
      const back  = coinEl.querySelector('.back');
      
      coinEl.classList.add('flip');

      setTimeout(() => {
        coinEl.classList.remove('flip');
        
        if (front && back) {
          if (isHeads) {
            front.style.transform = 'rotateY(0deg)';
            back.style.transform  = 'rotateY(180deg)';
          } else {
            front.style.transform = 'rotateY(180deg)';
            back.style.transform  = 'rotateY(0deg)';
          }
        }
        
        if (coinResult) {
          coinResult.textContent = isHeads ? "Heads" : "Tails";
        }
      }, 1500);
    }
  } catch (e) {
  }

  return resultStr; 
}

globalThis.doCoinFlip = doCoinFlip;

function flipCoinStatus() {
  return new Promise(resolve => {
    coinEl.classList.add('flip');

    const isHeads = Math.random() < 0.5;
    const front = coinEl.querySelector('.front');
    const back  = coinEl.querySelector('.back');

    setTimeout(() => {
      coinEl.classList.remove('flip');

      if (isHeads) {
        
        front.style.transform = 'rotateY(0deg)';
        back.style.transform  = 'rotateY(180deg)';
        coinResult.textContent = 'Heads';
      } else {
        
        front.style.transform = 'rotateY(180deg)';
        back.style.transform  = 'rotateY(0deg)';
        coinResult.textContent = 'Tails';
      }

      resolve(isHeads ? 'heads' : 'tails');
    }, 1500);
  });
}

async function visualCoinFlip(messagePrefix = "Flip") {
  return new Promise(resolve => {
    coinEl.classList.add("flip");

    const flip = Math.random() < 0.5 ? "heads" : "tails";

    setTimeout(() => {
      coinEl.classList.remove("flip");
      
      showPopup(`${messagePrefix}: ${flip.toUpperCase()}`);

      resolve(flip);
    }, 1500);
  });
}

function normalizeStatusName(name) {
  const n = String(name || '').toLowerCase().trim();
  if (!n) return '';

  if (n.startsWith('poison')) return 'poisoned';
  if (n.startsWith('sleep'))  return 'asleep';
  if (n.startsWith('burn'))   return 'burned';
  if (n.startsWith('para'))   return 'paralyzed';
  if (n.startsWith('conf'))   return 'confused';

  return n; 
}

function drawStatusIcon(img, key) {
  const slot = img.closest('.card-slot');
  if (!slot) return;

  let icon = slot.querySelector('.status-icon');
  if (!icon) {
    icon = document.createElement('div');
    icon.className = 'status-icon';
    slot.appendChild(icon);
  }

  const url = STATUS_ICON_URLS[key];
  if (url) {
    icon.style.backgroundImage = `url('${url}')`;
  } else {
    icon.style.backgroundImage = '';
  }
  
  if (currentZoom.img === img && zoomStatusIcon) {
    if (url) {
      zoomStatusIcon.style.display = 'inline-block';
      zoomStatusIcon.style.backgroundImage = `url('${url}')`;
    } else {
      zoomStatusIcon.style.display = 'none';
      zoomStatusIcon.style.backgroundImage = '';
    }
  }
}

function clearStatusOnImg(img) {
  if (!img) return;
  img.dataset.status = '';

  const slot = img.closest('.card-slot');
  if (slot) {
    const icon = slot.querySelector('.status-icon');
    if (icon) icon.remove();
  }
  
  if (currentZoom.img === img && zoomStatusIcon) {
    zoomStatusIcon.style.display = 'none';
    zoomStatusIcon.style.backgroundImage = '';
  }
}

function setStatus(pk, statusName) {
  const img = getActiveImg(pk);
  if (!img) return;
  
  if (img.dataset.statusProtected) {
    showPopup(`${img.alt} is protected from Special Conditions!`);
    return false;
  }

  const key = normalizeStatusName(statusName);
  if (!key) return;

  img.dataset.status = key;
  drawStatusIcon(img, key);
  return true;
}
globalThis.setStatus = setStatus;

function clearStatus(pk) {
  const img = getActiveImg(pk);
  clearStatusOnImg(img);
}

async function runStatusBetweenTurns() {
  for (const pk of ['p1', 'p2']) {
    const img = getActiveImg(pk);
    if (!img) continue;

    const status = (img.dataset.status || '').toLowerCase();
    if (!status) continue;

    const owner = pk === 'p1' ? 'player1' : 'player2';

    
    if (status === 'poisoned') {
      
      let poisonDamage = parseInt(img.dataset.heavyPoison || '10', 10);
      
      
      try {
        const allPokemon = [
          ...document.querySelectorAll('#player1 .card-img'),
          ...document.querySelectorAll('#player2 .card-img')
        ];
        
        for (const pokemon of allPokemon) {
          const cacheKey = `${pokemon.dataset.set}-${pokemon.dataset.num}`;
          const abilityRow = globalThis.abilityCache?.[cacheKey];
          
          if (abilityRow?.effect_type === 'increase_poison_damage') {
            const bonus = parseInt(abilityRow.param1 || '10', 10);
            poisonDamage += bonus;
          }
        }
      } catch (err) {
        console.error('[poison] More Poison check failed:', err);
      }
      
      const result = await damageActiveOf(owner, poisonDamage, { isDirectAttack: false });
      
      if (poisonDamage === 20 || poisonDamage > 10) {
        showPopup(`${img.alt || 'Active Pokmon'} took ${poisonDamage} damage from Poison!`);
      } else {
        showPopup(`${img.alt || 'Active Pokmon'} took ${poisonDamage} damage from Poison.`);
      }

      if (result.knocked) {
        const img2 = getActiveImage(owner);
        if (img2) {
          const ended = await handleKnockOut(owner, img2);
          if (ended) return;
          await beginPromotionFlow(owner);
        }
      }
    }

    
    if (status === 'burned') {
      const result = await damageActiveOf(owner, 20, { isDirectAttack: false });
      showPopup(`${img.alt || 'Active Pokmon'} took 20 damage from Burn.`);

      if (result.knocked) {
        const img2 = getActiveImage(owner);
        if (img2) {
          const ended = await handleKnockOut(owner, img2);
          if (ended) return;
          await beginPromotionFlow(owner);
        }
        continue;
      }

      const r = doCoinFlip();
      if (r === 'heads') {
        clearStatus(pk);
        showPopup('The burn was healed!');
      }
    }

    
  }
  
  
  for (const checkPk of ['p1', 'p2']) {
    const activeImg = getActiveImg(checkPk);
    if (!activeImg) continue;
    
    
    const cacheKey = `${activeImg.dataset.set}-${activeImg.dataset.num}`;
    const abilityRow = globalThis.abilityCache?.[cacheKey];
    
    if (abilityRow?.effect_type === 'damage_during_checkup') {
      const damage = parseInt(abilityRow.param1 || '10', 10);
      const oppPk = checkPk === 'p1' ? 'p2' : 'p1';
      const oppOwner = oppPk === 'p1' ? 'player1' : 'player2';

      const result = await damageActiveOf(oppOwner, damage, { isDirectAttack: false });
      showPopup(`${activeImg.alt}'s Snowy Terrain: ${damage} damage to opponent!`);
      
      if (result.knocked) {
        const oppImg = getActiveImage(oppOwner);
        if (oppImg) {
          const ended = await handleKnockOut(oppOwner, oppImg);
          if (ended) return;
          await beginPromotionFlow(oppOwner);
        }
      }
    }
  }
}

globalThis.setStatus  = setStatus;
globalThis.clearStatus = clearStatus;

updateDeckBubbles();
updateTurnBox();
updatePointsUI();
renderAllHands();

// Online Lobby UI Initialization
let currentLobbyMode = 'create';
let currentMatchId = null;

// Initialize energy grids
const MAX_ENERGIES = 3;
function initEnergyGrid(gridId) {
  const grid = document.getElementById(gridId);
  if (!grid) return;
  grid.innerHTML = '';
  Object.entries(ENERGY_ICONS).forEach(([type, url]) => {
    const div = document.createElement('div');
    div.className = 'energy-pip';
    div.dataset.type = type;
    div.style.cssText = 'width: 40px; height: 40px; border: 2px solid #3f444b; border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; background: #1e2227; transition: all 0.2s;';
    div.innerHTML = `<img src="${url}" alt="${type}" style="width: 32px; height: 32px;">`;
    grid.appendChild(div);
  });
  grid.addEventListener('click', e => {
    const pip = e.target.closest('.energy-pip');
    if (!pip) return;
    const selected = [...grid.querySelectorAll('.energy-pip.selected')];
    if (pip.classList.contains('selected')) {
      pip.classList.remove('selected');
      pip.style.borderColor = '#3f444b';
      pip.style.background = '#1e2227';
      return;
    }
    if (selected.length >= MAX_ENERGIES) {
      alert(`You can select up to ${MAX_ENERGIES} energy types.`);
      return;
    }
    pip.classList.add('selected');
    pip.style.borderColor = '#facc15';
    pip.style.background = '#3f444b';
  });
}

function getSelectedEnergies(gridId) {
  return [...document.querySelectorAll(`#${gridId} .energy-pip.selected`)].map(d => d.dataset.type);
}

// Initialize energy grids
initEnergyGrid('createRoomEnergyGrid');
initEnergyGrid('joinRoomEnergyGrid');
initEnergyGrid('quickMatchEnergyGrid');

// Deck parsing function
async function parseDeckForLobby(textareaId, energyGridId, statusId) {
  const textarea = document.getElementById(textareaId);
  const statusEl = document.getElementById(statusId);
  if (!textarea || !statusEl) return null;

  statusEl.textContent = 'Loading deck...';
  statusEl.style.color = '#9ca3af';

  try {
    const loadPocketSetsFn = loadPocketSets || globalThis.loadPocketSets;
    const parseDecklistFn = parseDecklist || globalThis.parseDecklist;
    const fetchCardDataFn = fetchCardData || globalThis.fetchCardData;
    
    if (!loadPocketSetsFn || !parseDecklistFn || !fetchCardDataFn) {
      throw new Error('Deck parsing functions not available');
    }
    
    await loadPocketSetsFn();
    let text = textarea.value.trim();

    // Detect Energy: line
    const energyMatch = text.match(/^\s*Energy:\s*(.+)$/im);
    let chosenEnergies = [];
    if (energyMatch) {
      const raw = energyMatch[1].split(/[,/]/).map(w => w.trim().toLowerCase());
      const valid = Object.keys(ENERGY_ICONS);
      chosenEnergies = raw.filter(w => valid.includes(w)).slice(0, MAX_ENERGIES);
      
      // Auto-select matching pips visually
      const grid = document.getElementById(energyGridId);
      if (grid) {
        [...grid.querySelectorAll('.energy-pip')].forEach(p => {
          const isSelected = chosenEnergies.includes(p.dataset.type);
          p.classList.toggle('selected', isSelected);
          p.style.borderColor = isSelected ? '#facc15' : '#3f444b';
          p.style.background = isSelected ? '#3f444b' : '#1e2227';
        });
      }
      
      text = text.replace(/^\s*Energy:\s*.+$/im, '').trim();
    }

    // Get selected energies from grid if not from text
    if (chosenEnergies.length === 0) {
      chosenEnergies = getSelectedEnergies(energyGridId);
    }

    if (chosenEnergies.length === 0) {
      statusEl.textContent = 'Please select at least one energy type';
      statusEl.style.color = '#f87171';
      return null;
    }

    const parsed = parseDecklistFn(text);
    if (!parsed.length) {
      statusEl.textContent = 'No valid cards found';
      statusEl.style.color = '#f87171';
      return null;
    }

    statusEl.textContent = `Loading ${parsed.length} cards...`;
    const fetchPromises = parsed.map(c => fetchCardDataFn(c));
    const results = await Promise.all(fetchPromises);

    const fetched = [];
    for (let i = 0; i < results.length; i++) {
      const card = results[i];
      if (card && card.name) {
        card.quantity = Number(parsed[i].quantity) || 1;
        fetched.push(card);
      }
    }

    const total = fetched.reduce((s, c) => s + (c.quantity || 0), 0);
    if (total !== 20) {
      statusEl.textContent = `Total: ${total} cards (expected 20)`;
      statusEl.style.color = '#fbbf24';
      return null;
    }

    statusEl.textContent = ' Deck ready!';
    statusEl.style.color = '#22c55e';
    return { deck: fetched, energy: chosenEnergies };
  } catch (error) {
    console.error('Error parsing deck:', error);
    statusEl.textContent = 'Error parsing deck: ' + error.message;
    statusEl.style.color = '#f87171';
    return null;
  }
}

const lobbyScreen = document.getElementById('lobbyScreen');
const lobbyError = document.getElementById('lobbyError');
const createRoomPanel = document.getElementById('createRoomPanel');
const joinRoomPanel = document.getElementById('joinRoomPanel');
const quickMatchPanel = document.getElementById('quickMatchPanel');
const createRoomTab = document.getElementById('createRoomTab');
const joinRoomTab = document.getElementById('joinRoomTab');
const quickMatchTab = document.getElementById('quickMatchTab');
const createRoomBtn = document.getElementById('createRoomBtn');
const joinRoomBtn = document.getElementById('joinRoomBtn');
const quickMatchBtn = document.getElementById('quickMatchBtn');
const cancelQuickMatchBtn = document.getElementById('cancelQuickMatchBtn');
const roomCodeInput = document.getElementById('roomCodeInput');
const roomCreatedInfo = document.getElementById('roomCreatedInfo');
const roomCodeDisplay = document.getElementById('roomCodeDisplay');
const roomStatus = document.getElementById('roomStatus');
const backToMenuBtn = document.getElementById('backToMenuBtn');
const connectionStatus = document.getElementById('connectionStatus');
const connectionDot = document.getElementById('connectionDot');
const connectionText = document.getElementById('connectionText');
const opponentInfo = document.getElementById('opponentInfo');
const opponentName = document.getElementById('opponentName');
const opponentStatusEl = document.getElementById('opponentStatus');

function switchLobbyMode(mode) {
  currentLobbyMode = mode;
  createRoomPanel.style.display = mode === 'create' ? 'block' : 'none';
  joinRoomPanel.style.display = mode === 'join' ? 'block' : 'none';
  quickMatchPanel.style.display = mode === 'quickmatch' ? 'block' : 'none';
  
  createRoomTab.style.background = mode === 'create' ? '#0074d9' : '#3f444b';
  joinRoomTab.style.background = mode === 'join' ? '#0074d9' : '#3f444b';
  quickMatchTab.style.background = mode === 'quickmatch' ? '#0074d9' : '#3f444b';
  
  lobbyError.textContent = '';
}

if (createRoomTab) createRoomTab.onclick = () => switchLobbyMode('create');
if (joinRoomTab) joinRoomTab.onclick = () => switchLobbyMode('join');
if (quickMatchTab) quickMatchTab.onclick = () => switchLobbyMode('quickmatch');

if (createRoomBtn) {
  createRoomBtn.onclick = async () => {
    lobbyError.textContent = '';
    try {
      const createRoomFn = createRoom || globalThis.createRoom;
      if (!createRoomFn) {
        throw new Error('createRoom function not available');
      }
      
      if (!window.firebaseDatabase) {
        throw new Error('Firebase Database not initialized. Please refresh the page.');
      }
      
      const getUserFn = getCurrentUser || globalThis.getCurrentUser;
      if (!getUserFn) {
        throw new Error('getCurrentUser function not available');
      }
      const user = getUserFn();
      if (!user) {
        throw new Error('You must be signed in to create a room');
      }
      
      // Parse deck before creating room
      const deckData = await parseDeckForLobby('createRoomDeckInput', 'createRoomEnergyGrid', 'createRoomDeckStatus');
      if (!deckData) {
        throw new Error('Please enter a valid 20-card deck and select energy types');
      }
      
      const result = await createRoomFn(deckData.deck, deckData.energy);
      roomCodeDisplay.textContent = result.roomCode;
      roomCreatedInfo.style.display = 'block';
      roomStatus.textContent = 'Waiting for opponent...';
      
      const onRoomChangeFn = onRoomChange || globalThis.onRoomChange;
      if (onRoomChangeFn) {
      onRoomChangeFn((room) => {
        if (room.player2Id && room.status === 'ready') {
          roomStatus.textContent = 'Opponent joined! Starting game...';
          // Only the room creator (player1) should start the game
          const getUserFn = getCurrentUser || globalThis.getCurrentUser;
          if (getUserFn) {
            const currentUser = getUserFn();
            if (currentUser && currentUser.uid === room.player1Id) {
              setTimeout(async () => {
                try {
                  const startGameFn = startGameFromRoom || globalThis.startGameFromRoom;
                  if (startGameFn) {
                    const matchId = await startGameFn();
                    currentMatchId = matchId;
                    await initializeGame(matchId);
                    lobbyScreen.style.display = 'none';
                  }
                } catch (error) {
                  console.error('Error starting game:', error);
                  lobbyError.textContent = error.message || 'Failed to start game';
                }
              }, 1000);
            }
          }
        } else if (room.status === 'in-progress' && room.matchId) {
          // Player 2: game was started by player 1
          currentMatchId = room.matchId;
          // Set player2's activeMatch
          const getUserFn = getCurrentUser || globalThis.getCurrentUser;
          if (getUserFn && window.firebaseDatabase) {
            const currentUser = getUserFn();
            if (currentUser) {
              import('./js/online/schema.js').then(({ DB_PATHS }) => {
                window.firebaseDatabase.ref(DB_PATHS.USER_ACTIVE_MATCH(currentUser.uid)).set(room.matchId).catch(err => {
                  console.warn('Failed to set activeMatch:', err);
                });
              }).catch(err => {
                console.warn('Failed to import schema:', err);
              });
            }
          }
          initializeGame(room.matchId).then(() => {
            lobbyScreen.style.display = 'none';
          }).catch(error => {
            console.error('Error initializing game:', error);
            lobbyError.textContent = error.message || 'Failed to start game';
          });
        }
      });
      }
    } catch (error) {
      console.error('Error creating room:', error);
      lobbyError.textContent = error.message || 'Failed to create room';
    }
  };
}

if (joinRoomBtn) {
  joinRoomBtn.onclick = async () => {
    lobbyError.textContent = '';
    const code = roomCodeInput.value.trim().toUpperCase();
    
    if (!code || code.length !== 6) {
      lobbyError.textContent = 'Please enter a valid 6-character room code';
      return;
    }
    
    try {
      const joinRoomFn = joinRoomByCode || globalThis.joinRoomByCode;
      if (!joinRoomFn) {
        throw new Error('joinRoomByCode function not available');
      }
      
      if (!window.firebaseDatabase) {
        throw new Error('Firebase Database not initialized. Please refresh the page.');
      }
      
      const userFn = getCurrentUser || globalThis.getCurrentUser;
      if (!userFn || !userFn()) {
        throw new Error('You must be signed in to join a room');
      }
      
      // Parse deck before joining room
      const deckData = await parseDeckForLobby('joinRoomDeckInput', 'joinRoomEnergyGrid', 'joinRoomDeckStatus');
      if (!deckData) {
        throw new Error('Please enter a valid 20-card deck and select energy types');
      }
      
      const result = await joinRoomFn(code, deckData.deck, deckData.energy);
      roomStatus.textContent = 'Joined room! Starting game...';
      
      const onRoomChangeFn = onRoomChange || globalThis.onRoomChange;
      if (onRoomChangeFn) {
        onRoomChangeFn((room) => {
          if (room.status === 'in-progress' && room.matchId) {
            currentMatchId = room.matchId;
            initializeGame(room.matchId).then(() => {
              lobbyScreen.style.display = 'none';
            }).catch(error => {
              console.error('Error initializing game:', error);
              const errorHandler = handleError || globalThis.handleError;
              if (errorHandler) {
                errorHandler(error, { context: 'joining game' });
              } else {
                lobbyError.textContent = error.message || 'Failed to start game';
              }
            });
          }
        });
      }
    } catch (error) {
      console.error('Error joining room:', error);
      lobbyError.textContent = error.message || 'Failed to join room';
    }
  };
}

if (quickMatchBtn) {
  quickMatchBtn.onclick = async () => {
    lobbyError.textContent = '';
    try {
      const joinQueueFn = joinQueue || globalThis.joinQueue;
      if (!joinQueueFn) {
        throw new Error('joinQueue function not available');
      }
      
      if (!window.firebaseDatabase) {
        throw new Error('Firebase Database not initialized. Please refresh the page.');
      }
      
      const user = getCurrentUser || globalThis.getCurrentUser;
      if (!user || !user()) {
        throw new Error('You must be signed in to use quick match');
      }
      
      // Parse deck before joining queue
      const deckData = await parseDeckForLobby('quickMatchDeckInput', 'quickMatchEnergyGrid', 'quickMatchDeckStatus');
      if (!deckData) {
        throw new Error('Please enter a valid 20-card deck and select energy types');
      }
      
      await joinQueueFn(deckData.deck, deckData.energy);
      quickMatchBtn.style.display = 'none';
      cancelQuickMatchBtn.style.display = 'block';
      document.getElementById('quickMatchStatus').textContent = 'Searching for opponent...';
      
      const onQueueUpdateFn = onQueueUpdate || globalThis.onQueueUpdate;
      if (onQueueUpdateFn) {
        onQueueUpdateFn((update) => {
          if (update.type === 'match_found') {
            currentMatchId = update.matchId;
            initializeGame(update.matchId).then(() => {
              lobbyScreen.style.display = 'none';
            }).catch(error => {
              console.error('Error starting game:', error);
              lobbyError.textContent = error.message || 'Failed to start game';
            });
          }
        });
      }
    } catch (error) {
      console.error('Error joining queue:', error);
      lobbyError.textContent = error.message || 'Failed to join queue';
    }
  };
}

if (cancelQuickMatchBtn) {
  cancelQuickMatchBtn.onclick = async () => {
    try {
      await leaveQueue();
      quickMatchBtn.style.display = 'block';
      cancelQuickMatchBtn.style.display = 'none';
      document.getElementById('quickMatchStatus').textContent = 'Click to find an opponent';
    } catch (error) {
      lobbyError.textContent = error.message || 'Failed to leave queue';
    }
  };
}

if (backToMenuBtn) {
  backToMenuBtn.onclick = () => {
    window.location.href = 'index.html';
  };
}

async function initializeGame(matchId) {
  const getUserFn = getCurrentUser || globalThis.getCurrentUser;
  if (!getUserFn) {
    throw new Error('getCurrentUser function not available');
  }
  const user = getUserFn();
  if (!user) {
    throw new Error('Not authenticated');
  }
  
  try {
    const initSyncFn = initSync || globalThis.initSync;
    if (!initSyncFn) {
      throw new Error('initSync function not available');
    }
    await initSyncFn(matchId, user.uid);
    
    // Set up reconnection handler
    setupReconnectionHandler();
    
    // Set up turn listener
    setupTurnListener();
    
    onConnectionChange((connected) => {
      if (connectionStatus) {
        connectionStatus.style.display = 'block';
        if (connected) {
          connectionDot.style.background = '#22c55e';
          connectionText.textContent = 'Connected';
        } else {
          connectionDot.style.background = '#f87171';
          connectionText.textContent = 'Disconnected';
        }
      }
    });
    
    // Listen for opponent presence
    import('./js/online/sync.js').then(module => {
      if (module.onPresenceChange) {
        module.onPresenceChange((presence) => {
          if (opponentStatusEl) {
            if (presence.online) {
              opponentStatusEl.textContent = 'Online';
              opponentStatusEl.style.color = '#22c55e';
            } else {
              opponentStatusEl.textContent = 'Offline';
              opponentStatusEl.style.color = '#f87171';
              handleOpponentDisconnected();
            }
          }
        });
      }
    });
    
    if (window.firebaseDatabase) {
      const matchRef = window.firebaseDatabase.ref(`matches/${matchId}`);
      matchRef.once('value').then(snapshot => {
        const match = snapshot.val();
        if (!match) {
          handleMatchNotFound();
          return;
        }
        
        // Determine if current user is player1 in the match
        const isCurrentUserPlayer1 = match.player1Id === user.uid;
        
        // Load decks from match gameState
        // The onStateChange handler will handle the player1/player2 mapping based on isPlayer1
        // So we just need to wait for the first state update, but we can initialize decks here
        if (match.gameState) {
          // Store the initial game state - onStateChange will properly map it
          // For now, just ensure decks are loaded (they'll be properly mapped by onStateChange)
          if (match.gameState.player1 && match.gameState.player1.deck) {
            // We'll let onStateChange handle the mapping, but initialize here
            // Initializing decks from match
            if (isCurrentUserPlayer1) {
              playerState.player1.deck = [...match.gameState.player1.deck];
              playerState.player1.energyTypes = [...(match.gameState.player1.energyTypes || [])];
              playerState.player2.deck = [...(match.gameState.player2?.deck || [])];
              playerState.player2.energyTypes = [...(match.gameState.player2?.energyTypes || [])];
              // Decks initialized for player1 (match)
            } else {
              // Current user is player2 in match, so swap the decks
              playerState.player1.deck = [...(match.gameState.player2?.deck || [])];
              playerState.player1.energyTypes = [...(match.gameState.player2?.energyTypes || [])];
              playerState.player2.deck = [...match.gameState.player1.deck];
              playerState.player2.energyTypes = [...(match.gameState.player1.energyTypes || [])];
              // Decks initialized for player2 (match, swapped)
            }
          }
          
          // Initialize energy for both players
          function selectRandomEnergy(energyTypes) {
            if (!energyTypes || energyTypes.length === 0) return null;
            if (energyTypes.length === 1) return energyTypes[0];
            return energyTypes[Math.floor(Math.random() * energyTypes.length)];
          }
          
          if (playerState.player1.energyTypes.length > 0) {
            playerState.player1.currentTurnEnergy = selectRandomEnergy(playerState.player1.energyTypes);
            playerState.player1.nextTurnEnergy = selectRandomEnergy(playerState.player1.energyTypes);
          }
          if (playerState.player2.energyTypes.length > 0) {
            playerState.player2.currentTurnEnergy = selectRandomEnergy(playerState.player2.energyTypes);
            playerState.player2.nextTurnEnergy = selectRandomEnergy(playerState.player2.energyTypes);
          }
          
          // Update UI
          updateDeckBubbles();
          updateDeckStack('player1');
          updateDeckStack('player2');
        }
        
        const opponentId = isCurrentUserPlayer1 ? match.player2Id : match.player1Id;
        const opponentRef = window.firebaseDatabase.ref(`users/${opponentId}/profile`);
        opponentRef.once('value').then(opponentSnapshot => {
          const opponentProfile = opponentSnapshot.val();
          if (opponentProfile && opponentInfo) {
            opponentInfo.style.display = 'block';
            opponentName.textContent = opponentProfile.displayName || 'Opponent';
          }
        }).catch(error => {
          handleError(error, { context: 'loading opponent profile' });
        });
        
        // Listen for game end
        matchRef.child('status').on('value', (statusSnapshot) => {
          const status = statusSnapshot.val();
          if (status === 'finished') {
            matchRef.once('value').then(finishedMatch => {
              const finished = finishedMatch.val();
              if (finished && finished.winner) {
                import('./js/online/error-handler.js').then(module => {
                  if (module.handleGameEnded) {
                    module.handleGameEnded(finished.winner);
                  }
                });
              }
            });
          }
        });
      }).catch(error => {
        handleError(error, { context: 'loading match' });
      });
    }
    
    let handsDrawn = false;
    onStateChange((gameState, isPlayer1) => {
      if (gameState) {
        // Map match player1/player2 to UI player1/player2
        // If current user is player1 in match: match.player1 -> UI.player1, match.player2 -> UI.player2
        // If current user is player2 in match: match.player1 -> UI.player2, match.player2 -> UI.player1
        if (isPlayer1) {
          // Current user is player1 in match
          if (gameState.player1) {
            if (gameState.player1.deck && Array.isArray(gameState.player1.deck)) {
              const newDeck = [...gameState.player1.deck];
              // Only update if different to avoid unnecessary overwrites
              const oldDeckStr = JSON.stringify(playerState.player1.deck);
              const newDeckStr = JSON.stringify(newDeck);
              if (oldDeckStr !== newDeckStr) {
                // Updating player1 deck from Firebase
                playerState.player1.deck = newDeck;
              } else {
                // Skipping player1 deck update (already correct)
              }
            }
            if (gameState.player1.hand && Array.isArray(gameState.player1.hand)) {
              // Don't update hands if we're currently drawing them
              if (!isDrawingHands) {
                const newHand = [...gameState.player1.hand];
                const oldHand = playerState.player1.hand || [];
                const oldHandStr = JSON.stringify(oldHand);
                const newHandStr = JSON.stringify(newHand);
                if (oldHandStr !== newHandStr) {
                  // Updating player1 hand from Firebase
                playerState.player1.hand = newHand;
                
                // Immediately update globalThis.playerState to ensure render functions have latest data
                if (globalThis.playerState) {
                  globalThis.playerState.player1.hand = newHand.map(c => ({...c}));
                }
                
                // Verify we didn't accidentally make both hands the same
                const p2Hand = playerState.player2.hand || [];
                if (JSON.stringify(newHand) === JSON.stringify(p2Hand) && newHand.length > 0) {
                  console.error('ERROR: After updating player1 hand, both hands became identical!', {
                    player1Hand: newHand.map(c => c?.name),
                    player2Hand: p2Hand.map(c => c?.name)
                  });
                }
                } else {
                  // Skipping player1 hand update (already correct)
                }
              } else {
                // Skipping player1 hand update (hands are being drawn)
              }
            }
            if (gameState.player1.energyTypes) playerState.player1.energyTypes = [...(gameState.player1.energyTypes || [])];
            if (gameState.player1.discard) playerState.player1.discard = gameState.player1.discard;
          }
          if (gameState.player2) {
            if (gameState.player2.deck && Array.isArray(gameState.player2.deck)) {
              const newDeck = [...gameState.player2.deck];
              // Only update if different to avoid unnecessary overwrites
              const oldDeckStr = JSON.stringify(playerState.player2.deck);
              const newDeckStr = JSON.stringify(newDeck);
              if (oldDeckStr !== newDeckStr) {
                // Updating player2 deck from Firebase
                playerState.player2.deck = newDeck;
              } else {
                // Skipping player2 deck update (already correct)
              }
            }
            if (gameState.player2.hand && Array.isArray(gameState.player2.hand)) {
              // Don't update hands if we're currently drawing them
              if (!isDrawingHands) {
                const newHand = [...gameState.player2.hand];
                const oldHand = playerState.player2.hand || [];
                const oldHandStr = JSON.stringify(oldHand);
                const newHandStr = JSON.stringify(newHand);
                if (oldHandStr !== newHandStr) {
                  // Updating player2 hand from Firebase
                  playerState.player2.hand = newHand;
                  
                  // Immediately update globalThis.playerState to ensure render functions have latest data
                  if (globalThis.playerState) {
                    globalThis.playerState.player2.hand = newHand.map(c => ({...c}));
                  }
                  
                  // Verify we didn't accidentally make both hands the same
                  const p1Hand = playerState.player1.hand || [];
                  if (JSON.stringify(newHand) === JSON.stringify(p1Hand) && newHand.length > 0) {
                    console.error('ERROR: After updating player2 hand, both hands became identical!', {
                      player1Hand: p1Hand.map(c => c?.name),
                      player2Hand: newHand.map(c => c?.name)
                    });
                  }
                } else {
                  // Skipping player2 hand update (already correct)
                }
              } else {
                // Skipping player2 hand update (hands are being drawn)
              }
            }
            if (gameState.player2.energyTypes) playerState.player2.energyTypes = [...(gameState.player2.energyTypes || [])];
            if (gameState.player2.discard) playerState.player2.discard = gameState.player2.discard;
          }
        } else {
          // Current user is player2 in match, so swap
          if (gameState.player1) {
            if (gameState.player1.deck && Array.isArray(gameState.player1.deck)) {
              const newDeck = [...gameState.player1.deck];
              // Only update if different to avoid unnecessary overwrites
              const oldDeckStr = JSON.stringify(playerState.player2.deck);
              const newDeckStr = JSON.stringify(newDeck);
              if (oldDeckStr !== newDeckStr) {
                // Updating player2 deck from Firebase (swapped)
                playerState.player2.deck = newDeck;
                // Check if decks became the same after update
                if (JSON.stringify(playerState.player1.deck) === JSON.stringify(playerState.player2.deck)) {
                  console.error('ERROR: Both players have the same deck after updating player2 deck!', {
                    player1DeckFirst3: playerState.player1.deck?.slice(0, 3).map(c => c?.name),
                    player2DeckFirst3: playerState.player2.deck?.slice(0, 3).map(c => c?.name)
                  });
                }
              } else {
                // Skipping player2 deck update (already correct)
              }
            }
            if (gameState.player1.hand && Array.isArray(gameState.player1.hand)) {
              const newHand = [...gameState.player1.hand];
              const oldHandStr = JSON.stringify(playerState.player2.hand);
              const newHandStr = JSON.stringify(newHand);
              if (oldHandStr !== newHandStr) {
                playerState.player2.hand = newHand;
                
                // Immediately update globalThis.playerState to ensure render functions have latest data
                if (globalThis.playerState) {
                  globalThis.playerState.player2.hand = newHand.map(c => ({...c}));
                }
              }
            }
            if (gameState.player1.energyTypes) playerState.player2.energyTypes = [...(gameState.player1.energyTypes || [])];
            if (gameState.player1.discard) playerState.player2.discard = gameState.player1.discard;
          }
          if (gameState.player2) {
            if (gameState.player2.deck && Array.isArray(gameState.player2.deck)) {
              const newDeck = [...gameState.player2.deck];
              // Only update if different to avoid unnecessary overwrites
              const oldDeckStr = JSON.stringify(playerState.player1.deck);
              const newDeckStr = JSON.stringify(newDeck);
              if (oldDeckStr !== newDeckStr) {
                // Updating player1 deck from Firebase (swapped)
                playerState.player1.deck = newDeck;
                // Check if decks became the same after update
                if (JSON.stringify(playerState.player1.deck) === JSON.stringify(playerState.player2.deck)) {
                  console.error('ERROR: Both players have the same deck after updating player1 deck!', {
                    player1DeckFirst3: playerState.player1.deck?.slice(0, 3).map(c => c?.name),
                    player2DeckFirst3: playerState.player2.deck?.slice(0, 3).map(c => c?.name)
                  });
                }
              } else {
                // Skipping player1 deck update (already correct)
              }
            }
            if (gameState.player2.hand && Array.isArray(gameState.player2.hand)) {
              // Don't update hands if we're currently drawing them
              if (!isDrawingHands) {
                const newHand = [...gameState.player2.hand];
                const oldHandStr = JSON.stringify(playerState.player1.hand);
                const newHandStr = JSON.stringify(newHand);
                if (oldHandStr !== newHandStr) {
                  playerState.player1.hand = newHand;
                  
                  // Immediately update globalThis.playerState to ensure render functions have latest data
                  if (globalThis.playerState) {
                    globalThis.playerState.player1.hand = newHand.map(c => ({...c}));
                  }
                } else {
                  // Skipping player1 hand update (already correct)
                }
              } else {
                // Skipping player1 hand update (hands are being drawn)
              }
            }
            if (gameState.player2.energyTypes) playerState.player1.energyTypes = [...(gameState.player2.energyTypes || [])];
            if (gameState.player2.discard) playerState.player1.discard = gameState.player2.discard;
          }
        }
        
        // Update globalThis.playerState to ensure render functions have the latest data
        // Create a deep copy to avoid reference issues
        globalThis.playerState = {
          player1: {
            deck: playerState.player1.deck ? [...playerState.player1.deck] : [],
            hand: playerState.player1.hand ? [...playerState.player1.hand] : [],
            energyTypes: playerState.player1.energyTypes ? [...playerState.player1.energyTypes] : [],
            currentTurnEnergy: playerState.player1.currentTurnEnergy,
            nextTurnEnergy: playerState.player1.nextTurnEnergy,
            discard: playerState.player1.discard || { cards: [], energyCounts: {} }
          },
          player2: {
            deck: playerState.player2.deck ? [...playerState.player2.deck] : [],
            hand: playerState.player2.hand ? [...playerState.player2.hand] : [],
            energyTypes: playerState.player2.energyTypes ? [...playerState.player2.energyTypes] : [],
            currentTurnEnergy: playerState.player2.currentTurnEnergy,
            nextTurnEnergy: playerState.player2.nextTurnEnergy,
            discard: playerState.player2.discard || { cards: [], energyCounts: {} }
          }
        };
        
        // Final check: verify decks are still different after all updates
        const finalP1Deck = playerState.player1.deck;
        const finalP2Deck = playerState.player2.deck;
        if (finalP1Deck && finalP2Deck && Array.isArray(finalP1Deck) && Array.isArray(finalP2Deck)) {
          const decksAreSame = JSON.stringify(finalP1Deck) === JSON.stringify(finalP2Deck);
          if (decksAreSame) {
            console.error('ERROR: Both players have the same deck after state update!', {
              player1DeckFirst3: finalP1Deck.slice(0, 3).map(c => c?.name),
              player2DeckFirst3: finalP2Deck.slice(0, 3).map(c => c?.name),
              player1DeckLength: finalP1Deck.length,
              player2DeckLength: finalP2Deck.length,
              isPlayer1
            });
          }
        }
        
        // Map firstPlayer from match to UI
        if (gameState.firstPlayer) {
          // Map match player to UI player
          // If isPlayer1=true: match.player1 -> UI.player1, match.player2 -> UI.player2
          // If isPlayer1=false: match.player1 -> UI.player2, match.player2 -> UI.player1
          // So if gameState.firstPlayer='player1' (match player1):
          //   - isPlayer1=true: UI.player1 goes first
          //   - isPlayer1=false: UI.player2 goes first (because match.player1 = UI.player2 for player2 user)
          // And if gameState.firstPlayer='player2' (match player2):
          //   - isPlayer1=true: UI.player2 goes first
          //   - isPlayer1=false: UI.player1 goes first (because match.player2 = UI.player1 for player2 user)
          const uiFirstPlayer = isPlayer1 
            ? (gameState.firstPlayer === 'player1' ? 'player1' : 'player2')
            : (gameState.firstPlayer === 'player1' ? 'player2' : 'player1');
          
          // Mapped to UI first player
          
          // Only update if firstPlayer changed or hasn't been set yet
          if (!firstPlayer || firstPlayer !== uiFirstPlayer) {
            // Updating firstPlayer
            firstPlayer = uiFirstPlayer;
            globalThis.firstPlayer = uiFirstPlayer;
            
            // Set currentPlayer to firstPlayer (will be used when game starts)
            if (!currentPlayer) {
              currentPlayer = uiFirstPlayer;
            }
            
            // Ensure isSetupPhase is set for player2 when they receive coin flip result
            isSetupPhase = true;
            globalThis.isSetupPhase = true;
              
              // Set energy types for both players (similar to flipCoin function)
              const firstState = playerState[uiFirstPlayer];
              const firstEnergyTypes = firstState.energyTypes || [];
              if (firstEnergyTypes.length > 1) {
                firstState.currentTurnEnergy = selectRandomEnergy(firstEnergyTypes);
                firstState.nextTurnEnergy = selectRandomEnergy(firstEnergyTypes);
              } else if (firstEnergyTypes.length === 1) {
                firstState.currentTurnEnergy = firstEnergyTypes[0];
                firstState.nextTurnEnergy = firstEnergyTypes[0];
              }
              
              const otherPlayer = uiFirstPlayer === 'player1' ? 'player2' : 'player1';
              const otherState = playerState[otherPlayer];
              const otherEnergyTypes = otherState.energyTypes || [];
              if (otherEnergyTypes.length > 1) {
                otherState.currentTurnEnergy = selectRandomEnergy(otherEnergyTypes);
                otherState.nextTurnEnergy = selectRandomEnergy(otherEnergyTypes);
              } else if (otherEnergyTypes.length === 1) {
                otherState.currentTurnEnergy = otherEnergyTypes[0];
                otherState.nextTurnEnergy = otherEnergyTypes[0];
              }
            
            // Update coin display whenever firstPlayer is received
              // Trigger coin flip animation for player 2
              if (coinEl) {
                coinEl.classList.add('flip');
                
                setTimeout(() => {
                  const front = coinEl.querySelector('.front');
                  const back = coinEl.querySelector('.back');
            
            if (front && back && coinResult) {
                    coinEl.classList.remove('flip');
                    
              if (uiFirstPlayer === 'player1') {
                front.style.transform = 'rotateY(0deg)';
                back.style.transform = 'rotateY(180deg)';
              } else {
                front.style.transform = 'rotateY(180deg)';
                back.style.transform = 'rotateY(0deg)';
              }
              // Show perspective-based message
              // uiFirstPlayer is already in UI terms, so:
              // - For both host and joiner, UI player1 is always "you" (bottom)
              // - So if uiFirstPlayer === 'player1', you are going first
              // - If uiFirstPlayer === 'player2', opponent is going first
              const isGoingFirst = uiFirstPlayer === 'player1';
              coinResult.textContent = isGoingFirst ? 'You are going first!' : 'Your opponent is going first!';
              showPopup(isGoingFirst ? 'You are going first!' : 'Your opponent is going first!');
                  }
                }, 1500);
              }
              
              // Log the coin flip event
              logEvent({
                player: uiFirstPlayer,
                text: `Won the coin flip and goes first.`
              });
              
              updateTurnBox();
              renderEnergyZone();
              
              (globalThis.updateDeckStack || updateDeckStack)('player1');
              (globalThis.updateDeckStack || updateDeckStack)('player2');
            
            // Update button state if it's still waiting for coin flip
            if (mainButton && isSetupPhase && (mainButton.textContent === 'Flip Coin' || mainButton.textContent === 'Waiting for opponent to flip coin...')) {
              // Check if hands are already present (drawn automatically by player1)
              const p1HasHand = playerState.player1.hand && playerState.player1.hand.length > 0;
              const p2HasHand = playerState.player2.hand && playerState.player2.hand.length > 0;
              if (p1HasHand && p2HasHand) {
                // Hands already drawn, go directly to Start Game (only if still in setup phase)
                mainButton.textContent = 'Start Game';
                showPopup('Choose Active & Benched Pokmon');
              } else {
                // Hands not yet received, wait for them
                mainButton.textContent = 'Waiting for hands...';
              }
            }
          }
        }
        
        // For the joiner (isPlayer1=false), draw their own hand when they receive the game state
        // The host already drew their hand, so the joiner needs to draw theirs
        if (!isPlayer1 && firstPlayer && !handsDrawn) {
          // Check if the host's hand is present (gameState.player1.hand) but joiner's hand is not (gameState.player2.hand)
          const hostHasHand = gameState.player1?.hand && gameState.player1.hand.length > 0;
          const joinerHasHand = gameState.player2?.hand && gameState.player2.hand.length > 0;
          
          if (hostHasHand && !joinerHasHand) {
            // Host has drawn their hand, but joiner hasn't - draw joiner's hand now
            // Joiner drawing own hand
            isDrawingHands = true;
            // For joiner: UI player1 = match player2 (their own hand)
            drawStartingHandForPlayer('player1', true).then(() => {
              // Animation complete
              const allAnimatedCards = document.querySelectorAll('[data-animated-card="true"]');
              allAnimatedCards.forEach(card => {
                if (card && card.parentNode) {
                  card.remove();
                }
              });
              void document.body.offsetHeight;
              
              // Update globalThis.playerState
              if (globalThis.playerState && playerState.player1?.hand) {
                globalThis.playerState.player1.hand = playerState.player1.hand.map(c => ({...c}));
              }
              
              isSetupPhase = true;
              globalThis.isSetupPhase = true;
              
              requestAnimationFrame(() => {
                // Ensure globalThis.playerState is fully synced before rendering
                if (globalThis.playerState) {
                  if (playerState.player1?.hand) {
                    globalThis.playerState.player1.hand = playerState.player1.hand.map(c => ({...c}));
                  }
                  if (playerState.player2?.hand) {
                    globalThis.playerState.player2.hand = playerState.player2.hand.map(c => ({...c}));
                  }
                }
                
                renderAllHands();
                
                // Verify the rendering was correct
                const p1HandDiv = document.getElementById('p1Hand');
                const p2HandDiv = document.getElementById('p2Hand');
                if (p1HandDiv && p2HandDiv) {
                  const p1Cards = Array.from(p1HandDiv.querySelectorAll('.card-img')).map(img => img.alt);
                  const p2Cards = Array.from(p2HandDiv.querySelectorAll('.card-img')).map(img => img.alt);
                  if (JSON.stringify(p1Cards) === JSON.stringify(p2Cards) && p1Cards.length > 0) {
                    console.error('ERROR: After renderAllHands (joiner), both hands show the same cards!', {
                      p1Cards,
                      p2Cards,
                      playerStateP1Hand: playerState.player1.hand?.map(c => c?.name),
                      playerStateP2Hand: playerState.player2.hand?.map(c => c?.name),
                      globalThisP1Hand: globalThis.playerState?.player1?.hand?.map(c => c?.name),
                      globalThisP2Hand: globalThis.playerState?.player2?.hand?.map(c => c?.name)
                    });
                  }
                }
                
                // Clear the flag after a longer delay to allow rendering to complete and prevent onStateChange from interfering
                setTimeout(() => {
                  isDrawingHands = false;
                }, 500);
              });
            }).catch(error => {
              console.error('Error drawing joiner hand:', error);
              isDrawingHands = false;
            });
          }
        }
        
        // Check if hands have been drawn (both players have hands)
        const p1HasHand = playerState.player1.hand && playerState.player1.hand.length > 0;
        const p2HasHand = playerState.player2.hand && playerState.player2.hand.length > 0;
        if (p1HasHand && p2HasHand) {
          if (!handsDrawn) {
          handsDrawn = true;
            
            // Hands detected in onStateChange
              globalThis: JSON.stringify(globalThis.playerState?.player1?.hand) === JSON.stringify(globalThis.playerState?.player2?.hand),
              // Hands detected
            
          // Ensure isSetupPhase is set when hands are received
          isSetupPhase = true;
          globalThis.isSetupPhase = true;
          }
          
          // Update button if it's waiting for hands or coin flip (only if still in setup phase)
          if (mainButton && isSetupPhase && (mainButton.textContent === 'Draw Hands' || mainButton.textContent === 'Waiting for hands...' || mainButton.textContent === 'Waiting for opponent to flip coin...')) {
            mainButton.textContent = 'Start Game';
            showPopup('Choose Active & Benched Pokmon');
          }
        } else if (firstPlayer && mainButton && mainButton.textContent === 'Waiting for hands...') {
          // If we have firstPlayer but not hands yet, keep waiting
          // (button should already say "Waiting for hands...")
        }
        
        // Handle active and bench Pokemon updates
        if (isPlayer1) {
          // Current user is player1 in match
          // gameState.player1 -> UI.player1, gameState.player2 -> UI.player2
          if (gameState.player1?.active) {
            const activeSlot = document.querySelector('#p1Active .card-slot');
            if (activeSlot) {
              // Clear existing image if it doesn't match
              const existingImg = activeSlot.querySelector('img');
              let shouldRender = true;
              if (existingImg) {
                const existingSet = existingImg.dataset.set;
                const existingNum = existingImg.dataset.num;
                const newSet = gameState.player1.active.set;
                const newNum = String(gameState.player1.active.num);
                if (existingSet !== newSet || existingNum !== newNum) {
                  console.log('Removing existing image that doesn\'t match:', { existingSet, existingNum, newSet, newNum });
                  existingImg.remove();
                  shouldRender = true; // Render new one
                } else {
                  // Active Pokemon already matches, skipping render
                  shouldRender = false; // Already correct
                }
              }
              
              // Render if we need to (slot is empty or we removed the old image)
              if (shouldRender) {
                const cardData = gameState.player1.active;
                const img = document.createElement('img');
                img.className = 'card-img';
                img.src = highImgUrl(cardData.set, cardData.num) || 'imgs/cardback.png';
                img.alt = cardData.name;
                img.dataset.set = cardData.set;
                img.dataset.num = cardData.num;
                img.dataset.owner = 'player1';
                img.dataset.instanceId = cardData.instanceId;
                img.dataset.playedTurn = cardData.playedTurn;
                activeSlot.appendChild(img);
                if (typeof setHpOnImage === 'function' && cardData.hp) {
                  setHpOnImage(img, cardData.hp, cardData.hp);
                }
                
                // Update background color
                if (typeof updatePlayerTypeBackground === 'function') {
                  updatePlayerTypeBackground(1);
                }
              }
            } else {
              console.error('Player1 active slot not found!');
            }
          }
          if (gameState.player1?.bench && Array.isArray(gameState.player1.bench)) {
            const bench = document.querySelector('#p1Bench');
            if (bench) {
              const slots = bench.querySelectorAll('.card-slot');
              // Clear all existing images first, then render the current bench
              slots.forEach(slot => {
                const existingImg = slot.querySelector('img');
                if (existingImg) {
                  existingImg.remove();
                }
              });
              
              // Render the current bench state
              gameState.player1.bench.forEach((cardData, index) => {
                if (index < slots.length) {
                  const img = document.createElement('img');
                  img.className = 'card-img';
                  img.src = highImgUrl(cardData.set, cardData.num) || 'imgs/cardback.png';
                  img.alt = cardData.name;
                  img.dataset.set = cardData.set;
                  img.dataset.num = cardData.num;
                  img.dataset.owner = 'player1';
                  img.dataset.instanceId = cardData.instanceId;
                  img.dataset.playedTurn = cardData.playedTurn;
                  slots[index].appendChild(img);
                  if (typeof setHpOnImage === 'function' && cardData.hp) {
                    setHpOnImage(img, cardData.hp, cardData.hp);
                  }
                }
              });
            }
          }
          if (gameState.player2?.active) {
            const activeSlot = document.querySelector('#p2Active .card-slot');
            if (activeSlot) {
              const cardData = gameState.player2.active;
              const existingImg = activeSlot.querySelector('img');
              
              // Check if we need to update
              let needsUpdate = true;
              if (existingImg) {
                const existingSet = existingImg.dataset.set;
                const existingNum = existingImg.dataset.num;
                const existingInstanceId = existingImg.dataset.instanceId;
                if (existingSet === cardData.set && 
                    existingNum === String(cardData.num) && 
                    existingInstanceId === cardData.instanceId) {
                  needsUpdate = false; // Already rendered with same card
                } else {
                  existingImg.remove(); // Remove old image
                }
              }
              
              if (needsUpdate) {
                const img = document.createElement('img');
                img.className = 'card-img';
                img.src = highImgUrl(cardData.set, cardData.num) || 'imgs/cardback.png';
                img.alt = cardData.name;
                img.dataset.set = cardData.set;
                img.dataset.num = cardData.num;
                img.dataset.owner = 'player2';
                img.dataset.instanceId = cardData.instanceId;
                img.dataset.playedTurn = cardData.playedTurn;
                activeSlot.appendChild(img);
                if (typeof setHpOnImage === 'function' && cardData.hp) {
                  setHpOnImage(img, cardData.hp, cardData.hp);
                }
                
                // Update background color
                if (typeof updatePlayerTypeBackground === 'function') {
                  updatePlayerTypeBackground(2);
                }
              }
            }
          } else {
            // If active is null/undefined, clear the slot
            const activeSlot = document.querySelector('#p2Active .card-slot');
            if (activeSlot) {
              const existingImg = activeSlot.querySelector('img');
              if (existingImg) {
                existingImg.remove();
                console.log('Cleared player2 active slot (no active Pokemon)');
              }
            }
          }
          if (gameState.player2?.bench && Array.isArray(gameState.player2.bench)) {
            const bench = document.querySelector('#p2Bench');
            if (bench) {
              const slots = bench.querySelectorAll('.card-slot');
              // Clear all existing images first, then render the current bench
              slots.forEach(slot => {
                const existingImg = slot.querySelector('img');
                if (existingImg) {
                  existingImg.remove();
                }
              });
              
              // Render the current bench state
              gameState.player2.bench.forEach((cardData, index) => {
                if (index < slots.length) {
                  const img = document.createElement('img');
                  img.className = 'card-img';
                  img.src = highImgUrl(cardData.set, cardData.num) || 'imgs/cardback.png';
                  img.alt = cardData.name;
                  img.dataset.set = cardData.set;
                  img.dataset.num = cardData.num;
                  img.dataset.owner = 'player2';
                  img.dataset.instanceId = cardData.instanceId;
                  img.dataset.playedTurn = cardData.playedTurn;
                  slots[index].appendChild(img);
                  if (typeof setHpOnImage === 'function' && cardData.hp) {
                    setHpOnImage(img, cardData.hp, cardData.hp);
                  }
                }
              });
            }
          }
        } else {
          // Current user is player2 in match, so swap
          // gameState.player1 -> UI.player2, gameState.player2 -> UI.player1
          if (gameState.player1?.active) {
            const activeSlot = document.querySelector('#p2Active .card-slot');
            if (activeSlot) {
              const cardData = gameState.player1.active;
              const existingImg = activeSlot.querySelector('img');
              
              // Check if we need to update
              let needsUpdate = true;
              if (existingImg) {
                const existingSet = existingImg.dataset.set;
                const existingNum = existingImg.dataset.num;
                const existingInstanceId = existingImg.dataset.instanceId;
                if (existingSet === cardData.set && 
                    existingNum === String(cardData.num) && 
                    existingInstanceId === cardData.instanceId) {
                  needsUpdate = false; // Already rendered with same card
                } else {
                  existingImg.remove(); // Remove old image
                }
              }
              
              if (needsUpdate) {
                const img = document.createElement('img');
                img.className = 'card-img';
                img.src = highImgUrl(cardData.set, cardData.num) || 'imgs/cardback.png';
                img.alt = cardData.name;
                img.dataset.set = cardData.set;
                img.dataset.num = cardData.num;
                img.dataset.owner = 'player2';
                img.dataset.instanceId = cardData.instanceId;
                img.dataset.playedTurn = cardData.playedTurn;
                activeSlot.appendChild(img);
                if (typeof setHpOnImage === 'function' && cardData.hp) {
                  setHpOnImage(img, cardData.hp, cardData.hp);
                }
                
                // Update background color for joiner (when isPlayer1=false, player2 is the current user)
                if (typeof updatePlayerTypeBackground === 'function') {
                  updatePlayerTypeBackground(2);
                }
              }
            }
          } else {
            // If active is null/undefined, clear the slot
            const activeSlot = document.querySelector('#p2Active .card-slot');
            if (activeSlot) {
              const existingImg = activeSlot.querySelector('img');
              if (existingImg) {
                existingImg.remove();
                console.log('Cleared player2 active slot (no active Pokemon, swapped)');
              }
            }
          }
          if (gameState.player1?.bench && Array.isArray(gameState.player1.bench)) {
            const bench = document.querySelector('#p2Bench');
            if (bench) {
              const slots = bench.querySelectorAll('.card-slot');
              // Clear all existing images first, then render the current bench
              slots.forEach(slot => {
                const existingImg = slot.querySelector('img');
                if (existingImg) {
                  existingImg.remove();
                }
              });
              
              // Render the current bench state
              gameState.player1.bench.forEach((cardData, index) => {
                if (index < slots.length) {
                  const img = document.createElement('img');
                  img.className = 'card-img';
                  img.src = highImgUrl(cardData.set, cardData.num) || 'imgs/cardback.png';
                  img.alt = cardData.name;
                  img.dataset.set = cardData.set;
                  img.dataset.num = cardData.num;
                  img.dataset.owner = 'player2';
                  img.dataset.instanceId = cardData.instanceId;
                  img.dataset.playedTurn = cardData.playedTurn;
                  slots[index].appendChild(img);
                  if (typeof setHpOnImage === 'function' && cardData.hp) {
                    setHpOnImage(img, cardData.hp, cardData.hp);
                  }
                }
              });
            }
          }
          if (gameState.player2?.active) {
            const activeSlot = document.querySelector('#p1Active .card-slot');
            if (activeSlot) {
              const cardData = gameState.player2.active;
              const existingImg = activeSlot.querySelector('img');
              
              // Check if we need to update
              let needsUpdate = true;
              if (existingImg) {
                const existingSet = existingImg.dataset.set;
                const existingNum = existingImg.dataset.num;
                const existingInstanceId = existingImg.dataset.instanceId;
                if (existingSet === cardData.set && 
                    existingNum === String(cardData.num) && 
                    existingInstanceId === cardData.instanceId) {
                  needsUpdate = false; // Already rendered with same card
                } else {
                  existingImg.remove(); // Remove old image
                }
              }
              
              if (needsUpdate) {
                const img = document.createElement('img');
                img.className = 'card-img';
                img.src = highImgUrl(cardData.set, cardData.num) || 'imgs/cardback.png';
                img.alt = cardData.name;
                img.dataset.set = cardData.set;
                img.dataset.num = cardData.num;
                img.dataset.owner = 'player1';
                img.dataset.instanceId = cardData.instanceId;
                img.dataset.playedTurn = cardData.playedTurn;
                activeSlot.appendChild(img);
                if (typeof setHpOnImage === 'function' && cardData.hp) {
                  setHpOnImage(img, cardData.hp, cardData.hp);
                }
              }
            }
          } else {
            // If active is null/undefined, clear the slot
            const activeSlot = document.querySelector('#p1Active .card-slot');
            if (activeSlot) {
              const existingImg = activeSlot.querySelector('img');
              if (existingImg) {
                existingImg.remove();
                console.log('Cleared player1 active slot (no active Pokemon, swapped)');
              }
            }
          }
          if (gameState.player2?.bench && Array.isArray(gameState.player2.bench)) {
            const bench = document.querySelector('#p1Bench');
            if (bench) {
              const slots = bench.querySelectorAll('.card-slot');
              // Clear all existing images first, then render the current bench
              slots.forEach(slot => {
                const existingImg = slot.querySelector('img');
                if (existingImg) {
                  existingImg.remove();
                }
              });
              
              // Render the current bench state
              gameState.player2.bench.forEach((cardData, index) => {
                if (index < slots.length) {
                  const img = document.createElement('img');
                  img.className = 'card-img';
                  img.src = highImgUrl(cardData.set, cardData.num) || 'imgs/cardback.png';
                  img.alt = cardData.name;
                  img.dataset.set = cardData.set;
                  img.dataset.num = cardData.num;
                  img.dataset.owner = 'player1';
                  img.dataset.instanceId = cardData.instanceId;
                  img.dataset.playedTurn = cardData.playedTurn;
                  slots[index].appendChild(img);
                  if (typeof setHpOnImage === 'function' && cardData.hp) {
                    setHpOnImage(img, cardData.hp, cardData.hp);
                  }
                }
              });
            }
          }
        }
        
        // Update points from Firebase and sync to UI
        // Check both nested (player1.points) and root level (p1Points) structures
        const newP1Points = gameState.player1?.points ?? gameState.p1Points;
        const newP2Points = gameState.player2?.points ?? gameState.p2Points;
        
        let pointsChanged = false;
        // [POINTS-FIX] Only update from Firebase if the value is reasonable (not a huge jump)
        // This prevents incorrect Firebase values from overwriting correct local values
        if (newP1Points !== undefined && typeof newP1Points === 'number') {
          // Only update if the difference is reasonable (within 5 points) or if local is 0
          // This prevents race conditions where old Firebase values overwrite new local values
          const diff = Math.abs(newP1Points - p1Points);
          if (diff <= 5 || p1Points === 0) {
            if (newP1Points !== p1Points) {
              p1Points = newP1Points;
              pointsChanged = true;
            }
          } else {
            console.warn('[POINTS-FIX] Ignoring suspicious Firebase points update:', {
              local: p1Points,
              firebase: newP1Points,
              diff
            });
          }
        }
        if (newP2Points !== undefined && typeof newP2Points === 'number') {
          const diff = Math.abs(newP2Points - p2Points);
          if (diff <= 5 || p2Points === 0) {
            if (newP2Points !== p2Points) {
              p2Points = newP2Points;
              pointsChanged = true;
            }
          } else {
            console.warn('[POINTS-FIX] Ignoring suspicious Firebase points update:', {
              local: p2Points,
              firebase: newP2Points,
              diff
            });
          }
        }
        
        // Always update globalThis.points to ensure they're in sync
        globalThis.p1Points = p1Points;
        globalThis.p2Points = p2Points;
        
        // Update points UI when points change from Firebase
        if (pointsChanged && typeof updatePointsUI === 'function') {
          updatePointsUI();
          console.log('[POINTS-SYNC] Updated points from Firebase:', {
            p1Points,
            p2Points,
            newP1Points,
            newP2Points
          });
        }
        // Update turn number
        if (gameState.turnNumber !== undefined && gameState.turnNumber !== globalThis.turnNumber) {
          // [TURN-1-DRAW] Store Firebase turn number for startTurn to use
          globalThis.__lastFirebaseTurnNumber = gameState.turnNumber;
          globalThis.turnNumber = gameState.turnNumber;
          console.log('Turn number updated from Firebase:', gameState.turnNumber);
        }
        
        // Update current player - ALWAYS update button text when currentPlayer changes
        if (gameState.currentPlayer) {
          const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
          const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
          // Map match player to UI player
          const uiCurrentPlayer = isP1 
            ? (gameState.currentPlayer === 'player1' ? 'player1' : 'player2')
            : (gameState.currentPlayer === 'player1' ? 'player2' : 'player1');
          
          // Always update currentPlayer when we receive a new value from Firebase
          const previousPlayer = currentPlayer;
          const shouldUpdate = !currentPlayer || uiCurrentPlayer !== currentPlayer;
          
          // ALWAYS update currentPlayer and button text when we receive currentPlayer from Firebase
          // This ensures the button state is always correct
          // IMPORTANT: In online mode, UI player1 is always "you" (the current user)
          // So uiCurrentPlayer === 'player1' means it's your turn
          currentPlayer = uiCurrentPlayer;
          globalThis.currentPlayer = uiCurrentPlayer;
          
          if (mainButton) {
            const isMyTurn = uiCurrentPlayer === 'player1'; // UI player1 is always the current user
            if (isMyTurn) {
              mainButton.textContent = 'End Turn';
              mainButton.disabled = false; // Enable the button when it's your turn
            } else {
              mainButton.textContent = 'Waiting for opponent...';
              mainButton.disabled = true; // Disable the button when it's not your turn
            }
            console.log('Updated button text from Firebase currentPlayer:', {
              uiCurrentPlayer,
              isMyTurn,
              buttonText: mainButton.textContent,
              previousPlayer,
              newCurrentPlayer: currentPlayer,
              buttonDisabled: mainButton.disabled
            });
          }
          
          if (shouldUpdate) {
            console.log('Current player changed from Firebase:', {
              matchCurrentPlayer: gameState.currentPlayer,
              uiCurrentPlayer,
              oldCurrentPlayer: previousPlayer, // Use previousPlayer, not currentPlayer (which was just updated)
              newCurrentPlayer: currentPlayer,
              isPlayer1: isP1
            });
            
            // Check if this is a turn change (not just initial load)
            const wasTurnChange = previousPlayer && previousPlayer !== uiCurrentPlayer;
            // Check if this is the initial game start (currentPlayer is null and we're starting the first turn)
            // Also check if setup phase was just ended (gameState.isSetupPhase is false but local isSetupPhase might still be true)
            const isInitialGameStart = !previousPlayer && (gameState.isSetupPhase === false || !isSetupPhase) && gameState.turnNumber === 1;
            
            // Update button state immediately (especially important for initial game start)
            // In online mode, UI player1 is always "you", so if uiCurrentPlayer === 'player1', it's your turn
            if (mainButton) {
              const isMyTurn = uiCurrentPlayer === 'player1'; // UI player1 is always the current user
              if (isMyTurn) {
                mainButton.textContent = 'End Turn';
                mainButton.disabled = false; // Enable the button when it's your turn
              } else {
                mainButton.textContent = 'Waiting for opponent...';
                mainButton.disabled = true; // Disable the button when it's not your turn
              }
              console.log('Updated button text from Firebase:', {
                uiCurrentPlayer,
                isMyTurn,
                buttonText: mainButton.textContent,
                buttonDisabled: mainButton.disabled
              });
            }
            
            // If this is a turn change or initial game start, call startTurn BEFORE updating currentPlayer
            // so startTurn can correctly determine previousPlayer (which will be null for initial start)
            // Prevent duplicate startTurn calls for the same turn/player
            const turnKey = `${gameState.turnNumber || 0}-${uiCurrentPlayer}`;
            const shouldCallStartTurn = (wasTurnChange || isInitialGameStart) && 
                                       typeof startTurn === 'function' &&
                                       (lastStartTurnTurn !== gameState.turnNumber || lastStartTurnPlayer !== uiCurrentPlayer);
            
            if (shouldCallStartTurn) {
              console.log('Turn changed/started, calling startTurn for:', uiCurrentPlayer, 'previous:', previousPlayer, 'isInitial:', isInitialGameStart, 'turnNumber:', gameState.turnNumber);
              // Mark that we're starting this turn
              lastStartTurnTurn = gameState.turnNumber;
              lastStartTurnPlayer = uiCurrentPlayer;
              
              // [TURN-1-DRAW] Pass turnNumber to startTurn so it can correctly detect turn 1
              const turnNumberForStartTurn = gameState.turnNumber;
              
              // IMPORTANT: currentPlayer has already been updated to uiCurrentPlayer above (line 16161)
              // So startTurn should see currentPlayer === uiCurrentPlayer
              // If it doesn't, that means another Firebase update changed it, which is a race condition
              // We'll check this synchronously before scheduling the async call to avoid the race
              if (currentPlayer !== uiCurrentPlayer) {
                console.warn('startTurn: currentPlayer mismatch detected before scheduling (race condition):', {
                  expected: uiCurrentPlayer,
                  actual: currentPlayer,
                  turnNumber: gameState.turnNumber,
                  note: 'Skipping startTurn - will be called again when the correct currentPlayer update arrives'
                });
                // Reset the lastStartTurn markers so we can try again on the next update
                lastStartTurnTurn = null;
                lastStartTurnPlayer = null;
                return;
              }
              
              (async () => {
                // Double-check that currentPlayer still matches what we expect before calling startTurn
                // This prevents race conditions where another Firebase update changed currentPlayer between the check above and here
                if (currentPlayer !== uiCurrentPlayer) {
                  console.warn('startTurn: currentPlayer changed between check and startTurn call (race condition):', {
                    expected: uiCurrentPlayer,
                    actual: currentPlayer,
                    turnNumber: gameState.turnNumber,
                    note: 'Skipping startTurn - will be called again when the correct currentPlayer update arrives'
                  });
                  // Reset the lastStartTurn markers so we can try again on the next update
                  lastStartTurnTurn = null;
                  lastStartTurnPlayer = null;
                  return;
                }
                
                await startTurn(uiCurrentPlayer, previousPlayer, turnNumberForStartTurn);
                // After startTurn completes, ensure button state is still correct
                if (mainButton) {
                  const isMyTurn = uiCurrentPlayer === 'player1'; // UI player1 is always the current user
                  if (isMyTurn) {
                    mainButton.textContent = 'End Turn';
                    mainButton.disabled = false;
                  } else {
                    mainButton.textContent = 'Waiting for opponent...';
                    mainButton.disabled = true;
                  }
                  console.log('Button state after startTurn:', {
                    uiCurrentPlayer,
                    isMyTurn,
                    buttonText: mainButton.textContent,
                    buttonDisabled: mainButton.disabled
                  });
                }
              })();
            } else if ((wasTurnChange || isInitialGameStart) && typeof startTurn === 'function') {
              console.log('Skipping duplicate startTurn call:', {
                turnNumber: gameState.turnNumber,
                uiCurrentPlayer,
                lastStartTurnTurn,
                lastStartTurnPlayer
              });
            } else {
              // If not a turn change (just a state update), just update currentPlayer
              currentPlayer = uiCurrentPlayer;
              globalThis.currentPlayer = uiCurrentPlayer;
              
              // Also update button state even if it's not a turn change
              if (mainButton) {
                const isMyTurn = uiCurrentPlayer === 'player1';
                if (isMyTurn) {
                  mainButton.textContent = 'End Turn';
                } else {
                  mainButton.textContent = 'Waiting for opponent...';
                }
              }
            }
            
            // Update turn box display
            if (typeof updateTurnBox === 'function') {
              updateTurnBox();
            }
            
            // Update energy zone when current player changes (to enable/disable based on whose turn it is)
            // (startTurn will also call this, but we call it here too for non-turn-change updates)
            if (typeof renderEnergyZone === 'function') {
              renderEnergyZone();
            }
          }
        }
        
        // Update setup phase
        if (gameState.isSetupPhase !== undefined && gameState.isSetupPhase !== isSetupPhase) {
          isSetupPhase = gameState.isSetupPhase;
          globalThis.isSetupPhase = gameState.isSetupPhase;
          console.log('Setup phase updated from Firebase:', gameState.isSetupPhase);
        }
        
        // Check if both players are ready to start
        if (gameState.player1Ready && gameState.player2Ready && isSetupPhase) {
          console.log('Both players ready, starting game...', {
            isP1: isPlayer1,
            firstPlayer: firstPlayer || globalThis.firstPlayer,
            gameStateCurrentPlayer: gameState.currentPlayer,
            gameStateIsSetupPhase: gameState.isSetupPhase
          });
          
          // Only sync game start from one player to avoid race conditions
          // Use a flag to ensure only one player does the sync
          const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
          const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
          
          // Get firstPlayer from local or global
          const currentFirstPlayer = firstPlayer || globalThis.firstPlayer;
          
          // Only player1 (match player1, which is the host) should sync the game start
          // This prevents both players from syncing simultaneously
          // Check if game hasn't started yet (currentPlayer not set or still in setup)
          if (isP1 && !gameState.currentPlayer && currentFirstPlayer) {
            // Sync game start state to Firebase
            (async () => {
              const updateGameStatePartialFn = updateGameStatePartial || globalThis.updateGameStatePartial;
              if (updateGameStatePartialFn) {
                try {
                  // Map UI firstPlayer to match firstPlayer
                  // For player1 (host), UI player1 = match player1, UI player2 = match player2
                  const matchFirstPlayer = currentFirstPlayer === 'player1' ? 'player1' : 'player2';
                  
                  console.log('Syncing game start to Firebase...', {
                    uiFirstPlayer: currentFirstPlayer,
                    matchFirstPlayer,
                    turnNumber: 1
                  });
                  
                  await updateGameStatePartialFn({
                    'player1Ready': false,
                    'player2Ready': false,
                    'isSetupPhase': false,
                    'currentPlayer': matchFirstPlayer,
                    'turnNumber': 1
                  });
                  console.log('Successfully synced game start to Firebase:', {
                    matchFirstPlayer,
                    turnNumber: 1
                  });
                  
                  // [TURN-1-DRAW] Draw a card for the first player when game starts
                  // The first player should draw a card on turn 1
                  if (typeof drawOne === 'function') {
                    console.log('[TURN-1-DRAW] Drawing card for first player on game start:', matchFirstPlayer);
                    await drawOne(matchFirstPlayer);
                    if (typeof renderAllHands === 'function') {
                      renderAllHands();
                    }
                  }
                } catch (error) {
                  console.error('Error syncing game start:', error);
                }
              } else {
                console.error('Cannot sync game start: updateGameStatePartial not available');
              }
            })();
          } else if (!isP1) {
            console.log('Player2 waiting for player1 to sync game start...');
          } else if (!currentFirstPlayer) {
            console.error('Cannot sync game start: firstPlayer not set yet');
          } else if (gameState.currentPlayer) {
            console.log('Game start already synced (currentPlayer is set)');
          }
          
          // Don't call startTurn here - let onStateChange handle it when it receives
          // the Firebase update. This ensures both players have the same state.
        } else if (gameState.player1Ready !== undefined || gameState.player2Ready !== undefined) {
          // Update button state based on ready status
          const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
          const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
          const myReady = isP1 ? gameState.player1Ready : gameState.player2Ready;
          const opponentReady = isP1 ? gameState.player2Ready : gameState.player1Ready;
          
          // Only update button if still in setup phase
          if (mainButton && isSetupPhase && (mainButton.textContent === 'Start Game' || mainButton.textContent === 'Waiting for opponent...')) {
            if (myReady && !opponentReady) {
              mainButton.textContent = 'Waiting for opponent...';
            } else if (!myReady) {
              mainButton.textContent = 'Start Game';
            }
          }
        }
        // DON'T set currentPlayer here - it's already set correctly from Firebase above
        // In online mode, currentPlayer should always come from Firebase gameState.currentPlayer
        // and be mapped to UI players. The current user is always UI player1.
        
        // Don't render hands if we're currently drawing them (to prevent overwriting)
        if (!isDrawingHands) {
        renderAllHands();
        } else {
          // Skipping renderAllHands (hands are being drawn)
        }
        updateDeckBubbles();
        updateHandBubbles();
        updateDiscardBubbles();
        updatePointsUI();
        updateTurnBox();
      }
    });
    
    // Listen for opponent actions
    import('./js/online/sync.js').then(module => {
      if (module.onAction) {
        module.onAction((action) => {
          // Handle action rejections for our own actions
          if (action.rejected && action.playerId === user.uid) {
            const handleValidationErrorFn = handleValidationError || globalThis.handleValidationError;
            if (handleValidationErrorFn) {
              handleValidationErrorFn(action.actionId || action.timestamp, action.rejectionReason);
            }
            return;
          }
          
          // Handle opponent actions
          if (action.playerId !== user.uid && action.actionType && action.actionData) {
            handleOpponentAction(action);
          }
        });
      }
    });
  } catch (error) {
    handleError(error, { context: 'initializing game' });
    throw error;
  }
}

// Handle opponent actions received from Firebase
async function handleOpponentAction(action) {
  const { actionType, actionData, timestamp, playerId } = action;
  const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
  const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
  
  // Create a unique key for this action to prevent duplicate processing
  const actionKey = `${actionType}-${playerId}-${timestamp || Date.now()}`;
  
  // Check if we've already processed this action
  if (processedActions.has(actionKey)) {
    // Skipping duplicate action
    return;
  }
  
  // Mark action as processed
  processedActions.add(actionKey);
  
  // Clean up old processed actions (older than 30 seconds)
  const now = Date.now();
  for (const key of Array.from(processedActions)) {
    if (key.includes('-')) {
      const parts = key.split('-');
      const actionTimestamp = parseInt(parts[parts.length - 1]);
      if (!isNaN(actionTimestamp) && now - actionTimestamp > 30000) {
        processedActions.delete(key);
      }
    }
  }
  
  console.log('Received opponent action:', { actionType, actionData, actionKey });
  
  try {
    switch (actionType) {
      case ACTION_TYPES.ATTACK:
        await handleOpponentAttack(actionData, isP1);
        break;
      case ACTION_TYPES.USE_ABILITY:
        await handleOpponentAbility(actionData, isP1);
        break;
      case ACTION_TYPES.PLAY_TRAINER:
        await handleOpponentTrainer(actionData, isP1);
        break;
      case ACTION_TYPES.ATTACH_ENERGY:
        console.log('Handling opponent energy attachment:', actionData);
        await handleOpponentEnergyAttachment(actionData, isP1, timestamp);
        break;
      case ACTION_TYPES.KNOCK_OUT:
        await handleOpponentKnockOut(actionData, isP1);
        break;
      case ACTION_TYPES.PROMOTE:
        await handleOpponentPromotion(actionData, isP1);
        break;
      case ACTION_TYPES.RETREAT:
        await handleOpponentRetreat(actionData, isP1);
        break;
      case ACTION_TYPES.EVOLVE:
        // Evolution is handled by handleOpponentTrainer when Rare Candy is used
        // For regular evolutions, they're handled through gameState updates
        console.log('Evolution action received (handled via gameState sync):', actionData);
        break;
      default:
        console.log('Unhandled action type:', actionType);
    }
  } catch (error) {
    console.error('Error handling opponent action:', error);
  }
}

// Handle opponent attack
async function handleOpponentAttack(actionData, isP1) {
  const { attacker, attack, target, knocked } = actionData;
  
  // Map match player to UI player
  const matchAttacker = attacker.owner;
  const uiAttacker = (isP1 && matchAttacker === 'player1') || (!isP1 && matchAttacker === 'player2')
    ? 'player1'
    : 'player2';
  const uiTarget = uiAttacker === 'player1' ? 'player2' : 'player1';
  
  // Find the attacker Pokemon
  const attackerPk = uiAttacker === 'player1' ? 'p1' : 'p2';
  const attackerImg = typeof getActiveImg === 'function' ? getActiveImg(attackerPk) : null;
  
  if (!attackerImg) {
    console.warn('Could not find attacker Pokemon for opponent attack');
    return;
  }
  
  // Apply damage to target
  const targetPk = uiTarget === 'player1' ? 'p1' : 'p2';
  let actualKnocked = knocked; // Use knocked from actionData as fallback
  if (typeof damageActiveOf === 'function' && attack.damage > 0) {
    const damageResult = await damageActiveOf(uiTarget, attack.damage, { attackerImg });
    // Use the actual knocked status from damageActiveOf result
    actualKnocked = damageResult.knocked || knocked;
  }
  
  // Show popup
  const attackerName = attackerImg.alt || attacker.name;
  showPopup(`${attackerName} used ${attack.name}${attack.damage > 0 ? ` for ${attack.damage} damage!` : '!'}`);
  
  // Handle knock out - check both actionData.knocked and actual result from damageActiveOf
  if (actualKnocked && typeof handleKnockOut === 'function' && typeof getActiveImage === 'function') {
    const foeImg = getActiveImage(targetPk);
    if (foeImg) {
      const ended = await handleKnockOut(uiTarget, foeImg);
      if (!ended && typeof beginPromotionFlow === 'function') {
        // Check if there are benched Pokemon before triggering promotion
        const benchDiv = uiTarget === 'player1' ? p1Bench : p2Bench;
        if (benchDiv) {
          const benchImgs = benchDiv.querySelectorAll('img');
          if (benchImgs.length > 0) {
            await beginPromotionFlow(uiTarget);
          }
        }
      }
    }
  }
}

// Handle opponent ability use
async function handleOpponentAbility(actionData, isP1) {
  const { owner, source, ability } = actionData;
  
  // Map match player to UI player
  const uiOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2')
    ? 'player1'
    : 'player2';
  
  // Show popup
  showPopup(`Opponent used ability: ${ability.name}`);
  
  // Find the source Pokemon and apply the ability effect
  const ownerPk = uiOwner === 'player1' ? 'p1' : 'p2';
  let sourceImg = null;
  
  // Try to find the source Pokemon by instanceId or set/num
  const activeArea = typeof activeFor === 'function' ? activeFor(uiOwner) : null;
  if (activeArea) {
    const activeSlot = activeArea.querySelector('.card-slot');
    const activeImg = activeSlot?.querySelector('img');
    if (activeImg && (
      activeImg.dataset.instanceId === source.instanceId ||
      (activeImg.dataset.set === source.set && String(activeImg.dataset.num) === String(source.num))
    )) {
      sourceImg = activeImg;
    }
  }
  
  // If not found in active, check bench
  if (!sourceImg) {
    const benchDiv = uiOwner === 'player1' ? p1Bench : p2Bench;
    if (benchDiv) {
      const benchImgs = benchDiv.querySelectorAll('img');
      for (const img of benchImgs) {
        if (img.dataset.instanceId === source.instanceId ||
            (img.dataset.set === source.set && String(img.dataset.num) === String(source.num))) {
          sourceImg = img;
          break;
        }
      }
    }
  }
  
  // Apply the ability effect if we found the source Pokemon
  if (sourceImg && typeof globalThis.applyAbilityEffectFromCsv === 'function') {
    try {
      // Get ability row from CSV
      const abilityRow = await getAbilityRow(source.set, source.num, ability.name);
      if (abilityRow) {
        const effectState = {
          p1: playerState.player1,
          p2: playerState.player2,
          activeFor,
          benchFor,
          opponentOf,
          fetchCardMeta,
          damageActiveOf,
          beginPromotionFlow,
          showPopup,
          logEvent,
          attachEnergyToSlot,
          energyZoneDiv,
          renderEnergyZone,
          getActiveImage
        };
        
        // Don't sync to Firebase since this is already from opponent's action
        const originalUpdate = globalThis.updateGameStatePartial;
        const originalBroadcast = globalThis.broadcastAction;
        globalThis.updateGameStatePartial = null; // Temporarily disable syncing
        globalThis.broadcastAction = null;
        
        await globalThis.applyAbilityEffectFromCsv(effectState, ownerPk, abilityRow, { abilityPokemon: sourceImg });
        
        globalThis.updateGameStatePartial = originalUpdate; // Restore
        globalThis.broadcastAction = originalBroadcast;
      }
    } catch (error) {
      console.error('Error applying opponent ability effect:', error);
    }
  }
}

// Handle opponent trainer play
async function handleOpponentTrainer(actionData, isP1) {
  const { owner, trainer, target } = actionData;
  
  // Map match player to UI player
  const uiOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2')
    ? 'player1'
    : 'player2';
  
  // Show popup
  const trainerType = trainer.type === 'supporter' ? 'Supporter' : trainer.type === 'item' ? 'Item' : 'Tool';
  showPopup(`Opponent played ${trainerType}: ${trainer.name}`);
  
  // Show trainer card animation for opponent's play
  const trainerCardSrc = highImgUrl(trainer.set, trainer.num) || 'imgs/cardback.png';
  const tempImg = document.createElement('img');
  tempImg.src = trainerCardSrc;
  tempImg.alt = trainer.name;
  showTrainerCardAnimation(tempImg, trainer.name);
  
  // Handle tool attachments
  if (trainer.type === 'tool' && target) {
    const ownerPk = uiOwner === 'player1' ? 'p1' : 'p2';
    let targetSlot = null;
    
    // Find the target Pokemon
    if (target.position === 'active') {
      const activeArea = typeof activeFor === 'function' ? activeFor(uiOwner) : null;
      if (activeArea) {
        targetSlot = activeArea.querySelector('.card-slot');
      }
    } else if (target.benchIndex !== undefined && target.benchIndex >= 0) {
      const benchDiv = uiOwner === 'player1' ? p1Bench : p2Bench;
      if (benchDiv) {
        const benchSlots = Array.from(benchDiv.querySelectorAll('.card-slot'));
        if (target.benchIndex < benchSlots.length) {
          targetSlot = benchSlots[target.benchIndex];
        }
      }
    }
    
    if (targetSlot) {
      const toolObj = {
        set: trainer.set,
        num: trainer.num,
        name: trainer.name,
        src: highImgUrl(trainer.set, trainer.num) || 'imgs/cardback.png'
      };
      
      // Attach the tool visually
      if (typeof attachToolToSlot === 'function') {
        // Don't sync to Firebase since this is already from opponent's action
        const originalBroadcast = globalThis.broadcastAction;
        globalThis.broadcastAction = null; // Temporarily disable syncing
        await attachToolToSlot(uiOwner, targetSlot, toolObj);
        globalThis.broadcastAction = originalBroadcast; // Restore
        
        // Apply tool HP effects if applicable (e.g., Giant's Cape)
        const isGiantCape = toolObj.set === 'A2' && toolObj.num === '147';
        const isLeafCape = toolObj.set === 'A3' && toolObj.num === '147';
        if (isGiantCape || isLeafCape) {
          const hpBonus = isGiantCape ? 20 : 30;
          const targetImg = targetSlot.querySelector('img');
          if (targetImg) {
            const baseHp = parseInt(targetImg.dataset.hp || '0', 10);
            const curHp = parseInt(targetImg.dataset.chp || baseHp, 10);
            const newMaxHp = baseHp + hpBonus;
            const newCurHp = curHp + hpBonus;
            
            targetSlot.dataset.maxHp = String(newMaxHp);
            targetImg.dataset.chp = String(newCurHp);
            
            if (typeof setHpOnImage === 'function') {
              setHpOnImage(targetImg, baseHp, newCurHp);
            }
          }
        }
      }
    }
  }
  
  // Handle supporter/item effects
  if ((trainer.type === 'supporter' || trainer.type === 'item') && trainer.effectType) {
    // [SABRINA] Special handling for force_opponent_switch - the opponent (this side) needs to see the selection glow
    if (trainer.effectType === 'force_opponent_switch') {
      // The opponent (this side) is the one who needs to switch
      // uiOwner is the player who used Sabrina, so the opponent is the other player
      const opponentOwner = uiOwner === 'player1' ? 'player2' : 'player1';
      
      console.log('[SABRINA-DEBUG] ===== SABRINA FORCED SWITCH START =====');
      console.log('[SABRINA-DEBUG] Player mapping:', {
        uiOwner,
        opponentOwner,
        isP1: typeof isCurrentPlayer1 === 'function' ? isCurrentPlayer1() : 'unknown'
      });
      
      console.log('[SABRINA-DEBUG] Function availability:', {
        hasBeginPromotionFlow: typeof beginPromotionFlow === 'function',
        hasBenchFor: typeof benchFor === 'function',
        benchForType: typeof benchFor
      });
      
      if (typeof beginPromotionFlow === 'function') {
        // Ensure the bench exists and has Pokemon
        const benchDiv = opponentOwner === 'player1' ? p1Bench : p2Bench;
        console.log('[SABRINA-DEBUG] Bench div lookup:', {
          opponentOwner,
          benchDivExists: !!benchDiv,
          benchDivId: benchDiv?.id,
          p1BenchExists: !!p1Bench,
          p2BenchExists: !!p2Bench
        });
        
        if (benchDiv) {
          const benchImgs = benchDiv.querySelectorAll('img');
          const benchImgArray = Array.from(benchImgs);
          console.log('[SABRINA-DEBUG] Bench Pokemon found:', {
            opponentOwner,
            count: benchImgs.length,
            pokemon: benchImgArray.map(img => ({
              alt: img.alt,
              hasPromoteGlow: img.classList.contains('promote-glow'),
              classes: Array.from(img.classList)
            }))
          });
          
          if (benchImgs.length > 0) {
            console.log('[SABRINA-DEBUG] Calling beginPromotionFlow for:', opponentOwner);
            // beginPromotionFlow will add the glow and wait for user selection
            // The glow will be visible while waiting for the user to click
            await beginPromotionFlow(opponentOwner);
            // Note: After beginPromotionFlow completes, the glow will have been removed
            // because the user has already made their selection. The glow check here
            // is just for debugging - the glow WAS visible while waiting.
            
            console.log('[SABRINA-DEBUG] beginPromotionFlow completed - user has made selection');
            
            showPopup('You must switch your Active Pokmon!');
          } else {
            console.warn('[SABRINA-DEBUG] No bench Pokemon found - cannot switch');
            showPopup('No Benched Pokmon to switch to.');
          }
        } else {
          console.error('[SABRINA-DEBUG] Bench div not found for:', opponentOwner);
        }
      } else {
        console.error('[SABRINA-DEBUG] beginPromotionFlow function not found');
      }
      console.log('[SABRINA-DEBUG] ===== SABRINA FORCED SWITCH END =====');
    } else {
      // Apply other trainer effects
    const effect = {
      effect_type: trainer.effectType,
      param1: trainer.param1,
      param2: trainer.param2,
      name: trainer.name
    };
    
    if (typeof applyTrainerEffect === 'function') {
      // Don't sync to Firebase since this is already from opponent's action
      const originalUpdate = globalThis.updateGameStatePartial;
      globalThis.updateGameStatePartial = null; // Temporarily disable syncing
      await applyTrainerEffect(effect, uiOwner, null, false);
      globalThis.updateGameStatePartial = originalUpdate; // Restore
    }
    }
  }
  
  // Update energy visuals after trainer effects to sync across both players
  if (typeof updateAllEnergyVisuals === 'function') {
    updateAllEnergyVisuals();
  }
}

// Handle opponent knock out
async function handleOpponentKnockOut(actionData, isP1) {
  const { owner, pokemon } = actionData;
  
  // Map match player to UI player
  const uiOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2')
    ? 'player1'
    : 'player2';
  
  // Find the knocked out Pokemon
  const activeArea = typeof activeFor === 'function' ? activeFor(uiOwner) : null;
  if (activeArea) {
    const activeSlot = activeArea.querySelector('.card-slot');
    const activeImg = activeSlot?.querySelector('img');
    
    // Check if the active Pokemon matches (by instanceId or by set/num if instanceId doesn't match)
    const shouldRemove = activeImg && (
      activeImg.dataset.instanceId === pokemon.instanceId ||
      (activeImg.dataset.set === pokemon.set && String(activeImg.dataset.num) === String(pokemon.num))
    );
    
    if (shouldRemove) {
      // Clear the active slot - remove ALL images to prevent duplicates
      const allImgs = activeSlot.querySelectorAll('img');
      for (const imgToRemove of allImgs) {
        imgToRemove.remove();
      }
      if (typeof markSlot === 'function') {
        markSlot(activeSlot, false);
      }
      
      // [POINTS-FIX] Don't update points here - the attacker's side already updated them
      // Only update globalThis.points to match what was synced from Firebase
      // The points should already be in Firebase from the attacker's handleKnockOut
      console.log('[POINTS-FIX] Opponent KO - skipping point update (attacker already updated)');
      
      // Move to discard (only if not already done by the attacker's side)
      // First, count energy from the active slot before it's cleared
      const activeSlotForEnergy = activeSlot;
      if (activeSlotForEnergy && activeImg) {
        const pips = countPipsOn(activeSlotForEnergy);
        Object.keys(pips).forEach(k => {
          if (k === 'total') return;
          if (!playerState[uiOwner].discard.energyCounts) {
            playerState[uiOwner].discard.energyCounts = {};
          }
          playerState[uiOwner].discard.energyCounts[k] = (playerState[uiOwner].discard.energyCounts[k] || 0) + pips[k];
        });
        
        // Sync energy discard to globalThis.playerState
        if (globalThis.playerState && globalThis.playerState[uiOwner]) {
          if (!globalThis.playerState[uiOwner].discard) {
            globalThis.playerState[uiOwner].discard = { cards: [], energyCounts: {} };
          }
          globalThis.playerState[uiOwner].discard.energyCounts = { ...playerState[uiOwner].discard.energyCounts };
        }
      }
      
      if (typeof moveCardToDiscard === 'function') {
        // Create a temporary img element for discard
        const tempImg = document.createElement('img');
        tempImg.dataset.set = pokemon.set;
        tempImg.dataset.num = pokemon.num;
        tempImg.alt = pokemon.name;
        tempImg.dataset.instanceId = pokemon.instanceId;
        // Attach to a temporary slot so moveCardToDiscard can find it
        const tempSlot = document.createElement('div');
        tempSlot.className = 'card-slot';
        tempSlot.appendChild(tempImg);
        moveCardToDiscard(uiOwner, tempImg);
      }
      
      // Sync discard to Firebase after moveCardToDiscard
      const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
      const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
      const isOnline = matchId && window.firebaseDatabase;
      if (isOnline && typeof updateGameStatePartial === 'function') {
        const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
        const isP1 = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
        const matchPlayer = (isP1 && uiOwner === 'player1') || (!isP1 && uiOwner === 'player2') 
          ? 'player1' 
          : 'player2';
        
        (async () => {
          try {
            await updateGameStatePartial({
              [`${matchPlayer}/discard`]: {
                cards: [...(playerState[uiOwner].discard.cards || [])],
                energyCounts: { ...(playerState[uiOwner].discard.energyCounts || {}) }
              }
            });
            console.log('Synced opponent KO discard to Firebase:', {
              matchPlayer,
              cards: playerState[uiOwner].discard.cards.length,
              energyCounts: playerState[uiOwner].discard.energyCounts
            });
          } catch (error) {
            console.error('Error syncing opponent KO discard to Firebase:', error);
          }
        })();
      }
      
      // Trigger promotion flow for the owner of the knocked out Pokemon
      if (typeof beginPromotionFlow === 'function') {
        const benchDiv = uiOwner === 'player1' ? p1Bench : p2Bench;
        if (benchDiv) {
          const benchImgs = benchDiv.querySelectorAll('img');
          if (benchImgs.length > 0) {
            // Only trigger promotion if there are benched Pokemon
            await beginPromotionFlow(uiOwner);
          }
        }
      }
      
      console.log('Handled opponent KO:', {
        uiOwner,
        pokemonName: pokemon.name
      });
    }
  }
}

// Handle opponent promotion
async function handleOpponentPromotion(actionData, isP1) {
  const { owner, promoted, benched } = actionData;
  
  // Map match player to UI player
  const uiOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2')
    ? 'player1'
    : 'player2';
  
  const activeArea = typeof activeFor === 'function' ? activeFor(uiOwner) : null;
  if (activeArea && promoted) {
    const activeSlot = activeArea.querySelector('.card-slot');
    
    // Find the promoted Pokemon on bench
    const benchDiv = uiOwner === 'player1' ? p1Bench : p2Bench;
    if (benchDiv) {
      const benchSlots = Array.from(benchDiv.querySelectorAll('.card-slot'));
      let promotedSlot = null;
      let promotedImg = null;
      
      for (const slot of benchSlots) {
        const img = slot.querySelector('img');
        if (img && img.dataset.instanceId === promoted.instanceId) {
          promotedSlot = slot;
          promotedImg = img;
          break;
        }
      }
      
      if (promotedImg && promotedSlot) {
        // [PROMOTION-DUPLICATE-FIX] Clear active slot completely to prevent duplicates
        const existingImgs = activeSlot.querySelectorAll('img');
        for (const existingImg of existingImgs) {
          existingImg.remove();
        }
        // [PROMOTION-DUPLICATE-FIX] Clear all attachments from both slots before moving to prevent duplicates
        const existingEnergy = activeSlot.querySelector('.energy-pips');
        const existingTool = activeSlot.querySelector('.tool-thumb');
        const existingHp = activeSlot.querySelector('.hp-overlay');
        const benchToolThumb = promotedSlot.querySelector('.tool-thumb');
        const benchEnergyPips = promotedSlot.querySelector('.energy-pips');
        
        if (existingEnergy) existingEnergy.remove();
        if (existingTool) existingTool.remove();
        if (existingHp) existingHp.remove();
        if (benchToolThumb && benchToolThumb.parentNode === promotedSlot) {
          benchToolThumb.remove();
        }
        if (benchEnergyPips && benchEnergyPips.parentNode === promotedSlot) {
          benchEnergyPips.remove();
        }
        
        // Move promoted Pokemon to active
        const benchPack = typeof detachAttachments === 'function' ? detachAttachments(promotedSlot) : {};
        
        // [PROMOTION-DUPLICATE-FIX] Remove promoted Pokemon from bench slot
        if (promotedImg && promotedImg.parentNode === promotedSlot) {
        promotedSlot.removeChild(promotedImg);
        }
        
        // [PROMOTION-DUPLICATE-FIX] Clear bench slot to prevent duplicates
        const benchImgs = promotedSlot.querySelectorAll('img');
        for (const benchImg of benchImgs) {
          if (benchImg !== promotedImg && benchImg.parentNode === promotedSlot) {
            benchImg.remove();
          }
        }
        
        // [PROMOTION-DUPLICATE-FIX] Clear activeSlot completely before appending to prevent duplicates
        const allActiveImgs = activeSlot.querySelectorAll('img');
        for (const img of allActiveImgs) {
          if (img !== promotedImg && img.parentNode === activeSlot) {
            img.remove();
          }
        }
        
        // [PROMOTION-DUPLICATE-FIX] Only append if not already in activeSlot
        if (promotedImg && promotedImg.parentNode !== activeSlot) {
        activeSlot.appendChild(promotedImg);
        }
        
        if (typeof attachAttachments === 'function') {
          attachAttachments(activeSlot, benchPack);
        }
        
        // [PROMOTION-DUPLICATE-FIX] Clear bench slot after moving to prevent duplicates
        const remainingBenchImgs = promotedSlot.querySelectorAll('img');
        for (const img of remainingBenchImgs) {
          if (img !== promotedImg && img.parentNode === promotedSlot) {
            img.remove();
          }
        }
        
        // Note: If there was an old active Pokemon, it should have been KO'd and moved to discard
        // We don't need to handle it here - the KO handler already took care of it
        
        if (typeof markSlot === 'function') {
          markSlot(activeSlot, true);
          markSlot(promotedSlot, !!promotedSlot.querySelector('img'));
        }
        
        // Update playerState.bench immediately for opponent
        if (playerState[uiOwner] && !playerState[uiOwner].bench) {
          playerState[uiOwner].bench = [];
        }
        const benchArray = Array.from(benchDiv.querySelectorAll('.card-slot img'))
          .filter(img => img.dataset.set && img.dataset.num) // Filter out empty slots
          .map(img => ({
            set: img.dataset.set,
            num: img.dataset.num,
            name: img.alt,
            instanceId: img.dataset.instanceId,
            hp: parseInt(img.dataset.hp || '0', 10),
            playedTurn: parseInt(img.dataset.playedTurn || '0', 10)
          }));
        playerState[uiOwner].bench = benchArray;
        
        // Sync globalThis.playerState
        if (globalThis.playerState && globalThis.playerState[uiOwner]) {
          globalThis.playerState[uiOwner].bench = [...benchArray];
        }
        
        // Update background color
        const playerNum = activeArea === p1Active ? 1 : 2;
        if (typeof updatePlayerTypeBackground === 'function') {
          updatePlayerTypeBackground(playerNum);
        }
        
        console.log('[ISSUE-5] Opponent promotion handled:', {
          uiOwner,
          promotedName: promoted.name
        });
        
        // Update energy visuals after promotion to sync across both players
        if (typeof updateAllEnergyVisuals === 'function') {
          updateAllEnergyVisuals();
        }
      }
    }
  }
}

// Handle opponent retreat
async function handleOpponentRetreat(actionData, isP1) {
  console.log('[RETREAT-ENERGY-DEBUG] handleOpponentRetreat CALLED', {
    actionData,
    isP1,
    hasOwner: !!actionData.owner,
    hasPromoted: !!actionData.promoted,
    hasRetreated: !!actionData.retreated
  });
  
  const { owner, retreated, promoted, energyDiscarded } = actionData;
  
  // Map match player to UI player
  const uiOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2')
    ? 'player1'
    : 'player2';
  
  console.log('[RETREAT-ENERGY-DEBUG] Mapped players', {
    owner,
    uiOwner,
    isP1
  });
  
  const activeArea = typeof activeFor === 'function' ? activeFor(uiOwner) : null;
  console.log('[RETREAT-ENERGY-DEBUG] Active area check', {
    hasActiveArea: !!activeArea,
    hasPromoted: !!promoted,
    willProceed: !!(activeArea && promoted)
  });
  
  if (activeArea && promoted) {
    console.log('[RETREAT-ENERGY-DEBUG] Entered main retreat handler block');
    const activeSlot = activeArea.querySelector('.card-slot');
    const benchDiv = uiOwner === 'player1' ? p1Bench : p2Bench;
    
    console.log('[RETREAT-ENERGY-DEBUG] Found elements', {
      hasActiveSlot: !!activeSlot,
      hasBenchDiv: !!benchDiv,
      uiOwner,
      promotedInstanceId: promoted.instanceId,
      p1BenchExists: typeof p1Bench !== 'undefined',
      p2BenchExists: typeof p2Bench !== 'undefined'
    });
    
    if (!benchDiv) {
      console.error('[RETREAT-ENERGY-DEBUG] ERROR: benchDiv is null!', {
        uiOwner,
        p1Bench: typeof p1Bench !== 'undefined' ? !!p1Bench : 'undefined',
        p2Bench: typeof p2Bench !== 'undefined' ? !!p2Bench : 'undefined'
      });
      return;
    }
    
    if (benchDiv) {
      // Find the promoted Pokemon on bench
      const benchSlots = Array.from(benchDiv.querySelectorAll('.card-slot'));
      let promotedSlot = null;
      let promotedImg = null;
      
      console.log('[RETREAT-ENERGY-DEBUG] Searching bench for promoted Pokemon', {
        benchSlotCount: benchSlots.length,
        lookingForInstanceId: promoted.instanceId
      });
      
      for (const slot of benchSlots) {
        const img = slot.querySelector('img');
        if (img) {
          const matchesById = img.dataset.instanceId === promoted.instanceId;
          const matchesByCard = img.dataset.set === promoted.set && String(img.dataset.num) === String(promoted.num);
          console.log('[RETREAT-ENERGY-DEBUG] Checking bench slot', {
            instanceId: img.dataset.instanceId,
            name: img.alt,
            set: img.dataset.set,
            num: img.dataset.num,
            matchesById,
            matchesByCard,
            promotedSet: promoted.set,
            promotedNum: promoted.num
          });
          
          // Try to match by instanceId first, then by set/num as fallback
          if (matchesById || matchesByCard) {
          promotedSlot = slot;
          promotedImg = img;
            console.log('[RETREAT-ENERGY-DEBUG] Found promoted Pokemon', {
              matchedBy: matchesById ? 'instanceId' : 'set/num',
              instanceId: img.dataset.instanceId,
              name: img.alt
            });
          break;
        }
        }
      }
      
      console.log('[RETREAT-ENERGY-DEBUG] Promoted Pokemon search result', {
        foundPromotedImg: !!promotedImg,
        foundPromotedSlot: !!promotedSlot,
        promotedImgName: promotedImg?.alt
      });
      
      if (!promotedImg || !promotedSlot) {
        // Check if the promoted Pokemon is already in the active slot (maybe it was already promoted)
        const activeImg = activeSlot.querySelector('img');
        const isAlreadyActive = activeImg && activeImg.dataset.instanceId === promoted.instanceId;
        
        if (isAlreadyActive) {
          console.log('[RETREAT-ENERGY-DEBUG] Promoted Pokemon is already active, handling energy removal (this is expected in some cases)');
          // The promoted Pokemon is already active, so we just need to:
          // 1. Remove energy from the active slot (it should have been discarded for retreat)
          // 2. Move the retreated Pokemon to bench if it exists
          
          const activeEnergyContainer = activeSlot.querySelector('.energy-pips');
          if (activeEnergyContainer) {
            const pipCount = activeEnergyContainer.querySelectorAll('.energy-pip').length;
            console.log('[RETREAT-ENERGY-DEBUG] Removing energy from already-active promoted Pokemon', {
              pipCount,
              energyTypes: Array.from(activeEnergyContainer.querySelectorAll('.energy-pip')).map(p => p.dataset.type)
            });
            activeEnergyContainer.remove();
          }
          
          // Find the retreated Pokemon - it should be on bench or we need to move it there
          if (retreated) {
            let retreatedImg = null;
            let retreatedSlot = null;
            
            // Check if retreated Pokemon is on bench
            for (const slot of benchSlots) {
              const img = slot.querySelector('img');
              if (img && img.dataset.instanceId === retreated.instanceId) {
                retreatedImg = img;
                retreatedSlot = slot;
                break;
              }
            }
            
            // If retreated Pokemon is not on bench, it might still be in active (shouldn't happen but handle it)
            if (!retreatedImg && activeImg && activeImg.dataset.instanceId === retreated.instanceId) {
              console.log('[RETREAT-ENERGY-DEBUG] Retreated Pokemon is still in active, this is unexpected');
            }
            
            // Remove energy from retreated Pokemon if found
            if (retreatedSlot) {
              const retreatedEnergyContainer = retreatedSlot.querySelector('.energy-pips');
              if (retreatedEnergyContainer) {
                console.log('[RETREAT-ENERGY-DEBUG] Removing energy from retreated Pokemon on bench');
                retreatedEnergyContainer.remove();
              }
            }
          }
          
          // Update energy visuals
          if (typeof updateAllEnergyVisuals === 'function') {
            updateAllEnergyVisuals();
          }
          
          return;
        }
        
        // If not found and not already active, we can't proceed
        return;
      }
      
      if (promotedImg && promotedSlot) {
        console.log('[RETREAT-ENERGY-DEBUG] Starting retreat swap process');
        const activeImg = activeSlot.querySelector('img');
        
        // [ISSUE-2: ENERGY VISUAL REMOVAL] Handle energy discard from retreat BEFORE swapping
        // Use the retreatCost and energyDiscarded from action data
        if (actionData.retreatCost > 0) {
          const retreatCost = actionData.retreatCost || 0;
          // Use energyDiscarded from action data if available, otherwise try to read from DOM
          const energyTypesDiscarded = actionData.energyDiscarded || {};
          
          // Find the retreated Pokemon's slot (it's currently in active before swap)
          const retreatedSlot = activeSlot;
          const energyPipsContainer = retreatedSlot.querySelector('.energy-pips');
          
          // Remove energy pips from DOM if available
          if (energyPipsContainer) {
            const pips = Array.from(energyPipsContainer.querySelectorAll('.energy-pip:not(.phantom-pip)'));
            
            // Remove pips based on energyDiscarded data
            let removedCount = 0;
            for (const [energyType, count] of Object.entries(energyTypesDiscarded)) {
              for (let i = 0; i < count && removedCount < retreatCost && removedCount < pips.length; i++) {
                // Find a pip of this energy type
                const matchingPip = pips.find(p => (p.dataset.type || 'colorless').toLowerCase() === energyType);
                if (matchingPip) {
                  matchingPip.remove();
                  removedCount++;
                }
              }
            }
            
            // If we still need to remove more, remove any remaining pips
            const remainingPips = Array.from(energyPipsContainer.querySelectorAll('.energy-pip:not(.phantom-pip)'));
            for (let i = 0; i < (retreatCost - removedCount) && i < remainingPips.length; i++) {
              const energyType = (remainingPips[i].dataset.type || 'colorless').toLowerCase();
              if (!energyTypesDiscarded[energyType]) {
                energyTypesDiscarded[energyType] = 0;
              }
              energyTypesDiscarded[energyType]++;
              remainingPips[i].remove();
            }
            
            // Also remove phantom pips if any
            const phantomPips = Array.from(energyPipsContainer.querySelectorAll('.energy-pip.phantom-pip'));
            for (let i = 0; i < retreatCost && i < phantomPips.length; i++) {
              phantomPips[i].remove();
            }
            
            // If no pips remain, remove the energy container
            const remainingPipsAfter = energyPipsContainer.querySelectorAll('.energy-pip');
            if (remainingPipsAfter.length === 0) {
              energyPipsContainer.remove();
            }
          } else if (Object.keys(energyTypesDiscarded).length === 0) {
            // Fallback: if no energyDiscarded data and no container, use generic counting
            energyTypesDiscarded['colorless'] = retreatCost;
          }
          
          // Mark slot to prevent double counting
          if (retreatedSlot) {
            retreatedSlot.dataset.energyCounted = 'true';
          }
          
          // Add energy to discard
          if (!playerState[uiOwner].discard.energyCounts) {
            playerState[uiOwner].discard.energyCounts = {};
          }
          for (const [energyType, count] of Object.entries(energyTypesDiscarded)) {
            playerState[uiOwner].discard.energyCounts[energyType] = 
              (playerState[uiOwner].discard.energyCounts[energyType] || 0) + count;
          }
          
          // Sync to globalThis.playerState
          if (globalThis.playerState && globalThis.playerState[uiOwner]) {
            if (!globalThis.playerState[uiOwner].discard) {
              globalThis.playerState[uiOwner].discard = { cards: [], energyCounts: {} };
            }
            if (!globalThis.playerState[uiOwner].discard.energyCounts) {
              globalThis.playerState[uiOwner].discard.energyCounts = {};
            }
            for (const [energyType, count] of Object.entries(energyTypesDiscarded)) {
              globalThis.playerState[uiOwner].discard.energyCounts[energyType] =
                (globalThis.playerState[uiOwner].discard.energyCounts[energyType] || 0) + count;
            }
          }
          
          // Sync discard to Firebase
          (async () => {
            if (typeof updateGameStatePartial === 'function') {
              const getCurrentMatchIdFn = getCurrentMatchId || globalThis.getCurrentMatchId;
              const matchId = getCurrentMatchIdFn ? getCurrentMatchIdFn() : null;
              const isOnline = matchId && window.firebaseDatabase;
              if (isOnline) {
                const isCurrentPlayer1Fn = isCurrentPlayer1 || globalThis.isCurrentPlayer1;
                const isP1Local = (isCurrentPlayer1Fn && typeof isCurrentPlayer1Fn === 'function') ? isCurrentPlayer1Fn() : false;
                const matchPlayer = (isP1Local && uiOwner === 'player1') || (!isP1Local && uiOwner === 'player2') 
                  ? 'player1' 
                  : 'player2';
                try {
                  await updateGameStatePartial({
                    [`${matchPlayer}/discard`]: playerState[uiOwner].discard
                  });
                } catch (error) {
                  console.error('Error syncing opponent retreat energy discard to Firebase:', error);
                }
              }
            }
          })();
          
          // Update discard bubbles
          if (typeof updateDiscardBubbles === 'function') {
            updateDiscardBubbles();
          }
        }
        
        // Swap active and bench
        // IMPORTANT: Remove energy from activeSlot (retreated Pokemon) BEFORE detaching attachments
        // The retreated Pokemon's energy was discarded, so remove it from DOM before swapping
        console.log('[RETREAT-ENERGY-DEBUG] Step 1: Before removing energy from DOM', {
          activeSlot: activeSlot ? {
            hasEnergyContainer: !!activeSlot.querySelector('.energy-pips'),
            energyPipsCount: activeSlot.querySelectorAll('.energy-pip').length,
            pokemon: activeImg?.alt
          } : null,
          promotedSlot: promotedSlot ? {
            hasEnergyContainer: !!promotedSlot.querySelector('.energy-pips'),
            energyPipsCount: promotedSlot.querySelectorAll('.energy-pip').length,
            pokemon: promotedImg?.alt
          } : null
        });
        
        if (activeSlot) {
          const activeEnergyContainer = activeSlot.querySelector('.energy-pips');
          if (activeEnergyContainer) {
            const pipCount = activeEnergyContainer.querySelectorAll('.energy-pip').length;
            console.log('[RETREAT-ENERGY-DEBUG] Step 2: Removing energy from activeSlot (retreated Pokemon)', {
              pipCount,
              energyTypes: Array.from(activeEnergyContainer.querySelectorAll('.energy-pip')).map(p => p.dataset.type)
            });
            activeEnergyContainer.remove();
          }
        }
        
        // Also remove energy from promotedSlot (new active) if it has any
        if (promotedSlot) {
          const promotedEnergyContainer = promotedSlot.querySelector('.energy-pips');
          if (promotedEnergyContainer) {
            const pipCount = promotedEnergyContainer.querySelectorAll('.energy-pip').length;
            console.log('[RETREAT-ENERGY-DEBUG] Step 3: Removing energy from promotedSlot (promoted Pokemon)', {
              pipCount,
              energyTypes: Array.from(promotedEnergyContainer.querySelectorAll('.energy-pip')).map(p => p.dataset.type)
            });
            promotedEnergyContainer.remove();
          }
        }
        
        // Detach attachments AFTER removing energy so tools are preserved but energy is not
        const activePack = activeImg && typeof detachAttachments === 'function' ? detachAttachments(activeSlot) : {};
        const benchPack = typeof detachAttachments === 'function' ? detachAttachments(promotedSlot) : {};
        
        console.log('[RETREAT-ENERGY-DEBUG] Step 4: After detachAttachments', {
          activePack: {
            hasEnergy: !!activePack.energy,
            energyIsNull: activePack.energy === null,
            energyType: activePack.energy?.constructor?.name,
            energyPipCount: activePack.energy ? activePack.energy.querySelectorAll('.energy-pip').length : 0,
            hasTool: !!activePack.toolThumb
          },
          benchPack: {
            hasEnergy: !!benchPack.energy,
            energyIsNull: benchPack.energy === null,
            energyType: benchPack.energy?.constructor?.name,
            energyPipCount: benchPack.energy ? benchPack.energy.querySelectorAll('.energy-pip').length : 0,
            hasTool: !!benchPack.toolThumb
          }
        });
        
        // CRITICAL: Explicitly clear energy from both packs to prevent re-attachment
        // The retreated Pokemon's energy was discarded, so it should NOT be re-attached
        activePack.energy = null;
        // The promoted Pokemon should not have energy (it's from bench), but clear it just in case
        benchPack.energy = null;
        
        console.log('[RETREAT-ENERGY-DEBUG] Step 5: After clearing energy from packs', {
          activePackEnergy: activePack.energy,
          benchPackEnergy: benchPack.energy
        });
        
        // Ensure no duplicate tool thumbs
        if (activePack && activePack.toolThumb) {
          const existingTool = promotedSlot.querySelector('.tool-thumb');
          if (existingTool && existingTool !== activePack.toolThumb) {
            existingTool.remove();
        }
        }
        if (benchPack && benchPack.toolThumb) {
          const existingTool = activeSlot.querySelector('.tool-thumb');
          if (existingTool && existingTool !== benchPack.toolThumb) {
            existingTool.remove();
          }
        }
        
        // Clear any existing images from slots before swapping to prevent duplicates
        const existingActiveImgs = activeSlot.querySelectorAll('img');
        const existingPromotedImgs = promotedSlot.querySelectorAll('img');
        
        console.log('[RETREAT-ENERGY-DEBUG] Clearing existing images', {
          activeSlotImgCount: existingActiveImgs.length,
          promotedSlotImgCount: existingPromotedImgs.length
        });
        
        // Remove all images from activeSlot
        existingActiveImgs.forEach(img => {
          if (img.parentNode === activeSlot) {
            img.remove();
          }
        });
        
        // Remove all images from promotedSlot
        existingPromotedImgs.forEach(img => {
          if (img.parentNode === promotedSlot) {
            img.remove();
          }
        });
        
        // [RETREAT-DUPLICATE-FIX] Clear promotedSlot completely before appending to prevent duplicates
        const allPromotedImgs = promotedSlot.querySelectorAll('img');
        for (const img of allPromotedImgs) {
          if (img !== activeImg && img.parentNode === promotedSlot) {
            promotedSlot.removeChild(img);
          }
        }
        
        if (activeImg) {
          // Only append if not already in promotedSlot
          if (activeImg.parentNode !== promotedSlot) {
          promotedSlot.appendChild(activeImg);
          }
          console.log('[RETREAT-ENERGY-DEBUG] Step 6: Before attaching activePack to promotedSlot', {
            activePackEnergy: activePack.energy,
            promotedSlotHasEnergy: !!promotedSlot.querySelector('.energy-pips'),
            promotedSlotImgCount: promotedSlot.querySelectorAll('img').length
          });
          if (typeof attachAttachments === 'function') {
            attachAttachments(promotedSlot, activePack);
          }
          console.log('[RETREAT-ENERGY-DEBUG] Step 7: After attaching activePack to promotedSlot', {
            promotedSlotHasEnergy: !!promotedSlot.querySelector('.energy-pips'),
            energyPipCount: promotedSlot.querySelectorAll('.energy-pip').length,
            promotedSlotImgCount: promotedSlot.querySelectorAll('img').length
          });
        }
        
        // Clear activeSlot completely before appending promotedImg to prevent duplicates
        const allActiveImgs = activeSlot.querySelectorAll('img');
        for (const img of allActiveImgs) {
          if (img !== promotedImg && img.parentNode === activeSlot) {
            img.remove();
          }
        }
        
        if (promotedImg) {
          // Only append if not already in activeSlot
          if (promotedImg.parentNode !== activeSlot) {
        activeSlot.appendChild(promotedImg);
          }
          console.log('[RETREAT-ENERGY-DEBUG] After appending promotedImg to activeSlot', {
            activeSlotImgCount: activeSlot.querySelectorAll('img').length,
            promotedImgParent: promotedImg.parentNode === activeSlot
          });
        }
        console.log('[RETREAT-ENERGY-DEBUG] Step 8: Before attaching benchPack to activeSlot', {
          benchPackEnergy: benchPack.energy,
          benchPackEnergyIsNull: benchPack.energy === null,
          benchPackEnergyIsUndefined: benchPack.energy === undefined,
          benchPackEnergyType: typeof benchPack.energy,
          activeSlotHasEnergy: !!activeSlot.querySelector('.energy-pips')
        });
        
        // CRITICAL: Double-check that benchPack.energy is null before attaching
        if (benchPack.energy !== null) {
          console.error('[RETREAT-ENERGY-DEBUG] ERROR: benchPack.energy is not null! Forcing to null.', {
            value: benchPack.energy,
            type: typeof benchPack.energy
          });
          benchPack.energy = null;
        }
        
        if (typeof attachAttachments === 'function') {
          attachAttachments(activeSlot, benchPack);
        }
        console.log('[RETREAT-ENERGY-DEBUG] Step 9: After attaching benchPack to activeSlot', {
          activeSlotHasEnergy: !!activeSlot.querySelector('.energy-pips'),
          energyPipCount: activeSlot.querySelectorAll('.energy-pip').length,
          energyTypes: Array.from(activeSlot.querySelectorAll('.energy-pip')).map(p => p.dataset.type)
        });
        
        // CRITICAL: Remove energy from new active AFTER attaching to ensure it's not re-added
        // The promoted Pokemon should NOT have energy (it was discarded for retreat)
        const newActiveEnergyContainer = activeSlot.querySelector('.energy-pips');
        if (newActiveEnergyContainer) {
          const pipCount = newActiveEnergyContainer.querySelectorAll('.energy-pip').length;
          console.log('[RETREAT-ENERGY-DEBUG] Step 10: Removing energy from new active (found energy container!)', {
            pipCount,
            energyTypes: Array.from(newActiveEnergyContainer.querySelectorAll('.energy-pip')).map(p => p.dataset.type)
          });
          newActiveEnergyContainer.remove();
        } else {
          console.log('[RETREAT-ENERGY-DEBUG] Step 10: No energy container found on new active (good!)');
        }
        
        // Also ensure the retreated Pokemon (now on bench) doesn't have energy
        const newBenchEnergyContainer = promotedSlot.querySelector('.energy-pips');
        if (newBenchEnergyContainer) {
          const pipCount = newBenchEnergyContainer.querySelectorAll('.energy-pip').length;
          console.log('[RETREAT-ENERGY-DEBUG] Step 11: Removing energy from new bench (found energy container!)', {
            pipCount,
            energyTypes: Array.from(newBenchEnergyContainer.querySelectorAll('.energy-pip')).map(p => p.dataset.type)
          });
          newBenchEnergyContainer.remove();
        } else {
          console.log('[RETREAT-ENERGY-DEBUG] Step 11: No energy container found on new bench (good!)');
        }
        
        // Final check for duplicates and energy
        const finalActiveImgs = activeSlot.querySelectorAll('img');
        const finalPromotedImgs = promotedSlot.querySelectorAll('img');
        const finalActiveEnergy = activeSlot.querySelector('.energy-pips');
        const finalBenchEnergy = promotedSlot.querySelector('.energy-pips');
        
        console.log('[RETREAT-ENERGY-DEBUG] Step 12: FINAL CHECK', {
          newActiveImgCount: finalActiveImgs.length,
          newPromotedImgCount: finalPromotedImgs.length,
          newActiveHasEnergy: !!finalActiveEnergy,
          newActivePipCount: finalActiveEnergy ? finalActiveEnergy.querySelectorAll('.energy-pip').length : 0,
          newBenchHasEnergy: !!finalBenchEnergy,
          newBenchPipCount: finalBenchEnergy ? finalBenchEnergy.querySelectorAll('.energy-pip').length : 0,
          newActivePokemon: promotedImg?.alt,
          newBenchPokemon: activeImg?.alt
        });
        
        // Remove duplicates if any exist
        if (finalActiveImgs.length > 1) {
          console.error('[RETREAT-ENERGY-DEBUG] ERROR: Duplicate images found on active slot!', {
            count: finalActiveImgs.length,
            pokemon: Array.from(finalActiveImgs).map(img => img.alt)
          });
          // Keep only the first image (should be promotedImg)
          for (let i = 1; i < finalActiveImgs.length; i++) {
            finalActiveImgs[i].remove();
          }
        }
        
        if (finalPromotedImgs.length > 1) {
          console.error('[RETREAT-ENERGY-DEBUG] ERROR: Duplicate images found on promoted slot (bench)!', {
            count: finalPromotedImgs.length,
            pokemon: Array.from(finalPromotedImgs).map(img => img.alt)
          });
          // Keep only the first image (should be activeImg/retreated Pokemon)
          for (let i = 1; i < finalPromotedImgs.length; i++) {
            finalPromotedImgs[i].remove();
          }
        }
        
        // Update energy visuals to sync across both players
        if (typeof updateAllEnergyVisuals === 'function') {
          console.log('[RETREAT-ENERGY-DEBUG] Step 13: Before calling updateAllEnergyVisuals', {
            newActiveHasEnergy: !!activeSlot.querySelector('.energy-pips'),
            newActivePipCount: activeSlot.querySelectorAll('.energy-pip').length
          });
          updateAllEnergyVisuals();
          console.log('[RETREAT-ENERGY-DEBUG] Step 14: After calling updateAllEnergyVisuals', {
            newActiveHasEnergy: !!activeSlot.querySelector('.energy-pips'),
            newActivePipCount: activeSlot.querySelectorAll('.energy-pip').length,
            newActiveEnergyTypes: Array.from(activeSlot.querySelectorAll('.energy-pip')).map(p => p.dataset.type)
          });
        }
        
        // Final safety check - remove energy if it somehow appeared
        const finalCheckActiveEnergy = activeSlot.querySelector('.energy-pips');
        if (finalCheckActiveEnergy) {
          const finalPipCount = finalCheckActiveEnergy.querySelectorAll('.energy-pip').length;
          console.error('[RETREAT-ENERGY-DEBUG] ERROR: Energy still present on new active after all operations!', {
            pipCount: finalPipCount,
            energyTypes: Array.from(finalCheckActiveEnergy.querySelectorAll('.energy-pip')).map(p => p.dataset.type),
            pokemon: promotedImg?.alt
          });
          // Remove it as a last resort
          finalCheckActiveEnergy.remove();
          console.log('[RETREAT-ENERGY-DEBUG] Step 15: Removed energy as last resort');
        }
        
        if (typeof markSlot === 'function') {
          markSlot(activeSlot, true);
          markSlot(promotedSlot, !!promotedSlot.querySelector('img'));
        }
        
        // Update playerState.bench immediately for opponent
        if (playerState[uiOwner] && !playerState[uiOwner].bench) {
          playerState[uiOwner].bench = [];
        }
        const benchArray = Array.from(benchDiv.querySelectorAll('.card-slot img'))
          .filter(img => img.dataset.set && img.dataset.num) // Filter out empty slots
          .map(img => ({
            set: img.dataset.set,
            num: img.dataset.num,
            name: img.alt,
            instanceId: img.dataset.instanceId,
            hp: parseInt(img.dataset.hp || '0', 10),
            playedTurn: parseInt(img.dataset.playedTurn || '0', 10)
          }));
        playerState[uiOwner].bench = benchArray;
        
        // Sync globalThis.playerState
        if (globalThis.playerState && globalThis.playerState[uiOwner]) {
          globalThis.playerState[uiOwner].bench = [...benchArray];
        }
        
        // Update background color
        const playerNum = activeArea === p1Active ? 1 : 2;
        if (typeof updatePlayerTypeBackground === 'function') {
          updatePlayerTypeBackground(playerNum);
        }
        
        console.log('Handled opponent retreat:', {
          uiOwner,
          promotedName: promoted.name
        });
      }
    }
  }
}

// Handle opponent energy attachment
async function handleOpponentEnergyAttachment(actionData, isP1, actionTimestamp = null) {
  const { owner, target, energy } = actionData;
  
  // Map match player to UI player
  const uiOwner = (isP1 && owner === 'player1') || (!isP1 && owner === 'player2')
    ? 'player1'
    : 'player2';
  
  // Find the target Pokemon
  const ownerPk = uiOwner === 'player1' ? 'p1' : 'p2';
  let targetSlot = null;
  
  // uiOwner is correctly mapped - it represents the opponent's Pokemon in UI terms
  // Since this is handleOpponentEnergyAttachment, owner is the opponent in match terms
  // The mapping should result in uiOwner = 'player2' (opponent is always UI player2, top)
  // But let's verify the mapping is correct and add logging
  
  console.log('Energy attachment player mapping:', {
    isP1,
    matchOwner: owner,
    uiOwner,
    targetPosition: target.position,
    targetBenchIndex: target.benchIndex
  });
  
  if (target.position === 'active') {
    const activeArea = typeof activeFor === 'function' ? activeFor(uiOwner) : null;
    if (activeArea) {
      targetSlot = activeArea.querySelector('.card-slot');
      console.log('Found active slot for energy attachment:', {
        uiOwner,
        targetSlot: !!targetSlot,
        activeArea: !!activeArea
      });
    } else {
      console.warn('Could not find activeArea for energy attachment:', uiOwner);
    }
  } else if (target.benchIndex !== undefined) {
    const benchDiv = uiOwner === 'player1' ? p1Bench : p2Bench;
    if (benchDiv) {
      const benchSlots = Array.from(benchDiv.querySelectorAll('.card-slot'));
      targetSlot = benchSlots[target.benchIndex];
      console.log('Found bench slot for energy attachment:', {
        uiOwner,
        benchIndex: target.benchIndex,
        benchSlotsLength: benchSlots.length,
        targetSlot: !!targetSlot
      });
    } else {
      console.warn('Could not find benchDiv for energy attachment:', uiOwner);
    }
  } else {
    console.warn('Invalid target position for energy attachment:', target);
  }
  
  if (targetSlot) {
    const img = targetSlot.querySelector('img');
    if (img) {
      // Try to match by instanceId first, but also try by set/num if instanceId doesn't match
      const matchesById = img.dataset.instanceId && target.instanceId && img.dataset.instanceId === target.instanceId;
      const matchesByCard = img.dataset.set === target.set && String(img.dataset.num) === String(target.num);
      
      console.log('Checking energy attachment match:', {
        imgInstanceId: img.dataset.instanceId,
        targetInstanceId: target.instanceId,
        imgSet: img.dataset.set,
        imgNum: img.dataset.num,
        targetSet: target.set,
        targetNum: target.num,
        matchesById,
        matchesByCard,
        position: target.position
      });
      
      if (matchesById || matchesByCard) {
        // Add energy pip visually
        let box = targetSlot.querySelector('.energy-pips');
        if (!box) {
          box = document.createElement('div');
          box.className = 'energy-pips';
          targetSlot.appendChild(box);
        }
        
        // Count existing energy pips of this type to avoid duplicates
        const existingPips = Array.from(box.querySelectorAll('.energy-pip'));
        const existingCount = existingPips.filter(pip => pip.dataset.type === energy.type).length;
        
        // Add energy pip - the action deduplication is handled at the handleOpponentAction level
        // So we can safely add the pip here
        const pip = document.createElement('div');
        pip.className = 'energy-pip';
        pip.dataset.type = energy.type;
        pip.style.backgroundImage = `url('${ENERGY_ICONS[energy.type] || ''}')`;
        box.appendChild(pip);
        
        console.log('Added energy pip for opponent:', {
          energyType: energy.type,
          targetName: img.alt,
          position: target.position,
          existingCount: existingPips.length,
          newCount: existingPips.length + 1
        });
      } else {
        console.warn('Could not match target Pokemon for energy attachment:', {
          imgInstanceId: img.dataset.instanceId,
          targetInstanceId: target.instanceId,
          imgSet: img.dataset.set,
          imgNum: img.dataset.num,
          targetSet: target.set,
          targetNum: target.num
        });
      }
    }
  }
  
  showPopup(`Opponent attached ${energy.type} Energy`);
}

// Initialize auth and set up listener
// Ensure Firebase is loaded first
function initializeAuth() {
  if (!window.firebaseAuth) {
    console.error('Firebase Auth not initialized');
    setTimeout(initializeAuth, 100);
    return;
  }
  
  const authInit = initAuth || globalThis.initAuth;
  const authStateChanged = onAuthStateChanged || globalThis.onAuthStateChanged;
  
  if (typeof authInit === 'function') {
    authInit();
  } else {
    console.error('initAuth is not available');
    return;
  }
  
  if (typeof authStateChanged === 'function') {
    authStateChanged((user) => {
      if (user) {
        if (lobbyScreen) lobbyScreen.style.display = 'flex';
      } else {
        window.location.href = 'index.html';
      }
    });
  } else {
    console.error('onAuthStateChanged is not available');
  }
}

// Wait for DOM and Firebase to be ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeAuth);
} else {
  initializeAuth();
}

const urlParams = new URLSearchParams(window.location.search);
const matchIdParam = urlParams.get('matchId');
if (matchIdParam) {
  const getUserFn = getCurrentUser || globalThis.getCurrentUser;
  if (getUserFn) {
    const user = getUserFn();
    if (user) {
      currentMatchId = matchIdParam;
      initializeGame(matchIdParam).then(() => {
        if (lobbyScreen) lobbyScreen.style.display = 'none';
      });
    }
  }
}
</script>
</body>
</html>