<!-- UPDATED: 1765141943.5356314 - All ability bugs fixed -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pok√©mon TCG Pocket Battle</title>
<link rel="icon" type="image/png" href="https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Pok%C3%A9_Ball_icon.svg/768px-Pok%C3%A9_Ball_icon.svg.png?20161023215848"/>
<style>
:root{--card-w:75px;--card-h:105px}

/* ============================================
   MISSING KEYFRAMES ANIMATIONS
============================================ */

/* Coin flip animation */
@keyframes flipCoin {
  0% {
    transform: rotateY(0deg);
  }
  100% {
    transform: rotateY(1800deg);
  }
}

/* Damage flash animation */
@keyframes damageFlash {
  0% {
    filter: brightness(1);
    box-shadow: 0 0 0 rgba(239, 68, 68, 0);
  }
  50% {
    filter: brightness(1.8) saturate(1.5);
    box-shadow: 0 0 30px rgba(239, 68, 68, 1);
    border-color: #ef4444;
  }
  100% {
    filter: brightness(1);
    box-shadow: 0 0 0 rgba(239, 68, 68, 0);
  }
}

/* Glow pulse animation */
@keyframes glowPulse {
  0% {
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.4);
    border-color: rgba(0, 212, 255, 0.6);
  }
  50% {
    box-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
    border-color: rgba(0, 212, 255, 1);
  }
  100% {
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.4);
    border-color: rgba(0, 212, 255, 0.6);
  }
}

/* Evolution glow animation */
@keyframes evoGlow {
  0% {
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.6);
    border-color: rgba(34, 197, 94, 0.8);
    filter: brightness(1.1);
  }
  50% {
    box-shadow: 0 0 40px rgba(34, 197, 94, 1);
    border-color: rgba(34, 197, 94, 1);
    filter: brightness(1.3);
  }
  100% {
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.6);
    border-color: rgba(34, 197, 94, 0.8);
    filter: brightness(1.1);
  }
}

/* Promotion glow animation */
@keyframes promoteGlow {
  0% {
    box-shadow: 0 0 20px rgba(168, 85, 247, 0.6);
    border-color: rgba(168, 85, 247, 0.8);
    filter: brightness(1.1);
  }
  50% {
    box-shadow: 0 0 40px rgba(168, 85, 247, 1);
    border-color: rgba(168, 85, 247, 1);
    filter: brightness(1.3);
  }
  100% {
    box-shadow: 0 0 20px rgba(168, 85, 247, 0.6);
    border-color: rgba(168, 85, 247, 0.8);
    filter: brightness(1.1);
  }
}

/* Popup slide animation */
@keyframes popupSlide {
  0% {
    opacity: 0;
    transform: translate(-50%, -100%);
  }
  10% {
    opacity: 1;
    transform: translate(-50%, -50%);
  }
  90% {
    opacity: 1;
    transform: translate(-50%, -50%);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -50%);
  }
}

/* Nebula pulse for background (if used) */
@keyframes nebulaPulse {
  0%, 100% {
    opacity: 0.3;
  }
  50% {
    opacity: 0.6;
  }
}

/* Twinkle for stars (if used) */
@keyframes twinkle {
  0%, 100% {
    opacity: 0.3;
  }
  50% {
    opacity: 1;
  }
}


body{
  font-family:'Segoe UI',Arial,sans-serif;
  background:linear-gradient(135deg, #0a0a1a 0%, #1a0f2e 50%, #2d1b4e 100%);
  background-size: 200% 200%;
  animation: backgroundShift 30s ease infinite;
  margin:0;
  padding:0;
  color:#e5e7eb;
  height:100vh;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  align-items:center;
  background-attachment:fixed;
  position: relative;
}

@keyframes backgroundShift {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

/* Subtle particle overlay */
body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: 
    radial-gradient(circle at 20% 30%, rgba(0, 212, 255, 0.08) 0%, transparent 50%),
    radial-gradient(circle at 80% 70%, rgba(227, 53, 13, 0.08) 0%, transparent 50%),
    radial-gradient(circle at 50% 50%, rgba(138, 43, 226, 0.05) 0%, transparent 70%);
  animation: particleFloat 25s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

@keyframes particleFloat {
  0%, 100% { opacity: 0.5; transform: translate(0, 0) scale(1); }
  33% { opacity: 0.7; transform: translate(20px, -20px) scale(1.1); }
  66% { opacity: 0.6; transform: translate(-20px, 20px) scale(0.9); }
}
h1{
  margin:0;
  width:100%;
  padding:.4rem 0;
  text-align:center;
  background:linear-gradient(135deg,#e3350d,#0074d9);
  color:#fff;
  font-size:1.05rem;
  letter-spacing:.2px;
}
.main-layout{
  display:flex;
  justify-content:center;
  align-items:center;
  width:100%;
  height:calc(100vh - 52px);
  position:relative;
  z-index:1;
}
.battlefield{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:space-evenly;
  max-width:850px !important;
  width:100%;
  height:95%;
  transform-origin:center center;
  transform:scale(0.92);
}
.player-area{
  transition: background 0.6s ease, box-shadow 0.6s ease, border-color 0.6s ease, min-height 0.3s ease !important;
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  padding:6px 0;
  position:relative;
  z-index:1;
  min-height: fit-content;
}
/* Drag and drop styles */
.card-slot.drag-target {
  border: 2px dashed #6e4e9c;
  background: rgba(110, 78, 156, 0.1);
}

.card-slot.drag-over {
  border: 2px solid #9d7dd4;
  background: rgba(157, 125, 212, 0.2);
  transform: scale(1.05);
}

.hand .card-img[draggable="true"] {
  cursor: grab;
}

.hand .card-img[draggable="true"]:active {
  cursor: grabbing;
}

.hand,.bench,.active{
  display:flex;
  justify-content:center;
  gap:8px;
  flex-wrap:wrap;
  position:relative;
}
.bench,.active{
  min-height:calc(var(--card-h) + 6px);
}
.card-slot{
  width:var(--card-w);
  height:var(--card-h);
  border-radius:8px;
  background:rgba(20, 20, 30, 0.65);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:10px;
  color:#a1a1aa;
  box-shadow:0 1px 3px rgba(0,0,0,.5);
  position:relative;
  flex-shrink:0;
  border:2px solid rgba(138, 43, 226, 0.3);
  backdrop-filter:blur(8px);
  transition: all 0.3s ease;
}

.card-slot:hover {
  border-color: rgba(138, 43, 226, 0.6);
  box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4), 0 0 20px rgba(138, 43, 226, 0.2);
  background: rgba(20, 20, 30, 0.8);
}
.slot-label{
  position:absolute;
  inset:auto 0 6px 0;
  text-align:center;
  font-weight:700;
  background:rgba(0,0,0,.7);
  color:#fff;
  border-radius:12px;
  line-height:1;
  padding:3px 8px;
  width:70px;
  margin:auto;
  font-size:10px;
  pointer-events:none;
}
/* HP Badge for cards with modified HP */
.hp-badge {
  position: absolute;
  top: 4px;
  right: 4px;
  background: rgba(239, 68, 68, 0.95);
  color: #fff;
  font-weight: 700;
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 8px;
  pointer-events: none;
  z-index: 10;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  border: 1px solid rgba(255, 255, 255, 0.2);
}
.hp-badge.tool-boosted {
  background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
  animation: pulse-green 2s ease-in-out infinite;
}
@keyframes pulse-green {
  0%, 100% { box-shadow: 0 2px 4px rgba(0,0,0,0.3), 0 0 0 0 rgba(34, 197, 94, 0.7); }
  50% { box-shadow: 0 2px 4px rgba(0,0,0,0.3), 0 0 0 4px rgba(34, 197, 94, 0); }
}
.card-img{
  width:var(--card-w);
  height:var(--card-h);
  object-fit:contain;
  border-radius:6px;
  cursor:pointer;
  transition:all .3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), left 0.4s cubic-bezier(0.4, 0, 0.2, 1), top 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  z-index:2;
  position:relative;
  transform:perspective(700px) rotateX(0deg);
  transform-style: preserve-3d;
  will-change: transform;
}

/* Smooth card movement animations */
.card-img.moving {
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 100;
}

@keyframes cardSlideIn {
  from {
    opacity: 0;
    transform: perspective(700px) rotateX(0deg) translateY(-20px) scale(0.9);
  }
  to {
    opacity: 1;
    transform: perspective(700px) rotateX(0deg) translateY(0) scale(1);
  }
}

.card-img.just-added {
  animation: cardSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

/* 3D tilt effect on hover - must override base transforms */
.card-img:hover {
  transform: perspective(700px) rotateX(5deg) rotateY(5deg) translateZ(10px) scale(1.05) !important;
  box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4), 0 0 40px rgba(138, 43, 226, 0.3) !important;
  filter: brightness(1.1);
  z-index: 1;
}
.active .card-img{
  border:3px solid #00d4ff !important;
  box-shadow:0 0 8px rgba(255,215,0,.6);
  transform:perspective(700px) rotateX(12deg);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.active .card-img:hover {
  transform: perspective(700px) rotateX(8deg) rotateY(5deg) translateZ(15px) scale(1.08) !important;
  box-shadow: 0 12px 35px rgba(0, 212, 255, 0.5), 0 0 50px rgba(255, 215, 0, 0.4) !important;
  z-index: 1;
}
.bench .card-img{
  transform:perspective(700px) rotateX(6deg);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.bench .card-img:hover {
  transform: perspective(700px) rotateX(4deg) rotateY(5deg) translateZ(12px) scale(1.06) !important;
  box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4), 0 0 40px rgba(138, 43, 226, 0.3) !important;
  z-index: 1;
}
.hand .card-img{
  transform:perspective(700px) rotateX(3deg);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.hand .card-img:hover {
  transform: perspective(700px) rotateX(2deg) rotateY(5deg) translateZ(10px) scale(1.05) !important;
  box-shadow: 0 8px 25px rgba(0, 212, 255, 0.4), 0 0 35px rgba(138, 43, 226, 0.3) !important;
  z-index: 1;
}
/* Pokemon Communication selection glow */
.poke-comm-glow {
  animation: poke-comm-pulse 1.5s ease-in-out infinite;
  box-shadow: 0 0 20px rgba(59, 130, 246, 0.8), 0 0 40px rgba(59, 130, 246, 0.4) !important;
  border: 2px solid #3b82f6 !important;
}
@keyframes poke-comm-pulse {
  0%, 100% { transform: perspective(700px) rotateX(3deg) scale(1); }
  50% { transform: perspective(700px) rotateX(3deg) scale(1.05); }
}
#p1Active,#p1Bench{
  outline:1.5px solid #4da3ff;
  outline-offset:3px;
  border-radius:5px;
}
#p2Active,#p2Bench{
  outline:1.5px solid #ff6b6b;
  outline-offset:3px;
  border-radius:5px;
}
.deck-bubble{
  position:absolute;
  width:32px;
  height:32px;
  border-radius:50%;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  font-weight:700;
  font-size:12px;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 2px 6px rgba(0,0,0,.5);
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  transition: all 0.3s ease;
  cursor: pointer;
  z-index: 100;
}

.deck-bubble:hover {
  transform: scale(1.15);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.5), 0 0 20px rgba(0, 212, 255, 0.3);
  border-color: rgba(0, 212, 255, 0.6) !important;
  background: rgba(40, 40, 50, 1) !important;
}
#p1Bubble{
  left:-40px;top:50%;transform:translateY(-50%);
}
#p2Bubble{
  right:-40px;top:50%;transform:translateY(-50%);
}

/* Visual Deck Stack */
.deck-stack {
  position: absolute;
  width: 60px;
  height: 84px;
  perspective: 1000px;
}

#p1DeckStack {
  right: 20px;
  bottom: 20px;
  transform: none;
}

#p2DeckStack {
  left: 20px;
  top: 20px;
  transform: none;
}

.deck-card {
  position: absolute;
  width: 60px;
  height: 84px;
  background-image: url('imgs/cardback.png');
  background-size: cover;
  background-position: center;
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(100, 100, 120, 0.3);
  transition: transform 0.3s ease, opacity 0.3s ease;
}

.deck-card:nth-child(1) { transform: translateY(0px) rotate(0deg); z-index: 10; }
.deck-card:nth-child(2) { transform: translateY(2px) rotate(0.5deg); z-index: 9; opacity: 0.95; }
.deck-card:nth-child(3) { transform: translateY(4px) rotate(-0.5deg); z-index: 8; opacity: 0.9; }
.deck-card:nth-child(4) { transform: translateY(6px) rotate(0.3deg); z-index: 7; opacity: 0.85; }
.deck-card:nth-child(5) { transform: translateY(8px) rotate(-0.3deg); z-index: 6; opacity: 0.8; }
.deck-card:nth-child(n+6) { transform: translateY(10px) rotate(0deg); z-index: 5; opacity: 0.75; }

.deck-stack.shuffling .deck-card {
  animation: deckShuffle 0.6s ease-in-out;
}

@keyframes deckShuffle {
  0%, 100% { transform: translateY(0) rotate(0deg); }
  25% { transform: translateY(-5px) rotate(2deg); }
  50% { transform: translateY(5px) rotate(-2deg); }
  75% { transform: translateY(-3px) rotate(1deg); }
}

/* Card draw animation */
.card-draw-animation {
  position: fixed;
  width: 60px;
  height: 84px;
  background-image: url('imgs/cardback.png');
  background-size: cover;
  background-position: center;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
  border: 1px solid rgba(100, 100, 120, 0.5);
  z-index: 10000;
  pointer-events: none;
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}
.points-indicator{
  position:absolute;
  top:calc(50% + 26px);
  transform:translateY(-50%);
  display:flex;
  gap:6px;
  align-items:center;
  z-index:5;
  filter:brightness(1.1) !important;
}
#p1Points{
  right:4px;transform:translateX(50%);
}
#p2Points{
  left:4px;transform:translateX(-50%);
}
.point-bubble{
  width:14px;
  height:14px;
  border-radius:50%;
  border:1.5px solid #94a3b8;
  background:rgba(40, 40, 50, 0.8) !important;
  box-shadow:0 0 4px rgba(0,0,0,.5);
  transition:background .25s,border-color .25s,box-shadow .25s;
  border-color:rgba(100, 100, 120, 0.5) !important;
}
.point-bubble.filled{
  background:#facc15 !important;
  border-color:#fde047 !important;
  box-shadow:0 0 8px 2px rgba(250, 204, 21, 0.7) !important;
}
.energy-zone{
  display:flex !important;
  flex-wrap:wrap;
  gap:6px !important;
  justify-content:center;
  background:rgba(40, 40, 50, 0.96) !important;
  backdrop-filter:blur(20px);
  border-radius:12px !important;
  padding:10px !important;
  z-index:200 !important;
  position:fixed !important;
  pointer-events:all !important;
  visibility:visible !important;
  left:50% !important;
  transform:translateX(-50%) !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  bottom:60px !important;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4), 0 0 20px rgba(0, 212, 255, 0.2) !important;
  transition: all 0.3s ease;
}

.energy-zone:hover {
  border-color: rgba(0, 212, 255, 0.5) !important;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 30px rgba(0, 212, 255, 0.3) !important;
  background: rgba(40, 40, 50, 1) !important;
}
/* General .energy rule - will be overridden by .energy-container > .energy for energy zone */
.energy{
  width:30px !important;
  height:30px !important;
  border-radius:50% !important;
  background-size:contain !important;
  background-position:center !important;
  cursor:pointer !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  box-shadow:0 2px 6px rgba(0, 0, 0, 0.3) !important;
  background-repeat:no-repeat !important;
  transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
  position: relative;
}

/* Energy zone specific - more specific selector to override general .energy */
.energy-zone .energy-container > .energy {
  width: 36px !important;
  height: 36px !important;
  background-size: cover !important;
}

.energy:hover {
  transform: scale(1.2) rotate(5deg) !important;
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.5), 0 0 20px rgba(0, 212, 255, 0.3) !important;
  border-color: rgba(0, 212, 255, 0.6) !important;
  z-index: 1;
}
.energy-pips{
  position:absolute;
  left:3px;
  bottom:3px;
  height:16px;
  display:flex;
  gap:2px;
  z-index:5;
}
.energy-pip{
  width:16px;
  height:16px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #1f2937;
}
.status-icon{
  position:absolute;
  left:4px;
  top:4px;
  width:20px;
  height:20px;
  border-radius:50%;
  background-size:contain;
  background-repeat:no-repeat;
  background-position:center;
  pointer-events:none;
  z-index:6;
}
.zoom-status{
  width:22px;
  height:22px;
  border-radius:50%;
  background-size:contain;
  background-repeat:no-repeat;
  background-position:center;
  flex-shrink:0;
}
.zoom-status-icon{
  width:22px;
  height:22px;
  border-radius:50%;
  background-size:contain;
  background-position:center;
  background-repeat:no-repeat;
  flex-shrink:0;
}
.hp-overlay{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom:22px;
  min-width:72px;
  text-align:center;
  background:rgba(0,0,0,.85);
  color:#fff;
  font-weight:800;
  font-size:10px;
  padding:2px 8px;
  border-radius:12px;
  z-index:5;
  line-height:1;
  white-space:nowrap;
  pointer-events:none;
  transition: all 0.3s ease;
  box-shadow: 0 2px 8px rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
}

.hp-overlay:hover {
  transform: translateX(-50%) scale(1.1);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.4);
}
.tool-thumb{
  position:absolute;
  top:30px;
  left:6px;
  width:34px;
  height:44px;
  border-radius:4px;
  box-shadow:0 2px 6px rgba(0,0,0,.6);
  border:1px solid #111827;
  background-color:#0b0f14;
  z-index:5;
  cursor:pointer;
  object-fit:cover;
  object-position:center 15%;
  clip-path:inset(15% 5% 45% 5%);
  transition:transform .15s ease;
}
#zoomTools img{
  width:88px;
  height:108px;
  border-radius:8px;
  border:1px solid #444;
  object-fit:cover;
  object-position:center 15%;
  clip-path:inset(15% 10% 45% 10%);
  box-shadow:0 0 8px rgba(0,0,0,.4);
  margin-top:0 !important;
}
#zoomTools{
  display:flex;
  align-items:center;
  gap:10px;
  padding:0 !important;
}
.side-panel{
  position:fixed;
  top:20px;
  right:20px;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:.6rem;
  z-index:10;
}
.coin{
  width:70px;
  height:70px;
  position:relative;
  transform-style:preserve-3d;
  transition:transform 1.5s ease-in-out;
}
.coin img{
  width:100%;
  height:100%;
  border-radius:50%;
  position:absolute;
  backface-visibility:hidden;
}
.coin .back{
  transform:rotateY(180deg);
}
.coin.flip{
  animation:flipCoin 1.5s ease-in-out;
  transform-style: preserve-3d;
}

.coin.flip .front,
.coin.flip .back {
  animation: coinSpin 1.5s ease-in-out;
}

@keyframes coinSpin {
  0% { transform: rotateY(0deg); }
  100% { transform: rotateY(1800deg); }
}
#coinResult{
  text-align:center;
  font-weight:700;
  font-size:13px;
  min-height:35px;
}
button{
  background:linear-gradient(135deg,#e3350d,#0074d9);
  color:#fff;
  border:1px solid #1f2937;
  padding:8px 14px;
  border-radius:10px;
  cursor:pointer;
  font-size:.9rem;
  transition:transform 0.15s ease, box-shadow 0.15s ease;
  position: relative;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  transform: translateY(0);
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4), 0 6px 20px rgba(227, 53, 13, 0.4);
}

button:active {
  transform: translateY(-1px) scale(0.98);
  box-shadow: 0 3px 10px rgba(0,0,0,0.4);
  transition: transform 0.1s ease, box-shadow 0.1s ease;
}

/* Ripple effect */
button::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: translate(-50%, -50%);
  transition: width 0.4s ease-out, height 0.4s ease-out, opacity 0.4s ease-out;
  opacity: 0;
  pointer-events: none;
}

button:active::after {
  width: 300px;
  height: 300px;
  opacity: 1;
}
.turnbox{
  width:150px;
  border:1px solid #3b3f46;
  background:#23272e;
  border-radius:12px;
  padding:10px;
  text-align:center;
  font-size:.92rem;
  box-shadow:0 1px 3px rgba(0,0,0,.4);
  color:#e5e7eb;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.turnbox::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(227, 53, 13, 0.1));
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

.turnbox:hover::before {
  opacity: 1;
}

.turnbox:hover {
  border-color: rgba(0, 212, 255, 0.5);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
  transform: translateY(-2px);
}
.turnbox .big{
  font-weight:800;
  font-size:1.05rem;
}
#popup{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%) scale(0.8);
  background:linear-gradient(135deg, rgba(17,17,17,0.95) 0%, rgba(30,30,40,0.95) 100%);
  color:#fff;
  padding:12px 20px;
  border-radius:12px;
  font-size:14px;
  font-weight:800;
  opacity:0;
  z-index:200;
  transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 8px 32px rgba(0,0,0,0.5), 0 0 20px rgba(0, 212, 255, 0.3);
  border: 1px solid rgba(0, 212, 255, 0.3);
  backdrop-filter: blur(10px);
}
#popup.show{
  opacity:1;
  transform:translate(-50%,-50%) scale(1);
  animation: popupBounce 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}
@keyframes popupBounce {
  0% { transform: translate(-50%,-50%) scale(0.3); opacity: 0; }
  50% { transform: translate(-50%,-50%) scale(1.1); }
  100% { transform: translate(-50%,-50%) scale(1); opacity: 1; }
}
.disable-clicks{
  pointer-events:none;
  filter:saturate(.9) brightness(.98);
}
.glow-evo{
  animation:evoGlow 1.5s ease-in-out infinite !important;
  outline:3px solid rgba(255,215,0,.95);
  border-radius:8px;
  cursor:pointer;
  filter:drop-shadow(0 0 6px rgba(255,215,0,.85));
  border:3px solid #ffd700 !important;
}
.promote-glow{
  animation:glowPulse .9s ease-in-out infinite alternate;
  outline:3px solid rgba(59,130,246,.95);
  border-radius:8px;
}
.attack-menu{
  position:fixed !important;
  /* left and top will be set by JavaScript */
  background:rgba(255, 255, 255, 0.98) !important;
  border:1px solid #3b3f46;
  border-radius:12px !important;
  box-shadow:0 14px 38px rgba(0,0,0,.5);
  padding:18px !important;
  min-width:280px !important;
  z-index:1000 !important;
  opacity:0;
  color:#e5e7eb;
  backdrop-filter:blur(20px);
  width:280px !important;
  overflow-y:auto !important;
  /* Don't set default transform - let JavaScript handle it */
  transform-origin: center center;
}
.attack-menu.show{
  opacity:1;
  /* Don't override transform here - JavaScript handles positioning */
}

@keyframes menuSlideIn {
  0% {
    opacity: 0;
    transform: translateY(-10px) scale(0.9);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}
.attack-item{
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  gap:8px;
  padding:14px 16px !important;
  border-radius:10px !important;
  cursor:pointer;
  background:linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%) !important;
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  color:#ffffff !important;
  min-height:52px;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.attack-item:hover {
  transform: translateX(4px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.attack-item.payable{
  background:rgba(0, 212, 255, 0.15) !important;
  border-color:#00d4ff !important;
}

.attack-item.payable:hover {
  background:rgba(0, 212, 255, 0.25) !important;
  box-shadow: 0 4px 16px rgba(0, 212, 255, 0.4);
  transform: translateX(4px) scale(1.02);
}
.attack-name{
  font-size:14px !important;
  font-weight:700 !important;
  color:#ffffff !important;
  line-height:1.2 !important;
  margin-right:8px !important;
  flex-shrink:0 !important;
}
.attack-cost{
  display:flex !important;
  gap:2px !important;
  margin-right:8px !important;
}
.cost-icon{
  width:16px;
  height:18px !important;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
  margin:0 1px !important;
}
.cost-icon.missing{
  filter:grayscale(100%) brightness(50%);
}
.damage-flash{
  animation:damageFlash 0.4s ease-out !important;
}
.zoom-backdrop{
  position:fixed;
  inset:0;
  background:rgba(0, 0, 0, 0.88) !important;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:3000 !important;
  backdrop-filter:blur(10px);
}
.zoom-backdrop.show{
  display:flex;
}
.zoom-modal{
  display:flex;
  gap:18px;
  align-items:flex-start;
  max-width:1180px;
  animation: zoomModalAppear 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes zoomModalAppear {
  0% {
    opacity: 0;
    transform: scale(0.8) translateY(20px);
  }
  100% {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.zoom-modal img{
  width:calc(var(--card-w) * 4);
  height:auto;
  border-radius:14px;
  box-shadow:0 18px 48px rgba(0,0,0,.65);
  background:#111;
  transition: transform 0.3s ease;
}

.zoom-modal img:hover {
  transform: scale(1.02);
}
.zoom-panel{
  min-width:470px;
  max-width:520px;
  background:rgba(30, 30, 40, 0.98) !important;
  border:1px solid #3b3f46;
  border-radius:18px !important;
  box-shadow:0 10px 28px rgba(0,0,0,.45);
  padding:16px;
  color:#e5e7eb !important;
  backdrop-filter:blur(20px);
  max-height:90vh !important;
  overflow-y:auto !important;
}
.zoom-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:10px;
}
.zoom-title{
  font-weight:700 !important;
  font-size:22px !important;
  color:#ffffff !important;
}
.zoom-hp{
  font-size:12px;
  color:#ffffff !important;
}
.zoom-type{
  width:24px;
  height:24px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
}
.hpbar-container{
  width:100%;
  height:12px;
  background:#2f343c;
  border-radius:8px;
  overflow:hidden;
  margin:8px 0 6px;
}
.hpbar-fill{
  height:100%;
  width:0;
  border-radius:8px;
  transition:width .4s cubic-bezier(0.4, 0, 0.2, 1), background .3s ease;
  background:linear-gradient(90deg,#22c55e,#16a34a);
  position: relative;
  overflow: hidden;
}

.hpbar-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  animation: hpbarShine 2s ease-in-out infinite;
}

@keyframes hpbarShine {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}
.zoom-section{
  border-top:1px solid #3b3f46;
  margin-top:12px;
  padding-top:12px;
  opacity:1 !important;
  margin-bottom:20px !important;
}
.row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  margin:4px 0;
}
.chip{
  font-size:12px;
  background:#2a2f36;
  border:1px solid #3b3f46;
  border-radius:999px;
  padding:2px 8px;
  color:#e5e7eb;
}
.icon-row{
  display:flex;
  gap:6px;
  align-items:center;
  flex-wrap:wrap;
}
.mini-icon{
  width:18px;
  height:18px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
  display:inline-block;
}
.mini-badge{
  font-size:11px;
  color:#cbd5e1;
  margin-left:4px;
}
.zoom-attack{
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  padding:16px !important;
  margin:10px 0;
  cursor:pointer;
  transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
  background:rgba(50, 50, 60, 0.8) !important;
  margin-bottom:12px !important;
  position: relative;
}

.zoom-attack:hover {
  transform: translateX(4px);
  border-color: rgba(0, 212, 255, 0.6) !important;
  box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
  background: rgba(50, 50, 60, 0.95) !important;
}
.zoom-attack .dmg {
  font-size:16px !important;
  font-weight:800 !important;
  color:#000000 !important; /* Default black, can be overridden by inline styles */
  transition: all 0.3s ease;
  text-shadow: 0 1px 3px rgba(0,0,0,0.5);
  display: inline-block;
}

.zoom-attack:hover .dmg {
  transform: scale(1.15);
  /* text-shadow and color are set by inline styles based on boost type */
  /* Only enhance the existing text-shadow on hover, don't override color */
}

.zoom-attack .top{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
  border-radius:10px;
  padding:8px 10px;
}
.zoom-attack .name{
  font-weight:800;
}
.zoom-attack .dmg{
  font-weight:900;
}
.thin{
  height:1px;
  background:#3b3f46;
  margin:8px 0;
}
.effect{
  font-size:12px;
  color:#cbd5e1;
  line-height:1.25;
}
.muted{
  opacity:.45;cursor:not-allowed;
}
.mini-icon.missing{
  filter:grayscale(100%) brightness(65%);
}
.discard-btn{
  position:absolute;
  left:12px;
  top:50%;
  transform:translateY(-50%);
  z-index:9;
}
.discard-btn.right{
  left:auto;
  right:12px;
}
.discard-drawer{
  position:fixed;
  top:0;
  bottom:0;
  width:320px;
  background:linear-gradient(180deg, #1a1e24 0%, #0f1216 100%);
  right:0;
  left:auto;
  border-left:2px solid rgba(0, 212, 255, 0.3);
  box-shadow:-20px 0 40px rgba(0,0,0,.7), 0 0 30px rgba(0, 212, 255, 0.1);
  z-index:1200;
  padding:20px;
  display:none;
  overflow:auto;
  color:#e5e7eb;
  backdrop-filter: blur(20px);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  transform: translateX(100%);
}

.discard-drawer.show {
  transform: translateX(0);
}

.discard-drawer::-webkit-scrollbar {
  width: 8px;
}

.discard-drawer::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}

.discard-drawer::-webkit-scrollbar-thumb {
  background: rgba(0, 212, 255, 0.4);
  border-radius: 4px;
}

.discard-drawer::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 212, 255, 0.6);
}

/* Player 1 drawer - positioned normally on right */
#p1DiscardDrawer {
  z-index: 1201;
}

/* Player 2 drawer - positioned slightly to the left when both are open */
#p2DiscardDrawer {
  z-index: 1200;
}

/* Stacking handled by JavaScript updateDiscardDrawerPositions() */

.discard-drawer.show{
  display:block;
  animation: drawerSlideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes drawerSlideInRight {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.discard-item{
  display:flex;
  align-items:center;
  gap:12px;
  margin:12px 0;
  padding:10px;
  background:rgba(30, 34, 42, 0.6);
  border-radius:12px;
  border:1px solid rgba(100, 100, 120, 0.2);
  transition: all 0.2s ease;
}

.discard-item:hover {
  background:rgba(40, 44, 52, 0.8);
  border-color: rgba(0, 212, 255, 0.4);
  transform: translateX(4px);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
}

.discard-item img{
  width:65px;
  height:91px;
  border-radius:10px;
  box-shadow:0 8px 20px rgba(0,0,0,.6), 0 0 15px rgba(0, 212, 255, 0.2);
  transition: all 0.3s ease;
  border: 2px solid rgba(100, 100, 120, 0.3);
}

.discard-item:hover img {
  transform: scale(1.05) rotate(2deg);
  box-shadow: 0 10px 25px rgba(0,0,0,.7), 0 0 20px rgba(0, 212, 255, 0.3);
  border-color: rgba(0, 212, 255, 0.5);
}

.discard-group{
  display:flex;
  align-items:center;
  gap:12px;
  flex-wrap: wrap;
}

.discard-count{
  font-weight:800;
  color:#ffffff;
  background:linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(138, 43, 226, 0.2));
  border:1px solid rgba(0, 212, 255, 0.4);
  border-radius:999px;
  padding:4px 12px;
  box-shadow: 0 2px 8px rgba(0, 212, 255, 0.2);
  font-size: 13px;
}
#victoryOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.68);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
  backdrop-filter: blur(8px);
  animation: fadeInOverlay 0.4s ease;
}

@keyframes fadeInOverlay {
  from { opacity: 0; }
  to { opacity: 1; }
}

#victoryCard{
  width:min(540px,92vw);
  background:#101418;
  border:1px solid #334155;
  border-radius:16px;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
  padding:22px;
  color:#e5e7eb;
  text-align:center;
  animation: victoryCardAppear 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
}

@keyframes victoryCardAppear {
  0% {
    opacity: 0;
    transform: scale(0.5) translateY(-50px);
  }
  50% {
    transform: scale(1.05) translateY(0);
  }
  100% {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

/* Confetti effect for victory */
#victoryCard::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: 
    radial-gradient(circle at 20% 30%, rgba(255, 215, 0, 0.3) 0%, transparent 2%),
    radial-gradient(circle at 80% 70%, rgba(0, 212, 255, 0.3) 0%, transparent 2%),
    radial-gradient(circle at 50% 50%, rgba(227, 53, 13, 0.3) 0%, transparent 2%);
  animation: confettiFall 3s ease-in-out infinite;
  pointer-events: none;
}

@keyframes confettiFall {
  0% { transform: translateY(-100%) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
}
#victoryCard h2{
  margin:4px 0 8px 0;
  font-size:24px;
}
#victoryCard p{
  margin:6px 0 16px 0;
  color:#cbd5e1;
}
#victoryBtns{
  display:flex;
  gap:10px;
  justify-content:center;
}
#victoryOverlay,#victoryOverlay *{
  pointer-events:auto;
}
#toolBackdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:1100;
}
#toolBackdrop.show{
  display:flex;
}
#toolCard{
  display:flex;
  gap:18px;
  align-items:flex-start;
  max-width:980px;
}
#toolCard img{
  width:calc(var(--card-w) * 4);
  height:auto;
  border-radius:14px;
  box-shadow:0 18px 48px rgba(0,0,0,.65);
  background:#111;
}
#toolPanel{
  min-width:360px;
  max-width:420px;
  background:#1f232a;
  border:1px solid #3b3f46;
  border-radius:16px;
  box-shadow:0 10px 28px rgba(0,0,0,.45);
  padding:16px;
  color:#e5e7eb;
}
#toolPanel h3{
  margin:0 0 8px 0;
}
#zoomAttached{
  padding-bottom:0;margin-bottom:0 !important;
}
#zoomAttached .row{
  margin:0 0 4px 0 !important;
}
#zoomAttached+.zoom-section{
  margin-top:6px;padding-top:8px !important;
}
.ability-box{
  border:1px solid #3b3f46;
  border-radius:10px;
  background:#23272e;
  margin:6px 0;
  padding:6px 8px;
}
.ability-head{
  display:flex;
  align-items:center;
  gap:6px;
  border-radius:8px;
  padding:6px 8px;
  font-weight:800;
  color:#0b0f14;
}
.ability-head img{
  width:60px;
  height:18px;
  border-radius:3px;
  display:block;
}
.ability-name{
  font-size:13px;
}
.ability-text{
  font-size:12px;
  color:#cbd5e1;
  margin-top:6px;
  line-height:1.25;
}
.heal-glow{
  animation:glowPulse .9s ease-in-out infinite alternate;
  outline:3px solid rgba(74,222,128,.95);
  border-radius:8px;
  cursor:pointer;
  filter:drop-shadow(0 0 6px rgba(74,222,128,.85));
}
#zoomRetreatRow{
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  background:linear-gradient(180deg,#2a2f36,#262b32);
  transition:all .2s ease;
  margin-top:10px;
  padding:8px 10px;
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  font-weight:700 !important;
  color:#ffffff !important;
  user-select:none;
  min-height:36px !important;
}
#zoomRetreatRow.enabled{
  cursor:pointer;
  filter:brightness(1.08);
  transform:scale(1.02);
}
#zoomRetreatRow.disabled{
  opacity:.5;
  cursor:not-allowed;
  filter:grayscale(80%);
}
#handType{
  color:#fff;
  font-weight:700;
  border:none;
  text-transform:capitalize;
}
#logToggleBtn{
  position:fixed;
  right:30px;
  top:355px;
  z-index:1500;
  background:linear-gradient(90deg,#2a2f36,#1f232a);
  border:1px solid #334155;
  padding:8px 14px;
  color:#e5e7eb;
  border-radius:10px;
  font-size:.85rem;
  cursor:pointer;
  box-shadow:0 4px 10px rgba(0,0,0,.4);
}
#logPanel{
  position:fixed;
  top:100px;
  right:-380px;
  width:360px;
  height:calc(100vh - 140px);
  background:linear-gradient(180deg, #0f1216 0%, #1a1e24 100%);
  border-left:2px solid rgba(0, 212, 255, 0.3);
  box-shadow:-15px 0 35px rgba(0,0,0,.7), 0 0 25px rgba(0, 212, 255, 0.1);
  padding:16px 16px 24px 16px;
  overflow-y:auto;
  transition:right .3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index:1200;
  color:#e5e7eb;
  backdrop-filter: blur(20px);
  clip-path: inset(0 0 0 0);
}

#logPanel:not(.show) {
  overflow: hidden;
  pointer-events: none;
  box-shadow: none !important;
  border-left: none !important;
}

#logPanel::-webkit-scrollbar {
  width: 8px;
}

#logPanel::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}

#logPanel::-webkit-scrollbar-thumb {
  background: rgba(0, 212, 255, 0.4);
  border-radius: 4px;
}

#logPanel::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 212, 255, 0.6);
}

#logPanel.show{
  right:20px;
  animation: logPanelSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes logPanelSlideIn {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}
#closeLogBtn{
  background:#d92d2d;
  color:white;
  border:none;
  padding:6px 10px;
  border-radius:6px;
  cursor:pointer;
  font-size:12px;
  width:100%;
  margin-bottom:10px;
}
#logPanelHeader{
  background:linear-gradient(135deg, rgba(217, 45, 45, 0.95) 0%, rgba(166, 28, 28, 0.95) 100%);
  color:white;
  padding:14px 16px;
  font-size:16px;
  font-weight:800;
  letter-spacing:1px;
  border-bottom:3px solid rgba(138, 20, 20, 0.8);
  margin-bottom:12px;
  border-radius:10px;
  box-shadow: 0 4px 12px rgba(217, 45, 45, 0.3);
  text-transform: uppercase;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
.turn-bar{
  background:linear-gradient(135deg, rgba(47, 52, 60, 0.9) 0%, rgba(36, 42, 49, 0.9) 100%);
  border-top:2px solid rgba(0, 212, 255, 0.3);
  border-bottom:2px solid rgba(0, 212, 255, 0.3);
  padding:12px 16px;
  font-size:14px;
  font-weight:800;
  color:#e5e7eb;
  display:flex;
  align-items:center;
  gap:10px;
  box-shadow:0 4px 12px rgba(0,0,0,.4), 0 0 10px rgba(0, 212, 255, 0.1);
  margin-top:10px;
  margin-bottom:10px;
  border-radius:10px;
  backdrop-filter: blur(10px);
}

.turn-icon{
  width:22px;
  height:22px;
  border-radius:50%;
  background:linear-gradient(135deg, #d92d2d, #a61c1c);
  display:flex;
  align-items:center;
  justify-content:center;
  color:white;
  font-size:12px;
  font-weight:900;
  box-shadow: 0 2px 8px rgba(217, 45, 45, 0.4);
  border: 2px solid rgba(255, 255, 255, 0.2);
}
.log-entry{
  background:linear-gradient(135deg, rgba(31, 35, 42, 0.95) 0%, rgba(20, 24, 30, 0.95) 100%);
  border:1px solid rgba(59, 63, 70, 0.5);
  border-left:4px solid #334155;
  padding:12px 14px;
  margin-bottom:14px;
  border-radius:12px;
  font-size:12px;
  line-height:1.4;
  color:#e5e7eb;
  box-shadow:0 4px 12px rgba(0,0,0,.4), 0 0 8px rgba(0,0,0,.2);
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
  position: relative;
  overflow: hidden;
}

.log-entry::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  background: inherit;
  transition: width 0.3s ease;
}

.log-entry:hover {
  transform: translateX(4px);
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(0, 212, 255, 0.2);
  border-color: rgba(100, 100, 120, 0.6);
}

.log-entry:hover::before {
  width: 6px;
}

.log-entry.p1{
  border-left-color:#3b82f6;
  background:linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(31, 35, 42, 0.95) 100%);
}

.log-entry.p1:hover {
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(59, 130, 246, 0.3);
  border-left-color: #60a5fa;
}

.log-entry.p2{
  border-left-color:#ef4444;
  background:linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(31, 35, 42, 0.95) 100%);
}

.log-entry.p2:hover {
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(239, 68, 68, 0.3);
  border-left-color: #f87171;
}

.log-entry.sys{
  border-left-color:#9ca3af;
  background:linear-gradient(135deg, rgba(156, 163, 175, 0.1) 0%, rgba(31, 35, 42, 0.95) 100%);
}

.log-entry.sys:hover {
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(156, 163, 175, 0.2);
  border-left-color: #cbd5e1;
}
.entry-player{
  font-weight:800;
  margin-bottom:4px;
}
.entry-player.p1{
  color:#1e73d8;
}
.entry-player.p2{
  color:#d82020;
}
.entry-player.sys{
  color:#888;
}
.entry-text{
  line-height:1.35;
}
.log-thumb{
  width:48px;
  height:67px;
  border-radius:6px;
  margin-top:8px;
  box-shadow:0 2px 6px rgba(0,0,0,.45);
  border:1px solid #1f2937;
  cursor:pointer;
  align-self:flex-start;
}
#historyBackdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.7);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
}
#historyBackdrop.show{
  display:flex;
}
#historyCard{
  width:min(600px,90vw);
  background:#101418;
  border:1px solid #334155;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
  border-radius:16px;
  padding:20px;
  color:#e5e7eb;
  max-height:80vh;
  overflow-y:auto;
}
#historyCard h2{
  margin:0 0 10px 0;
  font-size:22px;
  text-align:center;
}
#fullHistory{
  font-size:13px;
  line-height:1.32;
}
.match-log-entry{
  background:#111827;
  border:1px solid #374151;
  border-left:4px solid #9ca3af;
  border-radius:8px;
  padding:8px 10px;
  box-shadow:0 2px 6px rgba(0,0,0,.4);
  margin-bottom:12px;
  color:#e5e7eb;
}
.ability-glow{
  animation:glowPulse 1.2s infinite;
  cursor:pointer;
  box-shadow:0 0 10px rgba(255,255,255,0.6);
}
.ability-disabled{
  opacity:0.45;
  filter:grayscale(70%);
  pointer-events:none;
}
.ability-entry{
  background:rgba(85, 105, 255, 0.14);
  border:1px solid rgba(110, 150, 255, 0.4);
  border-radius:8px;
  padding:8px 10px;
  margin:6px 0;
  transition:0.15s ease;
}
.ability-entry.disabled{
  opacity:0.45;
  pointer-events:none;
}
.ability-header{
  display:flex;
  align-items:center;
  gap:6px;
  margin-bottom:6px;
}
.ability-badge{
  background:linear-gradient(90deg, #cc2a2a, #ff5959);
  color:white;
  padding:2px 8px;
  border-radius:6px;
  font-size:11px;
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:0.5px;
}
.ability-title{
  font-size:14px;
  font-weight:700;
  color:#ffffff;
}
.ability-desc{
  font-size:12px;
  line-height:1.3;
  opacity:0.9;
  color:#e8e8e8;
  margin-top:3px;
}
.ability-used-tag{
  margin-top:6px;
  font-size:11px;
  font-weight:bold;
  color:#ffaaaa;
  text-align:right;
}
.attack-ability-wrapper{
  margin-bottom:8px;
}
.attack-ability-row{
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  padding:6px 10px;
  border-radius:10px !important;
  background:linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
  box-shadow:0 0 0 1px rgba(15,23,42,0.7);
  cursor:pointer;
  transition:transform 0.08s ease-out, box-shadow 0.08s ease-out, opacity 0.15s;
  min-height:52px;
}
.attack-ability-row.used{
  opacity:0.45;
  cursor:default;
}
.attack-ability-left{
  display:flex;
  flex-direction:column;
  gap:2px;
}
.attack-ability-label{
  font-size:9px !important;
  font-weight:700;
  padding:1px 6px;
  border-radius:999px;
  background:rgba(0,0,0,0.4);
  text-transform:uppercase;
  letter-spacing:0.8px !important;
  color:rgba(255, 255, 255, 0.95) !important;
}
.attack-ability-name{
  font-size:14px !important;
  font-weight:700 !important;
  color:#fff !important;
  margin-top:2px !important;
  line-height:1.2 !important;
}
.attack-ability-right{
  display:flex;
  align-items:center;
  gap:4px;
  font-size:11px;
  opacity:0.8;
}
.attack-ability-toggle{
  cursor:pointer;
}
.attack-ability-desc{
  margin-top:4px;
  padding:6px 10px 7px;
  border-radius:8px;
  background:rgba(254, 226, 226, 0.2) !important;
  font-size:11px;
  color:#fecaca !important;
  line-height:1.3 !important;
  display:none;
}
.attack-desc{
  margin-top:-2px !important;
  margin-bottom:4px !important;
  padding:4px 10px 6px;
  border-radius:8px;
  background:rgba(30, 30, 40, 0.8) !important;
  font-size:11px;
  color:#d1d5db !important;
  display:none;
  line-height:1.3 !important;
}
.attack-info{
  font-size:12px !important;
  margin-left:6px;
  opacity:0.7;
  cursor:pointer;
  padding:2px 6px !important;
  color:#00d4ff !important;
}
#player1{
  border-radius:16px;
  padding:12px;
  box-shadow:0 -4px 16px rgba(0, 212, 255, 0.15);
  transition: background 0.6s ease, box-shadow 0.6s ease, border-color 0.6s ease, opacity 0.3s ease;
  position: relative;
}

#player1::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 16px;
  padding: 2px;
  background: linear-gradient(135deg, rgba(0, 212, 255, 0.3), rgba(0, 212, 255, 0.1));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

#player1:hover::before {
  opacity: 1;
}

#player2{
  border-radius:16px;
  padding:12px;
  box-shadow:0 4px 16px rgba(227, 53, 13, 0.15);
  transition: background 0.6s ease, box-shadow 0.6s ease, border-color 0.6s ease, opacity 0.3s ease;
  position: relative;
}

#player2::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 16px;
  padding: 2px;
  background: linear-gradient(135deg, rgba(227, 53, 13, 0.3), rgba(227, 53, 13, 0.1));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

#player2:hover::before {
  opacity: 1;
}
.zoom-card{
  border-radius:16px !important;
}
.zoom-hp-bar{
  background:linear-gradient(90deg, #22c55e 0%, #16a34a 100%) !important;
  border-radius:8px;
  box-shadow:inset 0 1px 2px rgba(0, 0, 0, 0.2);
}
.zoom-ability-card{
  background:linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border:2px solid #ef4444 !important;
  border-radius:10px !important;
  padding:16px !important;
  backdrop-filter:blur(10px);
  margin-bottom:8px !important;
}
.energy.selected{
  border:3px solid #00d4ff !important;
  box-shadow:0 0 16px rgba(0, 255, 255, 0.8) !important;
  transform:scale(1.2) !important;
}

.energy.selected-glow,
.card-img.selected-glow {
  box-shadow: 0 0 20px rgba(0, 212, 255, 0.8), 0 0 40px rgba(0, 212, 255, 0.6), 0 0 60px rgba(0, 212, 255, 0.4) !important;
  border: 2px solid #00d4ff !important;
  animation: pulse-glow 1.5s ease-in-out infinite !important;
  transform: scale(1.05) !important;
  z-index: 100 !important;
  position: relative;
}

@keyframes pulse-glow {
  0%, 100% {
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.8), 0 0 40px rgba(0, 212, 255, 0.6), 0 0 60px rgba(0, 212, 255, 0.4) !important;
  }
  50% {
    box-shadow: 0 0 30px rgba(0, 212, 255, 1), 0 0 60px rgba(0, 212, 255, 0.8), 0 0 90px rgba(0, 212, 255, 0.6) !important;
  }
}
#mainButton{
  background:rgba(40, 40, 50, 0.98) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:50px !important;
  padding:12px 20px !important;
  font-size:14px !important;
  font-weight:700 !important;
  text-transform:uppercase;
  letter-spacing:1px;
  transition:all 0.3s ease;
  z-index:150 !important;
  backdrop-filter:blur(20px);
  position:fixed !important;
  right:30px !important;
  top:50% !important;
  transform:translateY(-50%) !important;
  bottom:220px !important;
}
.popup{
  background:linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(243, 244, 246, 0.98) 100%) !important;
  backdrop-filter:blur(20px);
  color:#111827 !important;
  border-radius:50px !important;
  padding:14px 28px !important;
  font-weight:600 !important;
  font-size:15px !important;
  border:2px solid #e5e7eb !important;
  z-index:2500 !important;
}
.deck-bubble, .discard-btn{
  background:rgba(15, 15, 25, 0.85) !important;
  backdrop-filter:blur(12px);
  border:2px solid rgba(138, 43, 226, 0.4) !important;
  border-radius:12px !important;
}
.victory-overlay{
  background:rgba(0, 0, 0, 0.9) !important;
  backdrop-filter:blur(12px);
  z-index:5000 !important;
}
.victory-content{
  background:linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(243, 244, 246, 0.98) 100%) !important;
  backdrop-filter:blur(20px);
  border-radius:24px !important;
  border:3px solid #00d4ff !important;
}
.victory-title{
  font-size:44px !important;
  font-weight:700 !important;
  color:#111827 !important;
  text-transform:uppercase;
  letter-spacing:2px;
}
.victory-btn{
  background:linear-gradient(135deg, #00d4ff 0%, #0ff 100%) !important;
  color:#000 !important;
  border:none !important;
  border-radius:50px !important;
  padding:16px 40px !important;
  font-size:17px !important;
  font-weight:700 !important;
  text-transform:uppercase;
  letter-spacing:1px;
  box-shadow:0 8px 24px rgba(0, 212, 255, 0.5) !important;
}
.glow-promote, .promote-glow{
  animation:promoteGlow 1.5s ease-in-out infinite !important;
  border:3px solid #0ff !important;
}
.zoom-attack-name{
  font-size:16px !important;
  font-weight:700 !important;
  color:#ffffff !important;
}
.zoom-attack-text{
  font-size:14px !important;
  line-height:1.4 !important;
  color:#d1d5db !important;
  margin-top:4px !important;
}
.zoom-stats{
  border-radius:10px !important;
  padding:12px !important;
  margin-top:16px !important;
}
.zoom-stat-label{
  color:#9ca3af !important;
  font-weight:600 !important;
  font-size:12px !important;
  text-transform:uppercase;
  letter-spacing:1px;
  margin-bottom:6px !important;
}
.zoom-stat-value{
  color:#ffffff !important;
  font-weight:700 !important;
  display:flex !important;
  align-items:center !important;
  gap:6px !important;
  font-size:16px !important;
}
.attack-ability-wrapper[data-type="grass"] .attack-ability-row{
  background:linear-gradient(90deg, #22c55e 0%, #16a34a 100%) !important;
}
.attack-ability-wrapper[data-type="fire"] .attack-ability-row{
  background:linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
}
.attack-ability-wrapper[data-type="water"] .attack-ability-row{
  background:linear-gradient(90deg, #3b82f6 0%, #2563eb 100%) !important;
}
.attack-ability-wrapper[data-type="lightning"] .attack-ability-row{
  background:linear-gradient(90deg, #eab308 0%, #ca8a04 100%) !important;
}
.attack-ability-wrapper[data-type="psychic"] .attack-ability-row{
  background:linear-gradient(90deg, #a855f7 0%, #9333ea 100%) !important;
}
.attack-ability-wrapper[data-type="fighting"] .attack-ability-row{
  background:linear-gradient(90deg, #f97316 0%, #ea580c 100%) !important;
}
.attack-ability-wrapper[data-type="darkness"] .attack-ability-row{
  background:linear-gradient(90deg, #64748b 0%, #475569 100%) !important;
}
.attack-ability-wrapper[data-type="metal"] .attack-ability-row{
  background:linear-gradient(90deg, #94a3b8 0%, #64748b 100%) !important;
}
.attack-ability-wrapper[data-type="dragon"] .attack-ability-row{
  background:linear-gradient(90deg, #d3ba30 0%, #b89e20 100%) !important;
}
.attack-ability-wrapper[data-type="fairy"] .attack-ability-row{
  background:linear-gradient(90deg, #ec4899 0%, #db2777 100%) !important;
}
.attack-ability-wrapper[data-type="colorless"] .attack-ability-row{
  background:linear-gradient(90deg, #9ca3af 0%, #6b7280 100%) !important;
}
.attack-item.payable[data-type="grass"]{
  background:rgba(34, 197, 94, 0.2) !important;
  border-color:#22c55e !important;
}
.attack-item.payable[data-type="grass"] .attack-name{
  color:#15803d !important;
}
.attack-item.payable[data-type="fire"]{
  background:rgba(239, 68, 68, 0.2) !important;
  border-color:#ef4444 !important;
}
.attack-item.payable[data-type="fire"] .attack-name{
  color:#b91c1c !important;
}
.attack-item.payable[data-type="water"]{
  background:rgba(59, 130, 246, 0.2) !important;
  border-color:#3b82f6 !important;
}
.attack-item.payable[data-type="water"] .attack-name{
  color:#1e40af !important;
}
.attack-item.payable[data-type="lightning"]{
  background:rgba(234, 179, 8, 0.2) !important;
  border-color:#eab308 !important;
}
.attack-item.payable[data-type="lightning"] .attack-name{
  color:#a16207 !important;
}
.attack-item.payable[data-type="psychic"]{
  background:rgba(168, 85, 247, 0.2) !important;
  border-color:#a855f7 !important;
}
.attack-item.payable[data-type="psychic"] .attack-name{
  color:#7e22ce !important;
}
.attack-item.payable[data-type="fighting"]{
  background:rgba(249, 115, 22, 0.2) !important;
  border-color:#f97316 !important;
}
.attack-item.payable[data-type="fighting"] .attack-name{
  color:#c2410c !important;
}
.attack-item.payable[data-type="darkness"]{
  background:rgba(100, 116, 139, 0.2) !important;
  border-color:#64748b !important;
}
.attack-item.payable[data-type="darkness"] .attack-name{
  color:#334155 !important;
}
.attack-item.payable[data-type="metal"]{
  background:rgba(148, 163, 184, 0.2) !important;
  border-color:#94a3b8 !important;
}
.attack-item.payable[data-type="metal"] .attack-name{
  color:#475569 !important;
}
.attack-item.payable[data-type="dragon"]{
  background:linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%) !important;
  border-color:#8b5cf6 !important;
}
.attack-item.payable[data-type="dragon"] .attack-name{
  color:#6d28d9 !important;
}
.attack-item.payable[data-type="fairy"]{
  background:linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%) !important;
  border-color:#ec4899 !important;
}
.attack-item.payable[data-type="fairy"] .attack-name{
  color:#be185d !important;
}
.attack-item.payable[data-type="colorless"]{
  background:linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%) !important;
  border-color:#9ca3af !important;
}
.attack-item.payable[data-type="colorless"] .attack-name{
  color:#4b5563 !important;
}
.log-toggle-btn{
  bottom:20px !important;
  z-index:100 !important;
}
.prize-area{
  z-index:50 !important;
}
.hand{
  max-width:100% !important;
  flex-wrap:wrap !important;
  justify-content:center !important;
  min-height:calc(var(--card-h) + 12px);
  transition: min-height 0.3s ease;
}
.bench{
  max-width:100% !important;
  flex-wrap:wrap !important;
  justify-content:center !important;
}
.player-area > * + *{
  margin-top:2px !important;
}
.zoom-attack-header{
  display:flex !important;
  justify-content:space-between !important;
  align-items:center !important;
  margin-bottom:10px !important;
}
.zoom-attack-damage{
  font-size:20px !important;
  font-weight:900 !important;
  color:#ffffff !important;
  transition: all 0.3s ease;
  text-shadow: 0 1px 3px rgba(0,0,0,0.5);
  display: inline-block;
}

.zoom-attack:hover .zoom-attack-damage {
  transform: scale(1.15);
  text-shadow: 0 2px 6px rgba(0, 212, 255, 0.6), 0 0 12px rgba(0, 212, 255, 0.4);
  color: #00d4ff !important;
}
.zoom-attack-cost{
  display:flex !important;
  gap:3px !important;
  margin-right:8px !important;
}
.zoom-retreat-cost{
  background:rgba(40, 40, 50, 0.6) !important;
  border-radius:10px !important;
  padding:12px !important;
  margin-top:12px !important;
}
.zoom-retreat-btn{
  background:rgba(50, 50, 60, 0.8) !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  color:#ffffff !important;
  border-radius:10px !important;
  padding:14px !important;
  margin-top:12px !important;
  font-size:15px !important;
  font-weight:700 !important;
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
}
.zoom-panel *{
  filter:none !important;
  color:inherit;
}
.attack-damage{
  font-weight:900 !important;
  transition: all 0.3s ease;
  display: inline-block;
}

.attack-item:hover .attack-damage {
  transform: scale(1.15);
  text-shadow: 0 2px 6px rgba(0, 212, 255, 0.6), 0 0 12px rgba(0, 212, 255, 0.4);
  color: #00d4ff !important;
}
[id*="log"] button{
  z-index:90 !important;
}
.zoom-ability-card[data-type="grass"]{
  background:linear-gradient(135deg, rgba(34, 197, 94, 0.3) 0%, rgba(22, 163, 74, 0.3) 100%) !important;
  border-color:#22c55e !important;
}
.zoom-ability-card[data-type="grass"] .zoom-ability-name{
  color:#15803d !important;
}
.zoom-ability-card[data-type="fire"]{
  background:linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border-color:#ef4444 !important;
}
.zoom-ability-card[data-type="fire"] .zoom-ability-name{
  color:#b91c1c !important;
}
.zoom-ability-card[data-type="water"]{
  background:linear-gradient(135deg, rgba(59, 130, 246, 0.3) 0%, rgba(37, 99, 235, 0.3) 100%) !important;
  border-color:#3b82f6 !important;
}
.zoom-ability-card[data-type="water"] .zoom-ability-name{
  color:#1e40af !important;
}
.zoom-ability-card[data-type="lightning"]{
  background:linear-gradient(135deg, rgba(234, 179, 8, 0.3) 0%, rgba(202, 138, 4, 0.3) 100%) !important;
  border-color:#eab308 !important;
}
.zoom-ability-card[data-type="lightning"] .zoom-ability-name{
  color:#a16207 !important;
}
.zoom-ability-card[data-type="psychic"]{
  background:linear-gradient(135deg, rgba(168, 85, 247, 0.3) 0%, rgba(147, 51, 234, 0.3) 100%) !important;
  border-color:#a855f7 !important;
}
.zoom-ability-card[data-type="psychic"] .zoom-ability-name{
  color:#7e22ce !important;
}
.zoom-ability-card[data-type="fighting"]{
  background:linear-gradient(135deg, rgba(249, 115, 22, 0.3) 0%, rgba(234, 88, 12, 0.3) 100%) !important;
  border-color:#f97316 !important;
}
.zoom-ability-card[data-type="fighting"] .zoom-ability-name{
  color:#c2410c !important;
}
.zoom-ability-card[data-type="darkness"]{
  background:linear-gradient(135deg, rgba(100, 116, 139, 0.3) 0%, rgba(71, 85, 105, 0.3) 100%) !important;
  border-color:#64748b !important;
}
.zoom-ability-card[data-type="darkness"] .zoom-ability-name{
  color:#334155 !important;
}
.zoom-ability-card[data-type="metal"]{
  background:linear-gradient(135deg, rgba(148, 163, 184, 0.3) 0%, rgba(100, 116, 139, 0.3) 100%) !important;
  border-color:#94a3b8 !important;
}
.zoom-ability-card[data-type="metal"] .zoom-ability-name{
  color:#475569 !important;
}
.zoom-ability-text{
  -webkit-font-smoothing:antialiased !important;
  -moz-osx-font-smoothing:grayscale !important;
  text-rendering:optimizeLegibility !important;
  font-size:14px !important;
  line-height:1.4 !important;
  color:#d1d5db !important;
}
.zoom-section-title{
  color:#9ca3af !important;
  margin-bottom:10px !important;
}
.zoom-ability-name{
  font-size:18px !important;
  font-weight:700 !important;
  color:#ffffff !important;
  margin-bottom:6px !important;
}
.zoom-ability-card[data-type="grass"] .zoom-ability-text{
  color:#bbf7d0 !important;
}
.zoom-ability-card[data-type="fire"] .zoom-ability-text{
  color:#fecaca !important;
}
.zoom-ability-card[data-type="water"] .zoom-ability-text{
  color:#bfdbfe !important;
}
.zoom-ability-card[data-type="lightning"] .zoom-ability-text{
  color:#fde68a !important;
}
.zoom-ability-card[data-type="psychic"] .zoom-ability-text{
  color:#e9d5ff !important;
}
.zoom-ability-card[data-type="fighting"] .zoom-ability-text{
  color:#fdba74 !important;
}
.zoom-ability-card[data-type="darkness"] .zoom-ability-text{
  color:#cbd5e1 !important;
}
.zoom-ability-card[data-type="metal"] .zoom-ability-text{
  color:#e2e8f0 !important;
}
.zoom-tool-section{
  color:#e5e7eb !important;
}
.zoom-close{
  background:#ef4444 !important;
  color:#fff !important;
}
.zoom-tool-count{
  background:rgba(50, 50, 60, 0.8) !important;
  color:#ffffff !important;
  padding:4px 10px !important;
  border-radius:12px !important;
  font-weight:700 !important;
}
.zoom-attack-cost-icon{
  width:20px !important;
  height:18px !important;
  border-radius:50% !important;
  background-size:contain !important;
  background-position:center !important;
  border:1px solid rgba(255, 255, 255, 0.2) !important;
}
div[style*="retreat"]{
  margin-top:6px !important;
  padding:6px 10px !important;
  min-height:36px !important;
  background:rgba(60, 60, 70, 0.6) !important;
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  color:#ffffff !important;
}
[class*="retreat"] button{
  padding:6px 10px !important;
  min-height:36px !important;
  font-size:13px !important;
  color:#ffffff !important;
}
.zoom-ability-badge{
  padding:3px 10px !important;
  font-size:10px !important;
  margin-bottom:6px !important;
}
.zoom-resistance{
  background:rgba(40, 40, 50, 0.6) !important;
  border-radius:8px !important;
}
.attack-menu *{
  color:#ffffff !important;
}
.show-log-btn{
  z-index:100 !important;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:12px !important;
  padding:10px 16px !important;
  font-weight:600 !important;
  position:fixed !important;
  bottom:20px !important;
  right:20px !important;
}
[class*="turn"]{
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:1px solid rgba(100, 100, 120, 0.3) !important;
}
[class*="discard"] button{
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:12px !important;
  padding:10px 16px !important;
  font-weight:600 !important;
  transition:all 0.2s ease !important;
}
.deck-count{
  color:#ffffff !important;
  font-weight:700 !important;
}
.energy-zone.horizontal{
  flex-direction:row !important;
  border-radius:40px !important;
  padding:10px 14px !important;
}
[class*="turn-box"]{
  position:fixed !important;
  right:30px !important;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  border-radius:12px !important;
  padding:12px 16px !important;
  font-weight:600 !important;
  text-align:center !important;
  z-index:50 !important;
  min-width:120px !important;
}
#player1 .discard-btn{
  position:absolute !important;
  left:20px !important;
  bottom:50% !important;
  transform:translateY(50%) !important;
}
#player2 .discard-btn{
  position:absolute !important;
  left:20px !important;
  top:50% !important;
  transform:translateY(-50%) !important;
}
#turnInfo{
  bottom:300px !important;
}
.turn-info{
  z-index:50 !important;
}

/* ============================================
   BUTTON SIZE FIXES
============================================ */
/* Fix oversized buttons and elements */

/* Show Log button - make it compact */
#logToggleBtn, #showLogBtn, .show-log-btn {
  position: fixed;
  right: 30px;
  bottom: 20px;
  padding: 8px 16px;
  background: rgba(40, 40, 50, 0.9);
  border: 1px solid rgba(100, 100, 120, 0.4);
  border-radius: 12px;
  color: #e5e7eb;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  z-index: 100;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  transition: all 0.2s ease;
  width: auto;
  height: auto;
  min-width: auto;
}

#logToggleBtn:hover, #showLogBtn:hover {
  background: rgba(50, 50, 60, 0.95);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.3);
}

/* Energy Zone - make it compact and positioned correctly */
.energy-zone {
  position: fixed;
  right: 30px;
  bottom: 60px;
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 6px;
  padding: 10px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.3);
  border-radius: 12px;
  z-index: 200;
  width: auto;
  max-width: 120px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
}

.energy-container {
  position: relative;
  display: inline-block;
}

/* Energy container for energy zone */
.energy-container {
  position: relative;
  display: inline-block;
}

/* Next turn energy pip - smaller badge in corner - must be very specific */
.energy-zone .energy-container > .energy-next-turn {
  position: absolute !important;
  bottom: -2px !important;
  right: -2px !important;
  width: 10px !important;
  height: 10px !important;
  opacity: 1 !important;
  cursor: default !important;
  pointer-events: none !important;
  border: 1.5px solid rgba(255, 255, 255, 1) !important;
  filter: grayscale(0%) brightness(100%) !important;
  border-radius: 50% !important;
  background-color: transparent !important;
  box-shadow: 0 0 0 1px rgba(40, 40, 50, 1), 0 1px 3px rgba(0, 0, 0, 0.9) !important;
  z-index: 10 !important;
  display: block !important;
  visibility: visible !important;
  overflow: hidden !important;
}

.energy-zone .energy-container > .energy-next-turn > img {
  width: 100% !important;
  height: 100% !important;
  object-fit: cover !important;
  border-radius: 50% !important;
  display: block !important;
}

.energy:hover {
  transform: scale(1.1);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.5);
}

.energy.selected {
  border: 3px solid #0ff;
  box-shadow: 0 0 16px rgba(0, 255, 255, 0.8);
  transform: scale(1.15);
}

/* View Discard buttons - make them compact like deck bubbles */
.discard-btn {
  position: absolute;
  width: 85px;
  height: 36px;
  background: rgba(40, 40, 50, 0.9);
  color: #fff;
  border: 2px solid rgba(100, 100, 120, 0.4);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: 700;
  cursor: pointer;
  z-index: 9;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  transition: all 0.2s ease;
  padding: 0;
}

.discard-btn:hover {
  background: rgba(50, 50, 60, 0.95);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.4);
  transform: scale(1.05);
}

/* Deck bubble - keep small and compact */
.deck-bubble {
  width: 36px;
  height: 36px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.4);
  border-radius: 50%;
  font-size: 13px;
  font-weight: 700;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

/* Turn info box - compact */
.turnbox, #turnInfo {
  width: 120px;
  padding: 8px 12px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.3);
  border-radius: 10px;
  font-size: 13px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

/* Main button (END TURN) - keep reasonable size */
#mainButton {
  padding: 12px 24px;
  font-size: 15px;
  font-weight: 700;
  min-width: 140px;
  height: auto;
  border-radius: 50px;
}


/* ============================================
   RESTORE ORIGINAL LAYOUT - Match Image 1
============================================ */

/* Remove all the fixed positioning we added */
#mainButton {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  padding: 8px 14px !important;
  font-size: 0.9rem !important;
  min-width: 150px !important;
  max-width: none !important;
  height: auto !important;
  border-radius: 10px !important;
  background: linear-gradient(135deg, #e3350d, #0074d9) !important;
  border: 1px solid #1f2937 !important;
  color: #fff !important;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35) !important;
  cursor: pointer !important;
  z-index: auto !important;
}

#mainButton::after {
  display: none !important;
}

/* Energy zone - restore to side panel */
.energy-zone {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  display: flex !important;
  flex-wrap: wrap !important;
  gap: 6px !important;
  justify-content: center !important;
  padding: 0 !important;
  background: transparent !important;
  border: none !important;
  border-radius: 0 !important;
  z-index: auto !important;
  width: auto !important;
  max-width: none !important;
  box-shadow: none !important;
}

/* Removed duplicate .energy rule - using .energy-container > .energy instead */

.energy.selected {
  border: 3px solid #0ff !important;
  box-shadow: 0 0 12px rgba(0, 255, 255, 0.8) !important;
  transform: scale(1.15) !important;
}

/* Side panel - restore original positioning */
.side-panel {
  position: fixed !important;
  top: 20px !important;
  right: 20px !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  gap: 0.6rem !important;
  z-index: 10 !important;
}

/* Turn box - restore to side panel */
.turnbox, #turnInfo {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  width: 150px !important;
  border: 1px solid #3b3f46 !important;
  background: #23272e !important;
  border-radius: 12px !important;
  padding: 10px !important;
  text-align: center !important;
  font-size: 0.92rem !important;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4) !important;
  color: #e5e7eb !important;
  z-index: auto !important;
}

.turnbox .big {
  font-weight: 800;
  font-size: 1.05rem;
}

/* Show Log button - restore original */
#logToggleBtn, #showLogBtn, .show-log-btn {
  position: fixed !important;
  right: 30px !important;
  top: 355px !important;
  bottom: auto !important;
  z-index: 1500 !important;
  background: linear-gradient(90deg, #2a2f36, #1f232a) !important;
  border: 1px solid #334155 !important;
  padding: 8px 14px !important;
  color: #e5e7eb !important;
  border-radius: 10px !important;
  font-size: 0.85rem !important;
  cursor: pointer !important;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4) !important;
  width: auto !important;
  height: auto !important;
  min-width: auto !important;
}

#logToggleBtn:hover, #showLogBtn:hover {
  filter: brightness(1.08);
}

/* Remove any label styling we added */
.energy-zone-label,
#energyZoneLabel {
  display: none !important;
}

.energy-zone::before {
  content: none !important;
  display: none !important;
}

/* Coin - keep in side panel */
.coin {
  position: static !important;
  top: auto !important;
  right: auto !important;
  width: 70px !important;
  height: 70px !important;
  transform-style: preserve-3d !important;
  transition: transform 1.5s ease-in-out !important;
  z-index: auto !important;
}

/* Coin result text */
#coinResult {
  text-align: center;
  font-weight: 700;
  font-size: 13px;
  min-height: 35px;
}

/* Ensure buttons in side panel have correct styling */
.side-panel button {
  background: linear-gradient(135deg, #e3350d, #0074d9);
  color: #fff;
  border: none;
  padding: 8px 14px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 0.9rem;
  min-width: 150px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
  border: 1px solid #1f2937;
}

.side-panel button:hover {
  opacity: 0.95;
}


/* ============================================
   FINAL POLISH - Dark menus, compact padding, type-based backgrounds
============================================ */

/* 1. LEFT-CLICK ATTACK MENU - Dark background, minimal padding */
.attack-menu {
  background: rgba(30, 30, 40, 0.98) !important;
  backdrop-filter: blur(20px) !important;
  border: 2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 12px !important;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8) !important;
  padding: 8px !important;
  min-width: 240px !important;
  color: #e5e7eb !important;
}

.attack-item {
  padding: 8px 10px !important;
  margin-bottom: 4px !important;
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 8px !important;
  color: #ffffff !important;
  min-height: 36px !important;
}

.attack-item:hover {
  background: rgba(60, 60, 70, 0.9) !important;
  border-color: #00d4ff !important;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.3) !important;
}

.attack-item.payable {
  border-color: #00d4ff !important;
  background: rgba(0, 212, 255, 0.15) !important;
}

.attack-name {
  font-size: 13px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
  line-height: 1.2 !important;
}

.attack-cost {
  gap: 3px !important;
}

.cost-icon {
  width: 18px !important;
  height: 18px !important;
}

.attack-desc {
  padding: 3px 5px !important;
  margin-top: 2px !important;
  margin-bottom: 4px !important;
  font-size: 11px !important;
  line-height: 1.3 !important;
  background: rgba(20, 20, 30, 0.8) !important;
  color: #d1d5db !important;
  border-radius: 6px !important;
}

/* Ability row - dark with red accent */
.attack-ability-wrapper {
  margin-bottom: 6px !important;
}

.attack-ability-row {
  padding: 8px 10px !important;
  background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
  border-radius: 8px !important;
  min-height: 36px !important;
}

.attack-ability-row:hover {
  background: linear-gradient(90deg, #dc2626 0%, #b91c1c 100%) !important;
}

.attack-ability-name {
  font-size: 13px !important;
  font-weight: 700 !important;
  color: #fff !important;
  line-height: 1.2 !important;
}

.attack-ability-label {
  font-size: 9px !important;
  padding: 2px 6px !important;
}

.attack-ability-desc {
  padding: 3px 5px !important;
  font-size: 11px !important;
  line-height: 1.3 !important;
  background: rgba(254, 226, 226, 0.2) !important;
  color: #fecaca !important;
}

/* 2. ZOOM MODAL - Compact padding, dark theme */
.zoom-panel {
  background: rgba(30, 30, 40, 0.98) !important;
  backdrop-filter: blur(20px) !important;
  border-radius: 16px !important;
  padding: 16px !important;
  color: #e5e7eb !important;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9) !important;
  border: 2px solid rgba(100, 100, 120, 0.3) !important;
}

.zoom-header {
  margin-bottom: 12px !important;
  padding-bottom: 10px !important;
}

.zoom-title {
  font-size: 20px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
}

.zoom-hp {
  font-size: 14px !important;
  color: #ffffff !important;
  margin-bottom: 8px !important;
}

.hpbar-container {
  margin: 6px 0 !important;
}

.zoom-section {
  margin-top: 10px !important;
  padding-top: 10px !important;
  border-top: 1px solid rgba(100, 100, 120, 0.3) !important;
}

.zoom-attack {
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 10px !important;
  padding: 10px 12px !important;
  margin: 8px 0 !important;
}

.zoom-attack .top {
  padding: 6px 8px !important;
}

.zoom-attack-name,
.zoom-attack .name {
  font-size: 15px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
}

.zoom-attack-damage,
.zoom-attack .dmg {
  font-size: 18px !important;
  font-weight: 900 !important;
  color: #ffffff !important;
}

.zoom-attack-text,
.effect {
  font-size: 12px !important;
  line-height: 1.4 !important;
  color: #d1d5db !important;
  margin-top: 4px !important;
}

/* Ability in zoom */
.zoom-ability-card,
.ability-box {
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border: 2px solid #ef4444 !important;
  border-radius: 10px !important;
  padding: 10px 12px !important;
  margin: 8px 0 !important;
}

.zoom-ability-name,
.ability-name {
  font-size: 16px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
  margin-bottom: 6px !important;
}

.zoom-ability-text,
.ability-text {
  font-size: 12px !important;
  line-height: 1.4 !important;
  color: #fecaca !important;
}

/* Retreat row */
#zoomRetreatRow {
  padding: 10px 12px !important;
  margin-top: 10px !important;
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
}

/* Row spacing */
.row {
  margin: 6px 0 !important;
  gap: 6px !important;
}

.chip {
  padding: 3px 8px !important;
  font-size: 11px !important;
}

/* 3. TYPE-BASED PLAYER BACKGROUNDS */

/* Grass type */
#player1.type-grass,
#player2.type-grass {
  background: linear-gradient(180deg, 
    rgba(34, 197, 94, 0.3) 0%, 
    rgba(22, 163, 74, 0.5) 50%, 
    rgba(21, 128, 61, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(34, 197, 94, 0.3) !important;
  border: 1px solid rgba(34, 197, 94, 0.3) !important;
}

/* Fire type */
#player1.type-fire,
#player2.type-fire {
  background: linear-gradient(180deg, 
    rgba(239, 68, 68, 0.3) 0%, 
    rgba(220, 38, 38, 0.5) 50%, 
    rgba(185, 28, 28, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(239, 68, 68, 0.3) !important;
  border: 1px solid rgba(239, 68, 68, 0.3) !important;
}

/* Water type */
#player1.type-water,
#player2.type-water {
  background: linear-gradient(180deg, 
    rgba(59, 130, 246, 0.3) 0%, 
    rgba(37, 99, 235, 0.5) 50%, 
    rgba(29, 78, 216, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(59, 130, 246, 0.3) !important;
  border: 1px solid rgba(59, 130, 246, 0.3) !important;
}

/* Lightning type */
#player1.type-lightning,
#player2.type-lightning {
  background: linear-gradient(180deg, 
    rgba(234, 179, 8, 0.3) 0%, 
    rgba(202, 138, 4, 0.5) 50%, 
    rgba(161, 98, 7, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(234, 179, 8, 0.3) !important;
  border: 1px solid rgba(234, 179, 8, 0.3) !important;
}

/* Psychic type */
#player1.type-psychic,
#player2.type-psychic {
  background: linear-gradient(180deg, 
    rgba(168, 85, 247, 0.3) 0%, 
    rgba(147, 51, 234, 0.5) 50%, 
    rgba(126, 34, 206, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(168, 85, 247, 0.3) !important;
  border: 1px solid rgba(168, 85, 247, 0.3) !important;
}

/* Fighting type */
#player1.type-fighting,
#player2.type-fighting {
  background: linear-gradient(180deg, 
    rgba(249, 115, 22, 0.3) 0%, 
    rgba(234, 88, 12, 0.5) 50%, 
    rgba(194, 65, 12, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(249, 115, 22, 0.3) !important;
  border: 1px solid rgba(249, 115, 22, 0.3) !important;
}

/* Darkness type */
#player1.type-darkness,
#player2.type-darkness {
  background: linear-gradient(180deg, 
    rgba(100, 116, 139, 0.3) 0%, 
    rgba(71, 85, 105, 0.5) 50%, 
    rgba(51, 65, 85, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(100, 116, 139, 0.3) !important;
  border: 1px solid rgba(100, 116, 139, 0.3) !important;
}

/* Metal type */
#player1.type-metal,
#player2.type-metal {
  background: linear-gradient(180deg, 
    rgba(148, 163, 184, 0.3) 0%, 
    rgba(100, 116, 139, 0.5) 50%, 
    rgba(71, 85, 105, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(148, 163, 184, 0.3) !important;
  border: 1px solid rgba(148, 163, 184, 0.3) !important;
}

/* Dragon type */
#player1.type-dragon,
#player2.type-dragon {
  background: linear-gradient(180deg, 
    rgba(211, 186, 48, 0.3) 0%, 
    rgba(184, 158, 32, 0.5) 50%, 
    rgba(169, 142, 28, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(211, 186, 48, 0.3) !important;
  border: 1px solid rgba(211, 186, 48, 0.3) !important;
}

/* Fairy type */
#player1.type-fairy,
#player2.type-fairy {
  background: linear-gradient(180deg, 
    rgba(236, 72, 153, 0.3) 0%, 
    rgba(219, 39, 119, 0.5) 50%, 
    rgba(190, 24, 93, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(236, 72, 153, 0.3) !important;
  border: 1px solid rgba(236, 72, 153, 0.3) !important;
}

/* Colorless type */
#player1.type-colorless,
#player2.type-colorless {
  background: linear-gradient(180deg, 
    rgba(156, 163, 175, 0.3) 0%, 
    rgba(107, 114, 128, 0.5) 50%, 
    rgba(75, 85, 99, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(156, 163, 175, 0.3) !important;
  border: 1px solid rgba(156, 163, 175, 0.3) !important;
}

/* Default if no type class */
#player1:not([class*="type-"]) {
  background: linear-gradient(180deg, 
    transparent 0%, 
    rgba(30, 58, 95, 0.4) 15%, 
    rgba(13, 31, 58, 0.6) 100%) !important;
  box-shadow: 0 -6px 24px rgba(59, 130, 246, 0.25) !important;
  border: 1px solid rgba(59, 130, 246, 0.2) !important;
}

#player2:not([class*="type-"]) {
  background: linear-gradient(180deg, 
    rgba(95, 30, 30, 0.6) 0%, 
    rgba(58, 13, 13, 0.4) 75%, 
    transparent 100%) !important;
  box-shadow: 0 6px 24px rgba(239, 68, 68, 0.25) !important;
  border: 1px solid rgba(239, 68, 68, 0.2) !important;
}



/* ============================================
   ATTACK MENU ULTIMATE Z-INDEX FIX
   Makes menu appear as high as possible
============================================ */

/* CRITICAL: Attack menu must be above everything */
.attack-menu {
  z-index: 99999 !important;
  position: fixed !important;
}

/* Ensure card-slot can have positioned children escape */
.card-slot {
  position: relative;
  isolation: auto !important; /* Prevent new stacking context */
}

/* Make sure active area doesn't create stacking context */
.active {
  position: relative;
  z-index: auto !important;
  isolation: auto !important;
}

/* Player areas must have lower z-index */
#player1, #player2 {
  position: relative;
  z-index: 1 !important;
}

/* Ensure player area doesn't block */
.player-area {
  z-index: auto !important;
}

/* When menu is open, boost the entire chain */
.active:has(.attack-menu) {
  z-index: 99998 !important;
}

.active:has(.attack-menu) .card-slot {
  z-index: 99998 !important;
}

.active:has(.attack-menu) .attack-menu {
  z-index: 99999 !important;
}






/* ============================================
   PTCGL ATTACK MENU - SINGLE CLEAN VERSION
============================================ */

.attack-menu-backdrop { display: none !important; }

.attack-menu.ptcgl-style {
  position: fixed !important;
  z-index: 99999 !important;
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
  display: block !important;
}

.ptcgl-card-container {
  position: relative;
  width: 280px;
  height: 392px;
  border-radius: 12px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
  overflow: hidden;
}

.ptcgl-card-container img {
  width: 100%;
  height: 100%;
  border-radius: 12px;
  object-fit: cover;
}

/* Close button removed - click outside card to close */

.ptcgl-hp-type-bar {
  position: absolute;
  top: 6px;
  right: 6px;
  background: rgba(0, 0, 0, 0.85);
  padding: 6px 10px;
  border-radius: 15px;
  display: flex;
  align-items: center;
  gap: 10px;
  z-index: 10;
}

.ptcgl-hp-number {
  font-size: 16px;
  font-weight: 900;
  color: #ffffff;
}

.ptcgl-type-icon-inline {
  width: 20px;
  height: 20px;
  background-size: cover;
  border-radius: 50%;
}

.ptcgl-actions-overlay {
  position: absolute;
  top: 225px;
  left: 10px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 3px;
  z-index: 10;
}

.ptcgl-ability-overlay {
  background: rgba(239, 68, 68, 0.96);  /* Default red (fallback) */
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  padding: 3px 5px;
  cursor: pointer;
}

/* ABILITY TYPE COLORS */
.ptcgl-ability-overlay.type-grass {
  background: rgba(139, 195, 74, 0.96);
  border: 1px solid rgba(104, 159, 56, 0.8);
}

.ptcgl-ability-overlay.type-fire {
  background: rgba(239, 83, 80, 0.96);
  border: 1px solid rgba(211, 47, 47, 0.8);
}

.ptcgl-ability-overlay.type-water {
  background: rgba(66, 165, 245, 0.96);
  border: 1px solid rgba(25, 118, 210, 0.8);
}

.ptcgl-ability-overlay.type-lightning {
  background: rgba(255, 202, 40, 0.96);
  border: 1px solid rgba(251, 192, 45, 0.8);
}

.ptcgl-ability-overlay.type-psychic {
  background: rgba(171, 71, 188, 0.96);
  border: 1px solid rgba(123, 31, 162, 0.8);
}

.ptcgl-ability-overlay.type-fighting {
  background: rgba(255, 138, 101, 0.96);
  border: 1px solid rgba(230, 74, 25, 0.8);
}

.ptcgl-ability-overlay.type-darkness {
  background: rgba(66, 66, 66, 0.96);
  border: 1px solid rgba(33, 33, 33, 0.8);
}

.ptcgl-ability-overlay.type-metal {
  background: rgba(158, 158, 158, 0.96);
  border: 1px solid rgba(117, 117, 117, 0.8);
}

.ptcgl-ability-overlay.type-dragon {
  background: rgba(211, 186, 48, 0.96);  /* GOLD! */
  border: 1px solid rgba(184, 158, 32, 0.8);
}

.ptcgl-ability-overlay.type-fairy {
  background: rgba(236, 64, 122, 0.96);
  border: 1px solid rgba(194, 24, 91, 0.8);
}

.ptcgl-ability-overlay.type-colorless {
  background: rgba(189, 189, 189, 0.96);
  border: 1px solid rgba(158, 158, 158, 0.8);
}

.ptcgl-ability-name {
  font-size: 10px;
  font-weight: 900;
  color: #ffffff;
}

.ptcgl-ability-text {
  font-size: 8px;
  color: rgba(255, 255, 255, 0.95);
}

/* Attack overlay - DEFAULT (unpayable) state - WHITE */
.ptcgl-attack-overlay {
  background: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(0, 0, 0, 0.1);
  border-radius: 8px;
  cursor: not-allowed;
  overflow: hidden;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  opacity: 0.7;
}

/* PAYABLE - shows type color */
.ptcgl-attack-overlay.payable {
  cursor: pointer;
  opacity: 1;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
}

.ptcgl-attack-overlay.payable:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

/* TYPE COLORS */
.ptcgl-attack-overlay.payable.type-grass {
  background: rgba(139, 195, 74, 0.95);
  border: 2px solid rgba(104, 159, 56, 0.8);
}

.ptcgl-attack-overlay.payable.type-fire {
  background: rgba(239, 83, 80, 0.95);
  border: 2px solid rgba(211, 47, 47, 0.8);
}

.ptcgl-attack-overlay.payable.type-water {
  background: rgba(66, 165, 245, 0.95);
  border: 2px solid rgba(25, 118, 210, 0.8);
}

.ptcgl-attack-overlay.payable.type-lightning {
  background: rgba(255, 202, 40, 0.95);
  border: 2px solid rgba(251, 192, 45, 0.8);
}

.ptcgl-attack-overlay.payable.type-psychic {
  background: rgba(171, 71, 188, 0.95);
  border: 2px solid rgba(123, 31, 162, 0.8);
}

.ptcgl-attack-overlay.payable.type-fighting {
  background: rgba(255, 138, 101, 0.95);
  border: 2px solid rgba(230, 74, 25, 0.8);
}

.ptcgl-attack-overlay.payable.type-darkness {
  background: rgba(66, 66, 66, 0.95);
  border: 2px solid rgba(33, 33, 33, 0.8);
}

.ptcgl-attack-overlay.payable.type-metal {
  background: rgba(158, 158, 158, 0.95);
  border: 2px solid rgba(117, 117, 117, 0.8);
}

.ptcgl-attack-overlay.payable.type-dragon {
  background: rgba(211, 186, 48, 0.95);  /* GOLD! */
  border: 2px solid rgba(184, 158, 32, 0.8);
}

.ptcgl-attack-overlay.payable.type-fairy {
  background: rgba(236, 64, 122, 0.95);
  border: 2px solid rgba(194, 24, 91, 0.8);
}

.ptcgl-attack-overlay.payable.type-colorless {
  background: rgba(189, 189, 189, 0.95);
  border: 2px solid rgba(158, 158, 158, 0.8);
}

.ptcgl-attack-left {
  flex: 1;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 6px 10px;
  z-index: 2;
}

/* Attack name - grayed out when can't pay */
.ptcgl-attack-name {
  font-size: 12px;
  font-weight: 700;
  color: rgba(0, 0, 0, 0.3);
  line-height: 1;
}

.ptcgl-attack-overlay.payable .ptcgl-attack-name {
  color: #000000 !important;
  text-shadow: 0 1px 2px rgba(255,255,255,0.5);
}

/* Duplicate removed - using BLACK text above */



.ptcgl-attack-cost {
  display: flex;
  gap: 2px;
}

.ptcgl-cost-icon {
  width: 18px;
  height: 18px;
  background-size: cover;
  border-radius: 50%;
  opacity: 0.4;
}

.ptcgl-attack-overlay.payable .ptcgl-cost-icon {
  opacity: 1;
  filter: brightness(1.1);
}

/* Separator - dark when can't pay */
.ptcgl-attack-separator {
  display: none;
}

/* Separator - inherits type color when payable */
.ptcgl-attack-overlay.payable .ptcgl-attack-separator {
  opacity: 0.95;
}

.ptcgl-attack-damage-box {
  position: relative;
  right: auto;
  top: auto;
  width: auto;
  min-width: 40px;
  background: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 8px;
  z-index: 2;
}

.ptcgl-attack-damage {
  font-size: 22px;
  font-weight: 900;
  color: rgba(0, 0, 0, 0.3);
  line-height: 1;
  transition: all 0.3s ease;
  display: inline-block;
}

.ptcgl-attack-overlay.payable .ptcgl-attack-damage {
  color: #000000 !important;
  text-shadow: 0 1px 2px rgba(255,255,255,0.5);
}

.ptcgl-attack-overlay.payable:hover .ptcgl-attack-damage {
  transform: scale(1.15);
  text-shadow: 0 2px 4px rgba(0, 212, 255, 0.5), 0 0 8px rgba(0, 212, 255, 0.3);
  color: #00d4ff !important;
}

.ptcgl-attack-effect {
  font-size: 8px;
  color: rgba(255, 255, 255, 0.85);
  padding: 0 5px 3px 5px;
}

.ptcgl-retreat-corner {
  position: absolute;
  bottom: 35px;
  right: 6px;
  background: rgba(255, 255, 255, 0.98);
  border-radius: 12px;
  padding: 3px 10px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  z-index: 10;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ptcgl-retreat-corner:hover {
  background: rgba(255, 255, 255, 1);
  transform: translateY(-1px);
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
}

/* Type-based coloring for retreat corner */
.ptcgl-retreat-corner[data-type="water"] { background: #6890f0 !important; }
.ptcgl-retreat-corner[data-type="fire"] { background: #f08030 !important; }
.ptcgl-retreat-corner[data-type="grass"] { background: #78c850 !important; }
.ptcgl-retreat-corner[data-type="lightning"] { background: #f8d030 !important; }
.ptcgl-retreat-corner[data-type="psychic"] { background: #f85888 !important; }
.ptcgl-retreat-corner[data-type="fighting"] { background: #c03028 !important; }
.ptcgl-retreat-corner[data-type="darkness"] { background: #705848 !important; }
.ptcgl-retreat-corner[data-type="metal"] { background: #b8b8d0 !important; }
.ptcgl-retreat-corner[data-type="colorless"] { background: #c6c6a7 !important; }
.ptcgl-retreat-corner[data-type="dragon"] { background: #7038f8 !important; }

/* White text for colored retreat */
.ptcgl-retreat-corner[data-type] .ptcgl-retreat-label,
.ptcgl-retreat-corner[data-type] .ptcgl-retreat-icon {
  color: #ffffff !important;
}

.ptcgl-retreat-label {
  font-size: 10px;
  font-weight: 700;
  color: #000000;
  text-transform: lowercase;
  letter-spacing: 0.3px;
  line-height: 1;
}


/* Energy pips display */
.ptcgl-energy-pips {
  position: absolute;
  bottom: 6px;
  left: 6px;
  right: 6px;
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  max-height: 50px;
  z-index: 5;
  pointer-events: none;
}

.ptcgl-energy-pip {
  width: 20px;
  height: 20px;
  background-size: cover;
  background-position: center;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, 0.8);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  flex-shrink: 0;
}

.ptcgl-weakness-corner {
  position: absolute;
  bottom: 35px;
  left: 6px;
  background: rgba(255, 255, 255, 0.98);
  padding: 4px 6px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 4px;
  z-index: 10;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ptcgl-weakness-label {
  font-size: 9px;
  font-weight: 700;
  color: #000000 !important;
  text-transform: lowercase;
  letter-spacing: 0.3px;
  line-height: 1;
}

.ptcgl-weakness-value {
  font-size: 13px;
  font-weight: 900;
  color: #000000 !important;
  line-height: 1;
}

.ptcgl-weakness-icon {
  width: 16px;
  height: 16px;
  background-size: cover;
  border-radius: 50%;
}

.type-grass { color: #22c55e !important; }
.type-fire { color: #ef4444 !important; }
.type-water { color: #3b82f6 !important; }
.type-lightning { color: #eab308 !important; }
.type-psychic { color: #a855f7 !important; }
.type-fighting { color: #f97316 !important; }
.type-darkness { color: #64748b !important; }
.type-metal { color: #94a3b8 !important; }
.type-dragon { color: #8b5cf6 !important; }
.type-fairy { color: #ec4899 !important; }
.type-colorless { color: #9ca3af !important; }

.card-slot.menu-open {
  opacity: 0 !important;
  pointer-events: none !important;
}

/* ============================
   ABILITY MODAL STYLES
   Add these to your battle.html CSS
============================ */

/* Base ability option styling */
.ability-option {
  padding: 12px 16px;
  margin: 8px 0;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  color: white;
  font-weight: 500;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
  border: 2px solid transparent;
}

/* Active abilities - clickable */
.ability-option:not(.passive-ability):hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.3);
  border-color: rgba(255,255,255,0.3);
}

/* Passive abilities - not clickable */
.ability-option.passive-ability {
  cursor: not-allowed;
  opacity: 0.75;
  border: 2px solid rgba(255,255,255,0.2);
  filter: saturate(0.7);
}

.ability-option.passive-ability:hover {
  transform: none;
  box-shadow: none;
}

/* Passive label badge */
.passive-label {
  display: inline-block;
  padding: 3px 8px;
  background: rgba(0, 0, 0, 0.4);
  border-radius: 4px;
  font-size: 10px;
  font-weight: bold;
  color: white;
  margin-left: 8px;
  letter-spacing: 0.5px;
  vertical-align: middle;
}

/* ============================
   TYPE-BASED BACKGROUNDS
============================ */

/* Grass */
.ability-grass {
  background: linear-gradient(135deg, #78C850 0%, #5CA935 100%);
}

/* Fire */
.ability-fire {
  background: linear-gradient(135deg, #F08030 0%, #DD6610 100%);
}

/* Water */
.ability-water {
  background: linear-gradient(135deg, #6890F0 0%, #386CEB 100%);
}

/* Lightning/Electric */
.ability-lightning,
.ability-electric {
  background: linear-gradient(135deg, #F8D030 0%, #F0C108 100%);
  color: #333; /* Dark text for better contrast */
  text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
}

/* Psychic */
.ability-psychic {
  background: linear-gradient(135deg, #F85888 0%, #F61C5D 100%);
}

/* Fighting */
.ability-fighting {
  background: linear-gradient(135deg, #C03028 0%, #9D2721 100%);
}

/* Darkness/Dark */
.ability-darkness,
.ability-dark {
  background: linear-gradient(135deg, #705848 0%, #513F34 100%);
}

/* Metal/Steel */
.ability-metal,
.ability-steel {
  background: linear-gradient(135deg, #B8B8D0 0%, #9999B3 100%);
}

/* Dragon - FIXED COLOR */
.ability-dragon {
  background: linear-gradient(135deg, #d3ba30 0%, #b89e20 100%);
  color: #2d2d2d; /* Dark text for better contrast */
  text-shadow: 1px 1px 2px rgba(255,255,255,0.2);
}

/* Fairy */
.ability-fairy {
  background: linear-gradient(135deg, #EE99AC 0%, #E67199 100%);
}

/* Colorless/Normal */
.ability-colorless,
.ability-normal {
  background: linear-gradient(135deg, #A8A878 0%, #8A8A59 100%);
}

/* ============================
   MOVE TYPE BACKGROUNDS
   (Update dragon color here too)
============================ */

/* Dragon moves - FIXED COLOR */
.move-dragon {
  background: linear-gradient(135deg, #d3ba30 0%, #b89e20 100%);
  color: #2d2d2d;
  text-shadow: 1px 1px 2px rgba(255,255,255,0.2);
}

/* Lightning moves - better contrast */
.move-lightning,
.move-electric {
  background: linear-gradient(135deg, #F8D030 0%, #F0C108 100%);
  color: #333;
  text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
}

/* ============================
   ABILITY TEXT STYLING
============================ */

.ability-option strong {
  font-size: 16px;
  display: block;
  margin-bottom: 4px;
}

.ability-option small {
  font-size: 12px;
  opacity: 0.9;
  line-height: 1.4;
}

/* ============================
   RESPONSIVE ADJUSTMENTS
============================ */

@media (max-width: 768px) {
  .ability-option {
    padding: 10px 12px;
  }
  
  .ability-option strong {
    font-size: 14px;
  }
  
  .ability-option small {
    font-size: 11px;
  }
  
  .passive-label {
    font-size: 9px;
    padding: 2px 6px;
  }
}


</style>

<script src="./effects.js"></script>

</head>
<body>
<h1>Pok√©mon TCG Pocket Battle</h1>
<div id="popup"></div>
<div class="main-layout">
  <div class="battlefield">
    <div class="player-area" id="player2">
      <div id="p2Bubble" class="deck-bubble">0</div>
      <div id="p2DeckStack" class="deck-stack"></div>
      <div class="points-indicator" id="p2Points">
        <div class="point-bubble" data-i="1"></div>
        <div class="point-bubble" data-i="2"></div>
        <div class="point-bubble" data-i="3"></div>
      </div>
      <div class="hand" id="p2Hand"></div>
      <div class="bench" id="p2Bench">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="active" id="p2Active">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <button class="discard-btn right" id="p2DiscardBtn">View Discard</button>
    </div>

    <div class="player-area" id="player1">
      <div id="p1Bubble" class="deck-bubble">0</div>
      <div id="p1DeckStack" class="deck-stack"></div>
      <div class="points-indicator" id="p1Points">
        <div class="point-bubble" data-i="1"></div>
        <div class="point-bubble" data-i="2"></div>
        <div class="point-bubble" data-i="3"></div>
      </div>
      <div class="active" id="p1Active">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="bench" id="p1Bench">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="hand" id="p1Hand"></div>
      <button class="discard-btn" id="p1DiscardBtn">View Discard</button>
    </div>
  </div>

  <div class="side-panel">
    <div class="coin" id="coin">
      <img class="front" crossorigin="anonymous" src="imgs/coin_front.png" alt="Coin front">
      <img class="back" crossorigin="anonymous" src="imgs/Coin_Back_TM.png" alt="Coin back">
    </div>
    <div id="coinResult"></div>
    <button id="mainButton">Draw Hands</button>
    <div class="turnbox">
      <div>Turn</div>
      <div id="turnNum" class="big">1</div>
      <div id="turnPlayer">Current: ‚Äî</div>
    </div>
    <h4 style="margin:0 .25rem;">Energy Zone</h4>
    <div class="energy-zone" id="energyZone"></div>
    <button id="logToggleBtn">Show Log</button>
  </div>
</div>

<!-- Pok√©mon zoom modal -->
<div id="zoomBackdrop" class="zoom-backdrop">
  <div class="zoom-modal">
    <div style="position: relative;">
      <img id="zoomImg" src="" alt="Card zoom">
      <img id="zoomToolImg" src="" alt="Tool" style="display: none; position: absolute; top: -20px; right: -20px; width: 80px; height: 112px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 2px solid #6e4e9c; z-index: 10;">
    </div>
    <div class="zoom-panel">
<div class="zoom-header">
  <div id="zoomTitle" class="zoom-title"></div>
  <div style="display:flex;align-items:center;gap:8px">
    <div id="zoomStatus" class="zoom-status" style="display:none;"></div>
    <div id="zoomHp" class="zoom-hp"></div>
    <div id="zoomType" class="zoom-type-pill"></div>
  </div>
</div>


      <div class="hpbar-container"><div id="zoomHpBar" class="hpbar-fill"></div></div>
      <div class="zoom-section" id="zoomAttached">
        <div class="row">
          <div><strong>Attached Energy</strong></div>
          <div id="zoomEnergyCount" class="chip">x0</div>
        </div>
        <div id="zoomEnergyIcons" class="icon-row"></div>
        <div class="row" style="margin-top:10px">
          <div><strong>Attached Tools</strong></div>
          <div id="zoomTools" class="icon-row"></div>
        </div>
      </div>
      <div class="zoom-section" id="zoomAbilities" style="display:none"></div>
      <div class="zoom-section">
        <div><strong>Attacks</strong></div>
        <div id="zoomAttacks"></div>
      </div>
      <div class="zoom-section">
        <div class="row">
          <div><strong>Weakness</strong></div>
          <div id="zoomWeakness" class="icon-row"></div>
        </div>
        <div class="row" id="zoomRetreatRow">
          <div><strong>Retreat</strong></div>
          <div id="zoomRetreat" class="icon-row"></div>
        </div>
        <div style="text-align:right;color:#9ca3af;font-size:12px;margin-top:6px">Right-click anywhere or press Esc.</div>
      </div>
    </div>
  </div>
</div>

<!-- Tool modal -->
<div id="toolBackdrop">
  <div id="toolCard">
    <img id="toolImg" src="" alt="Tool Card">
    <div id="toolPanel">
      <h3 id="toolTitle">Tool</h3>
      <div id="toolMeta" class="chip" style="margin-bottom:8px"></div>
      <div class="thin" style="height:1px;background:#3b3f46;margin:8px 0"></div>
      <div id="toolText" style="font-size:13px;color:#cbd5e1;line-height:1.25"></div>
      <div style="margin-top:12px;font-size:12px;color:#9ca3af">Click outside to close.</div>
    </div>
  </div>
</div>

<!-- Hand Card modal -->
<div id="handBackdrop" class="zoom-backdrop">
  <div class="zoom-modal">
    <div style="position: relative;">
      <img id="handImg" src="" alt="Card image">
      <img id="handToolImg" src="" alt="Tool" style="display: none; position: absolute; top: -20px; right: -20px; width: 80px; height: 112px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 2px solid #6e4e9c; z-index: 10;">
    </div>
    <div class="zoom-panel" id="handPanel">
      <div id="handTitle" class="zoom-title"></div>
      <div id="handType" class="chip" style="margin-top:6px;"></div>
      <div id="handEffect" style="font-size:13px;color:#cbd5e1;margin-top:10px;line-height:1.4"></div>
      <div style="text-align:right;color:#9ca3af;font-size:12px;margin-top:12px">
        Right-click anywhere or press Esc to close.
      </div>
    </div>
  </div>
</div>

<!-- victory overlay -->
<div id="victoryOverlay">
  <div id="victoryCard">
    <h2 id="victoryTitle">Player Wins!</h2>
    <p id="victoryDesc">Game over</p>
    <div style="display:flex;justify-content:center;gap:12px;margin:10px 0 18px 0">
      <div class="chip">P1 Points: <span id="p1Pts">0</span></div>
      <div class="chip">P2 Points: <span id="p2Pts">0</span></div>
    </div>
    <div id="victoryBtns">
      <button id="playAgainBtn">Play again</button>
      <button id="chooseDecksBtn">Choose new decks</button>
      <button id="victoryShowLogBtn">Show Match Log</button>
    </div>
  </div>
</div>

<!-- Choice Dialog Modal -->
<div id="choiceDialogBackdrop" class="zoom-backdrop">
  <div id="choiceDialogCard" style="width:min(500px,90vw);background:#101418;border:1px solid #334155;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.6);padding:24px;color:#e5e7eb;text-align:center;">
    <h2 id="choiceDialogTitle" style="margin:0 0 12px 0;font-size:20px;font-weight:700;">Choose an Option</h2>
    <p id="choiceDialogDesc" style="margin:0 0 20px 0;color:#cbd5e1;font-size:14px;"></p>
    <div id="choiceDialogButtons" style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
      <!-- Buttons will be added dynamically -->
    </div>
  </div>
</div>

<!-- Hiker Card Reorder Modal -->
<div id="hikerReorderBackdrop" class="zoom-backdrop">
  <div id="hikerReorderCard" style="width:min(90vw,1200px);max-width:1200px;background:#101418;border:1px solid #334155;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.6);padding:24px;color:#e5e7eb;">
    <h2 id="hikerReorderTitle" style="margin:0 0 12px 0;font-size:20px;font-weight:700;text-align:center;">Reorder Top Cards</h2>
    <p id="hikerReorderDesc" style="margin:0 0 20px 0;color:#cbd5e1;font-size:14px;text-align:center;">Drag cards to reorder them. The leftmost card will be on top of your deck.</p>
    <div id="hikerReorderCards" style="position:relative;display:flex;gap:12px;justify-content:center;flex-wrap:wrap;min-height:200px;margin-bottom:20px;">
      <!-- Cards will be added dynamically -->
    </div>
    <div style="text-align:center;">
      <button id="hikerReorderDone" style="background:#6e4e9c;color:#fff;border:none;padding:10px 24px;border-radius:8px;cursor:pointer;font-size:16px;font-weight:600;">Done</button>
    </div>
  </div>
</div>

<!-- discard drawers -->
<div class="discard-drawer right" id="p1DiscardDrawer"></div>
<div class="discard-drawer right" id="p2DiscardDrawer"></div>

<!-- LOG PANEL (right slide) -->
<div id="logPanel">
  <div id="logPanelHeader">Battle Log</div>
  <button id="closeLogBtn" style="margin:8px 14px 10px;width:calc(100% - 28px);background:#e5e7eb;border:1px solid #c2c4c6;color:#111;padding:6px;border-radius:6px;cursor:pointer;">
    Close Log
  </button>
  <div id="logEntries"></div>
</div>


<!-- FULL MATCH HISTORY MODAL -->
<div id="historyBackdrop">
  <div id="historyCard">
    <h2>Match History</h2>
    <div id="fullHistory"></div>
    <div style="text-align:center;margin-top:14px;">
      <button onclick="document.getElementById('historyBackdrop').classList.remove('show')">
        Close
      </button>
    </div>
  </div>
</div>

<script type="module">

  

  // REQUIRED GLOBAL STATE OBJECT FOR EFFECTS
globalThis.state = { temp: { p1: {}, p2: {} } };


/* ============================
   SPECIAL EFFECTS SYSTEM
   
   Paste this entire section into your battle.html <script> tag
   (somewhere after effects.js is loaded)
============================ */

// Initialize special effects storage
if (!globalThis.__specialEffects) {
  globalThis.__specialEffects = { p1: {}, p2: {} };
  console.log('[special-effects] Initialized');
}

/**
 * Check if player can retreat
 * @param {string} pk - 'p1' or 'p2'
 * @returns {boolean}
 */
function canRetreat(pk) {
  // Check for sleep and paralysis - both block retreat
  const img = getActiveImg(pk);
  if (img) {
    const status = (img.dataset.status || '').toLowerCase();
    if (status === 'asleep') {
      console.log(`[retreat] ${pk} cannot retreat - Pokemon is asleep`);
      return false;
    }
    if (status === 'paralyzed') {
      console.log(`[retreat] ${pk} cannot retreat - Pokemon is paralyzed`);
      return false;
    }
  }
  
  if (globalThis.__specialEffects?.[pk]?.retreatLock) {
    console.log(`[special-effects] ${pk} is retreat locked`);
    return false;
  }
  return true;
}

/**
 * Check if player can attack
 * @param {string} pk - 'p1' or 'p2'
 * @returns {boolean}
 */
function canAttack(pk) {
  if (globalThis.__specialEffects?.[pk]?.attackLock) {
    console.log(`[special-effects] ${pk} is attack locked`);
    return false;
  }
  return true;
}

/**
 * Check if player can use Supporters
 * @param {string} pk - 'p1' or 'p2'
 * @returns {boolean}
 */
function canUseSupporter(pk) {
  if (globalThis.__specialEffects?.[pk]?.supporterBlock) {
    console.log(`[special-effects] ${pk} is supporter blocked`);
    return false;
  }
  return true;
}

/**
 * Apply damage reduction/prevention to incoming damage
 * @param {string} defendingPk - 'p1' or 'p2'
 * @param {number} baseDamage - Original damage amount
 * @returns {number} Final damage after reductions
 */
function applySpecialEffectsToDamage(defendingPk, baseDamage) {
  let damage = baseDamage;
  
  // üÜï A3 - Check for complete immunity (Mr. Mime's Barrier Shove)
  const defenderImg = getActiveImg(defendingPk);
  if (defenderImg?.dataset.preventAllNextTurn === 'true') {
    console.log(`[prevent-all-next-turn] ${defendingPk} immune to all damage and effects`);
    showPopup("All damage and effects prevented!");
    delete defenderImg.dataset.preventAllNextTurn; // Clear after use
    return 0;
  }
  
  // üÜï A4a - prevent_damage_and_effects_next_turn (Zoroark - Illusionary Strike)
  // This is set when the opponent's Pokemon is KO'd by this Pokemon's attack
  if (defenderImg?.dataset.preventDamageAndEffectsNextTurn === 'true') {
    console.log(`[prevent-damage-and-effects-next-turn] ${defendingPk} immune to all damage and effects`);
    showPopup("All damage and effects prevented!");
    delete defenderImg.dataset.preventDamageAndEffectsNextTurn; // Clear after use
    return 0;
  }
  
  // Check for complete prevention
  if (globalThis.__specialEffects?.[defendingPk]?.preventDamage) {
    console.log(`[special-effects] ${defendingPk} damage prevented`);
    showPopup("Attack prevented!");
    return 0;
  }
  
  // üÜï A3 - Check if defender takes increased damage this turn
  if (defenderImg?.dataset.incomingDamageIncrease) {
    const increase = parseInt(defenderImg.dataset.incomingDamageIncrease, 10);
    damage += increase;
    console.log(`[incoming-damage-increase] ${defendingPk} takes +${increase}: ${baseDamage} ‚Üí ${damage}`);
    showPopup(`Damage increased by ${increase}!`);
    delete defenderImg.dataset.incomingDamageIncrease; // Clear after use
  }
  
  // Apply reduction
  const reduction = globalThis.__specialEffects?.[defendingPk]?.damageReduction || 0;
  if (reduction > 0) {
    damage = Math.max(0, damage - reduction);
    console.log(`[special-effects] ${defendingPk} damage reduced by ${reduction}: ${baseDamage} ‚Üí ${damage}`);
    if (damage > 0) {
      showPopup(`Damage reduced by ${reduction}!`);
    } else {
      showPopup(`All damage blocked!`);
    }
  }
  
  return damage;
}

/**
 * Clear all special effects for a player
 * @param {string} pk - 'p1' or 'p2'
 */
function clearSpecialEffects(pk) {
  if (globalThis.__specialEffects?.[pk]) {
    const had = Object.keys(globalThis.__specialEffects[pk]).length > 0;
    if (had) {
      console.log(`[special-effects] Clearing effects for ${pk}:`, globalThis.__specialEffects[pk]);
    }
    globalThis.__specialEffects[pk] = {};
  }
}

/**
 * Clear effects at turn start
 * Call this at the beginning of each turn for the current player
 * @param {string} pk - 'p1' or 'p2' (player whose turn is starting)
 */
function clearExpiredEffectsOnTurnStart(pk) {
  // üÜï Don't clear attackLock here - it needs to persist until the locked turn ends
  // Clear other special effects, but preserve attackLock if it exists
  const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
  
  if (attackLock) {
    console.log(`[clearExpiredEffectsOnTurnStart] Preserving attackLock for ${pk}:`, attackLock);
  }
  
  clearSpecialEffects(pk);
  
  // Restore attackLock if it was cleared (it should persist until the locked turn ends)
  if (attackLock && globalThis.__specialEffects?.[pk]) {
    globalThis.__specialEffects[pk].attackLock = attackLock;
    console.log(`[clearExpiredEffectsOnTurnStart] Restored attackLock for ${pk}`);
  } else if (attackLock) {
    // If __specialEffects[pk] doesn't exist, recreate it
    if (!globalThis.__specialEffects) globalThis.__specialEffects = { p1: {}, p2: {} };
    if (!globalThis.__specialEffects[pk]) globalThis.__specialEffects[pk] = {};
    globalThis.__specialEffects[pk].attackLock = attackLock;
    console.log(`[clearExpiredEffectsOnTurnStart] Recreated and restored attackLock for ${pk}`);
  }
  
  // üÜï Clear attackLock if it's expired (after the locked turn has passed)
  if (globalThis.__specialEffects?.[pk]?.attackLock) {
    const lock = globalThis.__specialEffects[pk].attackLock;
    const currentTurn = globalThis.turnNumber || 0;
    
    if (typeof lock === 'object' && lock.lockedOnTurn !== undefined) {
      // Lock was applied on turn N, it's active on turn N+2 (player's next turn)
      // Lock should be cleared after turn N+2 ends, so clear it when we reach turn N+3
      // This means: turn N (used Giga Impact) ‚Üí turn N+1 (opponent) ‚Üí turn N+2 (locked) ‚Üí turn N+3 (lock cleared)
      if (currentTurn > lock.lockedOnTurn + 2) {
        delete globalThis.__specialEffects[pk].attackLock;
        console.log(`[Attack Lock] Cleared lock for ${pk} - lock was on turn ${lock.lockedOnTurn}, now on turn ${currentTurn}`);
      }
    } else if (lock === true) {
      // Backwards compat: clear immediately if it's just a boolean (shouldn't happen with new code)
      delete globalThis.__specialEffects[pk].attackLock;
    }
  }
  
  // üÜï A2 MOVE EFFECT - Clear locked attacks for this player
  const allPokemon = [getActiveImg(pk), ...getBenchImgs(pk)].filter(Boolean);
  for (const img of allPokemon) {
    if (img.dataset.lockedAttack) {
      console.log(`[clear-effects] Clearing locked attack "${img.dataset.lockedAttack}" from ${img.alt}`);
      delete img.dataset.lockedAttack;
    }
  }
}

// Expose globally for debugging
globalThis.canRetreat = canRetreat;
globalThis.canAttack = canAttack;
globalThis.canUseSupporter = canUseSupporter;
globalThis.applySpecialEffectsToDamage = applySpecialEffectsToDamage;
globalThis.clearSpecialEffects = clearSpecialEffects;
globalThis.clearExpiredEffectsOnTurnStart = clearExpiredEffectsOnTurnStart;

console.log('[special-effects] Helper functions loaded');

const popupEl = document.getElementById("popup");


/* ========= trainer CSV ========= */
let TRAINER_EFFECT_DATA=[];
fetch('trainer_effects.csv')
  .then(r=>r.text())
  .then(t=>{
    TRAINER_EFFECT_DATA=parseCSV(t);
    // Expose globally for effects.js
    globalThis.TRAINER_EFFECT_DATA = TRAINER_EFFECT_DATA;
    window.TRAINER_EFFECT_DATA = TRAINER_EFFECT_DATA;
    console.log('[trainer] CSV loaded:',TRAINER_EFFECT_DATA.length,'rows');
  });

function parseCSV(text){
  const rows=[];let i=0,f='',row=[],q=false;
  const pf=()=>{row.push(f);f=''},pr=()=>{if(row.length)rows.push(row);row=[]};
  while(i<text.length){
    const c=text[i];
    if(q){
      if(c==='"'&&text[i+1]==='"'){f+='"';i+=2;continue}
      if(c==='"'){q=false;i++;continue}
      f+=c;i++;continue;
    }else{
      if(c==='"'){q=true;i++;continue}
      if(c===','){pf();i++;continue}
      if(c==='\r'){i++;continue}
      if(c==='\n'){pf();pr();i++;continue}
      f+=c;i++;continue;
    }
  }
  if(f.length||row.length){pf();pr()}
  const [h,...b]=rows;
  if(!h) return[];
  return b.map(r=>Object.fromEntries(h.map((k,ix)=>[k.trim(),(r[ix]??'').trim()])));
}
const csvIdFor=(set,num)=>`${set}-${String(num).padStart(3,'0')}`;

/* ========= constants ========= */
const ENERGY_ICONS={
  fire:'https://archives.bulbagarden.net/media/upload/thumb/a/ad/Fire-attack.png/20px-Fire-attack.png',
  water:'https://archives.bulbagarden.net/media/upload/thumb/1/11/Water-attack.png/20px-Water-attack.png',
  grass:'https://archives.bulbagarden.net/media/upload/thumb/2/2e/Grass-attack.png/20px-Grass-attack.png',
  lightning:'https://archives.bulbagarden.net/media/upload/thumb/0/04/Lightning-attack.png/20px-Lightning-attack.png',
  psychic:'https://archives.bulbagarden.net/media/upload/thumb/e/ef/Psychic-attack.png/20px-Psychic-attack.png',
  fighting:'https://archives.bulbagarden.net/media/upload/thumb/4/48/Fighting-attack.png/20px-Fighting-attack.png',
  darkness:'https://archives.bulbagarden.net/media/upload/thumb/a/ab/Darkness-attack.png/20px-Darkness-attack.png',
  metal:'https://archives.bulbagarden.net/media/upload/thumb/6/64/Metal-attack.png/20px-Metal-attack.png',
  dragon:'https://archives.bulbagarden.net/media/upload/thumb/c/c9/Dragon-attack.png/20px-Dragon-attack.png',
  colorless:'https://archives.bulbagarden.net/media/upload/thumb/1/1d/Colorless-attack.png/30px-Colorless-attack.png'
};

/* ========= ability helpers ========= */
function getAbilityCardKey(set, num, img) {
  // If img provided, use its unique instance ID
  if (img && img.dataset.instanceId) {
    return `instance-${img.dataset.instanceId}`;
  }
  
  // Fallback to card-based key (for backwards compatibility)
  const normalizedSet = String(set || '').toUpperCase();
  const normalizedNum = String(num || '').padStart(3, '0');
  return `${normalizedSet}-${normalizedNum}`;
}

function abilityRequiresActive(row) {
  const txt = (row.text || '').toLowerCase();
  return txt.includes('if this pok√©mon is in the active spot') ||
         txt.includes('as long as this pok√©mon is in the active spot');
}

const TYPE_HEX={
  fire:'#f08030',water:'#6890f0',grass:'#78c850',lightning:'#f8d030',
  psychic:'#f85888',fighting:'#c03028',darkness:'#705848',
  metal:'#b8b8d0',dragon:'#d3ba30',colorless:'#c6c6a7'
};
const ABILITY_BADGE='https://archives.bulbagarden.net/media/upload/thumb/0/06/TCGAbilityIcon.png/150px-TCGAbilityIcon.png';

/* ========= status icon URLs ========= */
const STATUS_ICON_URLS = {
  poisoned:  'https://img.game8.co/4032556/c9ba9a1b0a05840ece5f931c7c1321a4.png/show',
  confused:  'https://img.game8.co/4094717/5ab86a0b822d0e62b2c579b570086f83.png/show',
  paralyzed: 'https://img.game8.co/4032560/0410c7a29706b6533839572ddf3204a5.png/show',
  asleep:    'https://img.game8.co/4032559/fd51a89575d9ce25c0ee9bf451f3a6fe.png/show',
  burned:    'https://img.game8.co/4096103/c432edb7c5f7bb6a914ad5837bffce84.png/show'
};


/* ========= DOM ========= */
const $=s=>document.querySelector(s);
const $$=s=>Array.from(document.querySelectorAll(s));

const popup=$('#popup'),
      energyZoneDiv=$('#energyZone'),
      coinEl=$('#coin'),
      coinResult=$('#coinResult'),
      mainButton=$('#mainButton'),
      turnNumEl=$('#turnNum'),
      turnPlayerEl=$('#turnPlayer');

const p1HandDiv=$('#p1Hand'),
      p2HandDiv=$('#p2Hand'),
      p1Active=$('#p1Active'),
      p2Active=$('#p2Active'),
      p1Bench=$('#p1Bench'),
      p2Bench=$('#p2Bench'),
      p1Bubble=$('#p1Bubble'),
      p2Bubble=$('#p2Bubble');

const zoomBackdrop=$('#zoomBackdrop'),
      zoomImg=$('#zoomImg'),
      zoomToolImg=$('#zoomToolImg'),
      zoomTitle=$('#zoomTitle'),
      zoomHp=$('#zoomHp'),
      zoomHpBar=$('#zoomHpBar'),
      zoomType=$('#zoomType'),
      zoomStatusIcon=$('#zoomStatusIcon'),
      zoomAttacks=$('#zoomAttacks'),
      zoomEnergyCount=$('#zoomEnergyCount'),
      zoomEnergyIcons=$('#zoomEnergyIcons'),
      zoomWeakness=$('#zoomWeakness'),
      zoomRetreat=$('#zoomRetreat'),
      zoomTools=$('#zoomTools'),
      zoomAbilities=$('#zoomAbilities');


const p1DiscardBtn=$('#p1DiscardBtn'),
      p2DiscardBtn=$('#p2DiscardBtn'),
      p1DiscardDrawer=$('#p1DiscardDrawer'),
      p2DiscardDrawer=$('#p2DiscardDrawer');

const victoryOverlay=$('#victoryOverlay'),
      victoryTitle=$('#victoryTitle'),
      victoryDesc=$('#victoryDesc'),
      p1PtsText=$('#p1Pts'),
      p2PtsText=$('#p2Pts'),
      playAgainBtn=$('#playAgainBtn'),
      chooseDecksBtn=$('#chooseDecksBtn');

const toolBackdrop=$('#toolBackdrop'),
      toolImg=$('#toolImg'),
      toolTitle=$('#toolTitle'),
      toolMeta=$('#toolMeta'),
      toolText=$('#toolText');

const handBackdrop=$('#handBackdrop'),
      handImg=$('#handImg'),
      handToolImg=$('#handToolImg'),
      handTitle=$('#handTitle'),
      handType=$('#handType'),
      handEffect=$('#handEffect');

/* log panel dom */
const logPanel=$('#logPanel'),
      logEntriesDiv=$('#logEntries'),
      logToggleBtn=$('#logToggleBtn'),
      historyBackdrop=$('#historyBackdrop'),
      fullHistoryDiv=$('#fullHistory');

/* ========= state ========= */
globalThis.turnNumber=1;
let currentPlayer=null,firstPlayer=null;

// Expose currentPlayer via getter
Object.defineProperty(globalThis, 'currentPlayer', {
  get: () => currentPlayer,
  set: (val) => { currentPlayer = val; }
});
let hasAttachedEnergyThisTurn=false,selectedEnergy=null,isSetupPhase=true,selectedEnergyElement=null,selectedToolElement=null;
let isEvoMode=false,evoMeta=null,evoOwner=null,evoHandCard=null;
let isPromotionPhase=false,openAttackMenu=null,gameOver=false,hasRetreatedThisTurn=false,isRetreatSelection=false,lastRetreatTime=0,abilityJustUsed=false;
const hasPlayedSupporterThisTurn={player1:false,player2:false};
let p1Points=0,p2Points=0,toolAttachPending=null,currentZoom={img:null,meta:null};
// Ensure global reference exists
globalThis.getPoints = function(player) {
  if (player === 'player1' || player === 'p1') return p1Points;
  if (player === 'player2' || player === 'p2') return p2Points;
  return 0;
};
if (!window.usedAbilitiesThisTurn) {
  window.usedAbilitiesThisTurn = {
    p1: {},
    p2: {}
  };
}
// Use the global reference
let usedAbilitiesThisTurn = window.usedAbilitiesThisTurn;

// Simple type ‚Üí color for ability header band
function typeColorHex(t) {
  const key = (t || '').toLowerCase();
  switch (key) {
    case 'fire':      return '#f97316';
    case 'water':     return '#38bdf8';
    case 'grass':     return '#22c55e';
    case 'lightning': return '#facc15';
    case 'psychic':   return '#a855f7';
    case 'fighting':  return '#f97316';
    case 'metal':
    case 'steel':     return '#9ca3af';
    case 'darkness':  return '#4b5563';
    case 'dragon':    return '#22d3ee';
    case 'colorless': return '#e5e7eb';
    default:          return '#64748b';
  }
}

const playerState={
  player1:{deck:[],hand:[],energyTypes:JSON.parse(localStorage.getItem('player1Energy')||'[]'),currentTurnEnergy:null,nextTurnEnergy:null,discard:{cards:[],energyCounts:{}} },
  player2:{deck:[],hand:[],energyTypes:JSON.parse(localStorage.getItem('player2Energy')||'[]'),currentTurnEnergy:null,nextTurnEnergy:null,discard:{cards:[],energyCounts:{}} }
};

// Helper function to randomly select energy from array
function selectRandomEnergy(energyTypes) {
  if (!energyTypes || energyTypes.length === 0) return null;
  if (energyTypes.length === 1) return energyTypes[0];
  // Randomly pick one from the array
  return energyTypes[Math.floor(Math.random() * energyTypes.length)];
}

// Initialize energy for both players at game start
function initializePlayerEnergy(player) {
  const state = playerState[player];
  const energyTypes = state.energyTypes || [];
  
  if (energyTypes.length > 0) {
    // Set current turn energy (randomly selected if multiple)
    state.currentTurnEnergy = selectRandomEnergy(energyTypes);
    
    // Set next turn energy (randomly selected if multiple)
    state.nextTurnEnergy = selectRandomEnergy(energyTypes);
  }
}

// Initialize energy for both players
initializePlayerEnergy('player1');
initializePlayerEnergy('player2');

function expandDeck(raw){
  const out=[];
  (raw||[]).forEach(c=>{
    if(!c||!c.name||!c.set||(c.number??c.num)==null)return;
    const n=Number(c.quantity)||1;
    for(let i=0;i<n;i++)out.push({...c,quantity:1});
  });
  return out;
}
playerState.player1.deck=expandDeck(JSON.parse(localStorage.getItem('player1Deck')||'[]'));
playerState.player2.deck=expandDeck(JSON.parse(localStorage.getItem('player2Deck')||'[]'));

// Initialize deck stacks
updateDeckStack('player1');
updateDeckStack('player2');

/* ========= logging ========= */

let fullHistoryLog=[];
let logCounter=1;

function highImgUrl(set,num){
  if(!set || num==null) return null;
  return `https://assets.tcgdex.net/en/tcgp/${set}/${String(num).padStart(3,'0')}/high.png`;
}

function logEvent({ player, text, cardSet = null, cardNum = null }) {
  const id = logCounter++;
  const ts = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  const who =
    player === 'player1' ? 'Player 1' :
    player === 'player2' ? 'Player 2' : 'System';

  const cls =
    player === 'player1' ? 'p1' :
    player === 'player2' ? 'p2' : 'sys';

  // build image URL if we have set/num
  const imgUrl = (cardSet && cardNum) ? highImgUrl(cardSet, cardNum) : null;

  // create the log entry element
  const div = document.createElement('div');
  div.className = `log-entry ${cls}`;
  div.dataset.id = id;

  div.innerHTML = `
    <div class="entry-player ${cls}">${who}</div>
    <div class="entry-text">${text}</div>
    ${imgUrl ? `<img class="log-thumb" src="${imgUrl}" alt="card">` : '' }
  `;

  logEntriesDiv.appendChild(div);
  logEntriesDiv.scrollTop = logEntriesDiv.scrollHeight;

  // store for match history modal
  fullHistoryLog.push({ id, ts, player: who, text, cardSet, cardNum, imgUrl });
}

/* === CLICK CARD IN LOG ‚Üí OPEN FULLSCREEN MODAL (FULLY POPULATED FIELDS) === */
logEntriesDiv.addEventListener("click", async (e) => {
  const thumb = e.target.closest(".log-thumb");
  if (!thumb) return;

  // Extract set + num from image URL
  const match = thumb.src.match(/tcgp\/([^\/]+)\/(\d{3})/i);
  if (!match) return;

  const set = match[1];
  const num = match[2];

  let meta;
  try {
    meta = await fetchCardMeta(set, num);
  } catch (err) {
    console.error("Failed to fetch meta", err);
    showPopup("Unable to load card details.");
    return;
  }

  const category = (meta.category || "").toLowerCase();

  // === Create a FAKE BOARD IMAGE so buildZoomPanel() can populate all fields ===
  const fakeImg = document.createElement("img");
  fakeImg.dataset.set = set;
  fakeImg.dataset.num = num;
  fakeImg.dataset.hp = meta.hp || "0";
  fakeImg.dataset.chp = meta.hp || "0";
  fakeImg.src = thumb.src;
  fakeImg.alt = meta.name;

  // Wrap in a temporary fake card-slot with no energies or tools
  const fakeSlot = document.createElement("div");
  fakeSlot.className = "card-slot";
  fakeSlot.appendChild(fakeImg);

  // Add empty energy & tool containers so zoom panel displays correctly
  const fakePips = document.createElement("div");
  fakePips.className = "energy-pips";
  fakeSlot.appendChild(fakePips);

  const fakeHP = document.createElement("div");
  fakeHP.className = "hp-overlay";
  fakeHP.textContent = `${meta.hp} / ${meta.hp}`;
  fakeSlot.appendChild(fakeHP);

  // === Pok√©mon handling ===
  if (category === "pokemon") {
    zoomImg.src = thumb.src;
    zoomBackdrop.classList.add("show");

    // Create a hidden container so fake card-slot exists in the DOM
    const tempWrap = document.createElement("div");
    tempWrap.style.display = "none";
    tempWrap.appendChild(fakeSlot);
    document.body.appendChild(tempWrap);

    await buildZoomPanel(meta, fakeImg);

    // Clean up after zoom closes
    zoomBackdrop.addEventListener("transitionend", () => {
      if (!zoomBackdrop.classList.contains("show")) {
        tempWrap.remove();
      }
    }, { once: true });

    return;

  }

  // === Trainer handling ===
  handImg.src = thumb.src;
  handBackdrop.classList.add("show");
  handTitle.textContent = meta.name || "Trainer Card";
  handType.textContent = meta.trainerType || "Trainer";
  handType.style.background = trainerColor(meta.trainerType || "trainer");
  handEffect.textContent = meta.effect || meta.description || "No effect listed.";
});



if(logToggleBtn){
  logToggleBtn.onclick = () => {
    logPanel.classList.toggle('show');
  };
}
/* === log panel close logic === */
const closeLogBtn = document.getElementById("closeLogBtn");

if (closeLogBtn) {
  closeLogBtn.onclick = () => {
    logPanel.classList.remove("show");
  };
}

// Escape closes log or cancels selection
let selectionCancelHandler = null;
function setupSelectionCancelHandler() {
  // Remove old handler if exists
  if (selectionCancelHandler) {
    document.removeEventListener('keydown', selectionCancelHandler);
  }
  
  // Add new handler
  selectionCancelHandler = (e) => {
    if (e.key === "Escape") {
      // Only cancel selection if log is not open
      if (!logPanel.classList.contains("show")) {
        cancelSelection();
      } else {
        logPanel.classList.remove("show");
      }
    }
  };
  document.addEventListener('keydown', selectionCancelHandler);
}

function cancelSelection() {
  if (selectedEnergy || toolAttachPending) {
    clearSelectionGlow();
    selectedEnergy = null;
    toolAttachPending = null;
    showPopup('Selection cancelled.');
  }
}

function clearSelectionGlow() {
  if (selectedEnergyElement) {
    selectedEnergyElement.classList.remove('selected-glow');
    selectedEnergyElement = null;
  }
  if (selectedToolElement) {
    selectedToolElement.classList.remove('selected-glow');
    selectedToolElement = null;
  }
  // Remove escape handler
  if (selectionCancelHandler) {
    document.removeEventListener('keydown', selectionCancelHandler);
    selectionCancelHandler = null;
  }
}

// Escape closes log (if no selection active)
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    // Only close log if no selection is active
    if (!selectedEnergy && !toolAttachPending) {
    logPanel.classList.remove("show");
    }
  }
});

if(historyBackdrop){
  historyBackdrop.addEventListener('click',e=>{
    if(e.target===historyBackdrop) historyBackdrop.classList.remove('show');
  });
}

/* ========= utils ========= */
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
let popupTimer = null;

let popupTimeout = null;

function showPopup(msg, duration = 1800) {
  if (!popupEl) return;

  if (popupTimeout) {
    clearTimeout(popupTimeout);
    popupTimeout = null;
  }

  popupEl.textContent = msg;
  popupEl.classList.add("show");

  popupTimeout = setTimeout(() => {
    popupEl.classList.remove("show");
    popupTimeout = null;
  }, duration);
}

globalThis.showPopup = showPopup;

function updateDeckStack(owner) {
  const stackId = owner === 'player1' ? 'p1DeckStack' : 'p2DeckStack';
  const stack = document.getElementById(stackId);
  if (!stack) return;
  
  const deckSize = playerState[owner].deck.length;
  const maxVisible = 10; // Show up to 10 cardbacks
  const visibleCount = Math.min(deckSize, maxVisible);
  
  // Clear existing cards
  stack.innerHTML = '';
  
  // Add cardbacks for visible cards
  for (let i = 0; i < visibleCount; i++) {
    const card = document.createElement('div');
    card.className = 'deck-card';
    stack.appendChild(card);
  }
  
  // If deck is empty, hide the stack
  if (deckSize === 0) {
    stack.style.opacity = '0';
  } else {
    stack.style.opacity = '1';
  }
}

async function animateCardDraw(owner, targetHand, card = null, cardIndex = null, totalCardsBeingDrawn = 1) {
  const stackId = owner === 'player1' ? 'p1DeckStack' : 'p2DeckStack';
  const deckStack = document.getElementById(stackId);
  const handDiv = owner === 'player1' ? p1HandDiv : p2HandDiv;
  
  if (!deckStack || !handDiv) return;
  
  const deckRect = deckStack.getBoundingClientRect();
  const handRect = targetHand.getBoundingClientRect();
  
  // Calculate target position in hand
  // If cardIndex is provided, use it; otherwise calculate based on current hand size
  const currentHandSize = playerState[owner].hand.length;
  const targetIndex = cardIndex !== null ? cardIndex : currentHandSize;
  
  // Get the actual rendered size of cards in the hand (using bounding rect, not CSS size)
  // This accounts for object-fit: contain which may make the image smaller than the element
  const existingHandCard = handDiv.querySelector('.card-img');
  let actualCardWidth = 69.27; // Default fallback size
  let actualCardHeight = 96.47; // Default fallback size
  
  if (existingHandCard) {
    // Use getBoundingClientRect to get the actual rendered size
    const cardRect = existingHandCard.getBoundingClientRect();
    if (cardRect.width > 0 && cardRect.height > 0) {
      actualCardWidth = cardRect.width;
      actualCardHeight = cardRect.height;
    } else {
      // Fallback: try computed style if bounding rect fails
      const computedStyle = window.getComputedStyle(existingHandCard);
      const computedWidth = parseFloat(computedStyle.width);
      const computedHeight = parseFloat(computedStyle.height);
      if (computedWidth && computedHeight) {
        actualCardWidth = computedWidth;
        actualCardHeight = computedHeight;
      }
    }
  }
  
  // Get existing card slots to calculate position
  const handCards = handDiv.querySelectorAll('.card-slot');
  const existingCardCount = handCards.length;
  
  // Calculate the final hand size after all cards are drawn
  // Use the current hand size + total cards being drawn
  const finalHandSize = currentHandSize + totalCardsBeingDrawn;
  
  // Calculate target position based on actual card positions
  // If we have existing cards, use their actual positions to calculate spacing
  let targetX, targetY;
  
  if (handCards.length > 0 && existingHandCard) {
    // Get the actual position of the first card
    const firstCardRect = existingHandCard.getBoundingClientRect();
    const firstCardCenterX = firstCardRect.left + firstCardRect.width / 2;
    const firstCardCenterY = firstCardRect.top + firstCardRect.height / 2;
    
    // Calculate spacing between cards by checking if there's a second card
    const secondCard = handDiv.querySelectorAll('.card-img')[1];
    let cardSpacing = actualCardWidth + 8; // Default: card width + gap
    if (secondCard) {
      const secondCardRect = secondCard.getBoundingClientRect();
      const secondCardCenterX = secondCardRect.left + secondCardRect.width / 2;
      cardSpacing = secondCardCenterX - firstCardCenterX;
    }
    
    // Calculate target position based on index
    // Use finalHandSize - 1 for centering calculation (not handCards.length)
    const indexOffset = targetIndex - (finalHandSize - 1) / 2;
    targetX = firstCardCenterX + (indexOffset * cardSpacing);
    targetY = firstCardCenterY;
  } else {
    // Fallback: calculate based on slot positions
    const cardSlotWidth = 75; // var(--card-w) from CSS
    const slotGap = 8; // gap: 8px from CSS (.hand has gap: 8px)
    const slotSpacing = cardSlotWidth + slotGap;
    
    const handCenterX = handRect.left + handRect.width / 2;
    const slotOffsetFromCenter = (targetIndex - (finalHandSize - 1) / 2) * slotSpacing;
    targetX = handCenterX + slotOffsetFromCenter;
    
    targetY = handRect.top + handRect.height / 2;
    if (handCards.length > 0) {
      const firstSlotRect = handCards[0].getBoundingClientRect();
      targetY = firstSlotRect.top + firstSlotRect.height / 2;
    }
  }
  
  // Get card image URL if card is provided and PRELOAD it
  let cardImageUrl = null;
  let imageLoaded = false;
  
  if (card) {
    
    // Try to use imgUrl if available, otherwise fetch it
    if (card.imgUrl) {
      cardImageUrl = card.imgUrl;
    } else if (card.set && (card.number || card.num)) {
      // Fetch card metadata to get image URL
      try {
        const meta = await fetchCardMeta(card.set, card.number || card.num);
        if (meta && meta.image) {
          // The API returns the base URL, we need to append "/high.png"
          cardImageUrl = meta.image + "/high.png";
        } else {
          console.warn('[Card Animation] No image in metadata:', meta);
        }
      } catch (e) {
        // Fall back to cardback if fetch fails
        console.warn('[Card Animation] Could not fetch card image for animation:', e);
      }
    } else {
      console.warn('[Card Animation] Card object missing set/number:', card);
    }
  } else {
  }
  
  // Preload the image NOW, before creating the animation
  if (cardImageUrl) {
    await new Promise((resolve) => {
      const img = new Image();
      let resolved = false;
      img.onload = () => {
        if (!resolved) {
          imageLoaded = true;
          resolved = true;
          resolve();
        }
      };
      img.onerror = () => {
        if (!resolved) {
          // If image fails to load, use cardback
          cardImageUrl = null;
          imageLoaded = false;
          resolved = true;
          console.warn('[Card Animation] Image failed to load');
          resolve();
        }
      };
      img.src = cardImageUrl;
      // If image is already cached, resolve immediately
      if (img.complete && img.naturalWidth > 0) {
        imageLoaded = true;
        resolved = true;
        resolve();
      }
    });
  } else {
  }
  
  // Create animated card container - use the correct size from the start
  // (actualCardWidth and actualCardHeight are already calculated above)
  const animCard = document.createElement('div');
  animCard.setAttribute('data-animated-card', 'true');
  animCard.style.position = 'fixed';
  animCard.style.width = `${actualCardWidth}px`;
  animCard.style.height = `${actualCardHeight}px`;
  // Position center of card at deck center (will animate to target center)
  animCard.style.left = `${deckRect.left + deckRect.width / 2 - actualCardWidth / 2}px`;
  animCard.style.top = `${deckRect.top + deckRect.height / 2 - actualCardHeight / 2}px`;
  animCard.style.transform = 'perspective(700px) rotateX(0deg)'; // Match initial card transform (no translate)
  animCard.style.zIndex = '1000';
  animCard.style.pointerEvents = 'none';
  animCard.style.willChange = 'left, top, transform';
  document.body.appendChild(animCard);
  
  // Only create animation if we have the card image loaded
  // If no image, skip animation entirely
  if (!cardImageUrl || !imageLoaded) {
    // Return a resolved promise with null to indicate no animation
    return Promise.resolve(null);
  }
  
  // Create card front layer - show it immediately, no cardback
  const cardFront = document.createElement('div');
  cardFront.style.position = 'absolute';
  cardFront.style.width = '100%';
  cardFront.style.height = '100%';
  cardFront.style.backgroundImage = `url('${cardImageUrl}')`;
  cardFront.style.backgroundSize = 'contain'; // Match object-fit: contain from actual cards
  cardFront.style.backgroundPosition = 'center';
  cardFront.style.backgroundRepeat = 'no-repeat';
  cardFront.style.borderRadius = '6px'; // Match card-img border-radius
  cardFront.style.boxShadow = '0 4px 12px rgba(0,0,0,0.4)';
  cardFront.style.opacity = '1'; // Show immediately, no fade-in
  cardFront.style.top = '0';
  cardFront.style.left = '0';
  cardFront.style.pointerEvents = 'none';
  cardFront.style.zIndex = '2';
  animCard.appendChild(cardFront);
  
  // Debug: Log initial state
  
  // Animation settings
  const animationDuration = 800; // 0.8 seconds
  
  // Set transition on the container - include transform
  animCard.style.transition = `left ${animationDuration}ms ease-out, top ${animationDuration}ms ease-out, transform ${animationDuration}ms ease-out`;
  
  // Force reflow to ensure initial position is set
  void animCard.offsetWidth;
  
  // Start animation - slide to hand
  // The card size is already set correctly, just animate position and transform
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      // Calculate target position as top-left corner (not center)
      // targetX and targetY are currently card centers, so adjust to top-left
      const targetLeft = targetX - actualCardWidth / 2;
      const targetTop = targetY - actualCardHeight / 2;
      
      // Start the slide animation to the calculated target position
      // The transform will transition to match hand cards (perspective + rotateX, no translate)
      animCard.style.left = `${targetLeft}px`;
      animCard.style.top = `${targetTop}px`;
      // Match the exact transform of hand cards: perspective(700px) rotateX(3deg)
      animCard.style.transform = `perspective(700px) rotateX(3deg)`;
      
      // No transition needed - card front is already visible from the start
    });
  });
  
  // Return a promise that resolves when animation completes, and return the animated card element
  // The animated card will be faded out when the actual card appears
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(animCard); // Return the animated card element for crossfade
    }, animationDuration);
  });
}

function animateDeckShuffle(owner) {
  const stackId = owner === 'player1' ? 'p1DeckStack' : 'p2DeckStack';
  const deckStack = document.getElementById(stackId);
  
  if (!deckStack) return;
  
  deckStack.classList.add('shuffling');
  
  setTimeout(() => {
    deckStack.classList.remove('shuffling');
    // Update the stack visual after shuffle
    updateDeckStack(owner);
  }, 600);
}

function updateDeckBubbles(){
  if(p1Bubble)p1Bubble.textContent=playerState.player1.deck.length;
  if(p2Bubble)p2Bubble.textContent=playerState.player2.deck.length;
  updateDeckStack('player1');
  updateDeckStack('player2');
}
function updatePointsUI(){
  const f=(id,pts)=>{$$(`#${id} .point-bubble`).forEach(b=>b.classList.toggle('filled',Number(b.dataset.i)<=pts))};
  f('p1Points',p1Points);f('p2Points',p2Points);
}
function updateTurnBox(){
  if(turnNumEl)turnNumEl.textContent=globalThis.turnNumber;
  if(turnPlayerEl)turnPlayerEl.textContent=`Current: ${currentPlayer?currentPlayer.replace('player','Player '):'‚Äî'}`;
}
const activeFor=p=>p==='player1'?p1Active:p2Active;
const benchFor=p=>p==='player1'?p1Bench:p2Bench;
const handDivFor=p=>p==='player1'?p1HandDiv:p2HandDiv;
const opponentOf=p=>p==='player1'?'player2':'player1';

// also add in the state section:
let damageBoostThisTurn = {
  player1: { flatAll: 0, flatByName: {} },
  player2: { flatAll: 0, flatByName: {} }
};
globalThis.damageBoostThisTurn = damageBoostThisTurn;
globalThis.resetDamageBoostsFor = function (playerKey) {
  const slot = damageBoostThisTurn[playerKey];
  if (!slot) return;
  slot.flatAll = 0;
  slot.flatByName = {};
};

function markSlot(slot,has){
  const lab=slot.querySelector('.slot-label');
  slot.dataset.empty=has?'0':'1';
  if(lab)lab.style.display=has?'none':'block';
}
globalThis.markSlot = markSlot;

const metaCache={};
async function fetchCardMeta(set,num){
  const key=`${set}-${num}`;
  if(metaCache[key])return metaCache[key];
  const r=await fetch(`https://api.tcgdex.net/v2/en/sets/${set}/${num}`);
  if(!r.ok)throw new Error('meta');
  const d=await r.json();
  metaCache[key]=d;
  return d;
}
async function isBasicPokemon(set,num){
  try{
    const d=await fetchCardMeta(set,num);
    return String(d.category||'').toLowerCase()==='pokemon' &&
           String(d.stage||'').toLowerCase()==='basic';
  }catch{return false}
}

function setHpOnImage(img,baseHp,chp){
  img.dataset.hp=String(baseHp);
  img.dataset.chp=String(chp);
  const slot=img.closest('.card-slot');
  if(!slot)return;
  
  // Check for Giant Cape or other max HP modifiers
  const modifiedMaxHp = slot.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  const displayMax = modifiedMaxHp || baseHp;
  
  let hpDiv=slot.querySelector('.hp-overlay');
  if(!hpDiv){
    hpDiv=document.createElement('div');
    hpDiv.className='hp-overlay';
    slot.appendChild(hpDiv);
  }
  hpDiv.textContent=`${chp} / ${displayMax}`;
  
  // Make HP green if Giant Cape is attached
  if (modifiedMaxHp) {
    hpDiv.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
    hpDiv.style.fontWeight = '900';
  } else {
    hpDiv.style.background = 'rgba(0,0,0,.85)';
    hpDiv.style.fontWeight = '800';
  }
}

/* ========= hand render ========= */
function renderHand(div,cards,hide=false,addFadeIn=false){
  const owner=div.id==='p1Hand'?'player1':'player2';
  
  // Check if Pokemon Communication is active
  const selData = globalThis.__pokemonCommSelection;
  const isCommActive = globalThis.__pokemonCommActive && selData;
  
  // Check if Rare Candy selection is active
  const rareCandyData = globalThis.__rareCandySelection;
  const isRareCandyActive = globalThis.__rareCandyActive && rareCandyData;
  
  div.innerHTML=(cards||[]).map(c=>{
    const src=hide?'imgs/cardback.png':(c.image||'https://archives.bulbagarden.net/media/upload/1/17/Cardback.jpg');
    
    // Add glow class if this card is eligible for Pokemon Communication
    let extraClass = '';
    if (isCommActive && selData.pokemonInHand.includes(c)) {
      extraClass = ' poke-comm-glow';
    }
    
    // Add glow class if this card is eligible for Rare Candy Stage 2 selection
    if (isRareCandyActive && rareCandyData.owner === owner) {
      const isEligibleStage2 = rareCandyData.pairsForBasic.some(p => 
        p.handCard.set === c.set && String(p.handCard.number || p.handCard.num) === String(c.number || c.num)
      );
      if (isEligibleStage2) {
        extraClass = ' poke-comm-glow';
      }
    }
    
    // No need for fade-in since we're using scale-down animation instead
    // The actual cards will just appear as the animated cards scale down
    
    return `<div class="card-slot" data-empty="0"><img class="card-img${extraClass}" src="${src}" alt="${c.name}" data-owner="${owner}" data-set="${c.set}" data-num="${c.number||c.num}" draggable="true"></div>`;
  }).join('');
  
  // Add drag handlers to hand cards (only for current player's hand, or during setup)
  if ((owner === currentPlayer || isSetupPhase) && !hide) {
    const handCards = div.querySelectorAll('.card-img');
    handCards.forEach(img => {
      // Remove existing handlers to avoid duplicates
      const newImg = img.cloneNode(true);
      img.parentNode.replaceChild(newImg, img);
      
      // Drag start
      newImg.addEventListener('dragstart', async (e) => {
        // Only allow dragging if it's the current player's turn and not in special modes
        // Exception: Allow dragging tools even if toolAttachPending is set (for drag-and-drop)
        let isTool = false;
        try {
          const cardMeta = await fetchCardMeta(newImg.dataset.set, newImg.dataset.num);
          if (cardMeta && String(cardMeta.trainerType || '').toLowerCase() === 'tool') {
            isTool = true;
          }
        } catch {}
        
        if (isEvoMode || selectedEnergy || isPromotionPhase || isRetreatSelection) {
          e.preventDefault();
          return;
        }
        
        // If toolAttachPending is set and this is NOT a tool, block dragging
        if (toolAttachPending && !isTool) {
          e.preventDefault();
          return;
        }
        
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', JSON.stringify({
          set: newImg.dataset.set,
          num: newImg.dataset.num,
          owner: newImg.dataset.owner
        }));
        
        newImg.style.opacity = '0.5';
        newImg.style.cursor = 'grabbing';
        
        // Add visual feedback
        document.querySelectorAll('.card-slot').forEach(slot => {
          const slotImg = slot.querySelector('img');
          if (slotImg && (slot.closest('.bench') || slot.closest('.active'))) {
            const slotOwner = slot.closest('#player1') ? 'player1' : 'player2';
            if (slotOwner === owner) {
              slot.classList.add('drag-target');
            }
          }
        });
      });
      
      // Drag end
      newImg.addEventListener('dragend', (e) => {
        newImg.style.opacity = '1';
        newImg.style.cursor = 'grab';
        document.querySelectorAll('.card-slot').forEach(slot => {
          slot.classList.remove('drag-target', 'drag-over');
        });
        // Clear tool drop highlights on Pok√©mon images
        document.querySelectorAll('.card-slot img.card-img').forEach(pokemonImg => {
          pokemonImg.style.border = '';
          pokemonImg.style.boxShadow = '';
        });
      });
    });
  }
}
function removeFromHand(owner,set,num){
  const h=playerState[owner].hand;
  const i=h.findIndex(c=>c.set===set&&String(c.number||c.num)===String(num));
  if(i>=0)h.splice(i,1);
}
function renderAllHands(){
  const p1Hide=currentPlayer==='player2',
        p2Hide=currentPlayer==='player1';
  renderHand(p1HandDiv,playerState.player1.hand,p1Hide);
  renderHand(p2HandDiv,playerState.player2.hand,p2Hide);
  p1HandDiv.classList.toggle('disable-clicks',currentPlayer==='player2');
  p2HandDiv.classList.toggle('disable-clicks',currentPlayer==='player1');
  
  // Setup drop handlers for bench and active slots (only once)
  if (!window.dropHandlersSetup) {
    setupDropHandlers();
    window.dropHandlersSetup = true;
  }
}

function setupDropHandlers() {
  // Add drop handlers to all bench and active slots
  const setupSlotsForPlayer = (playerDiv) => {
    const bench = playerDiv.querySelector('.bench');
    const active = playerDiv.querySelector('.active');
    
    [bench, active].forEach(container => {
      if (!container) return;
      
      const slots = container.querySelectorAll('.card-slot');
      slots.forEach(slot => {
        // Check if handlers already exist to avoid duplicates
        if (slot.dataset.dropHandlersSetup === 'true') return;
        slot.dataset.dropHandlersSetup = 'true';
        
        slot.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          
          const slotOwner = slot.closest('#player1') ? 'player1' : 'player2';
          // Allow during setup, or if it's the current player's turn
          if (!isSetupPhase && slotOwner !== currentPlayer) return;
          
          // Show drag-over effect (we'll validate in drop handler)
          slot.classList.add('drag-over');
        });
        
        slot.addEventListener('dragleave', (e) => {
          if (!slot.contains(e.relatedTarget)) {
            slot.classList.remove('drag-over');
          }
        });
        
        slot.addEventListener('drop', async (e) => {
          // If the drop was directly on a Pok√©mon image, check if it's a tool first
          const targetImg = e.target.closest('img.card-img');
          if (targetImg && targetImg.closest('.card-slot') === slot) {
            // Check if this is a tool by looking at the drag data
            try {
              const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
              if (dragData) {
                const { set, num } = dragData;
                // Quick check: fetch metadata to see if it's a tool
                const meta = await fetchCardMeta(set, num);
                if (meta && String(meta.trainerType || '').toLowerCase() === 'tool') {
                  // Let the img handler process tool drops
                  // Don't preventDefault or stopPropagation here - let it bubble to img handler
                  // But do stop immediate propagation to prevent this handler from continuing
                  e.stopImmediatePropagation();
                  return;
                }
              }
            } catch {}
          }
          
          e.preventDefault();
          e.stopPropagation();
          
          slot.classList.remove('drag-over');
          
          const slotOwner = slot.closest('#player1') ? 'player1' : 'player2';
          // Allow during setup, or if it's the current player's turn
          if (!isSetupPhase && slotOwner !== currentPlayer) return;
          
          try {
            const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
            if (!dragData || dragData.owner !== slotOwner) return;
            
            const { set, num } = dragData;
            
            // Find the card in hand
            const handCard = playerState[slotOwner].hand.find(c => 
              c.set === set && String(c.number || c.num) === String(num)
            );
            
            if (!handCard) {
              showPopup('Card not found in hand.');
              return;
            }
            
            // Get card metadata
            let meta = null;
            try {
              meta = await fetchCardMeta(set, num);
            } catch (err) {
              showPopup('Error loading card data.');
              return;
            }
            
            if (!meta) return;
            
            // Check if it's a tool - if so, let the img handler process it (don't handle in slot handler)
            const ttype = String(meta.trainerType || '').toLowerCase();
            if (ttype === 'tool') {
              // Tool drops should be handled by the img drop handler, not the slot handler
              // Don't preventDefault or stopPropagation - let it bubble to img handler
              return;
            }
            
            const slotImg = slot.querySelector('img');
            const isActive = slot.closest('.active');
            const isBench = slot.closest('.bench');
            
            // Check if slot is empty or has a Pokemon that can evolve
            if (slotImg) {
              // Evolution case
              if (meta.evolveFrom) {
                // Check if the Pokemon in the slot matches evolveFrom
                const targetName = (slotImg.alt || '').toLowerCase();
                const evolveFromLower = String(meta.evolveFrom).toLowerCase();
                
                let canEvolve = targetName.includes(evolveFromLower);
                
                // Check for fossils
                const FOSSIL_MAP = {
                  'helix fossil': 'omanyte',
                  'dome fossil': 'kabuto',
                  'old amber': 'aerodactyl',
                  'skull fossil': 'cranidos',
                  'armor fossil': 'shieldon'
                };
                
                if (!canEvolve && FOSSIL_MAP[targetName]) {
                  const fossilPokemon = FOSSIL_MAP[targetName];
                  canEvolve = fossilPokemon === evolveFromLower || evolveFromLower.includes(fossilPokemon);
                }
                
                // Check for Eevee ex special evolution
                if (!canEvolve && targetName.includes('eevee ex')) {
                  const EEVEELUTIONS = [
                    'vaporeon', 'jolteon', 'flareon', 'espeon', 'umbreon',
                    'leafeon', 'glaceon', 'sylveon'
                  ];
                  const evoCardName = (meta.name || '').toLowerCase();
                  canEvolve = EEVEELUTIONS.some(e => evoCardName.includes(e));
                }
                
                if (canEvolve) {
                  // Simulate click on the hand card to trigger evolution
                  const handCardElement = document.querySelector(`.hand img[data-set="${set}"][data-num="${num}"][data-owner="${slotOwner}"]`);
                  if (handCardElement) {
                    // Create a fake click event
                    const clickEvent = new MouseEvent('click', {
                      bubbles: true,
                      cancelable: true,
                      view: window
                    });
                    handCardElement.dispatchEvent(clickEvent);
                    
                    // Then click on the target Pokemon
                    setTimeout(() => {
                      slotImg.click();
                    }, 100);
                  }
                } else {
                  showPopup(`Cannot evolve ${slotImg.alt} into ${meta.name}.`);
                }
              } else {
                showPopup('This slot is already occupied.');
              }
            } else {
              // Placement case - only Basic Pokemon
              if (String(meta.category || '').toLowerCase() !== 'pokemon') {
                showPopup('Only Pok√©mon can be placed on the bench.');
                return;
              }
              
              if (String(meta.stage || '').toLowerCase() !== 'basic') {
                showPopup('Only Basic Pok√©mon can be placed.');
                return;
              }
              
              // Check if active is empty (for active placement)
              if (isActive) {
                const act = slotOwner === 'player1' ? p1Active : p2Active;
                if (act.querySelector('img')) {
                  showPopup('Active slot is already occupied.');
                  return;
                }
              }
              
              // Check if bench is full (for bench placement)
              if (isBench) {
                const bench = slotOwner === 'player1' ? p1Bench : p2Bench;
                const benchSlots = bench.querySelectorAll('.card-slot');
                const occupiedSlots = Array.from(benchSlots).filter(s => s.querySelector('img'));
                if (occupiedSlots.length >= 3) {
                  showPopup('Bench is full.');
                  return;
                }
              }
              
              // Place card directly in the dropped slot
              const handCardElement = document.querySelector(`.hand img[data-set="${set}"][data-num="${num}"][data-owner="${slotOwner}"]`);
              if (!handCardElement) {
                showPopup('Card not found in hand.');
                return;
              }
              
              // Create clone of the card
              const clone = handCardElement.cloneNode(true);
              clone.dataset.playedTurn = globalThis.turnNumber || 0;
              
              // Assign unique instance ID for ability tracking
              if (!window.pokemonInstanceCounter) window.pokemonInstanceCounter = 0;
              clone.dataset.instanceId = ++window.pokemonInstanceCounter;
              console.log('[INSTANCE] Assigned instanceId:', clone.dataset.instanceId, 'to', clone.alt || 'Unknown Pokemon');
              clone.dataset.set = set;
              clone.dataset.num = num;
              
              // Clear the slot and place the card
              slot.innerHTML = '';
              slot.appendChild(clone);
              markSlot(slot, true);
              
              // Animate slide from hand
              if (handCardElement) {
                animateSlideFromHand(handCardElement, slot, clone);
              }
              
              // Remove from hand
              removeFromHand(slotOwner, set, num);
              
              // Set HP
              try {
                const baseHp = parseInt(meta.hp || '0', 10) || 0;
                setHpOnImage(clone, baseHp, baseHp);
              } catch {}
              
              // Update player background if active
              if (isActive) {
                const playerNum = slotOwner === 'player1' ? 1 : 2;
                updatePlayerTypeBackground(playerNum);
              }
              
              renderAllHands();
              
              const placedTo = isActive ? 'active' : 'bench';
              logEvent({
                player: slotOwner,
                text: `Played Basic Pok√©mon to ${placedTo === 'active' ? 'Active' : 'Bench'}: ${meta.name}.`,
                cardSet: set,
                cardNum: num
              });
            }
          } catch (err) {
            console.error('[drop] Error handling drop:', err);
            showPopup('Error placing card.');
          }
        });
      });
    });
  };
  
  // Setup for both players
  const player1Div = document.getElementById('player1');
  const player2Div = document.getElementById('player2');
  if (player1Div) setupSlotsForPlayer(player1Div);
  if (player2Div) setupSlotsForPlayer(player2Div);
  
  // Store function globally so it can be called when slots are updated
  globalThis.reSetupDropHandlers = () => {
    if (player1Div) setupSlotsForPlayer(player1Div);
    if (player2Div) setupSlotsForPlayer(player2Div);
    // Also re-setup tool drop handlers
    if (globalThis.reSetupToolDropHandlers) {
      globalThis.reSetupToolDropHandlers();
    }
  };
  
  // Setup tool drop handlers on Pok√©mon images
  setupToolDropHandlers();
}

function setupToolDropHandlers() {
  // Add drop handlers to all Pok√©mon images in play (active and bench)
  const setupPokemonForPlayer = (playerDiv) => {
    const bench = playerDiv.querySelector('.bench');
    const active = playerDiv.querySelector('.active');
    
    [bench, active].forEach(container => {
      if (!container) return;
      
      const pokemonImgs = container.querySelectorAll('.card-slot img.card-img');
      pokemonImgs.forEach(img => {
        // Check if handlers already exist
        if (img.dataset.toolDropHandlersSetup === 'true') return;
        img.dataset.toolDropHandlersSetup = 'true';
        
        // Use capture phase so img handler runs before slot handler
        img.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          
          const pokemonOwner = img.closest('#player1') ? 'player1' : 'player2';
          // Allow during setup, or if it's the current player's turn
          if (!isSetupPhase && pokemonOwner !== currentPlayer) return;
          
          // Show highlight (we'll verify it's a tool in the drop handler)
          img.style.border = '2px solid #9d7dd4';
          img.style.boxShadow = '0 0 16px rgba(157, 125, 212, 0.6)';
        });
        
        img.addEventListener('dragleave', (e) => {
          if (!img.contains(e.relatedTarget)) {
            img.style.border = '';
            img.style.boxShadow = '';
          }
        });
        
        // Use capture phase so this handler runs before the slot handler
        img.addEventListener('drop', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation(); // Prevent slot handler from processing
          
          img.style.border = '';
          img.style.boxShadow = '';
          
          const pokemonOwner = img.closest('#player1') ? 'player1' : 'player2';
          // Allow during setup, or if it's the current player's turn
          if (!isSetupPhase && pokemonOwner !== currentPlayer) return;
          
          try {
            const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
            if (!dragData || dragData.owner !== pokemonOwner) return;
            
            const { set, num } = dragData;
            
            // Find the card in hand
            const handCard = playerState[pokemonOwner].hand.find(c => 
              c.set === set && String(c.number || c.num) === String(num)
            );
            
            if (!handCard) {
              showPopup('Card not found in hand.');
              return;
            }
            
            // Get card metadata to verify it's a tool
            let meta = null;
            try {
              meta = await fetchCardMeta(set, num);
            } catch (err) {
              showPopup('Error loading card data.');
              return;
            }
            
            if (!meta) return;
            
            // Check if it's a tool
            const ttype = String(meta.trainerType || '').toLowerCase();
            if (ttype !== 'tool') {
              showPopup('Only Tool cards can be attached to Pok√©mon.');
              return;
            }
            
            // Check if this Pok√©mon already has a tool
            const targetSlot = img.closest('.card-slot');
            if (!targetSlot) {
              showPopup('Invalid target.');
              return;
            }
            
            if (getToolDataFromSlot(targetSlot)) {
              showPopup('This Pok√©mon already has a Tool attached.');
              return;
            }
            
            // Attach tool using the same logic as click handler
            await attachToolToSlot(pokemonOwner, targetSlot, {
              set: set,
              num: num,
              src: handCard.image || `https://assets.tcgdex.net/en/tcgp/${set}/${String(num).padStart(3, '0')}/high.png`
            });
            
            // Apply tool effect
            const cardId = csvIdFor(set, num);
            const effect = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
            
            if (effect && effect.effect_type) {
              console.log('[tool] Applying effect:', effect.effect_type);
              globalThis.toolAttachTarget = img;
              
              try {
                await applyTrainerEffect(effect, pokemonOwner, null);
                
                // Effect succeeded - finish attachment
                removeFromHand(pokemonOwner, set, num);
                renderAllHands();

                logEvent({
                  player: pokemonOwner,
                  text: 'Attached Tool.',
                  cardSet: set,
                  cardNum: num
                });
                
              } catch (err) {
                // Effect failed
                console.log('[tool] Effect failed, removing tool:', err.message);
                
                const toolThumb = targetSlot.querySelector('.tool-thumb');
                if (toolThumb) toolThumb.remove();
                setToolDataOnSlot(targetSlot, null);
                
                showPopup(err.message || 'Cannot attach this Tool here.');
              } finally {
                globalThis.toolAttachTarget = null;
              }
            } else {
              // No effect to apply - just finish attachment
              removeFromHand(pokemonOwner, set, num);
              renderAllHands();

              logEvent({
                player: pokemonOwner,
                text: 'Attached Tool.',
                cardSet: set,
                cardNum: num
              });
            }
          } catch (err) {
            console.error('[tool-drop] Error handling drop:', err);
            showPopup('Error attaching tool.');
          }
        });
      });
    });
  };
  
  // Setup for both players
  const player1Div = document.getElementById('player1');
  const player2Div = document.getElementById('player2');
  if (player1Div) setupPokemonForPlayer(player1Div);
  if (player2Div) setupPokemonForPlayer(player2Div);
  
  // Store function globally so it can be called when Pok√©mon are updated
  globalThis.reSetupToolDropHandlers = () => {
    // Clear all flags so handlers can be re-attached
    document.querySelectorAll('.card-slot img.card-img').forEach(img => {
      delete img.dataset.toolDropHandlersSetup;
    });
    setupToolDropHandlers();
  };
}

/* ========= tools ========= */
function getToolDataFromSlot(slot){
  const set=slot.dataset.toolSet||null,
        num=slot.dataset.toolNum||null,
        src=slot.dataset.toolSrc||null;
  return set&&num&&src?{set,num,src}:null;
}
function setToolDataOnSlot(slot,tool){
  if(tool){
    slot.dataset.toolSet=tool.set;
    slot.dataset.toolNum=tool.num;
    slot.dataset.toolSrc=tool.src;
  }else{
    delete slot.dataset.toolSet;
    delete slot.dataset.toolNum;
    delete slot.dataset.toolSrc;
  }
}
function ensureToolThumb(slot){
  let th=slot.querySelector('.tool-thumb');
  if(!th){
    th=document.createElement('img');
    th.className='tool-thumb';
    th.title='Tool';
    slot.appendChild(th);
  }
  return th;
}
function removeToolThumb(slot){
  const th=slot.querySelector('.tool-thumb');
  if(th)th.remove();
}
async function attachToolToSlot(owner,slot,toolObj){
  if(!slot||!toolObj)return;
  const img=slot.querySelector('img');
  if(!img){showPopup('Attach to a Pok√©mon in play.');return}
  if(getToolDataFromSlot(slot)){showPopup('This Pok√©mon already has a Tool attached.');return}
  try{
    const metaP=await fetchCardMeta(img.dataset.set,img.dataset.num);
    if(String(metaP.category||'').toLowerCase()!=='pokemon'){
      showPopup('Attach only to Pok√©mon.');
      return;
    }
  }catch{
    showPopup('Error verifying Pok√©mon.');
    return;
  }
  setToolDataOnSlot(slot,toolObj);
  const th=ensureToolThumb(slot);
  th.src=toolObj.src;
  th.onerror = () => {
    console.error('[tool] Failed to load tool image:', toolObj.src);
    th.src = 'imgs/cardback.png'; // Fallback
  };
  th.onload = () => {
    console.log('[tool] Tool thumbnail loaded successfully:', toolObj.src);
  };
  th.onclick=async ev=>{
    ev.stopPropagation();
    await openToolModal(toolObj.set,toolObj.num,toolObj.src);
  };
  console.log('[tool] Tool attached visually:', toolObj);
  showPopup('Tool attached');
}

/* ========= A2 Helper Functions ========= */

// Set max HP for Giant Cape tool
globalThis.setMaxHp = function(img, newMax) {
  if (!img) return;
  const slot = img.closest('.card-slot');
  if (!slot) return;
  
  // Get OLD values
  const oldMaxHp = parseInt(img.dataset.hp, 10) || 0;
  const oldCurrentHp = parseInt(img.dataset.chp || img.dataset.hp, 10) || oldMaxHp;
  
  // Calculate the HP increase
  const hpIncrease = newMax - oldMaxHp;
  
  // ALWAYS increase current HP by the same amount as max HP increase
  const newCurrentHp = oldCurrentHp + hpIncrease;
  
  // Store new max HP
  slot.dataset.maxHp = String(newMax);
  
  // Update current HP in dataset
  img.dataset.chp = String(newCurrentHp);
  
  // Update the HP overlay (bottom green box) - NO badge!
  let hpDiv = slot.querySelector('.hp-overlay');
  if (!hpDiv) {
    hpDiv = document.createElement('div');
    hpDiv.className = 'hp-overlay';
    slot.appendChild(hpDiv);
  }
  
  // Update HP overlay with new current/max HP
  hpDiv.textContent = `${newCurrentHp} / ${newMax}`;
  
  // Make it green to show tool is active
  hpDiv.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
  hpDiv.style.fontWeight = '900';
  
  console.log(`[setMaxHp] ${img.alt} HP: ${oldCurrentHp}/${oldMaxHp} ‚Üí ${newCurrentHp}/${newMax} (+${hpIncrease})`);
};

// Force switch specific bench Pokemon (for Cyrus)
globalThis.forceSwitchSpecific = function(state, pk, benchImg) {
  if (!benchImg) return;
  
  const owner = pkToPlayer(pk);
  console.log(`[forceSwitchSpecific] Switching ${benchImg.alt} to active for ${owner}`);
  
  // Get the active slot directly - the .active div contains one .card-slot
  const activeDiv = owner === 'player1' ? document.getElementById('p1Active') : document.getElementById('p2Active');
  const activeSlot = activeDiv?.querySelector('.card-slot');
  const benchSlot = benchImg.closest('.card-slot');
  
  console.log('[forceSwitchSpecific] Slots found:', { activeSlot, benchSlot, activeDiv });
  
  if (!activeSlot || !benchSlot) {
    console.error('[forceSwitchSpecific] Could not find slots', { activeSlot, benchSlot });
    return;
  }
  
  // Get the active Pokemon image
  const activeImg = activeSlot.querySelector('img');
  if (!activeImg) {
    console.error('[forceSwitchSpecific] No active Pokemon to swap');
    return;
  }
  
  console.log('[forceSwitchSpecific] Found slots, swapping...');
  
  // Swap maxHp data (for Giant Cape / Leaf Cape)
  const activeMaxHp = activeSlot.dataset.maxHp;
  const benchMaxHp = benchSlot.dataset.maxHp;
  
  // Clear both first
  delete activeSlot.dataset.maxHp;
  delete benchSlot.dataset.maxHp;
  
  // Swap if they existed
  if (benchMaxHp) {
    activeSlot.dataset.maxHp = benchMaxHp;
  }
  if (activeMaxHp) {
    benchSlot.dataset.maxHp = activeMaxHp;
  }
  
  // üÜï A3a - Clear move locks when Pokemon moves to bench (Buzzwole ex - Big Beat)
  // Clear locks for the Pokemon that is currently active (will move to bench)
  const activeInstanceId = activeImg.dataset.instanceId;
  const ownerPk = owner === 'player1' ? 'p1' : 'p2';
  if (activeInstanceId && globalThis.__moveLocks?.[ownerPk]?.[activeInstanceId]) {
    delete globalThis.__moveLocks[ownerPk][activeInstanceId];
    console.log(`[Big Beat] Cleared move locks for ${activeImg.alt} (instanceId: ${activeInstanceId}) - moved to bench via switch`);
  }
  
  // Get positions before swapping for animation
  const activeRect = activeImg.getBoundingClientRect();
  const benchRect = benchImg.getBoundingClientRect();
  
  // Hide the actual cards during animation
  activeImg.style.opacity = '0';
  benchImg.style.opacity = '0';
  
  // Swap the innerHTML of the slots
  const activeHTML = activeSlot.innerHTML;
  const benchHTML = benchSlot.innerHTML;
  
  activeSlot.innerHTML = benchHTML;
  benchSlot.innerHTML = activeHTML;
  
  // Get the new card references after swap
  const newActiveImg = activeSlot.querySelector('img');
  const newBenchImg = benchSlot.querySelector('img');
  
  // Animate the swap
  if (newActiveImg && newBenchImg) {
    animateSlideSwap(benchImg, activeSlot, newActiveImg, benchRect);
    animateSlideSwap(activeImg, benchSlot, newBenchImg, activeRect);
  } else if (newActiveImg) {
    // Only bench to active (no active Pokemon)
    animateSlideSwap(benchImg, activeSlot, newActiveImg, benchRect);
  }
  
  console.log(`[forceSwitchSpecific] Successfully swapped ${benchImg.alt} to active`);
  
  // Update HP displays to reflect correct maxHp state (using already declared variables)
  
  if (newActiveImg) {
    const baseHp = parseInt(newActiveImg.dataset.hp, 10) || 0;
    const curHp = parseInt(newActiveImg.dataset.chp || newActiveImg.dataset.hp, 10) || baseHp;
    setHpOnImage(newActiveImg, baseHp, curHp);
  }
  
  if (newBenchImg) {
    const baseHp = parseInt(newBenchImg.dataset.hp, 10) || 0;
    const curHp = parseInt(newBenchImg.dataset.chp || newBenchImg.dataset.hp, 10) || baseHp;
    setHpOnImage(newBenchImg, baseHp, curHp);
  }
  
  // Update visual displays
  if (typeof updateAllEnergyVisuals === 'function') {
    updateAllEnergyVisuals();
  }
};

/* ========= hand modal ========= */
if(handBackdrop){
  handBackdrop.addEventListener('click',e=>{
    if(e.target===handBackdrop){
      handBackdrop.classList.remove('show');
      if(handToolImg) handToolImg.style.display = 'none';
    }
  });
  document.addEventListener('keydown',e=>{
    if(e.key==='Escape'){
      handBackdrop.classList.remove('show');
      if(handToolImg) handToolImg.style.display = 'none';
    }
  });
}
function trainerColor(type){
  const t=String(type||'').toLowerCase();
  if(t.includes('supporter'))return'#e45803';
  if(t.includes('item'))return'#0167b6';
  if(t.includes('tool'))return'#6e4e9c';
  return'#3b3f46';
}

/* ========= energy + costs ========= */
function countPipsOn(slot){
  const out={total:0};
  // Only count real energy pips, not phantom pips
  slot.querySelectorAll('.energy-pip:not(.phantom-pip)').forEach(p=>{
    const t=(p.dataset.type||'colorless').toLowerCase();
    out[t]=(out[t]||0)+1;
    out.total++;
  });
  return out;
}
function satisfiedFlags(pips, costArr, pokemonImg = null) {
  const cnt = {...pips};
  const keys = Object.keys(cnt).filter(k => k !== 'total');
  const f = [];
  
  // üÜï A3 - Check for increased attack costs (Oranguru's Primate's Trap)
  let costIncrease = 0;
  if (pokemonImg) {
    let pk = null;
    if (pokemonImg.closest('#player1')) pk = 'p1';
    else if (pokemonImg.closest('#player2')) pk = 'p2';
    
    if (pk && globalThis.__specialEffects?.[pk]?.attackCostIncrease) {
      costIncrease = globalThis.__specialEffects[pk].attackCostIncrease;
      console.log(`[attack-cost-increase] +${costIncrease} to attack costs`);
    }
    
    // üÜï A3a - Stoutland Guard Dog Visage (opponent attacks cost +1)
    // Check if opponent's active has increase_opponent_cost
    const oppPk = pk === 'p1' ? 'p2' : 'p1';
    const oppActive = oppPk === 'p1' ? p1Active : p2Active;
    const oppActiveImg = oppActive?.querySelector('img');
    
    if (oppActiveImg) {
      try {
        const cacheKey = `${oppActiveImg.dataset.set}-${oppActiveImg.dataset.num}`;
        const abilityRow = globalThis.abilityCache?.[cacheKey];
        
        if (abilityRow?.effect_type === 'increase_opponent_cost') {
          const increase = parseInt(abilityRow.param1 || '1', 10);
          costIncrease += increase;
          console.log(`[Guard Dog Visage] Opponent attacks cost +${increase}`);
        }
      } catch (err) {
        console.error('[canAfford] Guard Dog Visage check failed:', err);
      }
    }
  }
  
  // üÜï A2a PASSIVE ABILITY - reduce_attack_cost_if_arceus (Abomasnow)
  // Check if Pokemon has reduce_attack_cost_if_arceus and Arceus is in play
  let colorlessReduction = 0;
  if (pokemonImg && pokemonImg.dataset.set && pokemonImg.dataset.num) {
    try {
      const cacheKey = `${pokemonImg.dataset.set}-${pokemonImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_attack_cost_if_arceus') {
        // Determine which player owns this Pokemon
        let pk = null;
        if (pokemonImg.closest('#player1')) pk = 'p1';
        else if (pokemonImg.closest('#player2')) pk = 'p2';
        
        if (pk && typeof hasArceusInPlay === 'function' && hasArceusInPlay(pk)) {
          colorlessReduction = parseInt(abilityRow.param1 || '1', 10);
          console.log(`[Arceus cost reduction] -${colorlessReduction} colorless cost`);
        }
      }
    } catch (e) {
      // Ability check failed, no reduction
    }
  }
  
  // üÜï A2a TRAINER - Barry (reduce cost for specific Pokemon)
  if (pokemonImg) {
    const pokemonName = (pokemonImg.alt || '').toLowerCase();
    const barryCostReduction = globalThis.attackCostReduction?.[pokemonName] || 0;
    if (barryCostReduction > 0) {
      colorlessReduction += barryCostReduction;
      console.log(`[Barry] -${barryCostReduction} colorless cost for ${pokemonImg.alt}`);
    }
  }
  
  // Build modified cost array with cost increase
  const modifiedCostArr = [...(costArr || [])];
  for (let i = 0; i < costIncrease; i++) {
    modifiedCostArr.push('colorless');
  }
  
  modifiedCostArr.forEach(t => {
    const k = String(t || '').toLowerCase();
    if (k === 'colorless') {
      // Try to use reduction first
      if (colorlessReduction > 0) {
        colorlessReduction--;
        f.push(true);
        return;
      }
      
      // Otherwise, pay normally
      let ok = false;
      for (const tp of keys) {
        if ((cnt[tp] || 0) > 0) {
          cnt[tp]--;
          cnt.total--;
          ok = true;
          break;
        }
      }
      f.push(ok);
    } else {
      if ((cnt[k] || 0) > 0) {
        cnt[k]--;
        cnt.total--;
        f.push(true);
      } else {
        f.push(false);
      }
    }
  });
  return f;
}

function canPayCostFromAPI(slot, costArr, pokemonImg = null) {
  return satisfiedFlags(countPipsOn(slot), costArr || [], pokemonImg).every(Boolean);
}
const energyIconUrl=k=>ENERGY_ICONS[k==='electric'?'lightning':k]||ENERGY_ICONS.colorless;
function extractAbilities(meta) {
  if (!meta) return [];
  // Standard case: array of abilities
  if (Array.isArray(meta.abilities)) return meta.abilities;
  // Some cards might expose a single ability object
  if (meta.abilities && typeof meta.abilities === 'object') return [meta.abilities];
  // Fallback if the API ever uses a single "ability" field
  if (meta.ability) return [meta.ability];
  return [];
}

function makeCostIcons(costArr, slot, pokemonImg = null) {
  const wrap = document.createElement('div');
  wrap.className = 'attack-cost';
  const flags = satisfiedFlags(countPipsOn(slot), costArr || [], pokemonImg);
  (costArr || []).forEach((t, i) => {
    const ic = document.createElement('div');
    ic.className = 'cost-icon';
    ic.style.backgroundImage = `url('${energyIconUrl(String(t || '').toLowerCase())}')`;
    if (!flags[i]) ic.classList.add('missing');
    wrap.appendChild(ic);
  });
  return wrap;
}

/* ========= damage / KO ========= */
const parseDamage=v=>{const m=String(v??'').match(/\d+/);return m?parseInt(m[0],10):0};
const getActiveImage=p=>activeFor(p).querySelector('img')||null;

function pushCardToDiscard(owner,img){
  playerState[owner].discard.cards.push({set:img.dataset.set,num:img.dataset.num,src:img.src});
}
function moveCardToDiscard(owner,img){
  const slot=img.closest('.card-slot');
  const tool=getToolDataFromSlot(slot);
  if(tool){
    playerState[owner].discard.cards.push({set:tool.set,num:tool.num,src:tool.src});
    removeToolThumb(slot);
    setToolDataOnSlot(slot,null);
  }
  const drawer=owner==='player1'?p1DiscardDrawer:p2DiscardDrawer;
  pushCardToDiscard(owner,img);
  const pips=countPipsOn(slot);
  Object.keys(pips).forEach(k=>{
    if(k==='total')return;
    playerState[owner].discard.energyCounts[k]=(playerState[owner].discard.energyCounts[k]||0)+pips[k];
  });
  slot.innerHTML='';
  slot.classList.remove('damage-flash');
  const lab=document.createElement('span');
  lab.className='slot-label';
  lab.textContent='Empty';
  slot.appendChild(lab);
  markSlot(slot,false);
  if(drawer.classList.contains('show'))renderDiscard(owner);
}
async function pointsForCard(set,num){
  try{
    const meta=await fetchCardMeta(set,num);
    const s=(meta.suffix||'').toUpperCase();
    const name=(meta.name||'').toLowerCase();
    if(s==='EX'&&name.includes('mega'))return 3;
    if(s==='EX')return 2;
  }catch{}
  return 1;
}
const checkBenchOut=owner=>[...benchFor(owner).querySelectorAll('img')].length===0;

function showVictory(winnerKey,reason){
  if(gameOver)return;
  gameOver=true;
  $('.main-layout')?.classList.add('disable-clicks');
  $('.side-panel')?.classList.add('disable-clicks');
  victoryTitle.textContent=winnerKey==='player1'?'Player 1 Wins!':'Player 2 Wins!';
  victoryDesc.textContent=reason||'Game over';
  p1PtsText.textContent=String(p1Points);
  p2PtsText.textContent=String(p2Points);
  victoryOverlay.style.display='flex';
}

async function handleKnockOut(owner, img, wasActive = false){
  const set=img.dataset.set,
        num=img.dataset.num;
  const foe=owner==='player1'?'player2':'player1';
  
  // Check if this was the active Pokemon
  const activeImg = getActiveImage(owner);
  const isActive = wasActive || (activeImg === img);
  
  console.log('[KO] Handling knockout:', {
    owner,
    pokemon: img.alt,
    isActive,
    wasActive
  });
  
  // üÜï A3 PASSIVE ABILITIES - Knockout triggers (BEFORE removing Pokemon)
  if (typeof getAbilityRow === 'function') {
    try {
      const pk = owner === 'player1' ? 'p1' : 'p2';
      const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
      
      if (abilityRow && typeof applyAbilityEffectFromCsv === 'function') {
        // counter_on_knockout - Pyukumuku (damage attacker)
        if (abilityRow.effect_type === 'counter_on_knockout' && isActive) {
          await applyAbilityEffectFromCsv(abilityRow, pk, { 
            attacker: foe,
            knockedPokemon: img 
          });
        }
        
        // üÜï A4a - flip_ko_attacker_on_ko (Galarian Cursola - Perish Body)
        if (abilityRow.effect_type === 'flip_ko_attacker_on_ko' && isActive) {
          const effectState = {
            p1: playerState.player1,
            p2: playerState.player2
          };
          await applyAbilityEffectFromCsv(effectState, pk, abilityRow, { 
            attacker: foe,
            knockedPokemon: img 
          });
        }
        
        // move_energy_on_knockout - Passimian ex (move energy to bench)
        if (abilityRow.effect_type === 'move_energy_on_knockout' && isActive) {
          await applyAbilityEffectFromCsv(abilityRow, pk, { 
            knockedPokemon: img 
          });
        }
      }
    } catch (err) {
      console.warn('[KO Abilities] Failed to trigger:', err);
    }
  }
  
  // üÜï A3a TOOL - Electrical Cord (BEFORE removing Pokemon)
  if (isActive) {
    const slot = img.closest('.card-slot');
    const tool = getToolDataFromSlot(slot);
    
    if (tool && tool.num === '065' && tool.set === 'A3a') {
      console.log('[Electrical Cord] Checking if triggered...');
      
      // Check if Pokemon is Lightning type
      try {
        const meta = await fetchCardMeta(img.dataset.set, img.dataset.num);
        const isLightningType = meta.types?.some(t => t.toLowerCase() === 'lightning');
        
        if (isLightningType) {
          // Count Lightning energy attached
          const energyBox = slot?.querySelector('.energy-pips');
          const pips = energyBox?.querySelectorAll('.energy-pip');
          const lightningPips = Array.from(pips || []).filter(p => p.dataset.type === 'lightning');
          
          console.log(`[Electrical Cord] Lightning type with ${lightningPips.length} Lightning Energy`);
          
          if (lightningPips.length >= 2) {
            // Remove 2 Lightning Energy from KO'd Pokemon FIRST
            const energyBox = slot?.querySelector('.energy-pips');
            const pips = energyBox?.querySelectorAll('.energy-pip');
            const lightningPipsArray = Array.from(pips || []).filter(p => p.dataset.type === 'lightning');
            
            // Remove exactly 2 Lightning Energy
            const toRemove = Math.min(2, lightningPipsArray.length);
            for (let i = 0; i < toRemove; i++) {
              lightningPipsArray[i].remove();
            }
            
            console.log(`[Electrical Cord] Removed ${toRemove} Lightning Energy from KO'd Pokemon`);
            
            // Get benched Pokemon
            const pk = owner === 'player1' ? 'p1' : 'p2';
            const bench = [...benchFor(owner).querySelectorAll('img')];
            
            if (bench.length >= 2) {
              showPopup('Electrical Cord: Select 2 Benched Pok√©mon to receive Lightning Energy');
              
              // Select first bench Pokemon
              const first = await new Promise(resolve => {
                bench.forEach(b => b.classList.add('selectable'));
                const handler = (e) => {
                  const clicked = e.target.closest('img');
                  if (clicked && bench.includes(clicked)) {
                    bench.forEach(b => {
                      b.classList.remove('selectable');
                      b.removeEventListener('click', handler);
                    });
                    resolve(clicked);
                  }
                };
                bench.forEach(b => b.addEventListener('click', handler));
              });
              
              if (first) {
                // Select second bench Pokemon
                const remaining = bench.filter(b => b !== first);
                const second = await new Promise(resolve => {
                  remaining.forEach(b => b.classList.add('selectable'));
                  const handler = (e) => {
                    const clicked = e.target.closest('img');
                    if (clicked && remaining.includes(clicked)) {
                      remaining.forEach(b => {
                        b.classList.remove('selectable');
                        b.removeEventListener('click', handler);
                      });
                      resolve(clicked);
                    }
                  };
                  remaining.forEach(b => b.addEventListener('click', handler));
                });
                
                if (second) {
                  // Attach 1 Lightning to each
                  attachEnergy(first, 'lightning');
                  attachEnergy(second, 'lightning');
                  showPopup(`Electrical Cord: Distributed Lightning Energy to ${first.alt} and ${second.alt}!`);
                  console.log('[Electrical Cord] Distributed energy to 2 benched Pokemon');
                }
              }
            } else if (bench.length === 1) {
              // Only 1 bench Pokemon - give both energy to it
              attachEnergy(bench[0], 'lightning');
              attachEnergy(bench[0], 'lightning');
              showPopup(`Electrical Cord: Attached 2 Lightning Energy to ${bench[0].alt}!`);
              console.log('[Electrical Cord] Distributed 2 energy to single benched Pokemon');
            } else {
              console.log('[Electrical Cord] No benched Pokemon to distribute to');
            }
          } else {
            console.log(`[Electrical Cord] Not enough Lightning Energy (have ${lightningPips.length}, need 2)`);
          }
        }
      } catch (err) {
        console.warn('[Electrical Cord] Failed to check:', err);
      }
    }
  }
  
  // üÜï Set flag for Marshadow's Revenge attack
  // Track that this player had a Pokemon KO'd this turn
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.koLastTurn) globalThis.state.koLastTurn = {};
  
  const ownerPk = owner === 'player1' ? 'p1' : 'p2';
  globalThis.state.koLastTurn[ownerPk] = true;
  console.log(`[marshadow] Set KO flag for ${ownerPk} (owner: ${owner})`);
  
  // üÜï Check if Serperior was knocked out (Jungle Totem)
  const pokemonName = (img.alt || '').toLowerCase();
  if (pokemonName.includes('serperior')) {
    console.log('[KO] Serperior knocked out - updating energy visuals');
    // Remove phantom pips since Jungle Totem is gone
    setTimeout(() => {
      if (typeof globalThis.updateAllEnergyVisuals === 'function') {
        globalThis.updateAllEnergyVisuals();
      }
    }, 100); // Small delay to ensure DOM is updated
  }
  
  logEvent({
    player: foe,
    text:`Knocked out ${img.alt || 'a Pok√©mon'}.`,
    cardSet:set,cardNum:num
  });

  moveCardToDiscard(owner,img);
  const pts=await pointsForCard(set,num);
  if(foe==='player1')p1Points+=pts;else p2Points+=pts;
  updatePointsUI();
  if(p1Points>=3||p2Points>=3){
    showVictory(p1Points>=3?'player1':'player2','Reached 3 points');
    return true;
  }
  
  // Only check bench out if the ACTIVE Pokemon was knocked out
  if(isActive && checkBenchOut(owner)){
    console.log('[KO] Bench out - active Pokemon was KO\'d and no bench remaining');
    showVictory(foe,'Bench out');
    return true;
  }
  
  return false;
}

async function damageActiveOf(player, amount, options = {}) {
  const img = getActiveImage(player);
  if (!img) return { knocked: false, hpText: '' };
  
  const pk = player === 'player1' ? 'p1' : 'p2';
  
  // üÜï Check if this is from a direct attack (for Rocky Helmet)
  // Rocky Helmet should only trigger if the active Pokemon was attacked directly
  const isDirectAttack = options.isDirectAttack !== false; // Default true for backward compatibility
  const attackerImg = options.attackerImg; // For Safeguard ability

  amount = applySpecialEffectsToDamage(pk, amount);

  
  // Check for passive damage reduction
  const reduction = getPassiveDamageReduction(pk);
  if (reduction > 0) {
    amount = Math.max(0, amount - reduction);
    showPopup(`Ability reduced damage by ${reduction}!`);
  }
  
  // Check for Giant Cape or other max HP modifiers
  const slot = img.closest('.card-slot');
  const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  
  const base = modifiedMaxHp || parseInt(img.dataset.hp || '0', 10) || 0;
  let chp = parseInt(img.dataset.chp || base || '0', 10) || base;
  
  // üÜï Check for Safeguard ability (Oricorio) - blocks all damage from ex Pokemon
  if (isDirectAttack && attackerImg && shouldBlockDamageFromEx(pk, attackerImg)) {
    // Show shield animation
    const shield = document.createElement('div');
    shield.className = 'safeguard-shield';
    shield.innerHTML = 'üõ°Ô∏è';
    shield.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 60px;
      z-index: 9999;
      animation: safeguardPulse 0.8s ease-out;
      pointer-events: none;
    `;
    slot.appendChild(shield);
    
    // Add CSS animation if not already present
    if (!document.getElementById('safeguard-animation-style')) {
      const style = document.createElement('style');
      style.id = 'safeguard-animation-style';
      style.textContent = `
        @keyframes safeguardPulse {
          0% {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.3);
            filter: drop-shadow(0 0 10px rgba(59, 130, 246, 0.8));
          }
          50% {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
            filter: drop-shadow(0 0 20px rgba(59, 130, 246, 1));
          }
          100% {
            opacity: 0;
            transform: translate(-50%, -50%) scale(1.5);
            filter: drop-shadow(0 0 30px rgba(59, 130, 246, 0.4));
          }
        }
      `;
      document.head.appendChild(style);
    }
    
    // Remove shield after animation
    setTimeout(() => shield.remove(), 800);
    
    showPopup(`Safeguard: ${img.alt} takes no damage from ${attackerImg.alt}!`);
    return { knocked: false, hpText: `${chp} / ${base}` };
  }
  
  chp = Math.max(0, chp - amount);
  setHpOnImage(img, base, chp);
  
  slot.classList.add('damage-flash');
  setTimeout(() => slot.classList.remove('damage-flash'), 400);

  if (currentZoom.img && currentZoom.img === img) {
    const pct = base > 0 ? Math.round((chp / base) * 100) : 0;
    zoomHp.textContent = `HP: ${chp} / ${base}`;
    zoomHpBar.style.width = pct + "%";
    zoomHpBar.style.background = (chp === base)
      ? 'linear-gradient(90deg,#22c55e,#16a34a)'
      : 'linear-gradient(90deg,#f43f5e,#ef4444)';
  }

  // Check for counterattack ability
  // üÜï Only trigger counterattack if this was a direct attack
  if (amount > 0 && isDirectAttack) {
    const counterDmg = getCounterattackDamage(pk);
    if (counterDmg > 0) {
      const attacker = player === 'player1' ? 'player2' : 'player1';
      showPopup(`Counterattack: Dealt ${counterDmg} damage back!`);
      setTimeout(async () => {
        const counterResult = await damageActiveOf(attacker, counterDmg, { isDirectAttack: false });
        // Check if counterattack KO'd the attacker
        if (counterResult.knocked && typeof handleKnockOut === 'function') {
          console.log('[counterattack] Attacker knocked out by counterattack!');
          const attackerImg = getActiveImage(attacker);
          if (attackerImg) {
            const gameEnded = await handleKnockOut(attacker, attackerImg, true);
            if (!gameEnded && typeof beginPromotionFlow === 'function') {
              await beginPromotionFlow(attacker);
            }
          }
        }
      }, 600);
    }
    
    // üÜï A3 - Check for counter_next_turn effect (Sandslash's Spike Armor)
    if (img.dataset.counterDamageNextTurn) {
      const counterDamage = parseInt(img.dataset.counterDamageNextTurn, 10);
      const attacker = player === 'player1' ? 'player2' : 'player1';
      showPopup(`Counter activated: Dealt ${counterDamage} damage back!`);
      delete img.dataset.counterDamageNextTurn; // Clear after use
      
      setTimeout(async () => {
        const counterResult = await damageActiveOf(attacker, counterDamage, { isDirectAttack: false });
        // Check if counter KO'd the attacker
        if (counterResult.knocked && typeof handleKnockOut === 'function') {
          console.log('[counter-next-turn] Attacker knocked out by counter!');
          const attackerImg = getActiveImage(attacker);
          if (attackerImg) {
            const gameEnded = await handleKnockOut(attacker, attackerImg, true);
            if (!gameEnded && typeof beginPromotionFlow === 'function') {
              await beginPromotionFlow(attacker);
            }
          }
        }
      }, 800);
    }
    
    // üÜï Check for Rocky Helmet tool - Only trigger on direct attacks
    const tool = getToolDataFromSlot(slot);
    if (tool && tool.set && tool.num) {
      const cardId = `${tool.set}-${tool.num}`;
      
      // Rocky Helmet - A2-148
      if (cardId === 'A2-148') {
        const helmetDamage = 20;
        const attacker = player === 'player1' ? 'player2' : 'player1';
        showPopup(`Rocky Helmet: Dealt ${helmetDamage} damage back!`);
        setTimeout(async () => {
          const helmetResult = await damageActiveOf(attacker, helmetDamage, { isDirectAttack: false });
          // üÜï Check if Rocky Helmet KO'd the attacker
          if (helmetResult.knocked && typeof handleKnockOut === 'function') {
            console.log('[rocky-helmet] Attacker knocked out by Rocky Helmet!');
            const attackerImg = getActiveImage(attacker);
            if (attackerImg) {
              const gameEnded = await handleKnockOut(attacker, attackerImg, true);
              if (!gameEnded && typeof beginPromotionFlow === 'function') {
                beginPromotionFlow(attacker);
              }
            }
          }
        }, 800);
      }
      
      // üÜï Poison Barb - A3-146
      if (cardId === 'A3-146') {
        const attacker = player === 'player1' ? 'player2' : 'player1';
        const attackerPk = attacker === 'player1' ? 'p1' : 'p2';
        if (typeof setStatus === 'function') {
          setStatus(attackerPk, 'poisoned');
          showPopup(`Poison Barb: Poisoned the attacker!`);
          console.log('[poison-barb] Inflicted poison on attacker');
        }
      }
    }
  }

  if (chp <= 0) {
    // üÜï A3 PASSIVE ABILITY - Guts (flip to avoid knockout)
    if (typeof getAbilityRow === 'function' && typeof applyAbilityEffectFromCsv === 'function') {
      try {
        const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
        
        if (abilityRow?.effect_type === 'flip_avoid_knockout') {
          const pk = player === 'player1' ? 'p1' : 'player2';
          const result = await applyAbilityEffectFromCsv(abilityRow, pk, { targetImg: img });
          
          if (result?.avoided) {
            // Survived! Don't process knockout
            console.log('[Guts] Pokemon survived knockout');
            return { knocked: false, owner: player };
          }
        }
      } catch (err) {
        console.warn('[Guts] Failed to check ability:', err);
      }
    }
    
    const owner = img.closest('#player1') ? 'player1' : 'player2';
    return { knocked: true, owner };
  }
  
  return { knocked: false };
}
function animateCardToHand(pk, cardObj) {
  // Create ghost thumbnail
  const img = document.createElement('img');
  img.src = cardObj.image;
  img.style.position = 'fixed';
  img.style.width = '48px';
  img.style.height = '67px';
  img.style.pointerEvents = 'none';
  img.style.zIndex = 99999;
  img.style.borderRadius = '6px';
  img.style.left = '50%';
  img.style.top = '50%';
  img.style.transform = 'translate(-50%, -50%) scale(2)';
  img.style.opacity = '1';
  img.style.transition = 'all .4s ease-out';

  document.body.appendChild(img);

  // Destination: player's hand bar
  const handElm = pk === 'p1' ? document.getElementById('p1Hand') : document.getElementById('p2Hand');
  const rect = handElm.getBoundingClientRect();

  setTimeout(() => {
    img.style.left = rect.left + 40 + 'px';
    img.style.top = rect.top + 10 + 'px';
    img.style.transform = 'translate(0,0) scale(.6)';
    img.style.opacity = '0';
  }, 20);

  setTimeout(() => img.remove(), 420);
}

/* ========= slide animation helper ========= */
function animateSlideFromHand(sourceImg, targetSlot, targetCard) {
  if (!sourceImg || !targetSlot) return;
  
  // Ensure sourceImg is a valid DOM element with getBoundingClientRect
  if (typeof sourceImg.getBoundingClientRect !== 'function') {
    console.warn('[animateSlideFromHand] Invalid sourceImg, skipping animation');
    return;
  }
  
  // Hide the target card initially
  if (targetCard) {
    targetCard.style.opacity = '0';
  }
  
  // Get positions before any DOM changes
  const sourceRect = sourceImg.getBoundingClientRect();
  const animationDuration = 250; // Faster: 0.25s instead of 0.4s
  
  // Wait a frame to get target position after DOM update
  requestAnimationFrame(() => {
    const targetRect = targetSlot.getBoundingClientRect();
    
    // Create a clone for animation
    const clone = sourceImg.cloneNode(true);
    clone.style.cssText = `
      position: fixed;
      left: ${sourceRect.left}px;
      top: ${sourceRect.top}px;
      width: ${sourceRect.width}px;
      height: ${sourceRect.height}px;
      z-index: 10000;
      pointer-events: none;
      transition: all ${animationDuration}ms cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 1;
    `;
    document.body.appendChild(clone);
    
    // Force reflow
    void clone.offsetWidth;
    
    // Animate to target position
    requestAnimationFrame(() => {
      clone.style.left = `${targetRect.left}px`;
      clone.style.top = `${targetRect.top}px`;
      clone.style.width = `${targetRect.width}px`;
      clone.style.height = `${targetRect.height}px`;
      clone.style.opacity = '0.8';
    });
    
    // Clean up after animation and show the target card
    setTimeout(() => {
      clone.remove();
      if (targetCard) {
        targetCard.style.opacity = '1';
        targetCard.style.transition = 'opacity 0.1s ease';
      }
    }, animationDuration);
  });
}

/* ========= slide animation for swapping ========= */
function animateSlideSwap(sourceImg, targetSlot, targetCard, sourceRect) {
  if (!sourceImg || !targetSlot) return;
  
  // Hide the target card initially
  if (targetCard) {
    targetCard.style.opacity = '0';
  }
  
  // Use provided sourceRect or get it from sourceImg
  const sourcePosition = sourceRect || sourceImg.getBoundingClientRect();
  const animationDuration = 250; // Faster: 0.25s instead of 0.4s
  
  // Wait a frame to get target position after DOM update
  requestAnimationFrame(() => {
    const targetRect = targetSlot.getBoundingClientRect();
    
    // Create a clone for animation
    const clone = sourceImg.cloneNode(true);
    clone.style.cssText = `
      position: fixed;
      left: ${sourcePosition.left}px;
      top: ${sourcePosition.top}px;
      width: ${sourcePosition.width}px;
      height: ${sourcePosition.height}px;
      z-index: 10000;
      pointer-events: none;
      transition: all ${animationDuration}ms cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 1;
    `;
    document.body.appendChild(clone);
    
    // Force reflow
    void clone.offsetWidth;
    
    // Animate to target position
    requestAnimationFrame(() => {
      clone.style.left = `${targetRect.left}px`;
      clone.style.top = `${targetRect.top}px`;
      clone.style.width = `${targetRect.width}px`;
      clone.style.height = `${targetRect.height}px`;
      clone.style.opacity = '0.8';
    });
    
    // Clean up after animation and show the target card
    setTimeout(() => {
      clone.remove();
      if (targetCard) {
        targetCard.style.opacity = '1';
        targetCard.style.transition = 'opacity 0.1s ease';
      }
    }, animationDuration);
  });
}

/* ========= discard UI ========= */
function renderDiscard(owner){
  const drawer=owner==='player1'?p1DiscardDrawer:p2DiscardDrawer;
  const {cards,energyCounts}=playerState[owner].discard;
  const drawerId = owner==='player1'?'p1DiscardDrawer':'p2DiscardDrawer';
  drawer.innerHTML=`
    <h3 style="margin:10px 0 6px;">
      ${owner==='player1'?'Player 1':'Player 2'} Discard (${cards.length+Object.values(energyCounts).reduce((a,b)=>a+b,0)})
    </h3>
    <button style="margin-bottom:10px" onclick="document.getElementById('${drawerId}').classList.remove('show'); if(typeof updateDiscardDrawerPositions === 'function') updateDiscardDrawerPositions();">Close</button>
  `;
  const energiesRow=document.createElement('div');
  energiesRow.style.display='flex';
  energiesRow.style.flexDirection='column';
  Object.keys(energyCounts).forEach(k=>{
    const row=document.createElement('div');
    row.className='discard-item';
    const ico=document.createElement('span');
    ico.className='mini-icon';
    ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;
    ico.style.width='26px';ico.style.height='26px';
    const cnt=document.createElement('span');
    cnt.className='discard-count';
    cnt.textContent=`x${energyCounts[k]}`;
    row.appendChild(ico);row.appendChild(cnt);
    energiesRow.appendChild(row);
  });
  drawer.appendChild(energiesRow);
  cards.forEach(c=>{
    const row=document.createElement('div');
    row.className='discard-item';
    const im=document.createElement('img');
    im.src=c.src;
    row.appendChild(im);
    drawer.appendChild(row);
  });
}

/* ========= attack menu + retreat ========= */
// Handle attack click - executes the attack (using same logic as buildZoomPanel)
/**
 * Calculate preview damage for an attack (with all modifiers)
 * This is used to display the actual damage that will be dealt
 * Returns an object with damage amount and boost type info for styling
 */
async function calculatePreviewDamage(attack, attackerImg, meta, pk) {
  if (!attack || !attackerImg || !meta) {
    const baseDmg = attack?.damage || '';
    return { damage: baseDmg, hasWeakness: false, hasOtherBoosts: false };
  }
  
  // Parse base damage - check for multiplicative damage (x or √ó)
  let damage = 0;
  let isMultiplicative = false;
  let multiplier = 1;
  if (attack.damage) {
    const dmgStr = String(attack.damage).toLowerCase();
    // Check if damage contains "x" or "√ó" (multiplicative)
    if (dmgStr.includes('x') || dmgStr.includes('√ó')) {
      isMultiplicative = true;
      // Extract multiplier (number before "x", or 1 if just "x")
      const multMatch = dmgStr.match(/(\d+)\s*[x√ó]/);
      if (multMatch) {
        multiplier = parseInt(multMatch[1], 10);
      } else {
        multiplier = 1; // Just "x" means multiply by 1
      }
      damage = 0; // Base damage is 0 for multiplicative attacks
    } else {
      // Regular additive damage
      const match = dmgStr.match(/\d+/);
      if (match) damage = parseInt(match[0], 10);
    }
  }
  
  // Check if this attack uses bonus_damage_per_energy_on_opponent_all (Energy Crush)
  // or bonus_damage_for_each_bench (Suicune ex - Crystal Waltz, Altaria - Do the Wave)
  // For these attacks, base damage should be 0 ONLY if CSV shows 0 base damage
  try {
    if (typeof globalThis.getMoveRow === 'function' && typeof globalThis.loadMoveEffects === 'function') {
      await globalThis.loadMoveEffects();
      const moveRow = globalThis.getMoveRow(attackerImg.alt, attack.name);
      if (moveRow?.effect_type === 'bonus_damage_per_energy_on_opponent_all') {
        damage = 0; // Energy Crush has 0 base damage
        console.log(`[preview] Energy Crush detected, setting base damage to 0`);
      } else if (moveRow?.effect_type === 'bonus_damage_for_each_bench') {
        const csvBaseDamage = parseInt(moveRow?.damageBase || moveRow?.damage || '0', 10);
        if (csvBaseDamage === 0) {
          damage = 0; // Only set to 0 if CSV shows 0 base damage (Suicune ex case)
        }
        // Otherwise, preserve the base damage (Altaria has 20 base, Mega Altaria ex has 40)
      }
    }
  } catch (err) {
    console.error('[preview] Error checking move row for base damage:', err);
  }
  
  const foePk = pk === 'p1' ? 'p2' : 'p1';
  const foe = foePk === 'p1' ? 'player1' : 'player2';
  
  // Track boost types
  let hasWeakness = false;
  let hasOtherBoosts = false;
  const baseDamage = damage;
  let totalBonuses = 0; // Track bonuses separately for multiplicative attacks
  
  // Apply move effect from CSV (preview mode)
  const effectState = {
    p1: typeof playerState !== 'undefined' ? playerState.player1 : {},
    p2: typeof playerState !== 'undefined' ? playerState.player2 : {},
    activeFor: typeof activeFor === 'function' ? activeFor : () => null,
    benchFor: typeof benchFor === 'function' ? benchFor : () => null,
    opponentOf: typeof opponentOf === 'function' ? opponentOf : (p) => p === 'player1' ? 'player2' : 'player1',
    fetchCardMeta: typeof fetchCardMeta === 'function' ? fetchCardMeta : async () => ({}),
    damageActiveOf: typeof damageActiveOf === 'function' ? damageActiveOf : () => ({ knocked: false }),
    beginPromotionFlow: typeof beginPromotionFlow === 'function' ? beginPromotionFlow : () => {},
    showPopup: () => {}, // Silent for preview
    logEvent: () => {}
  };
  
  try {
      if (typeof applyMoveEffectFromCsv === 'function') {
      const result = await applyMoveEffectFromCsv(effectState, pk, attack.name, damage, { 
        moveName: attack.name,
        isFinal: false, // Preview mode
        isMultiplicative: isMultiplicative,
        multiplier: multiplier,
        attackCost: attack.cost || [] // Pass attack cost directly to avoid async fetch issues
      });
      
      if (typeof result === 'object' && result.damage !== undefined) {
        // result.damage already includes baseDamage + bonuses from applyMoveEffect
        damage = result.damage;
        // If multiplicative, extract total bonuses
        if (isMultiplicative && result.totalBonuses !== undefined) {
          totalBonuses = result.totalBonuses;
        }
      } else {
        // result is a number (total damage including base + bonuses)
        damage = result;
        // If multiplicative, damage is actually the total bonuses
        if (isMultiplicative) {
          totalBonuses = damage;
          damage = 0;
        }
      }
      
      // Note: result.damage from applyMoveEffect already includes baseDamage + bonuses
      // So we don't need to add baseDamage again here
      
      // üÜï A3b - Sweets Relay bonus (needs manual check in preview mode)
      // The handler returns early in preview mode, so we check manually here
      try {
        // Ensure move effects are loaded
        if (typeof globalThis.loadMoveEffects === 'function') {
          await globalThis.loadMoveEffects();
        }
        // Get move row to check for Sweets Relay effect
        if (typeof globalThis.getMoveRow === 'function') {
          const moveRow = globalThis.getMoveRow(attackerImg.alt, attack.name);
          if (moveRow?.effect_type === 'bonus_damage_if_last_move_name_used') {
            const moveName = moveRow.param1 || 'Sweets Relay';
            const bonus = parseInt(moveRow.param2 || '20', 10);
            
            // Check if this move was used last turn
            if (!globalThis.__moveHistory) globalThis.__moveHistory = { p1: [], p2: [] };
            const lastTurnMoves = globalThis.__moveHistory[pk] || [];
            const usedLastTurn = lastTurnMoves.some(move => 
              move.name && move.name.toLowerCase() === moveName.toLowerCase()
            );
            
            if (usedLastTurn) {
              if (isMultiplicative) {
                totalBonuses += bonus;
              } else {
                damage += bonus;
              }
              hasOtherBoosts = true;
              console.log(`[preview] Sweets Relay: +${bonus} damage (used last turn)`);
            }
          }
        }
      } catch (err) {
        console.error('[preview] Sweets Relay check failed:', err);
      }
      
      // Giovanni global damage boost
      const boost = (globalThis.state?.temp?.[pk]?.globalDamageBoost ?? 0);
      if (boost) {
        if (isMultiplicative) {
          totalBonuses += boost;
        } else {
          damage += boost;
        }
        hasOtherBoosts = true;
      }
      
      // Next turn damage bonus
      const nextTurnBonus = (globalThis.state?.temp?.[pkToPlayer(pk)]?.nextTurnDamageBonus ?? 0);
      if (nextTurnBonus > 0) {
        if (isMultiplicative) {
          totalBonuses += nextTurnBonus;
        } else {
          damage += nextTurnBonus;
        }
        hasOtherBoosts = true;
      }
      
      // Next turn attack bonuses
      const bonusKey = `${attackerImg.dataset.instanceId || attackerImg.alt}_${attack.name}`;
      const nextTurnBonus2 = globalThis.__attackBonuses?.[bonusKey] || 0;
      if (nextTurnBonus2 > 0) {
        if (isMultiplicative) {
          totalBonuses += nextTurnBonus2;
        } else {
          damage += nextTurnBonus2;
        }
        hasOtherBoosts = true;
      }
      
      // Beastite tool
      const attackerSlot = attackerImg.closest('.card-slot');
      const tool = getToolDataFromSlot(attackerSlot);
      if (tool && tool.num === '066' && tool.set === 'A3a') {
        const ULTRA_BEASTS = [
          'nihilego', 'buzzwole', 'pheromosa', 'xurkitree', 'celesteela',
          'kartana', 'guzzlord', 'poipole', 'naganadel', 'stakataka', 'blacephalon'
        ];
        const attackerName = (attackerImg.alt || '').toLowerCase();
        const isUltraBeast = ULTRA_BEASTS.some(ub => attackerName.includes(ub));
        if (isUltraBeast) {
          const attackerPlayer = attackerImg.closest('#player1') ? 'player1' : 'player2';
          const points = attackerPlayer === 'player1' ? p1Points : p2Points;
          const bonus = points * 10;
          if (isMultiplicative) {
            totalBonuses += bonus;
          } else {
            damage += bonus;
          }
          hasOtherBoosts = true;
        }
      }
      
      // Eevee Bag boost
      if (globalThis.state?.damageBoost?.[pk]) {
        const boostData = globalThis.state.damageBoost[pk];
        if (boostData.target === 'eeveelution' && boostData.duration === 'this_turn') {
          const attackerName = (attackerImg.alt || '').toLowerCase();
          const isEeveelution = boostData.targetNames?.some(ee => attackerName.includes(ee));
          if (isEeveelution) {
            if (isMultiplicative) {
              totalBonuses += boostData.amount;
            } else {
              damage += boostData.amount;
            }
            hasOtherBoosts = true;
          }
        }
      }
      
      // For multiplicative attacks, multiply total bonuses by multiplier
      if (isMultiplicative) {
        damage = totalBonuses * multiplier;
      }
    }
  } catch (err) {
    console.error('[preview] Move effect error:', err);
  }
  
  // Apply weakness - only if base damage > 0 (or bonuses > 0 for multiplicative)
  try {
    const effectiveDamage = isMultiplicative ? totalBonuses : damage;
    if (effectiveDamage > 0 && typeof getActiveImage === 'function') {
      const foeImg = getActiveImage(foe);
      if (foeImg && typeof fetchCardMeta === 'function') {
        const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const wk = metaFoe?.weaknesses?.[0];
        if (wk) {
          const wkType = (wk.type || '').toLowerCase();
          if (wkType !== 'colorless') {
            const atkType = (meta.types?.[0] || '').toLowerCase();
            if (atkType === wkType) {
              damage += 20;
              hasWeakness = true;
            }
          }
        }
      }
    }
  } catch (err) {
    console.error('[preview] Weakness check failed:', err);
  }
  
  // Fighting Coach boost
  try {
    const attackerType = (meta.types?.[0] || '').toLowerCase();
    if (attackerType) {
      const fightingCoachBoost = getFightingCoachBoost(pk, attackerType);
      if (fightingCoachBoost > 0) {
        damage += fightingCoachBoost;
        hasOtherBoosts = true;
      }
    }
  } catch (err) {
    console.error('[preview] Fighting Coach check failed:', err);
  }
  
  // Red (damage vs ex)
  try {
    const exBonus = globalThis.state?.temp?.[pk]?.damageVsEx || 0;
    if (exBonus > 0) {
      const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
      if (foeImg && typeof fetchCardMeta === 'function') {
        const foeMeta = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const isEx = foeMeta.suffix?.toUpperCase() === 'EX';
        if (isEx) {
          damage += exBonus;
          hasOtherBoosts = true;
        }
      }
    }
  } catch (err) {
    console.error('[preview] Red ex bonus check failed:', err);
  }
  
  // Thick Fat reduction
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg) {
      const attackerType = (meta.types?.[0] || '').toLowerCase();
      const thickFatReduction = getThickFatReduction(foeImg, attackerType);
      if (thickFatReduction > 0) damage = Math.max(0, damage - thickFatReduction);
    }
  } catch (err) {
    console.error('[preview] Thick Fat check failed:', err);
  }
  
  // reduce_damage_if_arceus
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      const foePk2 = foe === 'player1' ? 'p1' : 'p2';
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      if (abilityRow?.effect_type === 'reduce_damage_if_arceus' && hasArceusInPlay(foePk2)) {
        const reduction = parseInt(abilityRow.param1 || '30', 10);
        damage = Math.max(0, damage - reduction);
      }
    }
  } catch (err) {
    console.error('[preview] reduce_damage_if_arceus check failed:', err);
  }
  
  // Luxray Intimidating Fang
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      if (abilityRow?.effect_type === 'reduce_opponent_damage') {
        const reduction = parseInt(abilityRow.param1 || '20', 10);
        damage = Math.max(0, damage - reduction);
      }
    }
  } catch (err) {
    console.error('[preview] reduce_opponent_damage check failed:', err);
  }
  
  return { damage, hasWeakness, hasOtherBoosts };
}

async function handleAttackClick(attack, meta, ownerKey, activeDiv) {
  console.log('[attack] Executing attack:', attack.name, 'from', meta.name);
  
  // activeDiv is passed in as parameter
  if (!activeDiv) {
    console.error('[attack] No active Pokemon found');
    return;
  }
  
  const pk = ownerKey === 'p1' || ownerKey === 'p2' ? ownerKey : (ownerKey === 'player1' ? 'p1' : 'p2');
  const slot = activeDiv.querySelector('.card-slot');
  if (!slot) {
    console.error('[attack] No card slot found');
    return;
  }

  // üÜï A2 FIX - Store effect context for special effects like Rampardos
  let effectContext = null;

  // Don't deduct energy - energy stays on Pokemon during attacks
  const cost = attack.cost || [];
  console.log('[attack] Attack cost:', cost, '(energy not discarded)');
  
  // Check if blocked by status
  if (typeof isActiveBlockedFromAttacking === 'function' && isActiveBlockedFromAttacking(pk)) {
    const imgBlocked = typeof getActiveImg === 'function' ? getActiveImg(pk) : null;
    const st = (imgBlocked?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      showPopup('This Pok√©mon is asleep and can\'t attack.');
    } else if (st === 'paralyzed') {
      showPopup('This Pok√©mon is paralyzed and can\'t attack.');
    }
    return;
  }
  
  // üÜï A2a MOVE EFFECT - Attack lock self check
  const attackerImg = typeof getActiveImg === 'function' ? getActiveImg(pk) : null;
  if (globalThis.__specialEffects?.[pk]?.attackLockSelf) {
    showPopup('This Pok√©mon can\'t attack this turn!');
    delete globalThis.__specialEffects[pk].attackLockSelf;
    return;
  }
  
  // üÜï A3a MOVE EFFECT - Check for all-attacks lock (Aggron - Giga Impact, Dragonite ex - Giga Impact, Necrozma - Prismatic Laser)
  const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
  if (attackLock) {
    let isLocked = false;
    const currentTurn = globalThis.turnNumber || 0;
    
    console.log(`[Attack Lock] Found attackLock for ${pk}:`, attackLock, `currentTurn=${currentTurn}`);
    
    // Handle the structure from effects.js: { locked: true, lockedOnTurn: N }
    if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
      // Lock was applied on turn N (player's turn), it's locked during the player's NEXT turn
      // The player's next turn is 2 turns later (to skip the opponent's turn)
      // So: turn N (use Giga Impact) ‚Üí turn N+1 (opponent) ‚Üí turn N+2 (player's next turn, locked)
      isLocked = currentTurn === attackLock.lockedOnTurn + 2;
      console.log(`[Attack Lock] Checking lock: currentTurn=${currentTurn}, lockedOnTurn=${attackLock.lockedOnTurn}, isLocked=${isLocked} (lock active on turn ${attackLock.lockedOnTurn + 2})`);
    } else if (typeof attackLock === 'object' && attackLock.locked !== undefined) {
      // Handle nested structure (shouldn't happen, but just in case)
      if (attackLock.lockedOnTurn !== undefined) {
        isLocked = currentTurn === attackLock.lockedOnTurn + 2;
        console.log(`[Attack Lock] Checking lock (nested): currentTurn=${currentTurn}, lockedOnTurn=${attackLock.lockedOnTurn}, isLocked=${isLocked}`);
      } else {
        isLocked = attackLock.locked === true;
        console.log(`[Attack Lock] Checking lock (simple locked flag): isLocked=${isLocked}`);
      }
    } else if (attackLock === true) {
      // Backwards compat: if it's just true, treat as locked
      isLocked = true;
      console.log(`[Attack Lock] Checking lock (boolean): isLocked=true`);
    }
    
    if (isLocked) {
      showPopup('This Pok√©mon can\'t attack this turn!');
      console.log(`[Attack Lock] Blocked all attacks for ${attackerImg?.alt || 'unknown'} (pk: ${pk})`);
      return;
    }
  }
  
  // üÜï A3a MOVE EFFECT - Check for move-specific locks (Buzzwole ex - Big Beat)
  if (attackerImg) {
    const instanceId = attackerImg.dataset.instanceId;
    const moveName = attack.name?.toLowerCase();
    const moveLock = globalThis.__moveLocks?.[pk]?.[instanceId]?.[moveName];
    if (instanceId && moveName && moveLock) {
      // Check if lock is still valid based on turn number
      const currentTurn = globalThis.turnNumber || 0;
      let isLocked = false;
      
      if (typeof moveLock === 'object' && moveLock.lockedOnTurn !== undefined) {
        // Lock was applied on turn N (player's turn), it's locked during the player's NEXT turn
        // The player's next turn is 2 turns later (to skip the opponent's turn)
        // So: turn N (use Big Beat) ‚Üí turn N+1 (opponent) ‚Üí turn N+2 (player's next turn, locked)
        isLocked = currentTurn === moveLock.lockedOnTurn + 2;
        console.log(`[Move Lock] Checking lock: currentTurn=${currentTurn}, lockedOnTurn=${moveLock.lockedOnTurn}, isLocked=${isLocked} (lock active on turn ${moveLock.lockedOnTurn + 2})`);
      } else {
        // Backwards compat: if it's just true, treat as locked
        isLocked = moveLock === true;
      }
      
      if (isLocked) {
        showPopup(`This Pok√©mon can't use ${attack.name} this turn!`);
        console.log(`[Big Beat] Blocked ${attack.name} for ${attackerImg.alt} (instanceId: ${instanceId})`);
        return;
      }
    }
  }
  
  // üÜï A2a MOVE EFFECT - Attack lock with flip check
  if (globalThis.__specialEffects?.[pk]?.attackLockFlip) {
    showPopup('Must flip to attack...');
    
    const flip = Math.random() < 0.5;
    console.log(`[attack-lock-flip] Flipped: ${flip ? 'Heads' : 'Tails'}`);
    
    if (flip) {
      // Heads - attack succeeds
      showPopup('Heads! Attack proceeds.');
      delete globalThis.__specialEffects[pk].attackLockFlip;
    } else {
      // Tails - attack fails
      showPopup('Tails! Attack failed!');
      delete globalThis.__specialEffects[pk].attackLockFlip;
      closeAttackMenu();
      return;
    }
  }
  
  // üÜï A2 STATUS - Confusion check (flip on attack, damage self if tails)
  if (attackerImg && attackerImg.dataset.status?.toLowerCase() === 'confusion') {
    console.log('[confusion] Confused Pokemon attacking - flipping coin...');
    
    const flip = Math.random() < 0.5;
    console.log(`[confusion] Flipped: ${flip ? 'Heads' : 'Tails'}`);
    
    if (flip) {
      // Heads - attack succeeds, clear confusion
      showPopup('Confusion: Heads! Attack succeeds.');
      delete attackerImg.dataset.status;
      console.log('[confusion] Cleared confusion (heads)');
    } else {
      // Tails - attack fails, damage self 20
      showPopup('Confusion: Tails! This Pok√©mon hurt itself in confusion!');
      
      const player = pk === 'p1' ? 'player1' : 'player2';
      if (typeof damageActiveOf === 'function') {
        setTimeout(async () => {
          await damageActiveOf(player, 20, { isDirectAttack: false });
        }, 500);
      }
      
      // Clear confusion after hurting self
      delete attackerImg.dataset.status;
      console.log('[confusion] Cleared confusion (tails, hurt self)');
      
      // Close menu and don't continue attack
      closeAttackMenu();
      return;
    }
  }
  
  // Get opponent (pk format: p1/p2)
  const foePk = pk === 'p1' ? 'p2' : 'p1';
  const foe = foePk === 'p1' ? 'player1' : 'player2';  // Convert to player1/player2 for startTurn
  console.log('[attack] Attacker:', pk, '‚Üí Opponent:', foePk, '(', foe, ')');
  
  // Parse base damage - check for multiplicative damage (x or √ó)
  let damage = 0;
  let isMultiplicative = false;
  let multiplier = 1;
  let totalBonuses = 0;
  if (attack.damage) {
    const dmgStr = String(attack.damage).toLowerCase();
    // Check if damage contains "x" or "√ó" (multiplicative)
    if (dmgStr.includes('x') || dmgStr.includes('√ó')) {
      isMultiplicative = true;
      // Extract multiplier (number before "x", or 1 if just "x")
      const multMatch = dmgStr.match(/(\d+)\s*[x√ó]/);
      if (multMatch) {
        multiplier = parseInt(multMatch[1], 10);
      } else {
        multiplier = 1; // Just "x" means multiply by 1
      }
      damage = 0; // Base damage is 0 for multiplicative attacks
    } else {
      // Regular additive damage
    const match = dmgStr.match(/\d+/);
      if (match) damage = parseInt(match[0], 10);
    }
  }
  
  // Check if this attack uses bonus_damage_per_energy_on_opponent_all (Energy Crush)
  // or bonus_damage_for_each_bench (Suicune ex - Crystal Waltz, Altaria - Do the Wave)
  // For these attacks, base damage should be 0 ONLY if CSV shows 0 base damage
  try {
    if (typeof globalThis.getMoveRow === 'function' && typeof globalThis.loadMoveEffects === 'function') {
      await globalThis.loadMoveEffects();
      const moveRow = globalThis.getMoveRow(attackerImg.alt, attack.name);
      if (moveRow?.effect_type === 'bonus_damage_per_energy_on_opponent_all') {
        damage = 0; // Energy Crush has 0 base damage
        console.log(`[attack] Energy Crush detected, setting base damage to 0`);
      } else if (moveRow?.effect_type === 'bonus_damage_for_each_bench') {
        const csvBaseDamage = parseInt(moveRow?.damageBase || moveRow?.damage || '0', 10);
        if (csvBaseDamage === 0) {
          damage = 0; // Only set to 0 if CSV shows 0 base damage (Suicune ex case)
        }
        // Otherwise, preserve the base damage (Altaria has 20 base, Mega Altaria ex has 40)
      }
    }
  } catch (err) {
    console.error('[attack] Error checking move row for base damage:', err);
  }
  
  // Apply move effect from CSV
  const effectState = {
    p1: typeof playerState !== 'undefined' ? playerState.player1 : {},
    p2: typeof playerState !== 'undefined' ? playerState.player2 : {},
    activeFor: typeof activeFor === 'function' ? activeFor : () => null,
    benchFor: typeof benchFor === 'function' ? benchFor : () => null,
    opponentOf: typeof opponentOf === 'function' ? opponentOf : (p) => p === 'player1' ? 'player2' : 'player1',
    fetchCardMeta: typeof fetchCardMeta === 'function' ? fetchCardMeta : async () => ({}),
    damageActiveOf: typeof damageActiveOf === 'function' ? damageActiveOf : () => ({ knocked: false }),
    beginPromotionFlow: typeof beginPromotionFlow === 'function' ? beginPromotionFlow : () => {},
    showPopup: showPopup,
    logEvent: typeof logEvent === 'function' ? logEvent : () => {}
  };
  
  try {
    if (typeof applyMoveEffectFromCsv === 'function') {
      const result = await applyMoveEffectFromCsv(effectState, pk, attack.name, damage, { 
        moveName: attack.name,
        isFinal: true, // Final phase - apply all effects
        isMultiplicative: isMultiplicative,
        multiplier: multiplier,
        attackCost: attack.cost || [] // Pass attack cost directly to avoid async fetch issues
      });
      
      // üÜï A2 FIX - Handle returned object for special effects
      if (typeof result === 'object' && result.damage !== undefined) {
        damage = result.damage;
        effectContext = result.context;
        // If multiplicative, extract total bonuses
        if (isMultiplicative && result.totalBonuses !== undefined) {
          totalBonuses = result.totalBonuses;
        }
      } else {
        damage = result;
        // If multiplicative, damage is actually the total bonuses
        if (isMultiplicative) {
          totalBonuses = damage;
          damage = 0;
        }
      }
      
      // Giovanni global damage boost
      const boost = (globalThis.state?.temp?.[pk]?.globalDamageBoost ?? 0);
      if (boost) {
        console.log('[attack] Giovanni boost applied +', boost);
        if (isMultiplicative) {
          totalBonuses += boost;
        } else {
        damage += boost;
        }
      }
      
      // üÜï A3 - Next turn damage bonus (Crabominable ex)
      const nextTurnBonus = (globalThis.state?.temp?.[pkToPlayer(pk)]?.nextTurnDamageBonus ?? 0);
      if (nextTurnBonus > 0) {
        console.log('[attack] Next turn bonus applied +', nextTurnBonus);
        if (isMultiplicative) {
          totalBonuses += nextTurnBonus;
        } else {
        damage += nextTurnBonus;
        }
        // Clear after use
        if (globalThis.state?.temp?.[pkToPlayer(pk)]) {
          globalThis.state.temp[pkToPlayer(pk)].nextTurnDamageBonus = 0;
        }
      }
      
      // üÜï A2a MOVE EFFECT - Next turn attack bonuses (Donphan, Cyclizar)
      if (attackerImg) {
        const bonusKey = `${attackerImg.dataset.instanceId || attackerImg.alt}_${attack.name}`;
        const nextTurnBonus = globalThis.__attackBonuses?.[bonusKey] || 0;
        
        if (nextTurnBonus > 0) {
          if (isMultiplicative) {
            totalBonuses += nextTurnBonus;
          } else {
          damage += nextTurnBonus;
          }
          console.log(`[next-turn-bonus] +${nextTurnBonus} damage for ${attack.name}`);
          showPopup(`+${nextTurnBonus} bonus damage!`);
          
          // Clear the bonus after use
          delete globalThis.__attackBonuses[bonusKey];
        }
      }
      
      // üÜï A3a TOOL - Beastite (damage scales with points scored)
      if (attackerImg) {
        const attackerSlot = attackerImg.closest('.card-slot');
        const tool = getToolDataFromSlot(attackerSlot);
        
        if (tool && tool.num === '066' && tool.set === 'A3a') {
          // Check if attacker is Ultra Beast
          const ULTRA_BEASTS = [
            'nihilego', 'buzzwole', 'pheromosa', 'xurkitree', 'celesteela',
            'kartana', 'guzzlord', 'poipole', 'naganadel', 'stakataka', 'blacephalon'
          ];
          
          const attackerName = (attackerImg.alt || '').toLowerCase();
          const isUltraBeast = ULTRA_BEASTS.some(ub => attackerName.includes(ub));
          
          if (isUltraBeast) {
            // Get attacker's points
            const attackerPlayer = attackerImg.closest('#player1') ? 'player1' : 'player2';
            const points = attackerPlayer === 'player1' ? p1Points : p2Points;
            
            const beastiteBonus = points * 10;
            if (beastiteBonus > 0) {
              if (isMultiplicative) {
                totalBonuses += beastiteBonus;
              } else {
              damage += beastiteBonus;
              }
              showPopup(`Beastite: +${beastiteBonus} damage! (${points} points √ó 10)`);
              console.log(`[Beastite] Added ${beastiteBonus} damage based on ${points} points`);
            }
          }
        }
      }
      
      // üÜï A3b TRAINER - Eevee Bag (damage boost for Eeveelutions)
      if (attackerImg && globalThis.state?.damageBoost?.[pk]) {
        const boostData = globalThis.state.damageBoost[pk];
        if (boostData.target === 'eeveelution' && boostData.duration === 'this_turn') {
          const attackerName = (attackerImg.alt || '').toLowerCase();
          const isEeveelution = boostData.targetNames?.some(ee => attackerName.includes(ee));
          
          if (isEeveelution) {
            if (isMultiplicative) {
              totalBonuses += boostData.amount;
            } else {
              damage += boostData.amount;
            }
            showPopup(`Eevee Bag: +${boostData.amount} damage!`);
            console.log(`[Eevee Bag] Added +${boostData.amount} damage to ${attackerImg.alt}`);
          }
        }
      }
      
      // For multiplicative attacks, multiply total bonuses by multiplier
      if (isMultiplicative) {
        damage = totalBonuses * multiplier;
      }
    }
  } catch (err) {
    console.error('[attack] Move effect error:', err);
  }
  
  // Apply weakness - only if base damage > 0
  try {
    if (damage > 0 && typeof getActiveImage === 'function') {
      const foeImg = getActiveImage(foe);
      if (foeImg && typeof fetchCardMeta === 'function') {
        const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const wk = metaFoe?.weaknesses?.[0];
        
        if (wk) {
          const wkType = (wk.type || '').toLowerCase();
          if (wkType !== 'colorless') {
            const atkType = (meta.types?.[0] || '').toLowerCase();
            if (atkType === wkType) {
              console.log('[attack] Weakness: +20 damage');
              damage += 20;
            }
          }
        }
      }
    }
  } catch (err) {
    console.error('[attack] Weakness check failed:', err);
  }
  
  // üÜï A2 PASSIVE ABILITIES - Fighting Coach (boost attacker damage)
  try {
    const attackerType = (meta.types?.[0] || '').toLowerCase();
    if (attackerType) {
      const fightingCoachBoost = getFightingCoachBoost(pk, attackerType);
      if (fightingCoachBoost > 0) {
        damage += fightingCoachBoost;
        console.log(`[Fighting Coach] Boosted damage by +${fightingCoachBoost}`);
      }
    }
  } catch (err) {
    console.error('[attack] Fighting Coach check failed:', err);
  }
  
  // üÜï A2b TRAINER - Red (boost damage vs ex)
  try {
    const exBonus = globalThis.state?.temp?.[pk]?.damageVsEx || 0;
    if (exBonus > 0) {
      // Check if opponent is ex
      const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
      if (foeImg && typeof fetchCardMeta === 'function') {
        const foeMeta = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const isEx = foeMeta.suffix?.toUpperCase() === 'EX';
        
        if (isEx) {
          damage += exBonus;
          console.log(`[Red] +${exBonus} damage vs Pok√©mon ex`);
        }
      }
    }
  } catch (err) {
    console.error('[attack] Red ex bonus check failed:', err);
  }
  
  // üÜï A2 PASSIVE ABILITIES - Thick Fat (reduce damage from Fire/Water)
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg) {
      const attackerType = (meta.types?.[0] || '').toLowerCase();
      const thickFatReduction = getThickFatReduction(foeImg, attackerType);
      if (thickFatReduction > 0) {
        damage = Math.max(0, damage - thickFatReduction);
        showPopup(`Thick Fat: Reduced ${thickFatReduction} damage!`);
      }
    }
  } catch (err) {
    console.error('[attack] Thick Fat check failed:', err);
  }
  
  // üÜï A2 PASSIVE ABILITIES - Guarded Grill (flip to reduce damage)
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      damage = applyGuardedGrill(foeImg, damage);
    }
  } catch (err) {
    console.error('[attack] Guarded Grill check failed:', err);
  }
  
  // üÜï A2a PASSIVE ABILITY - reduce_damage_if_arceus (Raichu, Magnezone)
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      const foePk = foe === 'player1' ? 'p1' : 'p2';
      
      // Check if defender has reduce_damage_if_arceus ability
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_damage_if_arceus' && hasArceusInPlay(foePk)) {
        const reduction = parseInt(abilityRow.param1 || '30', 10);
        damage = Math.max(0, damage - reduction);
        showPopup(`${abilityRow.abilityName}: Reduced ${reduction} damage!`);
        console.log(`[${abilityRow.abilityName}] Arceus in play, reduced damage by ${reduction}`);
      }
    }
  } catch (err) {
    console.error('[attack] reduce_damage_if_arceus check failed:', err);
  }
  
  // üÜï A3a PASSIVE ABILITY - Luxray Intimidating Fang (reduce opponent damage)
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      // Check if defender has reduce_opponent_damage ability
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_opponent_damage') {
        const reduction = parseInt(abilityRow.param1 || '20', 10);
        damage = Math.max(0, damage - reduction);
        showPopup(`${abilityRow.abilityName}: Reduced ${reduction} damage!`);
        console.log(`[${abilityRow.abilityName}] Reduced damage by ${reduction}`);
      }
    }
  } catch (err) {
    console.error('[attack] reduce_opponent_damage check failed:', err);
  }
  
  // Apply damage
  let knocked = false;
  if (typeof damageActiveOf === 'function') {
    const result = await damageActiveOf(foe, damage, { attackerImg: attackerImg });
    knocked = result.knocked;
    showPopup(`${meta.name} used ${attack.name}${damage > 0 ? ` for ${damage} damage!` : '!'}`);
  } else {
    showPopup(`${meta.name} used ${attack.name}!`);
  }
  
  // Close menu
  closeAttackMenu();
  
  // Handle KO
  if (knocked && typeof handleKnockOut === 'function' && typeof getActiveImage === 'function') {
    const foeImg = getActiveImage(foe);
    if (foeImg) {
      const ended = await handleKnockOut(foe, foeImg);
      if (ended) return;
      
      // üÜï MANDATORY PROMOTION - Block all other actions until promotion completes
      if (typeof beginPromotionFlow === 'function') {
        await beginPromotionFlow(foe);
      }
    }
  }
  
  // üÜï A2 FIX - Rampardos Head Smash: Self-damage only if KO
  if (knocked && effectContext?.checkKoForRecoil) {
    const recoilDamage = effectContext.checkKoForRecoil;
    const attacker = pk === 'p1' ? 'player1' : 'player2'; // Convert pk to player format
    console.log(`[Rampardos] Opponent KO'd, applying ${recoilDamage} recoil damage to ${attacker}`);
    setTimeout(async () => {
      if (typeof damageActiveOf === 'function') {
        await damageActiveOf(attacker, recoilDamage, { isDirectAttack: false });
        showPopup(`Rampardos took ${recoilDamage} recoil damage!`);
      }
    }, 800);
  }
  
  
  // Start opponent's turn
  if (typeof startTurn === 'function') {
    setTimeout(() => startTurn(foe), 300);
  }
  
  console.log('[attack] Attack complete');
}

// Handle retreat click (using game's promotion system)
function handleRetreat(activeDiv, meta, retreatCost) {
  console.log('[RETREAT] === STARTING RETREAT ===');
  console.log('[retreat] Attempting to retreat:', meta.name, 'cost:', retreatCost);
  console.log('[RETREAT] activeDiv:', activeDiv);
  console.log('[RETREAT] Current flag states:', {
    isRetreatSelection,
    isPromotionPhase,
    isEvoMode,
    hasRetreatedThisTurn
  });
  
  // Check if already retreated this turn
  if (hasRetreatedThisTurn) {
    console.log('[RETREAT] BLOCKED - Already retreated this turn');
    showPopup('You can only retreat once per turn!');
    return;
  }
  
  // Check if activeDiv is valid
  if (!activeDiv) {
    console.error('[RETREAT] ERROR - activeDiv is null!');
    showPopup('Cannot retreat - invalid active area');
    return;
  }
  
  const slot = activeDiv.querySelector('.card-slot');
  if (!slot) {
    console.error('[retreat] No card slot found');
    return;
  }
  
  // Check if we have enough energy (only if retreat costs something)
  if (retreatCost > 0) {
    const energyPipsContainer = slot.querySelector('.energy-pips');
    if (!energyPipsContainer) {
      console.error('[retreat] No energy pips found');
      return;
    }
    
    const pips = energyPipsContainer.querySelectorAll('.energy-pip');
    if (pips.length < retreatCost) {
      showPopup(`Not enough energy to retreat! Need ${retreatCost}, have ${pips.length}`);
      return;
    }
  } else {
    console.log('[retreat] Free retreat (cost 0), skipping energy check');
  }
  
  // Determine which player owns this Pokemon
  let ownerKey = null;
  if (activeDiv.closest('#player1')) ownerKey = 'player1';
  else if (activeDiv.closest('#player2')) ownerKey = 'player2';
  
  if (!ownerKey) {
    console.error('[retreat] Could not determine owner');
    return;
  }
  
  // Check if bench has Pokemon using game's benchFor function
  let hasBench = false;
  if (typeof benchFor === 'function') {
    const benchDiv = benchFor(ownerKey);
    if (benchDiv) {
      const benchSlots = benchDiv.querySelectorAll('.card-slot');
      const occupied = Array.from(benchSlots).filter(s => {
        const img = s.querySelector('img');
        return img && img.dataset.set && img.dataset.num;
      });
      hasBench = occupied.length > 0;
      console.log('[retreat] Bench check: found', occupied.length, 'Pokemon');
    }
  } else {
    // Fallback: check bench manually
    const pk = ownerKey === 'player1' ? 'p1' : 'p2';
    const bench = document.querySelector(`#${pk}-bench`);
    if (bench) {
      const benchSlots = bench.querySelectorAll('.card-slot');
      const occupied = Array.from(benchSlots).filter(s => {
        const img = s.querySelector('img');
        return img && img.dataset.set && img.dataset.num;
      });
      hasBench = occupied.length > 0;
      console.log('[retreat] Bench check (fallback): found', occupied.length, 'Pokemon');
    }
  }
  
  if (!hasBench) {
    showPopup('No bench Pokemon to retreat to!');
    return;
  }
  
  // Store retreat cost for later (will be paid only after successful swap)
  const storedRetreatCost = retreatCost;
  
  // Close the menu first
  console.log('[RETREAT] Closing menu before retreat');
  closeAttackMenu();
  console.log('[RETREAT] Menu closed, flag states:', {
    isRetreatSelection,
    isPromotionPhase,
    isEvoMode
  });
  
  // Set retreat selection mode (blocks menu during selection)
  isRetreatSelection = true;
  console.log('[RETREAT] Set isRetreatSelection = true, menu now blocked');
  
  // Custom retreat promotion
  showPopup(`${meta.name} retreated! Choose new active Pokemon (or click anywhere to cancel).`);
  
  // Get bench div for highlighting
  const benchDiv = typeof benchFor === 'function' ? benchFor(ownerKey) : 
    document.querySelector(`#${ownerKey === 'player1' ? 'p1' : 'p2'}-bench`);
  
  if (!benchDiv) {
    console.error('[retreat] Could not find bench div');
    return;
  }
  
  // Highlight bench Pokemon
  const benchImgs = benchDiv.querySelectorAll('img');
  benchImgs.forEach(img => {
    if (img.dataset.set && img.dataset.num) {
      img.classList.add('promote-glow');
    }
  });
  
  // One-time click handler for selection or cancellation
  const selectReplacement = (e) => {
    console.log('[SELECT-REPLACEMENT] Fired! Target:', e.target, 'isRetreatSelection:', isRetreatSelection);
    
    // CRITICAL: Only respond if we're still in retreat mode
    // If flag was already reset, remove listener and ignore
    if (!isRetreatSelection) {
      document.body.removeEventListener('click', selectReplacement, true);
      console.log('[RETREAT] Guard check: isRetreatSelection is false, removing listener and exiting');
      return;
    }
    
    console.log('[SELECT-REPLACEMENT] Guard check passed, processing click');
    
    // Check if clicked a bench Pokemon
    const chosenImg = e.target.closest(`#${ownerKey} .bench img`);
    
    if (chosenImg && chosenImg.dataset.set && chosenImg.dataset.num) {
      // Valid bench Pokemon clicked
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      document.body.removeEventListener('click', selectReplacement, true);
      
      // Reset retreat mode IMMEDIATELY so guard check works
      isRetreatSelection = false;
      console.log('[RETREAT] Reset isRetreatSelection immediately after removing listener');
      console.log('[RETREAT] Swapping Pokemon');
      
      // Remove glow from all
      benchImgs.forEach(img => img.classList.remove('promote-glow'));
      
      // Perform the swap using game's helper if available
      if (typeof activeFor === 'function') {
        const activeDiv = activeFor(ownerKey);
        const activeSlot = activeDiv.querySelector('.card-slot');
        const benchSlot = chosenImg.closest('.card-slot');
        const activeImg = activeSlot.querySelector('img');
        
        // Get attachments
        const activePack = typeof detachAttachments === 'function' ? 
          detachAttachments(activeSlot) : { energy: [], tool: null };
        const benchPack = typeof detachAttachments === 'function' ? 
          detachAttachments(benchSlot) : { energy: [], tool: null };
        
        // Swap images
        if (activeImg) {
          // Clear status from active Pokemon
          if (typeof clearStatusOnImg === 'function') {
            clearStatusOnImg(activeImg);
          }
          
          // üÜï A3a - Clear move locks when Pokemon moves to bench (Buzzwole ex - Big Beat)
          const activeInstanceId = activeImg.dataset.instanceId;
          const ownerPk = ownerKey === 'player1' ? 'p1' : 'p2';
          if (activeInstanceId && globalThis.__moveLocks?.[ownerPk]?.[activeInstanceId]) {
            delete globalThis.__moveLocks[ownerPk][activeInstanceId];
            console.log(`[Big Beat] Cleared move locks for ${activeImg.alt} (instanceId: ${activeInstanceId}) - moved to bench via retreat`);
          }
          
          // Capture positions before DOM changes
          const activeRect = activeImg.getBoundingClientRect();
          const chosenRect = chosenImg.getBoundingClientRect();
          
          activeSlot.removeChild(activeImg);
          benchSlot.removeChild(chosenImg);
          activeSlot.appendChild(chosenImg);
          benchSlot.appendChild(activeImg);
          
          // Animate slide for retreat (after DOM changes)
          animateSlideSwap(activeImg, benchSlot, activeImg, activeRect);
          animateSlideSwap(chosenImg, activeSlot, chosenImg, chosenRect);
        } else {
          // Active is empty, just move bench to active
          // Capture position before DOM changes
          const chosenRect = chosenImg.getBoundingClientRect();
          
          benchSlot.removeChild(chosenImg);
          activeSlot.appendChild(chosenImg);
          
          // Animate slide for promotion (after DOM changes)
          animateSlideSwap(chosenImg, activeSlot, chosenImg, chosenRect);
        }
        
        // Reattach attachments
        if (typeof attachAttachments === 'function') {
          attachAttachments(activeSlot, benchPack);
          if (activeImg) {
            attachAttachments(benchSlot, activePack);
          }
        }
        
        // Mark slots
        if (typeof markSlot === 'function') {
          markSlot(activeSlot, true);
          markSlot(benchSlot, !!benchSlot.querySelector('img'));
        }
        
        // Update player background
        if (typeof updatePlayerTypeBackground === 'function') {
          const playerNum = activeDiv.id.includes('p1') ? 1 : 2;
          updatePlayerTypeBackground(playerNum);
        }
        
        // NOW remove retreat cost energy (only on successful retreat)
        if (storedRetreatCost > 0) {
          // Find the Pokemon that retreated (now on bench)
          const retreatedSlot = benchSlot; // The active Pokemon is now in benchSlot
          const energyPipsContainer = retreatedSlot.querySelector('.energy-pips');
          
          if (energyPipsContainer) {
            const pips = energyPipsContainer.querySelectorAll('.energy-pip:not(.phantom-pip)');
            console.log('[retreat] Removing', storedRetreatCost, 'energy from retreated Pokemon');
            
            // Add energy to discard pile
            for (let i = 0; i < storedRetreatCost && i < pips.length; i++) {
              const energyType = pips[i].dataset.type || 'colorless';
              playerState[ownerKey].discard.energyCounts[energyType] = 
                (playerState[ownerKey].discard.energyCounts[energyType] || 0) + 1;
              pips[i].remove();
              console.log('[retreat] Discarded', energyType, 'energy');
            }
            
            // Also remove phantom pips for discarded energy
            const phantomPips = energyPipsContainer.querySelectorAll('.energy-pip.phantom-pip');
            for (let i = 0; i < storedRetreatCost && i < phantomPips.length; i++) {
              phantomPips[i].remove();
            }
          }
        } else {
          console.log('[retreat] Free retreat (cost 0)');
        }
        
        showPopup('Promoted to Active.');

        // IMMEDIATELY clean up any menu state and dispatch click
        console.log('[RETREAT] Starting immediate cleanup');
        
        // 1. Force close any existing menus
        if (typeof closeAttackMenu === 'function') {
          closeAttackMenu();
          console.log('[RETREAT] Called closeAttackMenu');
        }
        
        // 2. Remove menu-open class from all slots
        document.querySelectorAll('.card-slot.menu-open').forEach(slot => {
          slot.classList.remove('menu-open');
        });
        
        // 3. Remove any attack menu elements
        document.querySelectorAll('.attack-menu').forEach(menu => {
          menu.remove();
        });
        
        // 4. Dispatch click on background to trigger handlers
        const background = document.querySelector('.board') || document.body;
        const clickEvent = new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
          view: window,
          clientX: 10,
          clientY: 10
        });
        background.dispatchEvent(clickEvent);
        console.log('[RETREAT] Immediate cleanup complete - closed menus and dispatched click');

        
        // isRetreatSelection already reset immediately after listener removal
        lastRetreatTime = Date.now();  // Record when retreat completed
        
        // Mark that we've retreated this turn (prevent multiple retreats)
        hasRetreatedThisTurn = true;
        console.log('[RETREAT] Set hasRetreatedThisTurn = true');
        console.log('[RETREAT] SUCCESS - Swap complete, ready for menu');
      }
    } else {
      // Clicked somewhere else - cancel
      document.body.removeEventListener('click', selectReplacement, true);
      
      // Reset retreat mode
      isRetreatSelection = false;
      console.log('[RETREAT] CANCEL - Reset isRetreatSelection = false, menu now unblocked');
      console.log('[RETREAT] SUCCESS - Reset isRetreatSelection = false, menu now unblocked');
      
      benchImgs.forEach(img => img.classList.remove('promote-glow'));
      showPopup('Retreat canceled (no replacement selected).');
    }
  };
  
  // Add click listener with slight delay to prevent immediate trigger
  setTimeout(() => {
    document.body.addEventListener('click', selectReplacement, true);
    console.log('[RETREAT] selectReplacement listener ADDED to document.body');
  }, 100);
  
  console.log('[retreat] Retreat complete, awaiting replacement selection');
}

// Handle ability click (using same logic as buildZoomPanel)
async function applyAbilityEffect(abilityRow, ownerKey, sourceImg = null) {
  console.log('[ability] Activating ability:', abilityRow);
  console.log('[ability] ownerKey received:', ownerKey);
  console.log('[ability] sourceImg:', sourceImg?.alt || 'none');
  
  if (typeof applyAbilityEffectFromCsv === 'function') {
    // ownerKey is now p1/p2 (not player1/player2)
    // Handle both formats for compatibility
    let pk;
    if (ownerKey === 'p1' || ownerKey === 'p2') {
      pk = ownerKey;  // Already correct
    } else {
      pk = ownerKey === 'player1' ? 'p1' : 'p2';  // Fallback conversion
    }
    console.log('[ability] Converted to pk:', pk);
    
    // Shared state object for effects.js (same as buildZoomPanel)
    const effectState = {
      p1: typeof playerState !== 'undefined' ? playerState.player1 : {},
      p2: typeof playerState !== 'undefined' ? playerState.player2 : {},
      activeFor: typeof activeFor === 'function' ? activeFor : () => null,
      benchFor: typeof benchFor === 'function' ? benchFor : () => null,
      opponentOf: typeof opponentOf === 'function' ? opponentOf : (p) => p === 'player1' ? 'player2' : 'player1',
      fetchCardMeta: typeof fetchCardMeta === 'function' ? fetchCardMeta : async () => ({}),
      damageActiveOf: typeof damageActiveOf === 'function' ? damageActiveOf : () => ({ knocked: false }),
      beginPromotionFlow: typeof beginPromotionFlow === 'function' ? beginPromotionFlow : () => {},
      showPopup: showPopup,
      logEvent: typeof logEvent === 'function' ? logEvent : () => {},
      attachEnergyToSlot: typeof attachEnergyToSlot === 'function' ? attachEnergyToSlot : () => {},
      energyZoneDiv: typeof energyZoneDiv !== 'undefined' ? energyZoneDiv : null,
      renderEnergyZone: typeof renderEnergyZone === 'function' ? renderEnergyZone : () => {},
      getActiveImage: typeof getActiveImage === 'function' ? getActiveImage : () => null
    };
    
    try {
      const result = await applyAbilityEffectFromCsv(effectState, pk, abilityRow, { sourceImg });
      showPopup(`Used ability: ${abilityRow.abilityName || 'Unknown'}`);
      
      // Close zoom modal if open (same as buildZoomPanel does)
      if (typeof zoomBackdrop !== 'undefined' && zoomBackdrop.classList.contains('show')) {
        zoomBackdrop.classList.remove('show');
        if (typeof currentZoom !== 'undefined') {
          currentZoom = { img: null, meta: null };
        }
      }
      
      // Check if ability caused a KO (e.g., Greninja's Water Shuriken)
      if (result && result.knocked) {
        console.log('[ability] KO detected, result:', result);
        const foe = pk === 'p1' ? 'player2' : 'player1';
        
        // Use the knockedImg from result if available (for abilities that target any Pokemon)
        // Otherwise fall back to active Pokemon
        const foeImg = result.knockedImg || getActiveImage(foe);
        
        if (foeImg && typeof handleKnockOut === 'function') {
          console.log('[ability] Handling KO for:', foeImg.alt);
          
          // Check if knocked Pokemon was active
          const foeActive = getActiveImage(foe);
          const wasActive = (foeImg === foeActive);
          
          const ended = await handleKnockOut(foe, foeImg, wasActive);
          if (!ended && typeof beginPromotionFlow === 'function') {
            // Only promote if active was KO'd
            if (wasActive) {
              await beginPromotionFlow(foe);
            }
          }
        }
      }
    } catch (err) {
      console.error('[ability] Ability effect error:', err);
      showPopup('Ability failed.');
    }
  } else {
    console.warn('[ability] applyAbilityEffectFromCsv not found');
    showPopup(`Used ability: ${abilityRow.abilityName || 'Unknown'}`);
  }
}

function closeAttackMenu(){
  if(openAttackMenu){
    // Remove menu-open mark from card slot
    const menuOpenSlots = document.querySelectorAll('.card-slot.menu-open');
    menuOpenSlots.forEach(slot => slot.classList.remove('menu-open'));
    // Remove escape key handler
    if(openAttackMenu._escapeHandler){
      document.removeEventListener('keydown', openAttackMenu._escapeHandler);
    }
    // Remove click outside handler
    if(openAttackMenu._clickOutsideHandler){
      document.removeEventListener('click', openAttackMenu._clickOutsideHandler);
      console.log('[MENU] Removed closeOnClickOutside listener');
    }
    // Remove backdrop if it exists
    if(openAttackMenu._backdrop){
      openAttackMenu._backdrop.remove();
    }
    // Remove menu
    if(openAttackMenu.parentElement){
      openAttackMenu.parentElement.removeChild(openAttackMenu);
    }
  }
  openAttackMenu=null;
}

function computeRetreatCost(activeDiv, meta) {
  const base = Number(meta.retreat || meta.retreatCost || 0) || 0;

  // If this card is not actually in an .active div (e.g. opened from log),
  // just return the base retreat cost and skip temp modifiers.
  if (!activeDiv) return base;
  
  // üÜï A2 PASSIVE ABILITY - Levitate (zero retreat if has energy)
  const activeImg = activeDiv.querySelector('img');
  if (activeImg && typeof hasLevitateZeroRetreat === 'function' && hasLevitateZeroRetreat(activeImg)) {
    return 0;
  }
  
  // üÜï A2a PASSIVE ABILITY - zero_retreat_if_arceus (Heatran, Rotom)
  // Check if active Pokemon has zero_retreat_if_arceus ability and Arceus is in play
  if (activeImg && activeImg.dataset.set && activeImg.dataset.num) {
    try {
      // Synchronous check via globalThis.abilityCache
      const cacheKey = `${activeImg.dataset.set}-${activeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      console.log(`[retreat-debug] Checking ${activeImg.alt} (${cacheKey})`);
      console.log(`[retreat-debug] Ability row:`, abilityRow);
      console.log(`[retreat-debug] Cache size:`, Object.keys(globalThis.abilityCache || {}).length);
      
      if (abilityRow?.effect_type === 'zero_retreat_if_arceus') {
        // Determine which player owns this Pokemon
        const pk = activeDiv.closest('#player1') ? 'p1' : 'p2';
        
        console.log(`[retreat-debug] ${activeImg.alt} has zero_retreat_if_arceus ability`);
        console.log(`[retreat-debug] Checking for Arceus for player ${pk}`);
        
        // Check for Arceus in play
        if (typeof hasArceusInPlay === 'function' && hasArceusInPlay(pk)) {
          console.log('[Arceus retreat] Zero retreat cost (Arceus in play)');
          return 0;
        } else {
          console.log('[retreat-debug] No Arceus found in play');
        }
      }
    } catch (e) {
      console.error('[retreat-debug] Error checking Arceus retreat:', e);
      // Ability check failed, continue with normal cost
    }
  }
  
  // üÜï A2a PASSIVE ABILITY - reduce_active_basic_retreat_cost (Shaymin)
  // Check if player has Shaymin on bench and active is Basic
  if (activeImg && meta.stage?.toLowerCase() === 'basic') {
    // Determine which player owns this Pokemon
    const pk = activeDiv.closest('#player1') ? 'p1' : 'p2';
    const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
    const benchImgs = benchDiv ? [...benchDiv.querySelectorAll('img')] : [];
    
    console.log(`[shaymin-debug] Active Pokemon is Basic (${activeImg.alt}), checking for Shaymin on bench`);
    console.log(`[shaymin-debug] Bench has ${benchImgs.length} Pokemon`);
    
    // Check if any benched Pokemon is Shaymin with reduce_active_basic_retreat_cost ability
    for (const benchImg of benchImgs) {
      const name = (benchImg.alt || '').toLowerCase();
      console.log(`[shaymin-debug] Checking bench Pokemon: ${benchImg.alt}`);
      
      if (name.includes('shaymin')) {
        // Check if this Shaymin has the ability
        try {
          const cacheKey = `${benchImg.dataset.set}-${benchImg.dataset.num}`;
          const abilityRow = globalThis.abilityCache?.[cacheKey];
          
          console.log(`[shaymin-debug] Found Shaymin (${cacheKey}), ability:`, abilityRow);
          
          if (abilityRow?.effect_type === 'reduce_active_basic_retreat_cost') {
            const reduction = parseInt(abilityRow.param1 || '1', 10);
            console.log(`[Shaymin Sky Support] -${reduction} retreat cost for active Basic`);
            return Math.max(0, base - reduction);
          }
        } catch (e) {
          console.error(`[shaymin-debug] Error checking Shaymin:`, e);
          // Continue checking other Shaymin
        }
      }
    }
  }

  const abs = activeDiv.dataset.tempRetreat;
  const red = Number(activeDiv.dataset.tempRetreatReduce || '0') || 0;

  if (abs != null) return Math.max(0, Number(abs));
  return Math.max(0, base - red);
}

// Set temporary retreat cost reduction (Leaf, X Speed)
globalThis.setTempRetreatFor = function(pk, amount, mode = 'reduce') {
  const activeDiv = pk === 'p1' ? p1Active : p2Active;
  if (!activeDiv) {
    console.warn('[retreat] No active div for', pk);
    return;
  }
  
  if (mode === 'reduce') {
    activeDiv.dataset.tempRetreatReduce = String(amount || 0);
    console.log(`[retreat] Set tempRetreatReduce=${amount} for ${pk}`);
  } else if (mode === 'set') {
    activeDiv.dataset.tempRetreat = String(amount || 0);
    console.log(`[retreat] Set tempRetreat=${amount} for ${pk}`);
  }
};

// Clear temporary retreat cost for a player
globalThis.clearTempRetreatFor = function(pk) {
  const activeDiv = pk === 'p1' ? p1Active : p2Active;
  if (!activeDiv) return;
  
  delete activeDiv.dataset.tempRetreat;
  delete activeDiv.dataset.tempRetreatReduce;
  console.log(`[retreat] Cleared temp retreat for ${pk}`);
};

function addRetreatRow(menu, activeDiv, meta){
  const slot = activeDiv.querySelector('.card-slot');
  const costCount = computeRetreatCost(activeDiv, meta);
  const row = document.createElement('div');
  row.style.marginTop = '6px';
  row.innerHTML = '<div class="thin"></div>';

  const btn = document.createElement('div');
  btn.className = 'attack-item';

  const left = document.createElement('div');
  left.style.display = 'flex';
  left.style.alignItems = 'center';
  left.style.gap = '6px';
  const nm = document.createElement('div');
  nm.className = 'attack-name';
  nm.textContent = 'Retreat';
  left.appendChild(nm);

  const icons = document.createElement('div');
  icons.className = 'attack-cost';
  if (costCount > 0) {
    const flags = satisfiedFlags(countPipsOn(slot), Array(costCount).fill('colorless'));
    for (let i = 0; i < costCount; i++) {
      const ic = document.createElement('div');
      ic.className = 'cost-icon';
      ic.style.backgroundImage = `url('${ENERGY_ICONS.colorless}')`;
      if (!flags[i]) ic.classList.add('missing');
      icons.appendChild(ic);
    }
  }
  left.appendChild(icons);

  const arrow = document.createElement('div');
  arrow.style.fontWeight = '900';
  arrow.textContent = '‚ü≤';
  btn.appendChild(left);
  btn.appendChild(arrow);

    const canPay = costCount === 0 || canPayCostFromAPI(slot, Array(costCount).fill('colorless'));
  const hasBench = [...benchFor(currentPlayer).querySelectorAll('img')].length > 0;

  const activeImg = activeDiv.querySelector('img');
  const st = (activeImg?.dataset.status || '').toLowerCase();
  const blockedByStatus = st === 'asleep' || st === 'paralyzed';

  const pk = currentPlayer === 'player1' ? 'p1' : 'p2';

// CHECK RETREAT LOCK
if (!canRetreat(pk)) {
  btn.classList.add('muted');
  btn.onclick = () => {
    const activeImg = activeDiv.querySelector('img');
    const st = (activeImg?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      showPopup("Can't retreat - this Pok√©mon is asleep!");
    } else if (st === 'paralyzed') {
      showPopup("Can't retreat - this Pok√©mon is paralyzed!");
    } else {
      showPopup("Can't retreat - this Pok√©mon is locked!");
    }
  };
  return;
}

const canRetreatNormally = hasBench && canPay && !hasRetreatedThisTurn && !blockedByStatus;

if (canRetreatNormally) {
  btn.classList.add('payable');
  
  // Apply type-based coloring using data-type attribute (like attacks do)
  const mainType = (meta.types && meta.types[0]) ? String(meta.types[0]).toLowerCase() : null;
  if (mainType) {
    btn.setAttribute('data-type', mainType);
    console.log('[RETREAT] Set data-type:', mainType);
  }
} else {
  btn.classList.add('muted');
}
btn.onclick = () => {
  // Check if retreat is blocked
  if (!canRetreatNormally) {
    if (hasRetreatedThisTurn) {
      showPopup('You can only retreat once per turn.');
    } else if (blockedByStatus) {
      showPopup('Cannot retreat while Asleep or Paralyzed.');
    } else {
      showPopup('Cannot retreat.');
    }
    return;
  }

  // EXECUTE RETREAT
  
  // 1. Discard energy for retreat cost
  let toDiscard = costCount;
  const energyBox = slot.querySelector('.energy-pips');
  if (energyBox && toDiscard > 0) {
    const pips = [...energyBox.querySelectorAll('.energy-pip')];
    for (const pip of pips) {
      if (toDiscard <= 0) break;
      pip.remove();
      toDiscard--;
      const type = (pip.dataset.type || 'colorless').toLowerCase();
      playerState[currentPlayer].discard.energyCounts[type] =
        (playerState[currentPlayer].discard.energyCounts[type] || 0) + 1;
    }
  }

  // 2. Consume temporary retreat cost reduction
  if (activeDiv.dataset.tempRetreatReduce != null) {
    delete activeDiv.dataset.tempRetreatReduce;
  }

  // 3. Mark that retreat has been used this turn
  hasRetreatedThisTurn = true;

  // 4. Move Active Pokemon to bench
  const activeSlot = activeDiv.querySelector('.card-slot');
  const benchDiv = benchFor(currentPlayer);
  const emptyBenchSlot = benchDiv.querySelector('.card-slot[data-empty="1"]');
  
  if (emptyBenchSlot && activeSlot) {
    // Detach all attachments (energy, HP, tools)
    const attachments = detachAttachments(activeSlot);
    
    // Move the card image
    const activeImg = activeSlot.querySelector('img');
    if (activeImg) {
      emptyBenchSlot.innerHTML = '';
      emptyBenchSlot.appendChild(activeImg.cloneNode(true));
      emptyBenchSlot.dataset.empty = '0';
      
      // Reattach everything to new bench position
      attachAttachments(emptyBenchSlot, attachments);
    }
    
    // Clear active slot
    activeSlot.innerHTML = '';
    markSlot(activeSlot, false);
    markSlot(emptyBenchSlot, true);
  }

  // 5. Log the retreat
  logEvent({
    player: currentPlayer,
    text: 'Retreated their Active Pok√©mon.'
  });

  // 6. Close attack menu
  closeAttackMenu();

  // 7. Begin promotion flow to choose new active
  beginPromotionFlow(currentPlayer);
};
  row.appendChild(btn);
  menu.appendChild(row);
}


function onPokemonClick(player, slot) {
    const card = (slot === "active")
        ? activePokemon[player]
        : benchPokemon[player][slot];

    // Ability check FIRST
    if (card && ABILITY_EFFECTS[card.id]) {
        openAbilityUI(player, card);
        return; // stop, do NOT open attack menu
    }

    // fallback to attacks
    showAttackMenuFor(player, slot);
}


/* ========= zoom ========= */
async function buildZoomPanel(meta,img){
  currentZoom={img,meta};

  zoomTitle.textContent=meta.name||'Pok√©mon';

  const mainType=(meta.types&&meta.types[0])?String(meta.types[0]).toLowerCase():null;
  zoomType.style.display=mainType?"block":"none";
  if(mainType)zoomType.style.backgroundImage=`url('${energyIconUrl(mainType)}')`;

  // Check for Giant Cape or other max HP modifiers
  const slot = img.closest('.card-slot');
  const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  
  const base = modifiedMaxHp || parseInt(img.dataset.hp||meta.hp||'0',10)||0;
  const chp=parseInt(img.dataset.chp||base||'0',10)||base;

  zoomHp.textContent=`HP: ${chp} / ${base}`;
  
  // Make HP green if Giant Cape is attached
  if (modifiedMaxHp) {
    zoomHp.style.color = '#22c55e';
    zoomHp.style.fontWeight = '700';
  } else {
    zoomHp.style.color = '';
    zoomHp.style.fontWeight = '';
  }
  
  const pct=base>0?Math.round((chp/base)*100):0;

  zoomHpBar.style.width=pct+'%';
  zoomHpBar.style.background=
    (chp===base)
      ?'linear-gradient(90deg,#22c55e,#16a34a)'
      :'linear-gradient(90deg,#f43f5e,#ef4444)';

        /* Status icon in zoom header */
  if (zoomStatusIcon) {
    const sKey = (img.dataset.status || '').toLowerCase();
    const url = STATUS_ICON_URLS[sKey];
    if (url) {
      zoomStatusIcon.style.display = 'inline-block';
      zoomStatusIcon.style.backgroundImage = `url('${url}')`;
    } else {
      zoomStatusIcon.style.display = 'none';
      zoomStatusIcon.style.backgroundImage = '';
    }
  }

  /* Energy section */
  const pips=countPipsOn(slot);

  zoomEnergyCount.textContent=`x${pips.total||0}`;
  zoomEnergyIcons.innerHTML='';

  Object.keys(pips).filter(k=>k!=='total').forEach(k=>{
    for(let i=0;i<pips[k];i++){
      const ico=document.createElement('span');
      ico.className='mini-icon';
      ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;
      zoomEnergyIcons.appendChild(ico);
    }
  });

  /* Tool display */
  zoomTools.innerHTML='';
  const tool=getToolDataFromSlot(slot);

  if(tool){
    // Show tool overlaid on card image
    if (zoomToolImg) {
      zoomToolImg.src = tool.src;
      zoomToolImg.style.display = 'block';
    }
    
    // Also show in tools section
    const tImg=document.createElement('img');
    tImg.src=tool.src;
    tImg.alt='Tool';
    tImg.style.borderRadius='4px';
    tImg.style.boxShadow='0 2px 6px rgba(0,0,0,.6)';
    tImg.style.cursor='pointer';
    tImg.onclick=async ev=>{
      ev.stopPropagation();
      await openToolModal(tool.set,tool.num,tool.src);
    };
    zoomTools.appendChild(tImg);
  }else{
    // Hide tool overlay
    if (zoomToolImg) {
      zoomToolImg.style.display = 'none';
    }
    
    const none=document.createElement('div');
    none.className='chip';
    none.textContent='none';
    zoomTools.appendChild(none);
  }

  /* Abilities */
  /* Abilities */
  zoomAbilities.style.display = 'none';
  zoomAbilities.innerHTML = '';

  // Ensure ability CSV is loaded
  if (typeof ensureAbilityEffectsLoaded === 'function') {
    await ensureAbilityEffectsLoaded();
  }

  // Get abilities from BOTH meta AND CSV
  const metaAbilities = extractAbilities(meta);
  const abilityRows = (window.ABILITY_EFFECT_ROWS || []);
  
  console.log('[ZOOM] Meta abilities:', metaAbilities);
  console.log('[ZOOM] CSV rows loaded:', abilityRows.length);
  
  // Find CSV abilities for this card
  const setId = img.dataset.set;
  const numId = img.dataset.num;
  const csvAbilities = abilityRows.filter(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === String(numId).padStart(3, '0')
  );
  
  console.log('[ZOOM] CSV abilities for', setId, numId, ':', csvAbilities);
  
  // Combine abilities: prefer meta abilities, but add CSV ones if not in meta
  const allAbilities = [...metaAbilities];
  csvAbilities.forEach(csvAb => {
    const alreadyHas = metaAbilities.some(metaAb => 
      (metaAb.name || '').toLowerCase() === (csvAb.abilityName || '').toLowerCase()
    );
    if (!alreadyHas) {
      // Add CSV ability that wasn't in meta
      allAbilities.push({
        name: csvAb.abilityName,
        effect: csvAb.text || '',
        type: csvAb.abilityType
      });
    }
  });
  
  console.log('[ZOOM] All abilities:', allAbilities);
  if (allAbilities.length) {
    const bandClr = (TYPE_HEX[mainType || 'colorless'] || '#94a3b8');

  let ownerKey = null;
  if (img.closest("#player1") && !img.closest(".hand")) ownerKey = "player1";
  else if (img.closest("#player2") && !img.closest(".hand")) ownerKey = "player2";


    allAbilities.forEach(ab => {
      const box = document.createElement('div');
      box.className = 'ability-box';

      const head = document.createElement('div');
      head.className = 'ability-head';
      head.style.background = bandClr;
      head.style.color = '#0b0f14';

      const badge = document.createElement('img');
      badge.src = ABILITY_BADGE;
      badge.alt = '';

      const nm = document.createElement('div');
      nm.className = 'ability-name';
      nm.textContent = ab.name || 'Ability';

      head.appendChild(badge);
      head.appendChild(nm);

      const tx = document.createElement('div');
      tx.className = 'ability-text';
      tx.textContent = ab.effect || '';

      box.appendChild(head);
      box.appendChild(tx);
      zoomAbilities.appendChild(box);

      // --------- Wiring to CSV / ability engine ----------
      // --------- Wiring to CSV / ability engine ----------
      if (!ownerKey || !currentPlayer) {
        box.classList.add('ability-disabled');
        return;
      }
      const isCurrentPlayersCard = (ownerKey === currentPlayer);
      const setId  = img.dataset.set;
      const numId  = img.dataset.num;
      
      // Use the img parameter directly - it's the actual clicked Pokemon!
      // Don't use querySelector - it finds the FIRST matching Pokemon, not the clicked one
      const actualPokemonImg = img;
      const cardKey = getAbilityCardKey(setId, numId, actualPokemonImg);
      console.log('[ZOOM-ABILITY] Using clicked img directly');
      console.log('[ZOOM-ABILITY] cardKey:', cardKey, 'instanceId:', actualPokemonImg?.dataset.instanceId);

      // Match row from ability_effects.csv
      const row = abilityRows.find(r =>
        r.set === setId &&
        String(r.number).padStart(3, '0') === String(numId).padStart(3, '0') &&
        (r.abilityName || '').toLowerCase() === (ab.name || '').toLowerCase()
      );
      
      // Convert ownerKey to p1/p2 format if needed
      const ownerPk = (ownerKey === 'p1' || ownerKey === 'p2') ? ownerKey : (ownerKey === 'player1' ? 'p1' : 'p2');
      
      // Check if this is an "unlimited" ability
      const isUnlimited = row && (
        (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
        (row.text && /as often as you like/i.test(row.text))
      );
      
      const alreadyUsed = !isUnlimited && !!window.usedAbilitiesThisTurn[ownerPk]?.[cardKey];
      console.log('[ZOOM-ABILITY] Checking:', ownerPk, cardKey, 'alreadyUsed:', alreadyUsed, 'isUnlimited:', isUnlimited);

      // Check if in active slot (for abilities that require being active)
      const isActiveSlot = img.closest('.active') !== null;
      const requiresActive = row ? abilityRequiresActive(row) : false;
      
      // üÜï Check if this is a passive ability
      const isPassive = row && row.abilityType === 'passive';

      // If it's passive, show it with PASSIVE label but keep colored background
      if (isPassive) {
        // Keep the type-colored background (bandClr already set above)
        // Just add PASSIVE label - don't change opacity or saturation
        
        const passiveLabel = document.createElement('span');
        passiveLabel.textContent = 'PASSIVE';
        passiveLabel.style.cssText = `
          display: inline-block;
          padding: 2px 6px;
          background: rgba(0, 0, 0, 0.4);
          border-radius: 3px;
          font-size: 9px;
          font-weight: bold;
          color: rgba(255, 255, 255, 0.9);
          margin-left: 6px;
          letter-spacing: 0.5px;
          vertical-align: middle;
        `;
        nm.appendChild(passiveLabel);
        
        // Mark as disabled (not clickable) but don't change visual appearance
        box.classList.add('ability-disabled');
        
        // Don't add click handler for passive abilities
        return;
      }

      // Only make it clickable if:
      // - we have a CSV row
      // - it is an "active" ability (not passive)
      // - it belongs to the current player
      // - it has not been used this turn
      // - if it requires active, the pokemon is in active slot
      if (!row || row.abilityType !== 'active' ||
          !isCurrentPlayersCard || alreadyUsed || gameOver ||
          (requiresActive && !isActiveSlot)) {
        box.classList.add('ability-disabled');
        return;
      }

      box.classList.add('ability-glow');

      box.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        
        // Check if already used (but allow unlimited abilities)
        const isUnlimitedAbility = 
          (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
          (row.text && /as often as you like/i.test(row.text));
        
        if (!isUnlimitedAbility && window.usedAbilitiesThisTurn[ownerPk]?.[cardKey]) return;

        // Close zoom modal IMMEDIATELY so user can interact with board
        if (zoomBackdrop && zoomBackdrop.classList.contains('show')) {
          console.log('[ZOOM] Closing zoom backdrop for ability interaction');
          zoomBackdrop.classList.remove('show');
          currentZoom = { img: null, meta: null };
        }

        if (typeof applyAbilityEffectFromCsv !== 'function') {
          console.warn('applyAbilityEffectFromCsv missing');
          showPopup('Ability engine not available.');
          return;
        }

        // ownerPk already in p1/p2 format
        const pk = ownerPk;

        // Shared state object for effects.js (similar to move effects)
        const effectState = {
          p1: playerState.player1,
          p2: playerState.player2,
          activeFor,
          benchFor,
          opponentOf,
          fetchCardMeta,
          damageActiveOf,
          beginPromotionFlow,
          showPopup,
          logEvent,
          attachEnergyToSlot,
          energyZoneDiv,
          renderEnergyZone,
          getActiveImage
        };

try {
          const result = await applyAbilityEffectFromCsv(effectState, pk, row, { abilityPokemon: actualPokemonImg });

          // Check if this is an "unlimited" ability (can be used multiple times per turn)
          const isUnlimited = 
            (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
            (row.text && /as often as you like/i.test(row.text));

          // Only mark as used if NOT unlimited
          if (!isUnlimited) {
            if (!window.usedAbilitiesThisTurn[ownerPk]) {
              window.usedAbilitiesThisTurn[ownerPk] = {};
            }
            window.usedAbilitiesThisTurn[ownerPk][cardKey] = true;
            
            console.log('[ZOOM] Ability used (once per turn):', ownerPk, cardKey, 'instanceId:', actualPokemonImg?.dataset.instanceId);
            console.log('[ZOOM] usedAbilitiesThisTurn:', JSON.stringify(window.usedAbilitiesThisTurn));

            box.classList.remove('ability-glow');
            box.classList.add('ability-disabled');
          } else {
            console.log('[ZOOM] Ability used (unlimited):', ownerPk, cardKey, 'instanceId:', actualPokemonImg?.dataset.instanceId);
            // Keep ability glowing - can be used again!
          }

          // Update attack menu if open
          if (openAttackMenu) {
            const abilityRow = openAttackMenu.querySelector('.attack-ability-row');
            if (abilityRow) {
              abilityRow.classList.add('used');
            }
          }
          
          // Check if ability caused a KO (e.g., Greninja's Water Shuriken)
          console.log('[ZOOM] Ability result:', result);
          if (result && result.knocked) {
            console.log('[ZOOM] Ability caused KO, handling...');
            const foePk = ownerPk === 'p1' ? 'p2' : 'p1';
            const foe = foePk === 'p1' ? 'player1' : 'player2';
            
            // Use the knockedImg from result if available (for abilities that target any Pokemon)
            const foeImg = result.knockedImg || getActiveImage(foe);
            
            if (foeImg && typeof handleKnockOut === 'function') {
              console.log('[ZOOM] Handling KO for:', foeImg.alt);
              
              // Check if knocked Pokemon was active
              const foeActive = getActiveImage(foe);
              const wasActive = (foeImg === foeActive);
              
              const ended = await handleKnockOut(foe, foeImg, wasActive);
              if (!ended && typeof beginPromotionFlow === 'function') {
                // Only promote if active was KO'd
                if (wasActive) {
                  beginPromotionFlow(foe);
                }
              }
            }
          }

        } catch (err) {
          console.error('Ability effect error:', err);
          showPopup('Ability failed.');
        }
      });
    });

    zoomAbilities.style.display = 'block';
  }

  /* Attacks */
  zoomAttacks.innerHTML='';
  
  // üÜï Check if this is a fossil - show Discard instead of attacks
  const isFossil = img.dataset.isFossil === 'true';
  
  if (isFossil) {
    const discardCard = document.createElement('div');
    discardCard.className = 'zoom-attack';
    discardCard.style.cursor = 'pointer'; // Make it look clickable
    
    const top = document.createElement('div');
    top.className = 'top';
    top.style.background = '#94a3b8'; // Colorless
    top.style.color = '#fff';
    
    const nm = document.createElement('div');
    nm.className = 'name';
    nm.textContent = 'Discard';
    
    top.appendChild(nm);
    discardCard.appendChild(top);
    
    const divider = document.createElement('div');
    divider.className = 'thin';
    const eff = document.createElement('div');
    eff.className = 'effect';
    eff.textContent = 'Discard this Fossil from play. Does not give opponent a point.';
    
    discardCard.appendChild(divider);
    discardCard.appendChild(eff);
    
    // üÜï Add click handler for discard
    discardCard.addEventListener('click', async (e) => {
      e.stopPropagation();
      
      // Determine which player owns this fossil
      const ownerDiv = img.closest('#player1, #player2');
      const pk = ownerDiv?.id === 'player1' ? 'p1' : 'p2';
      
      // Close zoom panel
      if (zoomBackdrop) {
        zoomBackdrop.classList.remove('show');
      }
      currentZoom = { img: null, meta: null };
      
      // Check if fossil is active
      const isActive = !!img.closest('.active');
      
      // Discard the fossil (no point given)
      if (globalThis.discardPokemon) {
        await globalThis.discardPokemon(img, pk, false);
      }
      
      showPopup(`${meta.name || 'Fossil'} was discarded.`);
      
      // If it was active, promote from bench
      if (isActive) {
        const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
        const benchImgs = Array.from(benchDiv?.querySelectorAll('img') ?? []);
        
        if (benchImgs.length === 0) {
          // Bench out!
          const winner = pk === 'p1' ? 'player2' : 'player1';
          showVictory(winner, 'Opponent has no Pok√©mon left!');
          return;
        }
        
        // Promote from bench - pk is the fossil owner
        if (globalThis.promoteFromBench) {
          await globalThis.promoteFromBench(null, pk); // pk = fossil owner (p1 or p2)
        }
      }
    });
    
    zoomAttacks.appendChild(discardCard);
    
    console.log('[zoom] Showing Discard option for fossil');
  } else {
    // Normal Pokemon - show attacks

  // Determine owner and pk for lock checking
  let ownerKey = null;
  let pk = null;
  if (img.closest("#player1") && !img.closest(".hand")) {
    ownerKey = "player1";
    pk = "p1";
  } else if (img.closest("#player2") && !img.closest(".hand")) {
    ownerKey = "player2";
    pk = "p2";
  }

  // üÜï A4a - use_previous_evolution_attacks (Memory Light tool)
  // Check if this Pokemon has Memory Light attached and can use previous evolution attacks
  let attacks = meta.attacks || [];
  console.log(`[Memory Light Zoom] Starting check for ${meta.name}, initial attacks: ${attacks.length}`);
  
  const slot = img.closest('.card-slot');
  console.log(`[Memory Light Zoom] Slot found: ${!!slot}`);
  
  const toolData = getToolDataFromSlot(slot);
  console.log(`[Memory Light Zoom] Tool data:`, toolData);
  
  if (toolData && toolData.set && toolData.num) {
    try {
      const toolCardId = csvIdFor(toolData.set, toolData.num);
      console.log(`[Memory Light Zoom] Tool card ID: ${toolCardId}`);
      
      const toolEffect = TRAINER_EFFECT_DATA.find(x => x.id === toolCardId);
      console.log(`[Memory Light Zoom] Tool effect found:`, toolEffect);
      
      if (toolEffect?.effect_type === 'use_previous_evolution_attacks') {
        console.log(`[Memory Light Zoom] Memory Light detected! Checking evolutions...`);
        
        // Helper function to recursively build the full evolution chain (same as in showAttackMenuFor)
        // skipFirstLevel: if true, skip adding the immediate previous evolution (for Rare Candy - skip Stage 1)
        async function buildEvolutionChain(currentMeta, owner, visited = new Set(), skipFirstLevel = false) {
          const chain = [];
          const currentKey = `${currentMeta.id || currentMeta.name}`;
          if (visited.has(currentKey)) return chain; // Prevent infinite loops
          visited.add(currentKey);
          
          // Get immediate previous evolution(s)
          let evolveFrom = currentMeta.evolvesFrom || currentMeta.evolveFrom || [];
          console.log(`[Memory Light Zoom] Building chain for ${currentMeta.name}, evolveFrom:`, evolveFrom, `skipFirstLevel: ${skipFirstLevel}`);
          
          // If evolveFrom is a string, convert to array format
          if (typeof evolveFrom === 'string' && evolveFrom.trim()) {
            const evolveFromLower = evolveFrom.toLowerCase();
            const matchingCards = [];
            
            // Search in play, hand, deck, discard, API (same logic as above)
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
            const pokemonInPlay = [
              ...(activeDiv?.querySelectorAll('img') || []),
              ...(benchDiv?.querySelectorAll('img') || [])
            ];
            
            for (const pokemonImg of pokemonInPlay) {
              const pokemonName = (pokemonImg.alt || '').toLowerCase();
              // Use exact match for Pokemon in play
              if (pokemonName === evolveFromLower) {
                const set = pokemonImg.dataset.set;
                const num = pokemonImg.dataset.num;
                if (set && num) matchingCards.push({ set, number: num });
              }
            }
            
            if (matchingCards.length === 0) {
              const hand = playerState[owner]?.hand || [];
              for (const card of hand) {
                const cardName = (card.name || '').toLowerCase();
                // Use exact match only
                if (cardName === evolveFromLower) {
                  matchingCards.push({ set: card.set, number: card.number || card.num });
                }
              }
            }
            
            if (matchingCards.length === 0) {
              const deck = playerState[owner]?.deck || [];
              for (const card of deck) {
                try {
                  const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                  const cardName = (cardMeta.name || '').toLowerCase();
                  // Use exact match and verify it's a Pokemon
                  if (cardMeta.category === 'Pokemon' && cardName === evolveFromLower) {
                    matchingCards.push({ set: card.set, number: card.number || card.num });
                  }
                } catch {}
              }
            }
            
            if (matchingCards.length === 0) {
              const discard = playerState[owner]?.discard?.cards || [];
              for (const card of discard) {
                const cardName = (card.name || '').toLowerCase();
                // Use exact match only for discard to avoid false positives
                if (cardName === evolveFromLower) {
                  // Verify it's actually a Pokemon by fetching metadata
                  try {
                    const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                    if (cardMeta && cardMeta.category === 'Pokemon' && cardMeta.name && cardMeta.name.toLowerCase() === evolveFromLower) {
                      matchingCards.push({ set: card.set, number: card.number || card.num });
                    }
                  } catch (err) {
                    console.warn(`[Memory Light Zoom] Failed to verify discard card ${card.set}-${card.number || card.num}:`, err);
                  }
                }
              }
            }
            
            if (matchingCards.length === 0) {
              // API search fallback
              const commonSets = ['A1', 'A1a', 'A2', 'A2a', 'A2b', 'A3', 'A3a', 'A3b', 'A4', 'A4a'];
              for (const set of commonSets) {
                try {
                  const setResponse = await fetch(`https://api.tcgdex.net/v2/en/sets/${set}`);
                  if (!setResponse.ok) continue;
                  const setData = await setResponse.json();
                  if (setData?.cards) {
                    for (const card of setData.cards) {
                      const cardName = (card.name || '').toLowerCase();
                      if (cardName === evolveFromLower || cardName.includes(evolveFromLower) || evolveFromLower.includes(cardName)) {
                        const localId = card.localId || card.number;
                        if (localId) {
                          matchingCards.push({ set, number: localId });
                          break;
                        }
                      }
                    }
                  }
                  if (matchingCards.length > 0) break;
                } catch (err) {
                  console.warn(`[Memory Light Zoom] Failed to search set ${set}:`, err);
                }
              }
            }
            
            evolveFrom = matchingCards;
          }
          
          // Process each previous evolution
          if (Array.isArray(evolveFrom) && evolveFrom.length > 0) {
            for (const prevEvo of evolveFrom) {
              try {
                const prevEvoMeta = await fetchCardMeta(prevEvo.set, prevEvo.number);
                if (prevEvoMeta) {
                  // If skipFirstLevel is true (Rare Candy), skip adding the immediate previous evolution (Stage 1)
                  // but still recurse to get the Basic Pokemon
                  if (!skipFirstLevel) {
                    chain.push(prevEvoMeta);
                    console.log(`[Memory Light Zoom] Added ${prevEvoMeta.name} to chain`);
                  } else {
                    console.log(`[Memory Light Zoom] Skipping ${prevEvoMeta.name} (Rare Candy - skipping Stage 1)`);
                  }
                  // Recursively get attacks from this evolution's previous evolutions
                  // Pass false for skipFirstLevel on recursive calls (only skip the first level)
                  const deeperChain = await buildEvolutionChain(prevEvoMeta, owner, visited, false);
                  chain.push(...deeperChain);
                }
              } catch (err) {
                console.error(`[Memory Light Zoom] Error fetching evolution ${prevEvo.set}-${prevEvo.number}:`, err);
              }
            }
          }
          
          return chain;
        }
        
        // Check if this Pokemon evolved via Rare Candy (skipped Stage 1) BEFORE building chain
        const evolvedViaRareCandy = img.dataset.evolvedViaRareCandy === 'true';
        console.log(`[Memory Light Zoom] Evolved via Rare Candy: ${evolvedViaRareCandy}`);
        
        // Build the full evolution chain recursively
        // Pass evolvedViaRareCandy as skipFirstLevel to skip Stage 1 for Rare Candy evolutions
        const ownerDiv = img.closest('#player1, #player2');
        const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
        const fullChain = await buildEvolutionChain(meta, owner, new Set(), evolvedViaRareCandy);
        console.log(`[Memory Light Zoom] Full evolution chain:`, fullChain.map(m => m.name));
        
        if (fullChain.length > 0) {
          if (evolvedViaRareCandy) {
            // If evolved via Rare Candy, only get attacks from the Basic Pokemon (last in chain)
            // The Stage 1 was already skipped in buildEvolutionChain, so chain only contains Basic
            const basicMeta = fullChain[fullChain.length - 1]; // Last one is the deepest (Basic)
            console.log(`[Memory Light Zoom] Rare Candy - fetching Basic only:`, basicMeta.name);
            if (basicMeta?.attacks) {
              attacks = [...attacks, ...basicMeta.attacks];
              console.log(`[Memory Light Zoom] ‚úÖ Added ${basicMeta.attacks.length} attacks from Basic ${basicMeta.name} (Rare Candy evolution). Total attacks now: ${attacks.length}`);
            } else {
              console.log(`[Memory Light Zoom] ‚ö†Ô∏è Basic ${basicMeta?.name} has no attacks`);
            }
          } else {
            // Normal evolution: get attacks from ALL previous evolutions in the chain
            console.log(`[Memory Light Zoom] Normal evolution - fetching all ${fullChain.length} previous evolutions`);
            for (const prevEvoMeta of fullChain) {
              console.log(`[Memory Light Zoom] Processing evolution:`, prevEvoMeta.name, `attacks: ${prevEvoMeta?.attacks?.length || 0}`);
              if (prevEvoMeta?.attacks) {
                attacks = [...attacks, ...prevEvoMeta.attacks];
                console.log(`[Memory Light Zoom] ‚úÖ Added ${prevEvoMeta.attacks.length} attacks from ${prevEvoMeta.name}. Total attacks now: ${attacks.length}`);
              } else {
                console.log(`[Memory Light Zoom] ‚ö†Ô∏è ${prevEvoMeta?.name} has no attacks`);
              }
            }
          }
        } else {
          console.log(`[Memory Light Zoom] ‚ö†Ô∏è No previous evolutions found in chain`);
        }
      } else {
        console.log(`[Memory Light Zoom] Tool effect type is not use_previous_evolution_attacks: ${toolEffect?.effect_type}`);
      }
    } catch (err) {
      console.error('[Memory Light Zoom] ‚ùå Error checking tool:', err);
    }
  } else {
    console.log(`[Memory Light Zoom] No tool data or missing set/num`);
  }
  
  console.log(`[Memory Light Zoom] Final attacks count: ${attacks.length}`);

  attacks.forEach(atk=>{
    const card=document.createElement('div');
    card.className='zoom-attack';

    const top=document.createElement('div');
    top.className='top';

    const left=document.createElement('div');
    left.style.display='flex';
    left.style.alignItems='center';
    left.style.gap='6px';

    const nm=document.createElement('div');
    nm.className='name';
    nm.textContent=atk.name||'Attack';

    const cost=makeCostIcons(atk.cost||[], slot, img);
    left.appendChild(nm);
    left.appendChild(cost);

    const dmg=document.createElement('div');
    dmg.className='dmg';
    dmg.textContent = (atk.damage || '').toString(); // Initial value
    // Calculate preview damage asynchronously and update
    (async () => {
      try {
        const previewResult = await calculatePreviewDamage(atk, img, meta, pk);
        let previewDamage = typeof previewResult === 'object' ? previewResult.damage : previewResult;
        // Ensure we have a valid number or string
        if (typeof previewDamage === 'object') previewDamage = '';
        dmg.textContent = String(previewDamage || '');
        
        // Apply color styling based on boost type
        if (typeof previewResult === 'object') {
          // Reset styles
          dmg.style.setProperty('color', '', 'important');
          dmg.style.setProperty('text-shadow', '', 'important');
          
          if (previewResult.hasWeakness) {
            // Green for weakness (takes priority, even if other boosts exist)
            dmg.style.setProperty('color', '#22c55e', 'important');
            dmg.style.setProperty('text-shadow', '0 0 8px rgba(34, 197, 94, 0.6), 0 0 4px rgba(34, 197, 94, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else if (previewResult.hasOtherBoosts) {
            // Golden for other effects
            dmg.style.setProperty('color', '#fbbf24', 'important');
            dmg.style.setProperty('text-shadow', '0 0 8px rgba(251, 191, 36, 0.6), 0 0 4px rgba(251, 191, 36, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else {
            // Black (default) for no boosts
            dmg.style.setProperty('color', '#000000', 'important');
            dmg.style.setProperty('text-shadow', '0 1px 3px rgba(0,0,0,0.5)', 'important');
          }
        }
      } catch (err) {
        console.error('[preview] Error calculating damage:', err);
        // Keep original value on error
      }
    })();

    top.appendChild(left);
    top.appendChild(dmg);
    card.appendChild(top);

    /* Effect text row */
    const divider=document.createElement('div');
    divider.className='thin';
    const eff=document.createElement('div');
    eff.className='effect';
    eff.textContent=atk.effect?String(atk.effect):'';

    card.appendChild(divider);
    card.appendChild(eff);

    // üÜï A3a MOVE EFFECT - Check for move-specific locks (Buzzwole ex - Big Beat)
    let isMoveLocked = false;
    const instanceId = img.dataset.instanceId;
    const moveName = atk.name?.toLowerCase();
    const currentTurn = globalThis.turnNumber || 0;
    
    if (instanceId && moveName && pk && globalThis.__moveLocks?.[pk]?.[instanceId]?.[moveName]) {
      const moveLock = globalThis.__moveLocks[pk][instanceId][moveName];
      
      if (typeof moveLock === 'object' && moveLock.lockedOnTurn !== undefined) {
        // Lock was applied on turn N (player's turn), it's locked during the player's NEXT turn
        // The player's next turn is 2 turns later (to skip the opponent's turn)
        isMoveLocked = currentTurn === moveLock.lockedOnTurn + 2;
        console.log(`[Zoom Move Lock] Checking lock for ${atk.name}: currentTurn=${currentTurn}, lockedOnTurn=${moveLock.lockedOnTurn}, isMoveLocked=${isMoveLocked}`);
      } else {
        // Backwards compat: if it's just true, treat as locked
        isMoveLocked = moveLock === true;
      }
    }
    
    // üÜï A3a MOVE EFFECT - Check for all-attacks lock (Aggron - Giga Impact, Necrozma - Prismatic Laser)
    // Check if all attacks are locked (Dragonite ex - Giga Impact, etc.)
    const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
    let isAllAttacksLocked = false;
    if (attackLock) {
      const currentTurn = globalThis.turnNumber || 0;
      if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
        isAllAttacksLocked = currentTurn === attackLock.lockedOnTurn + 2;
      } else if (attackLock === true) {
        isAllAttacksLocked = true; // Backwards compat
      }
    }

    const payable=canPayCostFromAPI(slot,atk.cost||[], img) && !isMoveLocked && !isAllAttacksLocked;

    // Add locked styling if move is locked
    if (isMoveLocked || isAllAttacksLocked) {
      card.classList.add('muted');
      card.style.opacity = '0.5';
      card.style.cursor = 'not-allowed';
      if (isMoveLocked) {
        card.title = `This Pok√©mon can't use ${atk.name} this turn!`;
      } else if (isAllAttacksLocked) {
        card.title = `This Pok√©mon can't attack this turn!`;
      }
    }

    if(payable&&mainType){
      top.style.background=TYPE_HEX[mainType]||'#94a3b8';
      top.style.color='#fff';
      nm.style.color='#fff';
      dmg.style.color='#fff';
    }else{
      top.style.background='#2a2f36';
      top.style.color='#e5e7eb';
      if (!isMoveLocked && !isAllAttacksLocked) {
      card.classList.add('muted');
      }
    }

    const isActiveCurrent = (currentPlayer && activeFor(currentPlayer).querySelector('img') === img);

    if (isActiveCurrent) {
      card.onclick = async () => {
        const pk  = currentPlayer === 'player1' ? 'p1' : 'p2';

        // Block attacks if Asleep or Paralyzed
        if (isActiveBlockedFromAttacking(pk)) {
          const imgBlocked = getActiveImg(pk);
          const st = (imgBlocked?.dataset.status || '').toLowerCase();
          if (st === 'asleep') {
            showPopup('This Pok√©mon is asleep and can‚Äôt attack.');
          } else if (st === 'paralyzed') {
            showPopup('This Pok√©mon is paralyzed and can‚Äôt attack.');
          }
          return;
        }

        // üÜï A3a MOVE EFFECT - Check for all-attacks lock (Aggron - Giga Impact, Necrozma - Prismatic Laser)
        // Check if all attacks are locked (Dragonite ex - Giga Impact, etc.)
        const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
        if (attackLock) {
          const currentTurn = globalThis.turnNumber || 0;
          let isLocked = false;
          if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
            isLocked = currentTurn === attackLock.lockedOnTurn + 2;
          } else if (attackLock === true) {
            isLocked = true; // Backwards compat
          }
          
          if (isLocked) {
            showPopup('This Pok√©mon can\'t attack this turn!');
            return;
          }
        }
        
        // üÜï A3a MOVE EFFECT - Check for move-specific locks (Buzzwole ex - Big Beat)
        // Re-check lock here in case it changed
        let isLockedNow = false;
        const instanceIdCheck = img.dataset.instanceId;
        const moveNameCheck = atk.name?.toLowerCase();
        const currentTurnCheck = globalThis.turnNumber || 0;
        if (instanceIdCheck && moveNameCheck && globalThis.__moveLocks?.[pk]?.[instanceIdCheck]?.[moveNameCheck]) {
          const moveLockCheck = globalThis.__moveLocks[pk][instanceIdCheck][moveNameCheck];
          if (typeof moveLockCheck === 'object' && moveLockCheck.lockedOnTurn !== undefined) {
            isLockedNow = currentTurnCheck === moveLockCheck.lockedOnTurn + 2;
          } else {
            isLockedNow = moveLockCheck === true;
          }
        }
        
        if (isLockedNow) {
          showPopup(`This Pok√©mon can't use ${atk.name} this turn!`);
          return;
        }

        if (!payable) {
          showPopup('Not enough energy to use this attack.');
          return;
        }

        const foe = opponentOf(currentPlayer);

        let damage = parseDamage(atk.damage);

        const effectState = {
          p1: playerState.player1,
          p2: playerState.player2,
          activeFor,
          benchFor,
          opponentOf,
          fetchCardMeta,
          damageActiveOf,
          beginPromotionFlow,
          showPopup,
          logEvent
        };

        // Single call to effects.js
        try {
          damage = await applyMoveEffectFromCsv(
            effectState,
            pk,
            atk.name,
            damage
          );
          // Giovanni global damage boost
          const boost = (globalThis.state?.temp?.[pk]?.globalDamageBoost ?? 0);
          if (boost) {
            console.log("[Giovanni boost applied] +", boost, "‚Üí", damage + boost);
            damage += boost;
          }
          
          // üÜï A3 - Next turn damage bonus (Crabominable ex)
          const nextTurnBonus = (globalThis.state?.temp?.[pkToPlayer(pk)]?.nextTurnDamageBonus ?? 0);
          if (nextTurnBonus > 0) {
            console.log('[zoom attack] Next turn bonus applied +', nextTurnBonus);
            damage += nextTurnBonus;
            // Clear after use
            if (globalThis.state?.temp?.[pkToPlayer(pk)]) {
              globalThis.state.temp[pkToPlayer(pk)].nextTurnDamageBonus = 0;
            }
          }

        } catch (err) {
          console.error('Move effect error (zoom):', err);
        }

        // Weakness
        try {
          const foeImg = getActiveImage(foe);
          if (foeImg) {
            const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
            const wk = metaFoe?.weaknesses?.[0];

            if (wk) {
              const wkType = (wk.type || '').toLowerCase();
              if (wkType !== 'colorless') {
                const atkType = (meta.types?.[0] || '').toLowerCase();
                if (atkType === wkType) {
                  damage += 20;
                }
              }
            }
          }
        } catch (err) {
          console.error('Weakness check failed (zoom):', err);
        }

        const result = await damageActiveOf(foe, damage, { attackerImg: img });
        // Status icon inside fullscreen modal
        const st = (img.dataset.status || "").toLowerCase();
        if (st && STATUS_ICON_URLS[st]) {
          zoomStatus.style.display = "block";
          zoomStatus.style.backgroundImage = `url('${STATUS_ICON_URLS[st]}')`;
        } else {
          zoomStatus.style.display = "none";
          zoomStatus.style.backgroundImage = "";
        }

        // Close zoom
        zoomBackdrop.classList.remove('show');
        currentZoom = { img: null, meta: null };

        // Handle KO
        if (result.knocked) {
          const foeImg2 = getActiveImage(foe);
          if (foeImg2) {
            const ended = await handleKnockOut(foe, foeImg2);
            if (ended) return;
            await beginPromotionFlow(foe);
          }
        }

        setTimeout(() => startTurn(foe), 300);
      };
    } else {
      // Not current active: just visually muted
      card.classList.add('muted');
    }



    zoomAttacks.appendChild(card);
  });
  
  } // End of else (normal Pokemon attacks)

  /* Weakness display */
  zoomWeakness.innerHTML='';
  {
    const wk=(meta.weaknesses&&meta.weaknesses[0])||null;
    if(wk){
      const k=String(wk.type||'').toLowerCase();
      if(k==='colorless'){
        zoomWeakness.textContent='‚Äî';
      }else{
        const ico=document.createElement('span');
        ico.className='mini-icon';
        ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;

        const val=document.createElement('span');
        val.className='mini-badge';
        val.textContent=wk.value||'';

        zoomWeakness.appendChild(ico);
        zoomWeakness.appendChild(val);
      }
    }else zoomWeakness.textContent='‚Äî';
  }

  /* Retreat cost display */
  zoomRetreat.innerHTML='';
  const rcost=computeRetreatCost(img.closest('.active'),meta);

  for(let i=0;i<rcost;i++){
    const ico=document.createElement('span');
    ico.className='mini-icon';
    ico.style.backgroundImage=`url('${ENERGY_ICONS.colorless}')`;
    zoomRetreat.appendChild(ico);
  }
}
/* ========= tool modal ========= */
async function openToolModal(set,num,src){
  if(!toolBackdrop)return;
  toolImg.src=src||'';
  toolTitle.textContent='Tool';
  toolMeta.textContent='';
  toolText.textContent='';
  toolBackdrop.classList.add('show');
  try{
    const meta=await fetchCardMeta(set,num);
    toolTitle.textContent=meta.name||'Tool';
    toolMeta.textContent=(meta.trainerType?meta.trainerType:'Tool');
    toolText.textContent=(meta.effect||meta.description||'');
  }catch{
    toolText.textContent='No details available.';
  }
}
if(toolBackdrop){
  toolBackdrop.addEventListener('click',e=>{
    if(e.target===toolBackdrop)toolBackdrop.classList.remove('show');
  });
  document.addEventListener('keydown',e=>{
    if(e.key==='Escape')toolBackdrop.classList.remove('show');
  });
}

/* ========= evolution ========= */
function clearGlow(){
  $$('.glow-evo,.promote-glow').forEach(el=>el.classList.remove('glow-evo','promote-glow'));
  isEvoMode=false;evoMeta=null;evoOwner=null;evoHandCard=null;
}

async function evolveCard(target,meta,handCard,owner,set,num){
  const pk = owner === 'player1' ? 'p1' : 'p2';
  const oppPk = pk === 'p1' ? 'p2' : 'p1';
  const activeDiv = owner === 'player1' ? p1Active : p2Active;
  const activeImg = activeDiv?.querySelector('img');
  const isTargetActive = target === activeImg;
  
  // üÜï B1 Eevee - Boosted Evolution: Check if this Pokemon has the ability and is in active slot
  let hasBoostedEvolution = false;
  if (isTargetActive) {
    const cacheKey = `${target.dataset.set}-${target.dataset.num}`;
    const numPadded = String(target.dataset.num || '').padStart(3, '0');
    const numUnpadded = String(parseInt(target.dataset.num || '0', 10));
    const abilityRow = globalThis.abilityCache?.[cacheKey] || 
                      globalThis.abilityCache?.[`${target.dataset.set}-${numPadded}`] || 
                      globalThis.abilityCache?.[`${target.dataset.set}-${numUnpadded}`];
    
    if (abilityRow?.effect_type === 'allow_evolution_first_turn') {
      hasBoostedEvolution = true;
      console.log('[evolveCard] Boosted Evolution detected - bypassing evolution restrictions');
    }
  }
  
  // Check first two turns restriction (bypass if Boosted Evolution in active)
  if(globalThis.turnNumber<=2){
    if (!hasBoostedEvolution) {
      showPopup('You cannot evolve during the first two turns.');
      clearGlow();
      return;
    }
  }
  
  // Check same turn restriction (bypass if Boosted Evolution in active)
  const playedTurn=parseInt(target.dataset.playedTurn||'0',10);
  if(playedTurn===globalThis.turnNumber){
    if (!hasBoostedEvolution) {
      showPopup('Cannot evolve the turn it was played.');
      clearGlow();
      return;
    }
  }

  // üÜï A3a - Check if Aerodactyl ex is blocking evolution of active Pokemon
  
  if (isTargetActive) {
    // Check if opponent has Aerodactyl ex with Primeval Law
    const oppActive = oppPk === 'p1' ? p1Active : p2Active;
    const oppBench = oppPk === 'p1' ? p1Bench : p2Bench;
    const oppPokemon = [
      ...(oppActive?.querySelectorAll('img') || []),
      ...(oppBench?.querySelectorAll('img') || [])
    ];
    
    for (const oppImg of oppPokemon) {
      const cacheKey = `${oppImg.dataset.set}-${oppImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'block_evolution') {
        const targetParam = abilityRow.param1 || 'opponent';
        if (targetParam === 'opponent' || targetParam === 'all') {
          showPopup('Cannot evolve Active Pok√©mon - blocked by Primeval Law!');
          clearGlow();
          return;
        }
      }
    }
  }

  const slot=target.closest('.card-slot');
  
  // Get previous HP, accounting for any HP-boosting tool on the previous Pokemon
  const prevBaseHp = parseInt(target.dataset.hp||'0',10);
  const prevSlotMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  const prevHp = prevSlotMaxHp || prevBaseHp; // Use modified max HP if tool was attached
  const prevChp=parseInt(target.dataset.chp||prevBaseHp||'0',10);

  const padded=String(num).padStart(3,'0');
  const evolvedImage=`https://assets.tcgdex.net/en/tcgp/${set}/${padded}/high.png`;
  const evo=document.createElement('img');
  evo.className='card-img';
  evo.alt=meta.name;
  evo.src=evolvedImage;
  evo.dataset.playedTurn=globalThis.turnNumber;
  
  // Preserve instance ID from base Pokemon
  if (target.dataset.instanceId) {
    evo.dataset.instanceId = target.dataset.instanceId;
  }
  // Preserve Rare Candy flag if it exists
  if (target.dataset.evolvedViaRareCandy === 'true') {
    evo.dataset.evolvedViaRareCandy = 'true';
  }
  evo.dataset.evolvedFrom=(meta.evolveFrom||'').toLowerCase();
  evo.dataset.set=set;
  evo.dataset.num=num;

  
/* clear any special condition on the old Pok√©mon */
  clearStatusOnImg(target);
/* -----------------------------
   ATTACHMENT TRANSFER ‚Äî correct + minimal
------------------------------ */
const energyBox = slot.querySelector('.energy-pips');
const hpOverlay = slot.querySelector('.hp-overlay');
const toolThumb = slot.querySelector('.tool-thumb');

// All attachments remain in the same slot; only the image changes.
// So we simply keep these elements alive and re-append them after replacing the img.

const oldImg = slot.querySelector('img'); // original card image
const hadEnergy = !!energyBox;
const hadHP     = !!hpOverlay;
const hadTool   = !!toolThumb;

// Get hand card position for animation (if available)
// handCard might be a DOM element or a card object from the hand array
let handCardForAnimation = null;

// Check if handCard is a DOM element
if (handCard && typeof handCard.getBoundingClientRect === 'function') {
  handCardForAnimation = handCard;
} else if (evoHandCard && typeof evoHandCard.getBoundingClientRect === 'function') {
  // evoHandCard is a DOM element from the hand
  handCardForAnimation = evoHandCard;
} else {
  // handCard might be a card object, or we need to find it in the DOM
  // Try to find the card in hand using set and num
  const handCardElement = document.querySelector(`.hand img[data-set="${set}"][data-num="${num}"]`);
  if (handCardElement && typeof handCardElement.getBoundingClientRect === 'function') {
    handCardForAnimation = handCardElement;
  } else if (handCard && handCard.set && handCard.number) {
    // handCard is a card object, try to find it by set and number
    const cardElement = document.querySelector(`.hand img[data-set="${handCard.set}"][data-num="${handCard.number || handCard.num}"]`);
    if (cardElement && typeof cardElement.getBoundingClientRect === 'function') {
      handCardForAnimation = cardElement;
    }
  }
}

// Remove old image
if (oldImg) oldImg.remove();

// Insert new card image
// Insert new evolved card image
slot.insertBefore(evo, slot.firstChild);

// Animate slide from hand if hand card exists and is valid
if (handCardForAnimation) {
  animateSlideFromHand(handCardForAnimation, slot, evo);
} else {
  // If no valid hand card found, just fade in the evolved card
  evo.style.opacity = '0';
  evo.style.transition = 'opacity 0.2s ease';
  requestAnimationFrame(() => {
    evo.style.opacity = '1';
  });
}

// Restore overlays
if (hadEnergy) slot.appendChild(energyBox);
if (hadHP)     slot.appendChild(hpOverlay);
if (hadTool)   slot.appendChild(toolThumb);

// Preserve tool data mapping
const toolObj = getToolDataFromSlot(slot);
if (toolObj) {
  setToolDataOnSlot(slot, toolObj);
}


  // Calculate new HP, accounting for Giant Cape if attached
  const newHp = parseInt(meta.hp||'0',10) || prevHp || 0;
  
  // Check if Giant Cape or Leaf Cape is attached
  const toolData = getToolDataFromSlot(slot);
  const isGiantCape = toolData && (toolData.set === 'A2' && toolData.num === '147');
  const isLeafCape = toolData && (toolData.set === 'A3' && toolData.num === '147');
  const hasHpBoostingTool = isGiantCape || isLeafCape;
  const hpBonus = isGiantCape ? 20 : (isLeafCape ? 30 : 0);
  
  // Calculate HP increase from evolution (use BASE HP difference, not modified max HP)
  // This ensures the HP increase is calculated correctly regardless of cape on previous Pokemon
  const hpIncrease = newHp - prevBaseHp;
  
  // New current HP = old current HP + HP increase
  // If cape is attached, also add the cape bonus to current HP
  let newChp = Math.max(0, prevChp + hpIncrease);
  if (hasHpBoostingTool) {
    newChp += hpBonus; // Add cape bonus to current HP
  }
  
  // Calculate new max HP: evolved HP + cape bonus
  const newMaxHp = newHp + hpBonus;
  
  // If HP-boosting tool is attached, update slot's maxHp
  if (hasHpBoostingTool) {
    slot.dataset.maxHp = String(newMaxHp);
    console.log(`[evolve] HP tool active, max HP: ${prevBaseHp} ‚Üí ${newMaxHp} (base: ${newHp}, bonus: +${hpBonus}, increase: +${hpIncrease})`);
    console.log(`[evolve] Current HP: ${prevChp} ‚Üí ${newChp} (+${hpIncrease} base + ${hpBonus} cape)`);
    console.log(`[evolve] Final display: ${newChp} / ${newMaxHp}`);
  } else {
    // No HP-boosting tool, clear any old maxHp data
    delete slot.dataset.maxHp;
    console.log(`[evolve] No HP tool, max HP: ${prevBaseHp} ‚Üí ${newHp} (+${hpIncrease})`);
    console.log(`[evolve] Current HP: ${prevChp} ‚Üí ${newChp} (+${hpIncrease})`);
  }
  
  setHpOnImage(evo, newHp, newChp);
  markSlot(slot,true);
  removeFromHand(owner,set,num);
  renderAllHands();

  logEvent({
    player: owner,
    text:`Evolved ${meta.evolveFrom || 'a Pok√©mon'} into ${meta.name}.`,
    cardSet:set,cardNum:num
  });

  showPopup(`${meta.evolveFrom} ‚Üí ${meta.name}`);
  
  // Update player background if this is the active Pok√©mon (type may have changed on evolution)
  const isActive = slot.closest('.active');
  if (isActive) {
    const playerNum = owner === 'player1' ? 1 : 2;
    updatePlayerTypeBackground(playerNum);
  }
  
  // üÜï A3b - Sylveon ex Happy Ribbon (draw on evolution)
  try {
    const cacheKey = `${set}-${num}`;
    const abilityRow = globalThis.abilityCache?.[cacheKey];
    
    if (abilityRow?.effect_type === 'draw_on_evolution') {
      const pkForAbility = owner === 'player1' ? 'p1' : 'p2';
      // Use effectState structure like other places
      const effectState = {
        p1: playerState.player1,
        p2: playerState.player2
      };
      
      if (typeof applyAbilityEffectFromCsv === 'function') {
        await applyAbilityEffectFromCsv(effectState, pkForAbility, abilityRow, {});
        console.log('[Happy Ribbon] Drew cards on evolution');
      }
    }
  } catch (err) {
    console.error('[Evolution] Happy Ribbon check failed:', err);
  }
  
  if(currentZoom.img&&currentZoom.img===evo){
    await buildZoomPanel(meta,evo);
  }
}

/* ========= board interactions ========= */
function handFind(owner,set,num){
  return playerState[owner].hand.find(c=>c.set===set&&String(c.number||c.num)===String(num))||null;
}

// Function to trigger Jolteon ex's Electromagnetic Wall ability
// This should be called whenever energy is attached to ANY Pokemon (active or bench)
async function triggerElectromagneticWall(targetImg) {
  if (!targetImg) return;
  
  try {
    // Determine which player owns the Pokemon that received energy
    const owner = targetImg.closest('#player1') ? 'player1' : 'player2';
    const pk = owner === 'player1' ? 'p1' : 'p2';
    const oppPk = pk === 'p1' ? 'p2' : 'p1';
    
    // Check if opponent has Jolteon ex in active spot
    const oppActive = oppPk === 'p1' ? p1Active : p2Active;
    const oppActiveImg = oppActive?.querySelector('img');
    
    if (oppActiveImg) {
      // Try multiple cache key formats (padded and unpadded)
      const set = oppActiveImg.dataset.set;
      const num = oppActiveImg.dataset.num;
      const numPadded = String(num || '').padStart(3, '0');
      const numUnpadded = String(parseInt(num || '0', 10));
      const cacheKey1 = `${set}-${numPadded}`;
      const cacheKey2 = `${set}-${numUnpadded}`;
      const cacheKey3 = `${set}-${num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey1] || 
                        globalThis.abilityCache?.[cacheKey2] || 
                        globalThis.abilityCache?.[cacheKey3];
      
      if (abilityRow?.effect_type === 'damage_on_opponent_energy_attach') {
        const damage = parseInt(abilityRow.param1 || '20', 10);
        console.log(`[Electromagnetic Wall] ${oppActiveImg.alt} deals ${damage} damage to ${targetImg.alt}`);
        
        // Deal damage to the Pokemon that received the energy
        const damageFn = globalThis.damageImg || window.damageImg || (typeof damageImg !== 'undefined' ? damageImg : null);
        if (damageFn && typeof damageFn === 'function') {
          const result = damageFn(targetImg, damage);
          showPopup(`Electromagnetic Wall: ${oppActiveImg.alt} deals ${damage} damage to ${targetImg.alt}!`);
          
          // Check for knockout - ALWAYS handle knockout if HP reaches 0
          if (result && result.knocked) {
            console.log(`[Electromagnetic Wall] ${targetImg.alt} was knocked out!`);
            // Check if the damaged Pokemon is active
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const activeImg = activeDiv?.querySelector('img');
            const wasActive = targetImg === activeImg;
            
            // Handle knockout
            if (typeof handleKnockOut === 'function') {
              const gameEnded = await handleKnockOut(owner, targetImg, wasActive);
              if (!gameEnded && wasActive && typeof beginPromotionFlow === 'function') {
                await beginPromotionFlow(owner);
              }
            }
          }
        } else {
          console.warn('[Electromagnetic Wall] damageImg function not found');
        }
      }
    }
  } catch (err) {
    console.warn('[Electromagnetic Wall] Failed to trigger ability:', err);
  }
}

// Expose globally
globalThis.triggerElectromagneticWall = triggerElectromagneticWall;

function attachEnergyToSlot(owner,slot,energyKey){
  if(!slot||!energyKey)return;
  const img=slot.querySelector('img');
  if(!img){showPopup('Select a Pok√©mon in play.');return}
  const area=currentPlayer==='player1'?$('#player1'):$('#player2');
  if(!area.contains(slot)||slot.closest('.hand')){
    showPopup('Attach only to Pok√©mon in play.');
    return;
  }
  const set=img.dataset.set,num=img.dataset.num;
  fetchCardMeta(set,num).then(meta=>{
    const isFossil = img.dataset.isFossil === 'true';
    if(String(meta.category||'').toLowerCase()!=='pokemon' && !isFossil){
      showPopup('You can only attach to Pok√©mon.');
      return;
    }
    let box=slot.querySelector('.energy-pips');
    if(!box){
      box=document.createElement('div');
      box.className='energy-pips';
      slot.appendChild(box);
    }
    const pip=document.createElement('div');
    pip.className='energy-pip';
    pip.dataset.type=energyKey;
    pip.style.backgroundImage=`url('${ENERGY_ICONS[energyKey]||''}')`;
    box.appendChild(pip);
    
    // üÜï Check if we need to add doubled visual pip (Jungle Totem)
    addDoubledEnergyVisuals(img, box, energyKey);
    
    // üÜï A2 PASSIVE ABILITY - Nightmare Aura (damage on Dark energy attach)
    if (typeof triggerNightmareAura === 'function') {
      triggerNightmareAura(img, energyKey);
    }
    
    // üÜï A3 PASSIVE ABILITY - Comatose (self-sleep on energy attach to active)
    (async () => {
      try {
        const pk = owner === 'player1' ? 'p1' : 'p2';
        const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
        
        if (abilityRow?.effect_type === 'inflict_status_on_energy_attach') {
          if (typeof applyAbilityEffectFromCsv === 'function') {
            // Need to pass state object
            const state = {
              p1: playerState.player1,
              p2: playerState.player2
            };
            await applyAbilityEffectFromCsv(state, pk, abilityRow, { targetImg: img });
          }
        }
      } catch (err) {
        console.warn('[Komala] Failed to trigger ability:', err);
      }
    })();
    
    // üÜï B1 PASSIVE ABILITY - Jolteon ex Electromagnetic Wall (damage on ANY energy attach)
    triggerElectromagneticWall(img);
    
    hasAttachedEnergyThisTurn=true;
    renderEnergyZone();
    showPopup('Energy attached');

    logEvent({
      player: owner,
      text:`Attached ${energyKey} Energy.`,
      cardSet:set,cardNum:num
    });

    if(currentZoom.img&&slot.contains(currentZoom.img)){
      buildZoomPanel(meta,currentZoom.img);
    }
  }).catch(()=>showPopup('Error verifying card.'));
}

// Add visual doubled energy pips (at 70% opacity) for Jungle Totem
function addDoubledEnergyVisuals(img, energyBox, energyKey) {
  if (!img || !energyBox || !energyKey) return;
  
  // Determine owner
  const p1Active = document.querySelector('#player1 .active img');
  const p1Bench = Array.from(document.querySelectorAll('#player1 .bench img'));
  const p2Active = document.querySelector('#player2 .active img');
  const p2Bench = Array.from(document.querySelectorAll('#player2 .bench img'));
  
  let owner = null;
  if (img === p1Active || p1Bench.includes(img)) owner = 'p1';
  else if (img === p2Active || p2Bench.includes(img)) owner = 'p2';
  
  if (!owner) return;
  
  // Check if Serperior is in play (Jungle Totem)
  const allMyPokemon = owner === 'p1' ? [p1Active, ...p1Bench] : [p2Active, ...p2Bench];
  let hasSerperior = false;
  
  for (const pokemon of allMyPokemon) {
    if (pokemon && pokemon.alt && pokemon.alt.toLowerCase().includes('serperior')) {
      hasSerperior = true;
      break;
    }
  }
  
  // Only double Grass energy on Grass Pokemon with Serperior in play
  if (hasSerperior && energyKey.toLowerCase() === 'grass') {
    const types = (img.dataset.pokemonTypes || '').toLowerCase().split(',');
    if (types.includes('grass')) {
      // Add phantom pip at 70% opacity
      const phantomPip = document.createElement('div');
      phantomPip.className = 'energy-pip phantom-pip';
      phantomPip.dataset.type = energyKey;
      phantomPip.dataset.phantom = 'true';  // Mark as phantom
      phantomPip.style.backgroundImage = `url('${ENERGY_ICONS[energyKey]||''}')`;
      phantomPip.style.opacity = '0.7';
      phantomPip.title = 'Doubled by Jungle Totem';
      energyBox.appendChild(phantomPip);
      
      console.log(`[jungle-totem-visual] Added phantom grass pip to ${img.alt}`);
    }
  }
}

// Update all energy visuals when Serperior enters/leaves play
function updateAllEnergyVisuals() {
  // Disconnect observer temporarily to prevent infinite loop
  const observer = globalThis.pokemonTypeObserver;
  if (observer) {
    observer.disconnect();
  }
  
  // Check both players
  ['p1', 'p2'].forEach(owner => {
    const area = owner === 'p1' ? document.querySelector('#player1') : document.querySelector('#player2');
    if (!area) return;
    
    const allSlots = Array.from(area.querySelectorAll('.card-slot'));
    
    allSlots.forEach(slot => {
      const img = slot.querySelector('img');
      const energyBox = slot.querySelector('.energy-pips');
      if (!img || !energyBox) return;
      
      // Remove all existing phantom pips
      energyBox.querySelectorAll('.phantom-pip').forEach(p => p.remove());
      
      // Get real energy pips (non-phantom)
      const realPips = Array.from(energyBox.querySelectorAll('.energy-pip:not(.phantom-pip)'));
      
      // Re-add phantom pips for each real grass energy
      realPips.forEach(pip => {
        const energyType = pip.dataset.type;
        if (energyType) {
          addDoubledEnergyVisuals(img, energyBox, energyType);
        }
      });
    });
  });
  
  // Reconnect observer after updates
  if (observer && document.body) {
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  
  console.log('[jungle-totem-visual] Updated all energy visuals');
}

// Expose globally
globalThis.updateAllEnergyVisuals = updateAllEnergyVisuals;


/* primary click */
document.body.addEventListener('click', async e => {
  if (e.button !== 0) return;

  /* üÜï Tool thumbnail click - show tool details */
  const toolThumb = e.target.closest('.tool-thumb');
  if (toolThumb) {
    e.stopPropagation();
    e.preventDefault();
    
    const slot = toolThumb.closest('.card-slot');
    const toolData = getToolDataFromSlot(slot);
    const pokemonImg = slot.querySelector('img:not(.tool-thumb)');
    
    if (toolData && toolData.set && toolData.num) {
      try {
        const meta = await fetchCardMeta(toolData.set, toolData.num);
        
        // Show in hand modal (for trainers)
        if (handBackdrop && handImg && handToolImg) {
          // Show Pokemon card
          if (pokemonImg) {
            handImg.src = pokemonImg.src;
          }
          
          // Show tool on top
          handToolImg.src = toolData.src || toolThumb.src;
          handToolImg.style.display = 'block';
          
          handBackdrop.classList.add('show');
          handTitle.textContent = meta.name || 'Tool';
          
          if (handType) {
            handType.textContent = 'Tool';
            handType.style.background = trainerColor('tool');
          }
          if (handEffect) {
            handEffect.textContent = meta.effect || meta.description || 'No effect listed.';
          }
        }
        
        console.log('[tool-click] Showing tool details:', meta.name);
      } catch (err) {
        showPopup('Could not load tool data.');
        console.error('[tool-click] Error:', err);
      }
    }
    
    return;
  }

  /* tool attach flow */
  if (toolAttachPending) {
    const targetImg = e.target.closest('.active img, .bench img');
    // If clicking outside a pokemon card, cancel selection
    if (!targetImg) {
      cancelSelection();
      return;
    }
    if (targetImg) {
      const owner = targetImg.closest('#player1') ? 'player1' : 'player2';
      if (owner !== toolAttachPending.owner) {
        showPopup('Attach Tools to your own Pok√©mon.');
      } else {
        const targetSlot = targetImg.closest('.card-slot');
        if (getToolDataFromSlot(targetSlot)) {
          showPopup('This Pok√©mon already has a Tool attached.');
        } else {
          // Attach tool visually
          await attachToolToSlot(owner, targetSlot, {
            set: toolAttachPending.set,
            num: toolAttachPending.num,
            src: toolAttachPending.src
          });
          
          // üÜï Apply tool effect!
          const cardId = csvIdFor(toolAttachPending.set, toolAttachPending.num);
          const effect = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
          
          if (effect && effect.effect_type) {
            console.log('[tool] Applying effect:', effect.effect_type);
            // Tools need to know which Pokemon they're attached to
            // Store target in a temp variable for the effect
            globalThis.toolAttachTarget = targetImg;
            
            try {
              await applyTrainerEffect(effect, owner, null); // null = no trainer card for tools
              
              // Effect succeeded - finish attachment
              removeFromHand(owner, toolAttachPending.set, toolAttachPending.num);
              renderAllHands();

              logEvent({
                player: owner,
                text: 'Attached Tool.',
                cardSet: toolAttachPending.set,
                cardNum: toolAttachPending.num
              });

              toolAttachPending = null;
              clearSelectionGlow();
              
            } catch (err) {
              // Effect failed (e.g., wrong type for Leaf Cape)
              console.log('[tool] Effect failed, removing tool:', err.message);
              
              // Remove the tool that was just attached
              const toolThumb = targetSlot.querySelector('.tool-thumb');
              if (toolThumb) toolThumb.remove();
              setToolDataOnSlot(targetSlot, null);
              
              showPopup(err.message || 'Cannot attach this Tool here.');
              // Card stays in hand
            } finally {
              globalThis.toolAttachTarget = null;
            }
          } else {
            // No effect to apply - just finish attachment
            removeFromHand(owner, toolAttachPending.set, toolAttachPending.num);
            renderAllHands();

            logEvent({
              player: owner,
              text: 'Attached Tool.',
              cardSet: toolAttachPending.set,
              cardNum: toolAttachPending.num
            });

            toolAttachPending = null;
            clearSelectionGlow();
          }
        }
      }
      e.stopPropagation();
      return;
    }
  }

  /* energy pick */
  if (selectedEnergy) {
    // Don't cancel if clicking on energy zone (to select different energy)
    const isEnergyZoneClick = e.target.closest('.energy-zone') || e.target.classList.contains('energy');
    if (isEnergyZoneClick) {
      // Let the energy zone click handler process this
      return;
    }
    
    const img = e.target.closest('.card-slot img');
    // If clicking outside a pokemon card, cancel selection
    if (!img) {
      cancelSelection();
      return;
    }
    const owner = img.closest('#player1') ? 'player1' : 'player2';
    if (owner !== currentPlayer) {
      showPopup('Attach Energy to your own Pok√©mon.');
      return;
    }
    attachEnergyToSlot(owner, img.closest('.card-slot'), selectedEnergy);
    selectedEnergy = null;
    clearSelectionGlow();
    return;
  }

  /* ========================================
     Left-click on Bench Pok√©mon - Open Zoom Panel
  ======================================== */
  
  // Check if clicking on a bench Pok√©mon (not in hand, not active)
  const benchImg = e.target.closest('.bench img');
  if (benchImg && !benchImg.closest('.hand')) {
    // Only proceed if not in a special selection mode
    if (!isPromotionPhase && !isRetreatSelection && !globalThis.isSelectingPokemon && !toolAttachPending && !selectedEnergy) {
      e.preventDefault();
      e.stopPropagation();
      
      zoomImg.src = benchImg.src;
      zoomBackdrop.classList.add('show');
      
      try {
        const set = benchImg.dataset.set;
        const num = benchImg.dataset.num;
        const meta = await fetchCardMeta(set, num);
        await buildZoomPanel(meta, benchImg);
      } catch {
        zoomTitle.textContent = 'Pok√©mon';
        zoomHp.textContent = '';
        zoomAttacks.innerHTML = '<div style="color:#cbd5e1">No data</div>';
        zoomEnergyCount.textContent = 'x0';
        zoomEnergyIcons.innerHTML = '';
        zoomWeakness.textContent = '‚Äî';
        zoomRetreat.innerHTML = '';
        zoomTools.innerHTML = '<div class="chip">none</div>';
        zoomAbilities.style.display = 'none';
      }
      
      return;
    }
  }

  /* ========================================
     FIXED: Attack Menu Opening
  ======================================== */
  
  // Check if clicking on Active Pok√©mon (not in hand)
  const clickedImg = e.target.closest('img');
  
  if (clickedImg && !clickedImg.closest('.hand')) {
    // Check if this is the current player's Active Pok√©mon
    const activeArea = currentPlayer ? activeFor(currentPlayer) : null;
    
    if (activeArea && activeArea.contains(clickedImg)) {
      // Check if we're in a special mode that should block attack menu
      if (isEvoMode || toolAttachPending || selectedEnergy || isPromotionPhase || isRetreatSelection || abilityJustUsed) {
        console.error('[MENU-BLOCKED] Cannot open menu, special mode active:', {
          isEvoMode,
          toolAttachPending: !!toolAttachPending,
          selectedEnergy,
          isPromotionPhase,
          isRetreatSelection,
          abilityJustUsed,
          timestamp: new Date().toISOString()
        });
        return;
      }
      
      console.log('[MENU-ALLOWED] Opening menu, all flags clear:', {
        isEvoMode,
        toolAttachPending: !!toolAttachPending,
        selectedEnergy,
        isPromotionPhase,
        isRetreatSelection
      });

      const set = clickedImg.dataset.set;
      const num = clickedImg.dataset.num;
      
      console.log('[attack-menu] Attempting to open for:', set, num);
      
      if (!set || !num) {
        console.error('[attack-menu] Missing set/num:', { set, num });
        closeAttackMenu();
        return;
      }

      try {
        const meta = await fetchCardMeta(set, num);
        console.log('[attack-menu] Fetched meta:', meta);
        
        if (!meta) {
          showPopup('Could not load card data.');
          return;
        }
        
        // Check if this is a Pok√©mon card OR a fossil
        const category = String(meta.category || '').toLowerCase();
        const isFossil = clickedImg.dataset.isFossil === 'true';
        
        if (category !== 'pokemon' && !isFossil) {
          console.warn('[attack-menu] Not a Pok√©mon card:', category);
          showPopup('This is not a Pok√©mon card.');
          return;
        }
        
        // Open the attack menu with the clicked image
        showAttackMenuFor(clickedImg, meta);
        
      } catch (err) {
        console.error('[attack-menu] Error loading card:', err);
        showPopup('No attacks available.');
      }
      
      return;
    }
  }

  /* hand interactions - only if not clicking active */
/* hand interactions - only if not clicking active */
if (e.target.tagName !== 'IMG') return;
const inHand = e.target.closest('.hand');
if (!inHand) return;

// üÜï Block hand clicks when selection is active (for move effects that target Pok√©mon)
if (globalThis.__selectionActive) {
  // Selection is active - block all hand clicks
  e.stopPropagation();
  e.preventDefault();
  showPopup('Cannot select cards in hand. Please select a Pok√©mon in play.');
  return;
}

const owner = e.target.dataset.owner;
const set = e.target.dataset.set;
const num = e.target.dataset.num;
const trainerCardImg = e.target; // Store reference to the trainer card image

// During game, only current player can interact with their hand
// During setup (currentPlayer is null), anyone can place cards
// Exception: Allow clicking opponent's hand during Silver's selection
if (currentPlayer && owner !== currentPlayer && !globalThis.__silverSelectionActive) return;

// üÜï Check if Silver's selection is active - if so, don't process as normal card play
if (globalThis.__silverSelectionActive && owner !== currentPlayer) {
  // Let the awaitSelection handler in effects.js handle this click
  return;
}

// üÜï Check if Pokemon Communication is active
if (globalThis.__pokemonCommActive) {
  const selData = globalThis.__pokemonCommSelection;
  if (selData) {
    // Check if this card is one of the eligible Pokemon
    const clickedCard = selData.hand.find(c => 
      (c.set === set && String(c.number || c.num) === String(num))
    );
    
    if (clickedCard && selData.pokemonInHand.includes(clickedCard)) {
      // Valid selection!
      globalThis.__pokemonCommActive = false;
      globalThis.__pokemonCommSelection = null;
      
      if (globalThis.__pokemonCommResolve) {
        globalThis.__pokemonCommResolve(clickedCard);
        globalThis.__pokemonCommResolve = null;
      }
      
      console.log('[Pokemon Communication] Selected:', clickedCard.name);
      return;
    }
  }
}

// üÜï Check if Rare Candy Stage 2 selection is active
if (globalThis.__rareCandyActive) {
  const rareCandyData = globalThis.__rareCandySelection;
  if (rareCandyData && rareCandyData.owner === owner) {
    // Check if this card is one of the eligible Stage 2 cards
    const clickedPair = rareCandyData.pairsForBasic.find(p => 
      p.handCard.set === set && String(p.handCard.number || p.handCard.num) === String(num)
    );
    
    if (clickedPair) {
      // Valid selection!
      if (globalThis.__rareCandyResolve) {
        globalThis.__rareCandyResolve(clickedPair);
        globalThis.__rareCandyResolve = null;
      }
      
      console.log('[Rare Candy] Selected Stage 2:', clickedPair.stage2Meta.name);
      return;
    }
  }
}

let meta = null;
try {
  meta = await fetchCardMeta(set, num);
} catch {}

/* trainer */
if (meta && String(meta.category || '').toLowerCase() === 'trainer') {
  if (isSetupPhase) {
    showPopup("You can't play Trainer cards during setup.");
    return;
  }
  
  const ttype = String(meta.trainerType || '').toLowerCase();
  const cardId = csvIdFor(set, num);
  const effect = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
  
  const doEffect = async () => {
    if (effect) {
      await applyTrainerEffect(effect, owner, trainerCardImg, true); // throwOnError = true for items
    } else {
      console.warn('No CSV effect for', cardId);
    }
  };

  if (ttype === 'supporter') {
    // CHECK SUPPORTER BLOCK
        const pk = owner === 'player1' ? 'p1' : 'p2';

    if (!canUseSupporter(pk)) {
      showPopup("Can't use Supporter cards this turn!");
      return;
    }
    // Check if Gengar ex is blocking Supporters
    if (isGengarBlocking(owner)) {
      showPopup('Shadowy Spellbind: You cannot play Supporter cards!');
      return;
    }
    
    if (hasPlayedSupporterThisTurn[owner]) {
      showPopup('Only one Supporter per turn.');
      return;
    }
    
    // Check if effect exists before consuming card
    if (!effect) {
      showPopup(`${meta.name || 'This Supporter'} is not yet implemented.`);
      console.warn('No CSV effect for', cardId, '- card not consumed');
      return;
    }
    
    // üÜï Don't consume card yet - wait for effect to complete successfully
    // This allows cancellation if selection is cancelled
    try {
      await doEffect();
      
      // Effect completed successfully - now consume the card
    addTrainerToDiscard(owner, e.target);
    removeFromHand(owner, set, num);
    renderAllHands();
    hasPlayedSupporterThisTurn[owner] = true;
    
    // Track for Silvally - Brave Buddies
    const pkForSilvally = owner === 'player1' ? 'p1' : 'p2';
    if (!globalThis.__supporterPlayedThisTurn) globalThis.__supporterPlayedThisTurn = { p1: false, p2: false };
    globalThis.__supporterPlayedThisTurn[pkForSilvally] = true;
    console.log(`[Supporter] Marked ${pkForSilvally} as having played Supporter this turn`);
      
    showPopup('Supporter played');

    logEvent({
      player: owner,
      text: `Played Supporter: ${meta.name}.`,
      cardSet: set,
      cardNum: num
    });
    } catch (err) {
      // Effect was cancelled or failed - don't consume the card
      if (err.message === 'SELECTION_CANCELLED') {
        console.log('[Supporter] Selection cancelled, card not consumed');
        showPopup('Supporter use cancelled.');
      } else if (err.message === 'No valid target') {
        console.log('[Supporter] No valid target, card not consumed');
        showPopup('No valid target');
      } else {
        console.log('[Supporter] Effect failed, card not consumed:', err);
        showPopup(err.message || 'Supporter effect failed.');
      }
      // Card remains in hand
    }

    return;
  } else if (ttype === 'item') {
    // Try to apply effect first
    try {
      await doEffect();
      
      // Animate item card scale
      const itemRect = e.target.getBoundingClientRect();
      const scaleClone = e.target.cloneNode(true);
      scaleClone.style.cssText = `
        position: fixed;
        left: ${itemRect.left}px;
        top: ${itemRect.top}px;
        width: ${itemRect.width}px;
        height: ${itemRect.height}px;
        z-index: 10000;
        pointer-events: none;
        transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        transform-origin: center center;
      `;
      document.body.appendChild(scaleClone);
      
      // Force reflow
      void scaleClone.offsetWidth;
      
      // Scale up
      requestAnimationFrame(() => {
        scaleClone.style.transform = 'scale(2)';
        scaleClone.style.opacity = '0.9';
      });
      
      // Clean up after animation
      setTimeout(() => {
        scaleClone.style.opacity = '0';
        setTimeout(() => scaleClone.remove(), 100);
      }, 500);
      
      // Only remove from hand if effect succeeded
      addTrainerToDiscard(owner, e.target);
      removeFromHand(owner, set, num);
      renderAllHands();
      showPopup('Item played');

      logEvent({
        player: owner,
        text: `Played Item: ${meta.name}.`,
        cardSet: set,
        cardNum: num
      });
    } catch (err) {
      // Effect failed - card stays in hand
      console.log('[item] Effect failed:', err.message);
      showPopup(err.message || 'Cannot use this Item right now.');
    }

    return;
  } else if (ttype === 'tool') {
    // Clear previous selection
    if (selectedEnergyElement) {
      selectedEnergyElement.classList.remove('selected-glow');
      selectedEnergy = null;
    }
    if (selectedToolElement) {
      selectedToolElement.classList.remove('selected-glow');
    }
    
    toolAttachPending = { owner, set, num, src: e.target.src };
    selectedToolElement = e.target;
    selectedEnergyElement = null;
    e.target.classList.add('selected-glow');
    showPopup('Select a Pok√©mon in play to attach this Tool, or press Escape to cancel.');

    logEvent({
      player: owner,
      text: `Played Tool: ${meta.name}.`,
      cardSet: set,
      cardNum: num
    });
    
    // Add escape key handler
    setupSelectionCancelHandler();

    return;
  } else {
    showPopup('Unknown Trainer type.');
    return;
  }
}

/* evolution */
if (meta && meta.evolveFrom) {
  isEvoMode = true;
  evoMeta = meta;
  evoOwner = owner;
  evoHandCard = e.target;
  
  let glow = 0;
  const evolveFromLower = String(meta.evolveFrom).toLowerCase();
  
  // üÜï Fossil mapping - fossils count as their Pokemon for evolution
  const FOSSIL_MAP = {
    'helix fossil': 'omanyte',
    'dome fossil': 'kabuto',
    'old amber': 'aerodactyl',
    'skull fossil': 'cranidos',
    'armor fossil': 'shieldon'
  };
  
  $$('#' + owner + ' .active img, #' + owner + ' .bench img').forEach(img => {
    const cardNameLower = (img.alt || '').toLowerCase();
    
    // Check normal evolution (name includes evolveFrom)
    let matches = cardNameLower.includes(evolveFromLower);
    
    // üÜï Check if this is a fossil that matches the evolveFrom
    if (!matches && FOSSIL_MAP[cardNameLower]) {
      const fossilPokemon = FOSSIL_MAP[cardNameLower];
      matches = fossilPokemon === evolveFromLower || evolveFromLower.includes(fossilPokemon);
    }
    
    // üÜï A3b - Eevee ex special evolution rule (can evolve into any Eeveelution)
    if (!matches && cardNameLower.includes('eevee ex')) {
      const EEVEELUTIONS = [
        'vaporeon', 'jolteon', 'flareon', 'espeon', 'umbreon',
        'leafeon', 'glaceon', 'sylveon'
      ];
      
      const evoCardName = (meta.name || '').toLowerCase();
      if (EEVEELUTIONS.some(e => evoCardName.includes(e))) {
        matches = true;
        console.log('[Veevee \'volve] Eevee ex can evolve into', meta.name);
      }
    }
    
    if (matches) {
      img.classList.add('glow-evo');
      glow++;
    }
  });
  
  if (glow === 0) {
    showPopup(`No valid ${meta.evolveFrom} to evolve.`);
    isEvoMode = false;
    return;
  }
  
  showPopup(`Select ${meta.evolveFrom} to evolve.`);
  return;
}

/* basic placement */
if (!(meta && String(meta.category || '').toLowerCase() === 'pokemon' &&
     String(meta.stage || '').toLowerCase() === 'basic')) {
  showPopup('Only Basic Pok√©mon can be placed.');
  return;
}

const clone = e.target.cloneNode(true);
clone.dataset.playedTurn = globalThis.turnNumber;
  
  // Assign unique instance ID for ability tracking
  if (!window.pokemonInstanceCounter) window.pokemonInstanceCounter = 0;
  clone.dataset.instanceId = ++window.pokemonInstanceCounter;
  console.log('[INSTANCE] Assigned instanceId:', clone.dataset.instanceId, 'to', clone.alt || 'Unknown Pokemon');
clone.dataset.set = set;
clone.dataset.num = num;

const act = owner === 'player1' ? p1Active : p2Active;
const bench = owner === 'player1' ? p1Bench : p2Bench;

let placedTo = 'bench';
let targetSlot = null;

// Determine target slot before DOM changes
if (!act.querySelector('img')) {
  targetSlot = act.querySelector('.card-slot');
  placedTo = 'active';
} else {
  // Find truly empty bench slot (no img element)
  const empty = [...bench.querySelectorAll('.card-slot')].find(s => !s.querySelector('img'));
  if (!empty) {
    showPopup('Bench full.');
    return;
  }
  targetSlot = empty;
  placedTo = 'bench';
}

// Now perform DOM updates
if (placedTo === 'active') {
  const slot = act.querySelector('.card-slot');
  slot.innerHTML = '';
  slot.appendChild(clone);
  markSlot(slot, true);
  
  // Animate slide from hand (after DOM update)
  if (targetSlot) {
    animateSlideFromHand(e.target, targetSlot, clone);
  }
  
  // Update player background when active Pokemon is placed during setup
  const playerNum = owner === 'player1' ? 1 : 2;
  updatePlayerTypeBackground(playerNum);
} else {
  const empty = [...bench.querySelectorAll('.card-slot')].find(s => !s.querySelector('img'));
  empty.innerHTML = '';
  empty.appendChild(clone);
  markSlot(empty, true);
  
  // Animate slide from hand (after DOM update)
  if (targetSlot) {
    animateSlideFromHand(e.target, targetSlot, clone);
  }
}

removeFromHand(owner, set, num);

try {
  const baseHp = parseInt(meta.hp || '0', 10) || 0;
  setHpOnImage(clone, baseHp, baseHp);
} catch {}

renderAllHands();

logEvent({
  player: owner,
  text: `Played Basic Pok√©mon to ${placedTo === 'active' ? 'Active' : 'Bench'}: ${meta.name}.`,
  cardSet: set,
  cardNum: num
});
  // ... rest of your hand interaction code ...
});

/* ========================================
   DEBUG: Add Logging to showAttackMenuFor
======================================== */

// Find your showAttackMenuFor function and add console.logs:
// PTCGL-Style Attack Menu JavaScript
// Replace your existing showAttackMenuFor function with this

// PTCGL-Style Attack Menu - CORRECT VERSION
// Attacks/Abilities overlay ON TOP of the card

// PTCGL-Style Attack Menu - FINAL VERSION
// All requirements met

async function showAttackMenuFor(cardImg, meta) {
  console.log('[MENU] showAttackMenuFor called, isRetreatSelection:', isRetreatSelection);
  console.log('[MENU] cardImg instanceId:', cardImg?.dataset.instanceId);
  
  // Don't open menu during retreat selection
  if (isRetreatSelection) {
    console.log('[attack-menu] Blocked - retreat selection in progress');
    return;
  }
  
  console.log('[MENU] Opening menu...');
  closeAttackMenu();

  const slot = cardImg.closest('.card-slot');

  if (!slot || !cardImg || !meta) {
    return;
  }

  // Get activeDiv from cardImg for functions that need it
  const activeDiv = cardImg.closest('.active, .bench');
  
  const pk = currentPlayer === 'player1' ? 'p1' : 'p2';
  const ownerKey = pk;  // Use p1/p2 for consistency with turn reset
  console.log('[PTCGL-OWNER] ownerKey:', ownerKey, '(currentPlayer:', currentPlayer + ')');
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const cardSet = cardImg.dataset.set;
  const cardNum = cardImg.dataset.num;
  const type0 = ((meta.types && meta.types[0]) || 'colorless').toLowerCase();
  console.log('[PTCGL Menu] Card type:', type0, 'from meta.types:', meta.types);

  // NO backdrop - requirement #5

  // Get card slot FIRST (needed for multiple purposes below)
  const cardSlot = cardImg.closest('.card-slot');

  // Create main menu container
  const menu = document.createElement('div');
  menu.className = 'attack-menu ptcgl-style';
  
  // Check if this menu is opening right after a retreat
  // Use longer delay if retreat happened within last 1000ms
  const timeSinceRetreat = Date.now() - lastRetreatTime;
  const delayForRetreat = (isRetreatSelection || timeSinceRetreat < 1000) ? 500 : 100;
  console.log('[MENU] Time since last retreat:', timeSinceRetreat, 'ms, delay:', delayForRetreat, 'ms');
  
  // Click anywhere to close
  menu.addEventListener('click', (e) => {
    if (e.target === menu) {
      closeAttackMenu();
    }
  });
  
  // Mark the card slot as having menu open
  if (cardSlot) {
    cardSlot.classList.add('menu-open');
  }

  // Create card container
  const cardContainer = document.createElement('div');
  cardContainer.className = 'ptcgl-card-container';
  cardContainer.style.position = 'relative'; // Allow absolute positioning for tool

  // Card image
  const cardImgClone = document.createElement('img');
  cardImgClone.src = cardImg.src;
  cardImgClone.alt = meta.name || 'Pokemon';
  cardContainer.appendChild(cardImgClone);
  
  // üÜï Add tool THUMBNAIL if tool is attached
  const toolData = getToolDataFromSlot(cardSlot);
  if (toolData && toolData.src) {
    const toolThumb = document.createElement('img');
    toolThumb.src = toolData.src;
    toolThumb.alt = 'Tool';
    toolThumb.style.cssText = `
      position: absolute;
      top: 120px;
      left: 8px;
      width: 80px;
      height: 112px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,.6);
      border: 1px solid #6e4e9c;
      background-color: #0b0f14;
      z-index: 10;
      object-fit: cover;
      object-position: center 15%;
      clip-path: inset(15% 5% 45% 5%);
      pointer-events: none;
    `;
    cardContainer.appendChild(toolThumb);
  }

  // Close button - SMALL, OUTSIDE card (#1)
  const closeBtn = document.createElement('button');
  closeBtn.className = 'ptcgl-close-btn';
  closeBtn.innerHTML = '√ó';
  closeBtn.addEventListener('click', () => {
    // Animate back to card position
    const cardRect = cardImg.getBoundingClientRect();
    const returnX = cardRect.left + cardRect.width / 2;
    const returnY = cardRect.top + cardRect.height / 2;
    
    menu.style.transition = 'all 0.25s ease-in';
    menu.style.left = returnX + 'px';
    menu.style.top = returnY + 'px';
    menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
    menu.style.opacity = '0';
    
    setTimeout(() => {
      closeAttackMenu();
    }, 500);  // Increased from 250ms to prevent immediate close during retreat
  });
  cardContainer.appendChild(closeBtn);

  // HP + Type combined bar (#2 & #3)
  // Check for Giant Cape or other max HP modifiers
  const modifiedMaxHp = cardSlot?.dataset.maxHp ? parseInt(cardSlot.dataset.maxHp, 10) : null;
  const baseHp = parseInt(cardImg.dataset.hp || meta.hp || '0', 10);
  const maxHp = modifiedMaxHp || baseHp;
  const chp = parseInt(cardImg.dataset.chp || maxHp || '0', 10);
  
  const hpTypeBar = document.createElement('div');
  hpTypeBar.className = 'ptcgl-hp-type-bar';
  
  // Make HP green if Giant Cape is attached
  const hpStyle = modifiedMaxHp ? 'color: #22c55e; font-weight: 700;' : '';
  
  hpTypeBar.innerHTML = `
    <span class="ptcgl-hp-number" style="${hpStyle}">${chp} / ${maxHp}</span>
    <div class="ptcgl-type-icon-inline" style="background-image: url('${energyIconUrl(type0)}')"></div>
  `;
  cardContainer.appendChild(hpTypeBar);

  // Energy pips - show attached energy from the card (cardSlot already declared above)
  const energyPipsContainer = document.createElement('div');
  energyPipsContainer.className = 'ptcgl-energy-pips';
  
  console.log('[energy-pips] cardSlot:', cardSlot);
  
  if (cardSlot) {
    const energyBox = cardSlot.querySelector('.energy-pips');
    console.log('[energy-pips] energyBox found:', energyBox);
    
    if (energyBox) {
      const energyPips = energyBox.querySelectorAll('.energy-pip');
      console.log('[energy-pips] Found', energyPips.length, 'energy pips');
      
      energyPips.forEach(pip => {
        const pipClone = document.createElement('div');
        pipClone.className = 'ptcgl-energy-pip';
        const energyType = pip.dataset.type || 'colorless';
        pipClone.style.backgroundImage = `url('${energyIconUrl(energyType)}')`;
        pipClone.dataset.type = energyType;
        energyPipsContainer.appendChild(pipClone);
        console.log('[energy-pips] Added pip:', energyType);
      });
    }
  }
  
  if (energyPipsContainer.children.length > 0) {
    console.log('[energy-pips] Appending', energyPipsContainer.children.length, 'pips to card');
    cardContainer.appendChild(energyPipsContainer);
  } else {
    console.log('[energy-pips] No energy pips to display');
  }

  // Actions overlay container (bottom of card)
  const actionsOverlay = document.createElement('div');
  actionsOverlay.className = 'ptcgl-actions-overlay';

  // ABILITIES (if exists) - Show ALL abilities (active + passive)
  
  // Find ALL abilities for this card (not just active)
  const allAbilityRows = abilityRows.filter(r => {
    const matches = r.set === cardSet &&
      String(r.number).padStart(3, '0') === String(cardNum).padStart(3, '0');
    
    return matches;
  });

  // Display each ability
  allAbilityRows.forEach(abilityRow => {
    const isPassive = abilityRow.abilityType === 'passive';
    
    // Check if this is an unlimited ability
    const isUnlimited = 
      (abilityRow.param2 && abilityRow.param2.toLowerCase() === 'unlimited') ||
      (abilityRow.text && /as often as you like/i.test(abilityRow.text));
    
    const usedMap = window.usedAbilitiesThisTurn;
    usedMap[ownerKey] = usedMap[ownerKey] || {};
    
    // Use the cardImg that was passed in (has correct instance ID)
    const pokemonImg = cardImg;
    const cardKey = getAbilityCardKey(abilityRow.set, abilityRow.number, pokemonImg);
    const alreadyUsed = !isUnlimited && !!usedMap[ownerKey][cardKey];

    const abilityBox = document.createElement('div');
    abilityBox.className = 'ptcgl-ability-overlay';
    
    // Add type class for background color
    const pokemonType = (type0 || 'colorless').toLowerCase();
    abilityBox.classList.add(`type-${pokemonType}`);
    
    // Style passive abilities differently
    if (isPassive) {
      abilityBox.classList.add('passive-ability');
      abilityBox.style.opacity = '1';  // Keep full opacity
      abilityBox.style.pointerEvents = 'none';
      abilityBox.style.cursor = 'default';
    } else if (alreadyUsed) {
      abilityBox.classList.add('used');
      abilityBox.style.pointerEvents = 'none';
      abilityBox.style.opacity = '0.5';
      abilityBox.style.cursor = 'not-allowed';
    }

    const abilityHeader = document.createElement('div');
    abilityHeader.className = 'ptcgl-ability-header';
    
    const abilityLeft = document.createElement('div');
    abilityLeft.className = 'ptcgl-ability-left';
    
    // Show "PASSIVE" label for passive abilities
    const labelText = isPassive ? 'PASSIVE' : 'ABILITY';
    abilityLeft.innerHTML = `
      <img src="${ABILITY_BADGE}" style="width:60px"  />      
      <span class="ptcgl-ability-name">${abilityRow.abilityName || 'Ability'}</span>
    `;
    
    abilityHeader.appendChild(abilityLeft);
    abilityBox.appendChild(abilityHeader);
    
    const abilityText = document.createElement('div');
    abilityText.className = 'ptcgl-ability-text';
    abilityText.textContent = abilityRow.text || '';
    abilityBox.appendChild(abilityText);
    
    // Only add click handler for ACTIVE abilities
    if (!isPassive && !alreadyUsed) {
      abilityBox.addEventListener('click', async (e) => {
        e.stopPropagation();
        e.preventDefault();
        
        // Double-check if already used (but allow unlimited)
        if (!isUnlimited && usedMap[ownerKey]?.[cardKey]) {
          showPopup('This ability has already been used this turn.');
          return;
        }
        
        // Only mark as used if NOT unlimited
        if (!isUnlimited) {
          if (!usedMap[ownerKey]) usedMap[ownerKey] = {};
          usedMap[ownerKey][cardKey] = true;
          
          // Gray out the ability box immediately
          abilityBox.classList.add('used');
          abilityBox.style.pointerEvents = 'none';
          abilityBox.style.opacity = '0.5';
          abilityBox.style.cursor = 'not-allowed';
        }
        
        // Set flag to prevent menu from reopening
        abilityJustUsed = true;
        
        // Close menu BEFORE applying effect
        if (typeof closeAttackMenu === 'function') {
          closeAttackMenu();
        }
        
        // Small delay to ensure menu is closed before effect
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Apply the ability effect with source Pokemon image (use captured reference)
        await applyAbilityEffect(abilityRow, ownerKey, pokemonImg);
        
        // Clear flag after a delay
        setTimeout(() => {
          abilityJustUsed = false;
        }, 300);
      });
    }

    actionsOverlay.appendChild(abilityBox);
  });

  // FOSSIL DISCARD OPTION - Fossils have no attacks, only "Discard"
  const isFossil = cardImg.dataset.isFossil === 'true';
  
  if (isFossil) {
    // Create discard button for fossil
    const discardBox = document.createElement('div');
    discardBox.className = 'ptcgl-attack-overlay payable';
    discardBox.classList.add('type-colorless'); // Fossils are colorless
    
    const discardHeader = document.createElement('div');
    discardHeader.className = 'ptcgl-attack-header';
    
    const discardLeft = document.createElement('div');
    discardLeft.className = 'ptcgl-attack-left';
    
    const discardName = document.createElement('span');
    discardName.className = 'ptcgl-attack-name type-colorless';
    discardName.textContent = 'Discard';
    
    discardLeft.appendChild(discardName);
    discardHeader.appendChild(discardLeft);
    discardBox.appendChild(discardHeader);
    
    const discardEffect = document.createElement('div');
    discardEffect.className = 'ptcgl-attack-effect';
    discardEffect.textContent = 'Discard this Fossil from play. Does not give opponent a point.';
    discardBox.appendChild(discardEffect);
    
    // Click handler for discard
    discardBox.addEventListener('click', async () => {
      closeAttackMenu();
      
      // Discard the fossil
      const isActive = !!cardImg.closest('#p1Active, #p2Active');
      
      // Move to discard pile
      if (globalThis.discardPokemon) {
        await globalThis.discardPokemon(cardImg, pk, false); // false = no point given
      } else {
        // Fallback: just remove the card
        slot.innerHTML = '';
        globalThis.markSlot?.(slot, false);
      }
      
      showPopup(`${meta.name} was discarded.`);
      
      // If it was active, promote from bench
      if (isActive) {
        const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
        const benchImgs = Array.from(benchDiv?.querySelectorAll('img') ?? []);
        
        if (benchImgs.length === 0) {
          // Bench out!
          const winner = pk === 'p1' ? 'player2' : 'player1';
          showVictory(winner, 'Opponent has no Pok√©mon left!');
          return;
        }
        
        // Promote from bench - pk is the fossil owner
        if (globalThis.promoteFromBench) {
          await globalThis.promoteFromBench(null, pk); // pk = fossil owner (p1 or p2)
        }
      }
    });
    
    actionsOverlay.appendChild(discardBox);
  }

  // ATTACKS - (#4 - type-colored names, #7 - should work)
  let attacks = meta.attacks || [];
  
  // üÜï A4a - use_previous_evolution_attacks (Memory Light tool)
  // Check if this Pokemon has Memory Light attached and can use previous evolution attacks
  console.log(`[Memory Light Menu] Starting check for ${meta.name}, initial attacks: ${attacks.length}`);
  console.log(`[Memory Light Menu] Tool data:`, toolData);
  
  if (toolData && toolData.set && toolData.num) {
    try {
      const toolCardId = csvIdFor(toolData.set, toolData.num);
      console.log(`[Memory Light Menu] Tool card ID: ${toolCardId}`);
      
      const toolEffect = TRAINER_EFFECT_DATA.find(x => x.id === toolCardId);
      console.log(`[Memory Light Menu] Tool effect found:`, toolEffect);
      
      if (toolEffect?.effect_type === 'use_previous_evolution_attacks') {
        console.log(`[Memory Light Menu] Memory Light detected! Checking evolutions...`);
        
        // Helper function to recursively build the full evolution chain
        // skipFirstLevel: if true, skip adding the immediate previous evolution (for Rare Candy - skip Stage 1)
        async function buildEvolutionChain(currentMeta, owner, visited = new Set(), skipFirstLevel = false) {
          const chain = [];
          const currentKey = `${currentMeta.id || currentMeta.name}`;
          if (visited.has(currentKey)) return chain; // Prevent infinite loops
          visited.add(currentKey);
          
          // Get immediate previous evolution(s)
          let evolveFrom = currentMeta.evolvesFrom || currentMeta.evolveFrom || [];
          console.log(`[Memory Light Menu] Building chain for ${currentMeta.name}, evolveFrom:`, evolveFrom, `skipFirstLevel: ${skipFirstLevel}`);
          
          // If evolveFrom is a string, convert to array format
          if (typeof evolveFrom === 'string' && evolveFrom.trim()) {
            const evolveFromLower = evolveFrom.toLowerCase();
            const matchingCards = [];
            
            // Search in play, hand, deck, discard, API (same logic as above)
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
            const pokemonInPlay = [
              ...(activeDiv?.querySelectorAll('img') || []),
              ...(benchDiv?.querySelectorAll('img') || [])
            ];
            
            for (const pokemonImg of pokemonInPlay) {
              const pokemonName = (pokemonImg.alt || '').toLowerCase();
              // Use exact match for Pokemon in play
              if (pokemonName === evolveFromLower) {
                const set = pokemonImg.dataset.set;
                const num = pokemonImg.dataset.num;
                if (set && num) matchingCards.push({ set, number: num });
              }
            }
            
            if (matchingCards.length === 0) {
              const hand = playerState[owner]?.hand || [];
              for (const card of hand) {
                const cardName = (card.name || '').toLowerCase();
                // Use exact match only
                if (cardName === evolveFromLower) {
                  matchingCards.push({ set: card.set, number: card.number || card.num });
                }
              }
            }
            
            if (matchingCards.length === 0) {
              const deck = playerState[owner]?.deck || [];
              for (const card of deck) {
                try {
                  const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                  const cardName = (cardMeta.name || '').toLowerCase();
                  // Use exact match and verify it's a Pokemon
                  if (cardMeta.category === 'Pokemon' && cardName === evolveFromLower) {
                    matchingCards.push({ set: card.set, number: card.number || card.num });
                  }
                } catch {}
              }
            }
            
            if (matchingCards.length === 0) {
              const discard = playerState[owner]?.discard?.cards || [];
              for (const card of discard) {
                const cardName = (card.name || '').toLowerCase();
                // Use exact match only for discard to avoid false positives
                if (cardName === evolveFromLower) {
                  // Verify it's actually a Pokemon by fetching metadata
                  try {
                    const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                    if (cardMeta && cardMeta.category === 'Pokemon' && cardMeta.name && cardMeta.name.toLowerCase() === evolveFromLower) {
                      matchingCards.push({ set: card.set, number: card.number || card.num });
                    }
                  } catch (err) {
                    console.warn(`[Memory Light Menu] Failed to verify discard card ${card.set}-${card.number || card.num}:`, err);
                  }
                }
              }
            }
            
            if (matchingCards.length === 0) {
              // API search fallback
              const commonSets = ['A1', 'A1a', 'A2', 'A2a', 'A2b', 'A3', 'A3a', 'A3b', 'A4', 'A4a'];
              for (const set of commonSets) {
                try {
                  const setResponse = await fetch(`https://api.tcgdex.net/v2/en/sets/${set}`);
                  if (!setResponse.ok) continue;
                  const setData = await setResponse.json();
                  if (setData?.cards) {
                    for (const card of setData.cards) {
                      const cardName = (card.name || '').toLowerCase();
                      if (cardName === evolveFromLower || cardName.includes(evolveFromLower) || evolveFromLower.includes(cardName)) {
                        const localId = card.localId || card.number;
                        if (localId) {
                          matchingCards.push({ set, number: localId });
                          break;
                        }
                      }
                    }
                  }
                  if (matchingCards.length > 0) break;
                } catch (err) {
                  console.warn(`[Memory Light Menu] Failed to search set ${set}:`, err);
                }
              }
            }
            
            evolveFrom = matchingCards;
          }
          
          // Process each previous evolution
          if (Array.isArray(evolveFrom) && evolveFrom.length > 0) {
            for (const prevEvo of evolveFrom) {
              try {
                const prevEvoMeta = await fetchCardMeta(prevEvo.set, prevEvo.number);
                if (prevEvoMeta) {
                  // If skipFirstLevel is true (Rare Candy), skip adding the immediate previous evolution (Stage 1)
                  // but still recurse to get the Basic Pokemon
                  if (!skipFirstLevel) {
                    chain.push(prevEvoMeta);
                    console.log(`[Memory Light Menu] Added ${prevEvoMeta.name} to chain`);
                  } else {
                    console.log(`[Memory Light Menu] Skipping ${prevEvoMeta.name} (Rare Candy - skipping Stage 1)`);
                  }
                  // Recursively get attacks from this evolution's previous evolutions
                  // Pass false for skipFirstLevel on recursive calls (only skip the first level)
                  const deeperChain = await buildEvolutionChain(prevEvoMeta, owner, visited, false);
                  chain.push(...deeperChain);
                }
              } catch (err) {
                console.error(`[Memory Light Menu] Error fetching evolution ${prevEvo.set}-${prevEvo.number}:`, err);
              }
            }
          }
          
          return chain;
        }
        
        // Check if this Pokemon evolved via Rare Candy (skipped Stage 1) BEFORE building chain
        const evolvedViaRareCandy = cardImg.dataset.evolvedViaRareCandy === 'true';
        console.log(`[Memory Light Menu] Evolved via Rare Candy: ${evolvedViaRareCandy}`);
        
        // Get all previous evolution's attacks
        // Handle both array format (evolvesFrom) and string format (evolveFrom)
        let evolveFrom = meta.evolvesFrom || meta.evolveFrom || [];
        console.log(`[Memory Light Menu] evolveFrom (raw):`, evolveFrom, `type: ${typeof evolveFrom}`);
        
        // If evolveFrom is a string, we need to look it up
        if (typeof evolveFrom === 'string' && evolveFrom.trim()) {
          console.log(`[Memory Light Menu] evolveFrom is a string, looking up: "${evolveFrom}"`);
          // Try to find the card by name in multiple locations
          try {
            const ownerDiv = cardImg.closest('#player1, #player2');
            const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
            const evolveFromLower = evolveFrom.toLowerCase();
            const matchingCards = [];
            
            // 1. Check Pokemon in play (active/bench) - they have set/num on the image
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
            const pokemonInPlay = [
              ...(activeDiv?.querySelectorAll('img') || []),
              ...(benchDiv?.querySelectorAll('img') || [])
            ];
            
            for (const pokemonImg of pokemonInPlay) {
              const pokemonName = (pokemonImg.alt || '').toLowerCase();
              if (pokemonName === evolveFromLower || pokemonName.includes(evolveFromLower) || evolveFromLower.includes(pokemonName)) {
                const set = pokemonImg.dataset.set;
                const num = pokemonImg.dataset.num;
                if (set && num) {
                  matchingCards.push({ set, number: num });
                  console.log(`[Memory Light Menu] Found ${evolveFrom} in play: ${set}-${num}`);
                }
              }
            }
            
            // 2. Check hand (with strict matching)
            if (matchingCards.length === 0) {
              const hand = playerState[owner]?.hand || [];
              for (const card of hand) {
                const cardName = (card.name || '').toLowerCase();
                // Use exact match only to avoid false positives
                if (cardName === evolveFromLower) {
                  matchingCards.push({ set: card.set, number: card.number || card.num });
                  console.log(`[Memory Light Menu] Found ${evolveFrom} in hand: ${card.set}-${card.number || card.num}`);
                }
              }
            }
            
            // 3. Check deck (with strict matching and verification)
            if (matchingCards.length === 0) {
              const deck = playerState[owner]?.deck || [];
              for (const card of deck) {
                try {
                  const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                  const cardName = (cardMeta.name || '').toLowerCase();
                  // Use exact match and verify it's a Pokemon
                  if (cardMeta.category === 'Pokemon' && cardName === evolveFromLower) {
                    matchingCards.push({ set: card.set, number: card.number || card.num });
                    console.log(`[Memory Light Menu] Found ${evolveFrom} in deck: ${card.set}-${card.number || card.num}`);
                  }
                } catch {}
              }
            }
            
            // 4. Check discard (with strict matching and verification)
            if (matchingCards.length === 0) {
              const discard = playerState[owner]?.discard?.cards || [];
              for (const card of discard) {
                const cardName = (card.name || '').toLowerCase();
                // Use exact match only for discard to avoid false positives
                if (cardName === evolveFromLower) {
                  // Verify it's actually a Pokemon by fetching metadata
                  try {
                    const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                    if (cardMeta && cardMeta.category === 'Pokemon' && cardMeta.name && cardMeta.name.toLowerCase() === evolveFromLower) {
                      matchingCards.push({ set: card.set, number: card.number || card.num });
                      console.log(`[Memory Light Menu] Found ${evolveFrom} in discard: ${card.set}-${card.number || card.num}`);
                    }
                  } catch (err) {
                    console.warn(`[Memory Light Menu] Failed to verify discard card ${card.set}-${card.number || card.num}:`, err);
                  }
                }
              }
            }
            
            if (matchingCards.length > 0) {
              evolveFrom = matchingCards; // Convert to array format
              console.log(`[Memory Light Menu] ‚úÖ Found ${matchingCards.length} matching evolution(s)`);
            } else {
              // 5. Last resort: Try to find card by name using API search (similar to Rare Candy)
              console.log(`[Memory Light Menu] Not found in locations, trying API search for: "${evolveFrom}"`);
              try {
                // Try common sets to find the card
                const commonSets = ['A1', 'A1a', 'A2', 'A2a', 'A2b', 'A3', 'A3a', 'A3b', 'A4', 'A4a'];
                const evolveFromLower = evolveFrom.toLowerCase();
                
                for (const set of commonSets) {
                  try {
                    // Try to fetch set data and search for the card
                    const setResponse = await fetch(`https://api.tcgdex.net/v2/en/sets/${set}`);
                    if (!setResponse.ok) continue;
                    const setData = await setResponse.json();
                    if (setData?.cards) {
                      for (const card of setData.cards) {
                        const cardName = (card.name || '').toLowerCase();
                        if (cardName === evolveFromLower || cardName.includes(evolveFromLower) || evolveFromLower.includes(cardName)) {
                          const localId = card.localId || card.number;
                          if (localId) {
                            matchingCards.push({ set, number: localId });
                            console.log(`[Memory Light Menu] ‚úÖ Found ${evolveFrom} via API: ${set}-${localId}`);
                            break;
                          }
                        }
                      }
                    }
                    if (matchingCards.length > 0) break;
                  } catch (err) {
                    console.warn(`[Memory Light Menu] Failed to search set ${set}:`, err);
                  }
                }
                
                if (matchingCards.length > 0) {
                  evolveFrom = matchingCards;
                } else {
                  console.log(`[Memory Light Menu] ‚ö†Ô∏è Could not find ${evolveFrom} in any location or API`);
                  evolveFrom = [];
                }
              } catch (err) {
                console.error('[Memory Light Menu] ‚ùå Error in API search:', err);
                evolveFrom = [];
              }
            }
          } catch (err) {
            console.error('[Memory Light Menu] ‚ùå Error looking up evolution:', err);
            evolveFrom = [];
          }
        }
        
        console.log(`[Memory Light Menu] evolveFrom array (processed):`, evolveFrom, `length: ${Array.isArray(evolveFrom) ? evolveFrom.length : 0}`);
        
        // Build the full evolution chain recursively
        // Pass evolvedViaRareCandy as skipFirstLevel to skip Stage 1 for Rare Candy evolutions
        const ownerDiv = cardImg.closest('#player1, #player2');
        const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
        const fullChain = await buildEvolutionChain(meta, owner, new Set(), evolvedViaRareCandy);
        console.log(`[Memory Light Menu] Full evolution chain:`, fullChain.map(m => m.name));
        
        if (fullChain.length > 0) {
          if (evolvedViaRareCandy) {
            // If evolved via Rare Candy, only get attacks from the Basic Pokemon (last in chain)
            // The Stage 1 was already skipped in buildEvolutionChain, so chain only contains Basic
            const basicMeta = fullChain[fullChain.length - 1]; // Last one is the deepest (Basic)
            console.log(`[Memory Light Menu] Rare Candy - fetching Basic only:`, basicMeta.name);
            if (basicMeta?.attacks) {
              attacks = [...attacks, ...basicMeta.attacks];
              console.log(`[Memory Light Menu] ‚úÖ Added ${basicMeta.attacks.length} attacks from Basic ${basicMeta.name} (Rare Candy evolution). Total attacks now: ${attacks.length}`);
            } else {
              console.log(`[Memory Light Menu] ‚ö†Ô∏è Basic ${basicMeta?.name} has no attacks`);
            }
          } else {
            // Normal evolution: get attacks from ALL previous evolutions in the chain
            console.log(`[Memory Light Menu] Normal evolution - fetching all ${fullChain.length} previous evolutions`);
            for (const prevEvoMeta of fullChain) {
              console.log(`[Memory Light Menu] Processing evolution:`, prevEvoMeta.name, `attacks: ${prevEvoMeta?.attacks?.length || 0}`);
              if (prevEvoMeta?.attacks) {
                attacks = [...attacks, ...prevEvoMeta.attacks];
                console.log(`[Memory Light Menu] ‚úÖ Added ${prevEvoMeta.attacks.length} attacks from ${prevEvoMeta.name}. Total attacks now: ${attacks.length}`);
              } else {
                console.log(`[Memory Light Menu] ‚ö†Ô∏è ${prevEvoMeta?.name} has no attacks`);
              }
            }
          }
        } else {
          console.log(`[Memory Light Menu] ‚ö†Ô∏è No previous evolutions found in chain`);
        }
      } else {
        console.log(`[Memory Light Menu] Tool effect type is not use_previous_evolution_attacks: ${toolEffect?.effect_type}`);
      }
    } catch (err) {
      console.error('[Memory Light Menu] ‚ùå Error checking tool:', err);
    }
  } else {
    console.log(`[Memory Light Menu] No tool data or missing set/num`);
  }
  
  console.log(`[Memory Light Menu] Final attacks count: ${attacks.length}`);
  
  // Process attacks - need to use for...of for async
  for (const atk of attacks) {
    // üÜï A2 MOVE EFFECT - Check if this specific attack is locked
    const isLocked = cardImg.dataset.lockedAttack === atk.name;
    
    // üÜï A3a MOVE EFFECT - Check for move-specific locks (Buzzwole ex - Big Beat)
    let isMoveLocked = false;
    const instanceId = cardImg.dataset.instanceId;
    const moveName = atk.name?.toLowerCase();
    const currentTurn = globalThis.turnNumber || 0;
    
    console.log(`[Move Lock Menu] Checking ${atk.name} for ${cardImg.alt}: instanceId=${instanceId}, moveName=${moveName}, pk=${pk}, currentTurn=${currentTurn}`);
    console.log(`[Move Lock Menu] __moveLocks structure:`, globalThis.__moveLocks);
    
    if (instanceId && moveName && globalThis.__moveLocks?.[pk]?.[instanceId]?.[moveName]) {
      const moveLock = globalThis.__moveLocks[pk][instanceId][moveName];
      console.log(`[Move Lock Menu] Found lock for ${atk.name}:`, moveLock);
      
      if (typeof moveLock === 'object' && moveLock.lockedOnTurn !== undefined) {
        // Lock was applied on turn N (player's turn), it's locked during the player's NEXT turn
        // The player's next turn is 2 turns later (to skip the opponent's turn)
        // So: turn N (use Big Beat) ‚Üí turn N+1 (opponent) ‚Üí turn N+2 (player's next turn, locked)
        isMoveLocked = currentTurn === moveLock.lockedOnTurn + 2;
        console.log(`[Move Lock Menu] Checking lock for ${atk.name}: currentTurn=${currentTurn}, lockedOnTurn=${moveLock.lockedOnTurn}, isMoveLocked=${isMoveLocked} (lock active on turn ${moveLock.lockedOnTurn + 2})`);
      } else {
        // Backwards compat: if it's just true, treat as locked
        isMoveLocked = moveLock === true;
        console.log(`[Move Lock Menu] Using backwards compat lock check: isMoveLocked=${isMoveLocked}`);
      }
    } else {
      console.log(`[Move Lock Menu] No lock found for ${atk.name} - instanceId: ${instanceId}, moveName: ${moveName}, lock exists: ${!!globalThis.__moveLocks?.[pk]?.[instanceId]?.[moveName]}`);
    }
    
    // üÜï A3a MOVE EFFECT - Check for all-attacks lock (Aggron - Giga Impact, Necrozma - Prismatic Laser)
    // Check if all attacks are locked (Dragonite ex - Giga Impact, etc.)
    const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
    let isAllAttacksLocked = false;
    if (attackLock) {
      const currentTurn = globalThis.turnNumber || 0;
      if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
        isAllAttacksLocked = currentTurn === attackLock.lockedOnTurn + 2;
      } else if (attackLock === true) {
        isAllAttacksLocked = true; // Backwards compat
      }
    }
    
    // üÜï A4a - reduce_energy_cost_if_damaged (Boltund - Thunder Fang)
    // Check if this Pokemon has damage and the attack has this effect
    // Initialize actualCost BEFORE using it in canPay calculation
    let actualCost = atk.cost || [];
    if (typeof globalThis.getMoveRow === 'function') {
      try {
        const moveRow = globalThis.getMoveRow(cardImg.alt, atk.name);
        // getMoveRow is synchronous
        if (moveRow?.effect_type === 'reduce_energy_cost_if_damaged') {
          // Check if Pokemon has damage
          const maxHp = parseInt(cardImg.dataset.hp || '0', 10);
          const curHp = parseInt(cardImg.dataset.chp || maxHp, 10);
          if (curHp < maxHp) {
            // Reduce cost by param1 (number of energy to reduce)
            const reduceAmount = parseInt(moveRow.param1 || '1', 10);
            // Remove up to reduceAmount energy from cost
            actualCost = [...actualCost];
            for (let i = 0; i < reduceAmount && actualCost.length > 0; i++) {
              actualCost.pop(); // Remove last energy
            }
            console.log(`[reduce_energy_cost_if_damaged] Reduced cost by ${reduceAmount}, new cost:`, actualCost);
          }
        }
      } catch (err) {
        console.error('[reduce_energy_cost_if_damaged] Error:', err);
      }
    }
    
    const pips = countPipsOn(slot);
    // Use actualCost (may be reduced) for payment check
    const canPay = !isLocked && !isMoveLocked && !isAllAttacksLocked && canPayCostFromAPI(slot, actualCost, cardImg);

    const attackBox = document.createElement('div');
    attackBox.className = 'ptcgl-attack-overlay';
    
    // Add locked class if attack is blocked
    if (isLocked || isMoveLocked || isAllAttacksLocked) {
      attackBox.classList.add('locked');
      attackBox.style.opacity = '0.5';
      attackBox.style.cursor = 'not-allowed';
      if (isMoveLocked) {
        attackBox.title = `This Pok√©mon can't use ${atk.name} this turn!`;
      } else if (isAllAttacksLocked) {
        attackBox.title = `This Pok√©mon can't attack this turn!`;
      }
    }
    
    // Add Pokemon type class for coloring
    const pokemonType = (type0 || 'colorless').toLowerCase();
    attackBox.classList.add('type-' + pokemonType);
    
    if (canPay) attackBox.classList.add('payable');

    // Create cost icons with CORRECT energy types (using actualCost)
    const costHTML = actualCost.map(energyType => {
      const type = String(energyType).toLowerCase();
      return `<div class="ptcgl-cost-icon" style="background-image: url('${energyIconUrl(type)}')"></div>`;
    }).join('');

    const attackHeader = document.createElement('div');
    attackHeader.className = 'ptcgl-attack-header';
    
    const attackLeft = document.createElement('div');
    attackLeft.className = 'ptcgl-attack-left';
    
    const attackName = document.createElement('span');
    attackName.className = 'ptcgl-attack-name';
    attackName.textContent = atk.name || 'Attack';
    
    // #4 - Color attack name based on type if payable
    if (canPay) {
      attackName.classList.add(`type-${type0.toLowerCase()}`);
    }
    
    // Left side: name and cost
    const attackInfo = document.createElement('div');
    attackInfo.style.display = 'flex';
    attackInfo.style.alignItems = 'center';
    attackInfo.style.gap = '6px';
    
    attackInfo.appendChild(attackName);
    
    const attackCost = document.createElement('div');
    attackCost.className = 'ptcgl-attack-cost';
    attackCost.innerHTML = costHTML;
    attackInfo.appendChild(attackCost);
    
    attackLeft.appendChild(attackInfo);
    
    // Right side: damage (calculate preview damage with all modifiers)
    const damageBox = document.createElement('div');
    damageBox.className = 'ptcgl-attack-damage-box';
    
    const attackDamage = document.createElement('span');
    attackDamage.className = 'ptcgl-attack-damage';
    attackDamage.textContent = atk.damage || ''; // Initial value
    // Calculate preview damage asynchronously and update
    (async () => {
      try {
        const previewResult = await calculatePreviewDamage(atk, cardImg, meta, pk);
        let previewDamage = typeof previewResult === 'object' ? previewResult.damage : previewResult;
        // Ensure we have a valid number or string
        if (typeof previewDamage === 'object') previewDamage = '';
        attackDamage.textContent = String(previewDamage || '');
        
        // Apply color styling based on boost type
        if (typeof previewResult === 'object') {
          // Reset styles
          attackDamage.style.setProperty('color', '', 'important');
          attackDamage.style.setProperty('text-shadow', '', 'important');
          
          if (previewResult.hasWeakness) {
            // Green for weakness (takes priority, even if other boosts exist)
            attackDamage.style.setProperty('color', '#22c55e', 'important');
            attackDamage.style.setProperty('text-shadow', '0 0 8px rgba(34, 197, 94, 0.6), 0 0 4px rgba(34, 197, 94, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else if (previewResult.hasOtherBoosts) {
            // Golden for other effects
            attackDamage.style.setProperty('color', '#fbbf24', 'important');
            attackDamage.style.setProperty('text-shadow', '0 0 8px rgba(251, 191, 36, 0.6), 0 0 4px rgba(251, 191, 36, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else {
            // Black (default) for no boosts
            attackDamage.style.setProperty('color', '#000000', 'important');
            attackDamage.style.setProperty('text-shadow', '0 1px 3px rgba(0,0,0,0.5)', 'important');
          }
        }
      } catch (err) {
        console.error('[preview] Error calculating damage:', err);
        // Keep original value on error
      }
    })();
    damageBox.appendChild(attackDamage);
    
    attackLeft.appendChild(damageBox);
    
    attackHeader.appendChild(attackLeft);
    
    attackBox.appendChild(attackHeader);

    if (atk.effect) {
      const attackEffect = document.createElement('div');
      attackEffect.className = 'ptcgl-attack-effect';
      attackEffect.textContent = atk.effect;
      attackBox.appendChild(attackEffect);
    }

    // #7 - Attack should actually work
    if (canPay) {
      attackBox.addEventListener('click', () => {
        handleAttackClick(atk, meta, ownerKey, activeDiv);
        closeAttackMenu();
      });
    }

    actionsOverlay.appendChild(attackBox);
  }

  // Add actions overlay to card
  cardContainer.appendChild(actionsOverlay);

  // RETREAT - bottom right corner ONLY (#6)
  // Fossils cannot retreat!
  const retreatCost = computeRetreatCost(activeDiv, meta);
  const pips = countPipsOn(slot);
  
  // Check if retreat is allowed (considering status, locks, etc.)
  // pk already declared above, reuse it
  const retreatAllowed = typeof canRetreat === 'function' ? canRetreat(pk) : true;
  const canPayCost = !isFossil && pips.total >= retreatCost && !hasRetreatedThisTurn;
  const canRetreatFinal = retreatAllowed && canPayCost;

  const retreatCorner = document.createElement('div');
  retreatCorner.className = 'ptcgl-retreat-corner';
  if (!canRetreatFinal) retreatCorner.classList.add('disabled');
  
  // Show "Can't Retreat" for fossils
  if (isFossil) {
    retreatCorner.title = "Fossils cannot retreat";
  }
  
  // Show appropriate message for sleep/paralysis
  if (!retreatAllowed && !isFossil) {
    const activeImg = activeDiv.querySelector('img');
    const st = (activeImg?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      retreatCorner.title = "Can't retreat - Pok√©mon is asleep";
    } else if (st === 'paralyzed') {
      retreatCorner.title = "Can't retreat - Pok√©mon is paralyzed";
    } else {
      retreatCorner.title = "Can't retreat - Pok√©mon is locked";
    }
  }
  
  // Add type-based coloring if retreat is available
  if (canRetreatFinal) {
    const mainType = (meta.types && meta.types[0]) ? String(meta.types[0]).toLowerCase() : null;
    if (mainType) {
      retreatCorner.setAttribute('data-type', mainType);
      console.log('[RETREAT CORNER] Set data-type:', mainType);
    }
  }

  const costIcons = Array(retreatCost).fill(0).map(() => 
    `<div class="ptcgl-cost-icon" style="background-image: url('${energyIconUrl('colorless')}')"></div>`
  ).join('');

  retreatCorner.innerHTML = `
    <div class="ptcgl-retreat-label">Retreat</div>
    <div class="ptcgl-retreat-cost">${costIcons}</div>
    <div class="ptcgl-retreat-icon">‚Ü©</div>
  `;

  // #7 - Retreat should work
  if (canRetreatFinal) {
    retreatCorner.addEventListener('click', () => {
      handleRetreat(activeDiv, meta, retreatCost);
      // Note: handleRetreat closes menu internally, no need to close again
    });
  }

  cardContainer.appendChild(retreatCorner);

  // Weakness corner (optional - bottom left)
  if (meta.weaknesses && meta.weaknesses.length > 0) {
    const wk = meta.weaknesses[0];
    const wkType = String(wk.type || '').toLowerCase();
    const weaknessCorner = document.createElement('div');
    weaknessCorner.className = 'ptcgl-weakness-corner';
    weaknessCorner.innerHTML = `
      <span class="ptcgl-weakness-label">WEAKNESS</span>
      <div class="ptcgl-weakness-icon" style="background-image: url('${energyIconUrl(wkType)}')"></div>
      <span class="ptcgl-weakness-value">√ó${wk.value || '2'}</span>
    `;
    cardContainer.appendChild(weaknessCorner);
  }

  menu.appendChild(cardContainer);

  // Append to body
  document.body.appendChild(menu);

  // Click outside menu to close with shrink animation
  setTimeout(() => {
    const closeOnClickOutside = (e) => {
      if (!menu.contains(e.target)) {
        if (abilityJustUsed) {
          console.log('[MENU-CLOSE] Blocked close - ability just used');
          return;
        }
        
        document.removeEventListener('click', closeOnClickOutside);
        
        // Animate back to card position (same as close button)
        const cardRect = cardImg.getBoundingClientRect();
        const returnX = cardRect.left + cardRect.width / 2;
        const returnY = cardRect.top + cardRect.height / 2;
        
        menu.style.willChange = 'transform, opacity, left, top';
        menu.style.transition = 'all 0.25s cubic-bezier(0.4, 0, 0.2, 1)';
        menu.style.left = returnX + 'px';
        menu.style.top = returnY + 'px';
        menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
        menu.style.opacity = '0';
        
        setTimeout(() => {
          menu.style.willChange = 'auto';
          closeAttackMenu();
        }, 250);
      }
    };
    
    // Store reference to listener so it can be removed later
    menu._clickOutsideHandler = closeOnClickOutside;
    document.addEventListener('click', closeOnClickOutside);
    console.log('[MENU] Added closeOnClickOutside listener');
  }, delayForRetreat);  // Variable delay

  // Get card's starting position for animation
  const cardRect = cardImg.getBoundingClientRect();
  const startX = cardRect.left + cardRect.width / 2;
  const startY = cardRect.top + cardRect.height / 2;
  
  // Calculate target position in pixels (30% from left)
  const targetX = window.innerWidth * 0.30;
  const targetY = window.innerHeight * 0.50;
  
  // Set initial position to card's location
  menu.style.position = 'fixed';
  menu.style.left = startX + 'px';
  menu.style.top = startY + 'px';
  menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
  menu.style.opacity = '0';
  
  // Force a reflow to ensure initial position is set
  void menu.offsetHeight;
  
  // Animate DIRECTLY to left position - use will-change for smoother animation
  menu.style.willChange = 'transform, opacity, left, top';
  requestAnimationFrame(() => {
    menu.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
    
    // After a frame, move DIRECTLY to final position (no intermediate)
    requestAnimationFrame(() => {
      // Set final position in one go
      menu.style.left = targetX + 'px';
      menu.style.top = targetY + 'px';
      menu.style.transform = 'translate(-50%, -50%) scale(1)';
      menu.style.opacity = '1';
      menu.classList.add('show');
      
      // Remove will-change after animation completes and ensure position stays
      setTimeout(() => {
        // Force position to stay fixed - prevent any CSS from overriding
        menu.style.position = 'fixed';
        menu.style.left = targetX + 'px';
        menu.style.top = targetY + 'px';
        menu.style.willChange = 'auto';
      }, 350);
    });
  });

  openAttackMenu = menu;
  
  // Add escape key handler (#2)
  const escapeHandler = (e) => {
    if (e.key === 'Escape') {
      // Animate back to card position
      const cardRect = cardImg.getBoundingClientRect();
      const returnX = cardRect.left + cardRect.width / 2;
      const returnY = cardRect.top + cardRect.height / 2;
      
      menu.style.transition = 'all 0.25s ease-in';
      menu.style.left = returnX + 'px';
      menu.style.top = returnY + 'px';
      menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
      menu.style.opacity = '0';
      
      setTimeout(() => {
        closeAttackMenu();
        document.removeEventListener('keydown', escapeHandler);
      }, 250);
    }
  };
  document.addEventListener('keydown', escapeHandler);
  menu._escapeHandler = escapeHandler;
}






/**
 * Apply type-based colors to attack menu items
 * @param {string} type - Pokemon type (e.g., 'psychic', 'fire', 'grass')
 */
function applyTypesToAttackMenu(type) {
  if (!type) return;
  
  const typeLower = type.toLowerCase();
  
  // Apply to ability rows
  const abilityRows = document.querySelectorAll('.attack-ability-row');
  abilityRows.forEach(row => {
    row.setAttribute('data-type', typeLower);
  });
  
  const abilityWrappers = document.querySelectorAll('.attack-ability-wrapper');
  abilityWrappers.forEach(wrapper => {
    wrapper.setAttribute('data-type', typeLower);
  });
  
  // Apply to attack items
  const attackItems = document.querySelectorAll('.attack-item');
  attackItems.forEach(item => {
    item.setAttribute('data-type', typeLower);
  });
}

// Expose to global
globalThis.isActiveBlockedFromAttacking = isActiveBlockedFromAttacking;

/* ========================================
   DEBUG: Check What's Preventing Clicks
======================================== */

// Add this temporarily to see what's blocking:
console.log('[debug] Click handler state:', {
  currentPlayer,
  isEvoMode,
  toolAttachPending,
  selectedEnergy,
  isPromotionPhase,
  gameOver
});

const zoomStatus = document.getElementById("zoomStatus");

/* evolution click */
document.body.addEventListener('click',async e=>{
  if(!isEvoMode)return;
  const target=e.target.closest('img.glow-evo');
  if(!target)return;
  e.stopPropagation();
  await evolveCard(target,evoMeta,evoHandCard,evoOwner,evoHandCard.dataset.set,evoHandCard.dataset.num);
  clearGlow();
});
/* promotion helpers: attachments follow their Pok√©mon */
/* ========================================
   ABILITY HELPER FUNCTIONS
======================================== */

// Global ability cache for faster synchronous lookups
globalThis.abilityCache = {};

// Populate ability cache when abilities are loaded
async function populateAbilityCache() {
  if (!window.ABILITY_EFFECT_ROWS) {
    console.log('[ability-cache] ABILITY_EFFECT_ROWS not yet loaded');
    return false;
  }
  
  globalThis.abilityCache = {}; // Clear before repopulating
  
  for (const row of window.ABILITY_EFFECT_ROWS) {
    const set = row.set;
    const num = row.number;
    
    // Store under multiple formats to handle both "009" and "9"
    const keyPadded = `${set}-${num}`; // e.g., "A2a-009"
    const keyUnpadded = `${set}-${parseInt(num, 10)}`; // e.g., "A2a-9"
    
    globalThis.abilityCache[keyPadded] = row;
    globalThis.abilityCache[keyUnpadded] = row;
  }
  console.log('[ability-cache] Populated with', Object.keys(globalThis.abilityCache).length, 'abilities (with multiple key formats)');
  console.log('[ability-cache] Sample keys:', Object.keys(globalThis.abilityCache).slice(0, 10));
  return true;
}

// Call this after abilities are loaded - with retry mechanism
if (window.ABILITY_EFFECT_ROWS) {
  populateAbilityCache();
} else {
  console.log('[ability-cache] Will retry population...');
  // Retry every 500ms for up to 10 seconds
  let retries = 0;
  const maxRetries = 20;
  const retryInterval = setInterval(() => {
    retries++;
    if (populateAbilityCache()) {
      clearInterval(retryInterval);
    } else if (retries >= maxRetries) {
      console.warn('[ability-cache] Failed to load after', maxRetries, 'retries');
      clearInterval(retryInterval);
    }
  }, 500);
}

// Expose for manual population
globalThis.populateAbilityCache = populateAbilityCache;

// Helper: Check if player has Arceus or Arceus ex in play
function hasArceusInPlay(pk) {
  const activeDiv = pk === 'p1' ? p1Active : p2Active;
  const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
  
  const activeImg = activeDiv ? activeDiv.querySelector('img') : null;
  const benchImgs = benchDiv ? [...benchDiv.querySelectorAll('img')] : [];
  
  const allPokemon = [activeImg, ...benchImgs].filter(Boolean);
  
  const hasArceus = allPokemon.some(img => {
    const name = (img.alt || '').toLowerCase();
    return name.includes('arceus');
  });
  
  console.log(`[arceus-check-battle] Player ${pk} has ${allPokemon.length} Pokemon`);
  console.log(`[arceus-check-battle] Pokemon names:`, allPokemon.map(img => img.alt));
  console.log(`[arceus-check-battle] Has Arceus: ${hasArceus}`);
  
  return hasArceus;
}

// Expose to effects.js
globalThis.hasArceusInPlay = hasArceusInPlay;

// Helper: Get ability row for a Pokemon (async)
globalThis.getAbilityRow = async function(set, num) {
  const key = `${set}-${num}`;
  if (globalThis.abilityCache && globalThis.abilityCache[key]) {
    return globalThis.abilityCache[key];
  }
  
  // Fallback: search in ABILITY_EFFECT_ROWS
  if (!window.ABILITY_EFFECT_ROWS) return null;
  
  const numPadded = String(num || '').padStart(3, '0');
  const row = window.ABILITY_EFFECT_ROWS.find(r =>
    r.set === set && String(r.number).padStart(3, '0') === numPadded
  );
  
  return row || null;
};

function getPassiveDamageReduction(pk) {
  const img = getActiveImg(pk);
  if (!img) return 0;
  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const setId = img.dataset.set;
  const numId = String(img.dataset.num || '').padStart(3, '0');
  
  const row = abilityRows.find(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === numId &&
    r.abilityType === 'passive' &&
    r.effect_type === 'reduce_incoming_damage'
  );
  
  if (row) {
    return parseInt(row.param1 || '0', 10);
  }
  
  return 0;
}

function shouldBlockDamageFromEx(pk, attackerImg) {
  if (!attackerImg) return false;
  
  const img = getActiveImg(pk);
  if (!img) return false;
  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const setId = img.dataset.set;
  const numId = String(img.dataset.num || '').padStart(3, '0');
  
  const row = abilityRows.find(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === numId &&
    r.abilityType === 'passive' &&
    r.effect_type === 'prevent_damage_from_ex'
  );
  
  if (row) {
    // Check if attacker is an ex Pokemon
    const attackerName = (attackerImg.alt || '').toLowerCase();
    const isEx = attackerName.includes(' ex');
    
    if (isEx) {
      console.log('[Safeguard] Blocking damage from', attackerImg.alt);
      return true;
    }
  }
  
  return false;
}

function getCounterattackDamage(pk) {
  const img = getActiveImg(pk);
  if (!img) return 0;
  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const setId = img.dataset.set;
  const numId = String(img.dataset.num || '').padStart(3, '0');
  
  const row = abilityRows.find(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === numId &&
    r.abilityType === 'passive' &&
    r.effect_type === 'counter_on_hit'
  );
  
  if (row) {
    return parseInt(row.param1 || '0', 10);
  }
  
  return 0;
}

// üÜï A2 PASSIVE ABILITY HELPERS

/**
 * Get passive ability row for a Pokemon
 */
function getPassiveAbility(pokemonImg, effectType) {
  if (!pokemonImg || !effectType) return null;
  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const setId = pokemonImg.dataset.set;
  const numId = String(pokemonImg.dataset.num || '').padStart(3, '0');
  
  return abilityRows.find(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === numId &&
    r.abilityType === 'passive' &&
    r.effect_type === effectType
  ) || null;
}

/**
 * Check if Pokemon has a passive ability
 */
function checkPassiveAbility(pokemonImg, effectType) {
  return !!getPassiveAbility(pokemonImg, effectType);
}

/**
 * Get Fighting Coach damage boost for a type
 * Returns total boost amount from all Pokemon with Fighting Coach (stacks)
 */
function getFightingCoachBoost(attackerPk, attackerType) {
  if (!attackerType) return 0;
  
  const allAllies = [getActiveImg(attackerPk), ...getBenchImgs(attackerPk)].filter(Boolean);
  let totalBoost = 0;
  
  for (const ally of allAllies) {
    const coachAbility = getPassiveAbility(ally, 'boost_type_damage');
    if (coachAbility) {
      const boostedType = (coachAbility.param1 || '').toLowerCase();
      const boost = parseInt(coachAbility.param2 || '0', 10);
      
      if (attackerType.toLowerCase() === boostedType) {
        console.log(`[Fighting Coach] ${ally.alt} boosting ${attackerType} by +${boost}`);
        totalBoost += boost;
      }
    }
  }
  
  if (totalBoost > 0) {
    console.log(`[Fighting Coach] Total boost: +${totalBoost}`);
  }
  
  return totalBoost;
}

/**
 * Calculate damage reduction from Thick Fat
 * Checks if defender has Thick Fat and attacker is Fire/Water type
 */
function getThickFatReduction(defenderImg, attackerType) {
  if (!defenderImg || !attackerType) return 0;
  
  const thickFat = getPassiveAbility(defenderImg, 'reduce_damage_from_types');
  if (!thickFat) return 0;
  
  const reducedTypes = (thickFat.param1 || '').split(';');
  const reduction = parseInt(thickFat.param2 || '0', 10);
  
  if (reducedTypes.includes(attackerType.toLowerCase())) {
    console.log(`[Thick Fat] Reducing ${reduction} damage from ${attackerType}`);
    return reduction;
  }
  
  return 0;
}

/**
 * Apply Guarded Grill flip reduction
 * Flips coin, if heads reduces damage by 100
 */
function applyGuardedGrill(defenderImg, baseDamage) {
  if (!defenderImg || baseDamage <= 0) return baseDamage;
  
  const grill = getPassiveAbility(defenderImg, 'flip_reduce_damage');
  if (!grill) return baseDamage;
  
  const reduction = parseInt(grill.param1 || '0', 10);
  const flip = Math.random() < 0.5;
  
  console.log(`[Guarded Grill] Flipped: ${flip ? 'Heads' : 'Tails'}`);
  
  if (flip) {
    const newDamage = Math.max(0, baseDamage - reduction);
    showPopup(`Guarded Grill: Heads! Reduced ${reduction} damage.`);
    return newDamage;
  } else {
    showPopup(`Guarded Grill: Tails! No reduction.`);
    return baseDamage;
  }
}

/**
 * Check if defender has Crystal Body (blocks attack effects)
 */
function hasCrystalBody(defenderImg) {
  return checkPassiveAbility(defenderImg, 'block_attack_effects');
}

/**
 * Check if Pokemon has Levitate and should have zero retreat cost
 */
function hasLevitateZeroRetreat(pokemonImg) {
  if (!pokemonImg) return false;
  
  const levitate = getPassiveAbility(pokemonImg, 'zero_retreat_if_energy');
  if (!levitate) return false;
  
  // Check if has any energy
  const slot = pokemonImg.closest('.card-slot');
  if (!slot) return false;
  
  const energyBox = slot.querySelector('.energy-pips');
  const hasEnergy = energyBox && energyBox.querySelectorAll('.energy-pip').length > 0;
  
  if (hasEnergy) {
    console.log(`[Levitate] ${pokemonImg.alt} has energy - retreat cost = 0`);
    return true;
  }
  
  return false;
}

/**
 * Trigger Nightmare Aura when attaching Dark energy
 */
function triggerNightmareAura(pokemonImg, energyType) {
  if (!pokemonImg || !energyType) return;
  
  const aura = getPassiveAbility(pokemonImg, 'damage_on_energy_attach');
  if (!aura) return;
  
  const triggerType = (aura.param1 || '').toLowerCase();
  const damage = parseInt(aura.param2 || '0', 10);
  
  if (energyType.toLowerCase() === triggerType) {
    console.log(`[Nightmare Aura] Triggered! Dealing ${damage} damage`);
    
    // Damage opponent's active Pokemon
    const ownerDiv = pokemonImg.closest('#player1, #player2');
    const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
    const opponent = owner === 'player1' ? 'player2' : 'player1';
    
    setTimeout(async () => {
      const result = await damageActiveOf(opponent, damage, { isDirectAttack: false });
      showPopup(`Nightmare Aura: ${damage} damage!`);
      
      // Check if Nightmare Aura KO'd the opponent
      if (result.knocked && typeof handleKnockOut === 'function') {
        console.log('[nightmare-aura] Opponent knocked out by Nightmare Aura!');
        const oppImg = getActiveImage(opponent);
        if (oppImg) {
          const gameEnded = await handleKnockOut(opponent, oppImg, true);
          if (!gameEnded && typeof beginPromotionFlow === 'function') {
            await beginPromotionFlow(opponent);
          }
        }
      }
    }, 300);
  }
}

function isGengarBlocking(player) {
  const opp = player === 'player1' ? 'player2' : 'player1';
  const oppActiveImg = getActiveImage(opp);
  
  if (!oppActiveImg) return false;
  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const setId = oppActiveImg.dataset.set;
  const numId = String(oppActiveImg.dataset.num || '').padStart(3, '0');
  
  const row = abilityRows.find(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === numId &&
    r.abilityType === 'passive' &&
    r.effect_type === 'block_supporters'
  );
  
  return !!row;
}

// Expose to global
globalThis.getActiveImg = getActiveImg;
globalThis.getPassiveDamageReduction = getPassiveDamageReduction;
globalThis.getCounterattackDamage = getCounterattackDamage;
globalThis.isGengarBlocking = isGengarBlocking;

function detachAttachments(slot){
  if (!slot) return { energy: null, hp: null, toolThumb: null, toolData: null, maxHp: null };
  const energy    = slot.querySelector('.energy-pips');
  const hp        = slot.querySelector('.hp-overlay');
  const toolThumb = slot.querySelector('.tool-thumb');

  if (energy)    energy.remove();
  if (hp)        hp.remove();
  if (toolThumb) toolThumb.remove();

  const toolData = getToolDataFromSlot(slot);
  if (toolData) setToolDataOnSlot(slot, null);
  
  // Also detach maxHp data (for Giant Cape / Leaf Cape)
  const maxHp = slot.dataset.maxHp || null;
  if (maxHp) delete slot.dataset.maxHp;

  return { energy, hp, toolThumb, toolData, maxHp };
}
globalThis.detachAttachments = detachAttachments;

function attachAttachments(slot, pack){
  if (!slot || !pack) return;
  const { energy, hp, toolThumb, toolData, maxHp } = pack;
  if (energy)    slot.appendChild(energy);
  if (hp)        slot.appendChild(hp);
  if (toolThumb) slot.appendChild(toolThumb);
  if (toolData)  setToolDataOnSlot(slot, toolData);
  
  // Restore maxHp data (for Giant Cape / Leaf Cape)
  if (maxHp) {
    slot.dataset.maxHp = maxHp;
  } else {
    // Make sure maxHp is cleared if it wasn't in the pack
    delete slot.dataset.maxHp;
  }
}
globalThis.attachAttachments = attachAttachments;

function beginPromotionFlow(owner){
  return new Promise((resolve) => {
  isPromotionPhase = true;

  const benchImgs = [...benchFor(owner).querySelectorAll('img')];
  if (!benchImgs.length) {
    const foe = owner === 'player1' ? 'player2' : 'player1';
    showVictory(foe, 'Bench out');
    isPromotionPhase = false;
      resolve();
    return;
  }

  benchImgs.forEach(img => img.classList.add('promote-glow'));
  showPopup('Choose a Benched Pok√©mon to promote.');

  const clickOnce = (e) => {
    if (!isPromotionPhase) return;
    
    // Check if this is a forced promotion (from Sabrina/Cyrus)
    const forcedImg = globalThis.__forcedPromotion;
    let chosenImg;
    
    if (forcedImg) {
      // Forced promotion - use the specified Pokemon
      chosenImg = forcedImg;
      globalThis.__forcedPromotion = null;
    } else {
      // Normal promotion - player clicks to choose
      chosenImg = e.target.closest(`#${owner} .bench img`);
      if (!chosenImg) return;
    }

    e.stopPropagation();
    document.body.removeEventListener('click', clickOnce, true);

    const activeDiv  = activeFor(owner);
    const activeSlot = activeDiv.querySelector('.card-slot');
    const benchSlot  = chosenImg.closest('.card-slot');
    const activeImg  = activeSlot.querySelector('img');

    if (activeImg) {
      clearStatusOnImg(activeImg);
    }
    /* CASE 1 ‚Äî Active slot is empty */
    if (!activeImg) {
      const benchPack = detachAttachments(benchSlot);

        // Capture position before DOM changes
        const chosenRect = chosenImg.getBoundingClientRect();

      benchSlot.removeChild(chosenImg);
      activeSlot.appendChild(chosenImg);
        
        // Animate slide for promotion (after DOM changes)
        animateSlideSwap(chosenImg, activeSlot, chosenImg, chosenRect);

      attachAttachments(activeSlot, benchPack);

      markSlot(activeSlot, true);
      markSlot(benchSlot, !!benchSlot.querySelector('img'));

      benchImgs.forEach(x => x.classList.remove('promote-glow'));
      isPromotionPhase = false;

      showPopup(forcedImg ? 'Forced to Active.' : 'Promoted to Active.');
      // Update player background based on new active Pokemon
      const playerNum = activeDiv === p1Active ? 1 : 2;
      updatePlayerTypeBackground(playerNum);
        resolve();
      return;
    }

    /* CASE 2 ‚Äî Swap Active <-> Bench */
      // üÜï A3a - Clear move locks when Pokemon moves to bench (Buzzwole ex - Big Beat)
      const activeInstanceId = activeImg.dataset.instanceId;
      const ownerPk = owner === 'player1' ? 'p1' : 'p2';
      if (activeInstanceId && globalThis.__moveLocks?.[ownerPk]?.[activeInstanceId]) {
        delete globalThis.__moveLocks[ownerPk][activeInstanceId];
        console.log(`[Big Beat] Cleared move locks for ${activeImg.alt} (instanceId: ${activeInstanceId}) - moved to bench via promotion`);
      }
      
    const activePack = detachAttachments(activeSlot);
    const benchPack  = detachAttachments(benchSlot);

      // Capture positions before DOM changes
      const activeRect = activeImg.getBoundingClientRect();
      const chosenRect = chosenImg.getBoundingClientRect();

    activeSlot.removeChild(activeImg);
    benchSlot.removeChild(chosenImg);

    activeSlot.appendChild(chosenImg);
    benchSlot.appendChild(activeImg);
      
      // Animate slide for promotion swap (after DOM changes)
      animateSlideSwap(activeImg, benchSlot, activeImg, activeRect);
      animateSlideSwap(chosenImg, activeSlot, chosenImg, chosenRect);

    attachAttachments(activeSlot, benchPack);
    attachAttachments(benchSlot, activePack);

    markSlot(activeSlot, true);
    markSlot(benchSlot, !!benchSlot.querySelector('img'));

    benchImgs.forEach(x => x.classList.remove('promote-glow'));
    isPromotionPhase = false;

    showPopup(forcedImg ? 'Forced to Active.' : 'Promoted to Active.');
      // Update player background based on new active Pokemon
      const playerNum = activeDiv === p1Active ? 1 : 2;
      updatePlayerTypeBackground(playerNum);
      resolve();
  };

  document.body.addEventListener('click', clickOnce, true);
  });
}

// Make core helpers visible to effects.js after their definitions
globalThis.benchFor           = benchFor;
globalThis.activeFor          = activeFor;
globalThis.beginPromotionFlow = beginPromotionFlow;
globalThis.fetchCardMeta      = fetchCardMeta;
globalThis.ENERGY_ICONS       = ENERGY_ICONS;
globalThis.attachEnergyToSlot = attachEnergyToSlot;
globalThis.energyZoneDiv      = energyZoneDiv;
globalThis.renderEnergyZone   = renderEnergyZone;
globalThis.getActiveImage     = getActiveImage;
globalThis.applyAbilityEffectFromCsv = window.applyAbilityEffectFromCsv;

// üÜï Additional exports for trainer effects
globalThis.evolveCard         = evolveCard;
globalThis.handleKnockOut     = handleKnockOut;
globalThis.damageActiveOf     = damageActiveOf;
globalThis.startTurn          = startTurn;

/* ========= TYPE-BASED BACKGROUNDS ========= */
// Update player background based on active Pok√©mon type
async function updatePlayerTypeBackground(playerNum) {
  const playerId = `player${playerNum}`;
  const playerDiv = document.getElementById(playerId);
  
  // Get the active slot for this player
  const activeDiv = playerNum === 1 ? p1Active : p2Active;
  const activeSlot = activeDiv?.querySelector('.card-slot');
  const activeImg = activeSlot?.querySelector('img');
  
  if (!playerDiv) return;
  
  // If no active Pok√©mon, remove type class and overlay
  if (!activeImg) {
    // Remove all type classes using classList
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    // Remove overlay if it exists
    const overlay = playerDiv.querySelector('.type-overlay');
    if (overlay) {
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 600);
    }
    return;
  }
  
  // Get card metadata
  const set = activeImg.dataset.set;
  const num = activeImg.dataset.num;
  
  if (!set || !num) {
    // Remove all type classes using classList
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    // Remove overlay if it exists
    const overlay = playerDiv.querySelector('.type-overlay');
    if (overlay) {
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 600);
    }
    return;
  }
  
  try {
    // Fetch metadata using existing function
    const meta = await fetchCardMeta(set, num);
    
    // Extract type from metadata
    let pokemonType = 'colorless';
    if (meta.types && meta.types[0]) {
      pokemonType = String(meta.types[0]).toLowerCase();
    }
    
    // Get or create overlay for smooth transition
    let overlay = playerDiv.querySelector('.type-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.className = 'type-overlay';
      overlay.style.position = 'absolute';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.right = '0';
      overlay.style.bottom = '0';
      overlay.style.borderRadius = '16px';
      overlay.style.pointerEvents = 'none';
      overlay.style.zIndex = '0';
      overlay.style.transition = 'opacity 0.6s ease';
      overlay.style.opacity = '0';
      // Insert at the beginning so it's behind other content
      playerDiv.insertBefore(overlay, playerDiv.firstChild);
    }
    
    // Get gradient colors for the type
    const typeGradients = {
      grass: 'linear-gradient(180deg, rgba(34, 197, 94, 0.3) 0%, rgba(22, 163, 74, 0.5) 50%, rgba(21, 128, 61, 0.4) 100%)',
      fire: 'linear-gradient(180deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.5) 50%, rgba(185, 28, 28, 0.4) 100%)',
      water: 'linear-gradient(180deg, rgba(59, 130, 246, 0.3) 0%, rgba(37, 99, 235, 0.5) 50%, rgba(29, 78, 216, 0.4) 100%)',
      lightning: 'linear-gradient(180deg, rgba(234, 179, 8, 0.3) 0%, rgba(202, 138, 4, 0.5) 50%, rgba(161, 98, 7, 0.4) 100%)',
      psychic: 'linear-gradient(180deg, rgba(168, 85, 247, 0.3) 0%, rgba(147, 51, 234, 0.5) 50%, rgba(126, 34, 206, 0.4) 100%)',
      fighting: 'linear-gradient(180deg, rgba(249, 115, 22, 0.3) 0%, rgba(234, 88, 12, 0.5) 50%, rgba(194, 65, 12, 0.4) 100%)',
      darkness: 'linear-gradient(180deg, rgba(100, 116, 139, 0.3) 0%, rgba(71, 85, 105, 0.5) 50%, rgba(51, 65, 85, 0.4) 100%)',
      metal: 'linear-gradient(180deg, rgba(148, 163, 184, 0.3) 0%, rgba(100, 116, 139, 0.5) 50%, rgba(71, 85, 105, 0.4) 100%)',
      dragon: 'linear-gradient(180deg, rgba(211, 186, 48, 0.3) 0%, rgba(184, 158, 32, 0.5) 50%, rgba(169, 142, 28, 0.4) 100%)',
      fairy: 'linear-gradient(180deg, rgba(236, 72, 153, 0.3) 0%, rgba(219, 39, 119, 0.5) 50%, rgba(190, 24, 93, 0.4) 100%)',
      colorless: 'linear-gradient(180deg, rgba(156, 163, 175, 0.3) 0%, rgba(107, 114, 128, 0.5) 50%, rgba(75, 85, 99, 0.4) 100%)'
    };
    
    const typeShadows = {
      grass: '0 0 30px rgba(34, 197, 94, 0.3)',
      fire: '0 0 30px rgba(239, 68, 68, 0.3)',
      water: '0 0 30px rgba(59, 130, 246, 0.3)',
      lightning: '0 0 30px rgba(234, 179, 8, 0.3)',
      psychic: '0 0 30px rgba(168, 85, 247, 0.3)',
      fighting: '0 0 30px rgba(249, 115, 22, 0.3)',
      darkness: '0 0 30px rgba(100, 116, 139, 0.3)',
      metal: '0 0 30px rgba(148, 163, 184, 0.3)',
      dragon: '0 0 30px rgba(211, 186, 48, 0.3)',
      fairy: '0 0 30px rgba(236, 72, 153, 0.3)',
      colorless: '0 0 30px rgba(156, 163, 175, 0.3)'
    };
    
    const typeBorders = {
      grass: '1px solid rgba(34, 197, 94, 0.3)',
      fire: '1px solid rgba(239, 68, 68, 0.3)',
      water: '1px solid rgba(59, 130, 246, 0.3)',
      lightning: '1px solid rgba(234, 179, 8, 0.3)',
      psychic: '1px solid rgba(168, 85, 247, 0.3)',
      fighting: '1px solid rgba(249, 115, 22, 0.3)',
      darkness: '1px solid rgba(100, 116, 139, 0.3)',
      metal: '1px solid rgba(148, 163, 184, 0.3)',
      dragon: '1px solid rgba(211, 186, 48, 0.3)',
      fairy: '1px solid rgba(236, 72, 153, 0.3)',
      colorless: '1px solid rgba(156, 163, 175, 0.3)'
    };
    
    // Fade out old overlay first
    if (overlay.style.opacity !== '0') {
      overlay.style.opacity = '0';
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    // Update overlay with new type
    overlay.style.background = typeGradients[pokemonType] || typeGradients.colorless;
    overlay.style.boxShadow = typeShadows[pokemonType] || typeShadows.colorless;
    overlay.style.border = typeBorders[pokemonType] || typeBorders.colorless;
    
    // Also update the class for box-shadow and border on the player div
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    playerDiv.classList.add(`type-${pokemonType}`);
    
    // Force reflow and fade in
    void overlay.offsetWidth;
    requestAnimationFrame(() => {
      overlay.style.opacity = '1';
    });
    
  } catch (error) {
    console.error('Error updating player background:', error);
    // Remove all type classes
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    // Remove overlay if it exists
    const overlay = playerDiv.querySelector('.type-overlay');
    if (overlay) {
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 600);
    }
  }
}

globalThis.updatePlayerTypeBackground = updatePlayerTypeBackground;

function updateAllPlayerBackgrounds() {
  updatePlayerTypeBackground(1);
  updatePlayerTypeBackground(2);
}
globalThis.updateAllPlayerBackgrounds = updateAllPlayerBackgrounds;



/* ========= draws / turns ========= */
function drawOne(player){
  const d=playerState[player].deck,
        h=playerState[player].hand;
  if(!d.length) return false;
  
  // Animate card draw
  const handDiv = player === 'player1' ? p1HandDiv : p2HandDiv;
  animateCardDraw(player, handDiv);
  
  h.push(d.shift());
  updateDeckBubbles();
  return true;
}

async function runStatusStartOfTurn(pk) {
  const img = getActiveImg(pk);
  if (!img) return;

  const status = (img.dataset.status || "").toLowerCase();

  // Paralysis: automatically clears at the start of your next turn
  if (status === "paralyzed") {
    clearStatus(pk);
    showPopup("The Active Pok√©mon is no longer paralyzed.", 1800);
  }

  // Poison/Burn are handled in runStatusBetweenTurns()
}

// Check sleep for BOTH players at the end of each turn
async function checkSleepEndOfTurn() {
  // Check both players' active Pokemon for sleep
  for (const pk of ['p1', 'p2']) {
    const img = getActiveImg(pk);
    if (!img) continue;
    
    const status = (img.dataset.status || "").toLowerCase();
    
    if (status === "asleep") {
      const pokemonName = img.alt || "Active Pok√©mon";
      showPopup(`${pokemonName} is asleep. Flipping coin...`, 2000);
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Show visual coin flip and wait for result
      coinEl.classList.add('flip');
      const isHeads = Math.random() < 0.5;
      const front = coinEl.querySelector('.front');
      const back = coinEl.querySelector('.back');
      
      await new Promise(resolve => setTimeout(() => {
        coinEl.classList.remove('flip');
        
        // Display correct side
        if (front && back) {
          if (isHeads) {
            front.style.transform = 'rotateY(0deg)';
            back.style.transform = 'rotateY(180deg)';
          } else {
            front.style.transform = 'rotateY(180deg)';
            back.style.transform = 'rotateY(0deg)';
          }
        }
        
        // Update result text
        if (coinResult) {
          coinResult.textContent = isHeads ? "Heads" : "Tails";
        }
        
        resolve();
      }, 1500));
      
      if (isHeads) {
        clearStatus(pk);
        showPopup(`${pokemonName} woke up!`, 1800);
      } else {
        showPopup(`${pokemonName} is still asleep.`, 1800);
      }
      
      // Small delay between checking each player
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}

async function runStatusStartOfOpponentTurn(pk) {
    const opp = pk === "p1" ? "p2" : "p1";
    const img = getActiveImg(opp);
    if (!img) return;

    const status = (img.dataset.status || "").toLowerCase();

    const base = parseInt(img.dataset.hp || 0, 10);
    let cur = parseInt(img.dataset.chp || base, 10);

    if (status === "poisoned") {
        cur = Math.max(0, cur - 10);
        setHpOverlayForImg(img, base, cur);
        showPopup("Poison deals 10 damage!");
    }

    if (status === "burned") {
        cur = Math.max(0, cur - 20);
        setHpOverlayForImg(img, base, cur);
        showPopup("Burn deals 20 damage!");

        let flip = Math.random() < 0.5 ? "heads" : "tails";
        if (flip === "heads") {
            img.dataset.status = "";
            removeStatusMarker(img);
            showPopup("Burn was healed!");
        } else {
            showPopup("Burn remains.");
        }
    }

    if (cur <= 0) {
        await handleKnockout(opp);
    }
}


async function startTurn(player) {
  // üÜï Check sleep at END of previous turn (for BOTH players)
  // This happens BEFORE the new turn officially starts
  await checkSleepEndOfTurn();
  
  // üÜï A3a/A3b - End of turn passive abilities (BEFORE turn number increments)
  // These trigger at END of the previous player's turn
  const previousPlayer = currentPlayer;
  const previousPk = previousPlayer === 'player1' ? 'p1' : 'p2';
  
  if (previousPlayer) {
    try {
      const prevActiveDiv = previousPlayer === 'player1' ? p1Active : p2Active;
      const prevBenchDiv = previousPlayer === 'player1' ? p1Bench : p2Bench;
      const prevPokemon = [
        ...(prevActiveDiv?.querySelectorAll('img') || []),
        ...(prevBenchDiv?.querySelectorAll('img') || [])
      ];
      
      // Check Snorlax ex - heal_active_end_of_turn
      const prevActiveImg = prevActiveDiv?.querySelector('img');
      if (prevActiveImg) {
        const cacheKey = `${prevActiveImg.dataset.set}-${prevActiveImg.dataset.num}`;
        const abilityRow = globalThis.abilityCache?.[cacheKey];
        
        if (abilityRow?.effect_type === 'heal_active_end_of_turn') {
          const effectState = {
            p1: playerState.player1,
            p2: playerState.player2
          };
          
          if (typeof applyAbilityEffectFromCsv === 'function') {
            await applyAbilityEffectFromCsv(effectState, previousPk, abilityRow, { 
              abilityPokemon: prevActiveImg 
            });
            console.log('[Full-Mouth Manner] Healed at end of turn');
          }
        }
        
        // üÜï A3b TOOL - Leftovers (heal at end of turn)
        // Check if the previous player's active Pokemon has Leftovers attached
        const slot = prevActiveImg.closest('.card-slot');
        if (slot) {
          const tool = getToolDataFromSlot(slot);
          
          if (tool && tool.num === '067' && tool.set === 'A3b') {
            const maxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : parseInt(prevActiveImg.dataset.hp, 10);
            const curHp = parseInt(prevActiveImg.dataset.chp, 10);
            
            if (curHp < maxHp) {
              const healAmount = 10;
              const newHp = Math.min(maxHp, curHp + healAmount);
              prevActiveImg.dataset.chp = String(newHp);
              
              // Update HP display
              if (typeof setHpOnImage === 'function') {
                setHpOnImage(prevActiveImg, maxHp, newHp);
              }
              
              showPopup(`Leftovers: Healed 10 damage from ${prevActiveImg.alt}!`);
              console.log('[Leftovers] Healed 10 damage at end of turn');
            }
          }
        }
      }
      
      // Check Zeraora - attach_energy_end_of_first_turn (only on turn 1 or 2)
      // This triggers at the END of a player's first turn
      // turnNumber 1 = the player who went first just finished their first turn
      // turnNumber 2 = the player who went second just finished their first turn
      if (globalThis.turnNumber === 1 || globalThis.turnNumber === 2) {
        // Determine which player's first turn just ended based on firstPlayer
        // If firstPlayer is 'player1': turnNumber 1 = p1, turnNumber 2 = p2
        // If firstPlayer is 'player2': turnNumber 1 = p2, turnNumber 2 = p1
        let firstTurnPk, firstTurnPlayer;
        if (globalThis.turnNumber === 1) {
          // First turn of the game - whoever went first
          firstTurnPlayer = firstPlayer || 'player1'; // fallback to player1 if firstPlayer not set
          firstTurnPk = firstTurnPlayer === 'player1' ? 'p1' : 'p2';
        } else {
          // Second turn of the game - whoever went second
          firstTurnPlayer = firstPlayer === 'player1' ? 'player2' : 'player1';
          firstTurnPk = firstTurnPlayer === 'player1' ? 'p1' : 'p2';
        }
        const firstTurnActiveDiv = firstTurnPlayer === 'player1' ? p1Active : p2Active;
        const firstTurnBenchDiv = firstTurnPlayer === 'player1' ? p1Bench : p2Bench;
        const activePokemon = firstTurnActiveDiv?.querySelectorAll('img') || [];
        const benchPokemon = firstTurnBenchDiv?.querySelectorAll('img') || [];
        const firstTurnPokemon = [...activePokemon, ...benchPokemon];
        
        console.log(`[Thunderclap Flash] Checking ${firstTurnPlayer}'s Pokemon (turnNumber: ${globalThis.turnNumber}, pk: ${firstTurnPk})`);
        console.log(`[Thunderclap Flash] Active div:`, firstTurnActiveDiv?.id, `(${activePokemon.length} Pokemon)`);
        console.log(`[Thunderclap Flash] Bench div:`, firstTurnBenchDiv?.id, `(${benchPokemon.length} Pokemon)`);
        console.log(`[Thunderclap Flash] Found ${firstTurnPokemon.length} Pokemon total to check`);
        console.log(`[Thunderclap Flash] Pokemon names:`, firstTurnPokemon.map(img => img.alt));
        
        for (const img of firstTurnPokemon) {
          // Try multiple cache key formats to match the ability cache
          const set = img.dataset.set;
          const num = img.dataset.num;
          const cacheKeyPadded = `${set}-${String(num).padStart(3, '0')}`; // e.g., "A3a-021"
          const cacheKeyUnpadded = `${set}-${parseInt(num, 10)}`; // e.g., "A3a-21"
          const cacheKey = `${set}-${num}`; // Original format
          
          console.log(`[Thunderclap Flash] Checking ${img.alt} (set: ${set}, num: ${num})`);
          console.log(`[Thunderclap Flash] Trying cache keys: ${cacheKeyPadded}, ${cacheKeyUnpadded}, ${cacheKey}`);
          
          // Try all three formats
          const abilityRow = globalThis.abilityCache?.[cacheKeyPadded] || 
                           globalThis.abilityCache?.[cacheKeyUnpadded] || 
                           globalThis.abilityCache?.[cacheKey];
          console.log(`[Thunderclap Flash] Ability row for ${img.alt}:`, abilityRow);
          
          if (abilityRow?.effect_type === 'attach_energy_end_of_first_turn') {
            console.log(`[Thunderclap Flash] ‚úì Found attach_energy_end_of_first_turn for ${img.alt}`);
            const effectState = {
              p1: playerState.player1,
              p2: playerState.player2
            };
            
            if (typeof applyAbilityEffectFromCsv === 'function') {
              console.log(`[Thunderclap Flash] Calling applyAbilityEffectFromCsv with pk=${firstTurnPk}`);
              await applyAbilityEffectFromCsv(effectState, firstTurnPk, abilityRow, { 
                abilityPokemon: img 
              });
              console.log(`[Thunderclap Flash] ‚úì Called ability handler for ${firstTurnPk} (turnNumber: ${globalThis.turnNumber})`);
            } else {
              console.error(`[Thunderclap Flash] applyAbilityEffectFromCsv is not a function!`);
            }
          } else {
            console.log(`[Thunderclap Flash] No matching ability for ${img.alt} (effect_type: ${abilityRow?.effect_type || 'none'})`);
          }
        }
      }
    } catch (err) {
      console.error('[startTurn] End of turn abilities failed:', err);
    }
  }
  
  globalThis.turnNumber++;

  logEvent({
    player,
    text: `Turn ${globalThis.turnNumber} started for ${player === 'player1' ? 'Player 1' : 'Player 2'}.`
  });

// Define pk for the CURRENT player (needed for status effects, abilities, etc.)
  const pk = player === 'player1' ? 'p1' : 'p2';
  
  // Clear Silvally supporter flag for CURRENT player (new turn)
  if (!globalThis.__supporterPlayedThisTurn) globalThis.__supporterPlayedThisTurn = { p1: false, p2: false };
  globalThis.__supporterPlayedThisTurn[pk] = false;
  
  // üÜï A3a - Clear move locks at start of turn (Buzzwole ex - Big Beat)
  // The lock applies to the next turn, so clear it when that turn ends (i.e., at start of the turn after)
  // Lock applied on turn N ‚Üí locked during turn N+1 ‚Üí clear at start of turn N+2
  if (globalThis.__moveLocks?.[pk]) {
    const currentTurn = globalThis.turnNumber || 0;
    // Clear locks that were applied 2+ turns ago (lock was on turn N, we're now on turn N+2 or later)
    for (const instanceId in globalThis.__moveLocks[pk]) {
      for (const moveName in globalThis.__moveLocks[pk][instanceId]) {
        const lock = globalThis.__moveLocks[pk][instanceId][moveName];
        if (typeof lock === 'object' && lock.lockedOnTurn) {
          // Lock was applied on turn N, it's active on turn N+2 (player's next turn)
          // Lock should be cleared after turn N+2 ends, so clear it when we reach turn N+3
          // This means: turn N (used Big Beat) ‚Üí turn N+1 (opponent) ‚Üí turn N+2 (locked) ‚Üí turn N+3 (lock cleared)
          if (currentTurn > lock.lockedOnTurn + 2) {
            delete globalThis.__moveLocks[pk][instanceId][moveName];
            console.log(`[Big Beat] Cleared lock for move ${moveName} (instanceId: ${instanceId}) - lock was on turn ${lock.lockedOnTurn}, now on turn ${currentTurn}`);
          }
        }
      }
    }
  }
  
  // Clear effects for the PREVIOUS player (whose turn just ended)
  // previousPlayer and previousPk already declared above, reuse them
  clearExpiredEffectsOnTurnStart(previousPk);
  
  // üÜï Also clear effects for the CURRENT player (in case their lock expired)
  // This ensures attack locks are cleared after the locked turn ends
  clearExpiredEffectsOnTurnStart(pk);
  
  // üÜï Clear all temporary turn effects for previous player
  if (typeof clearTurnEffects === 'function') {
    // Initialize globalThis.state if it doesn't exist
    if (!globalThis.state) {
      globalThis.state = { temp: { p1: {}, p2: {} } };
    }
    clearTurnEffects(globalThis.state, previousPk);
    console.log(`[turn] Cleared turn effects for ${previousPk}`);
  }
  
  // üÜï Clear Marshadow Revenge flag for the CURRENT player
  // This clears the flag from the turn BEFORE the previous turn
  // Example: P1 turn -> P2 Pokemon KO'd -> P2 turn (can use Revenge) -> P1 turn (clear P2's flag)
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.koLastTurn) globalThis.state.koLastTurn = {};
  
  // Clear the flag for the current player (since their opponent's turn just ended)
  if (globalThis.state.koLastTurn[pk]) {
    console.log(`[marshadow] Clearing KO flag for ${pk} at start of turn`);
    globalThis.state.koLastTurn[pk] = false;
  }

  currentPlayer = player;

  // üÜï Randomly select energy for this turn if multiple energy types are available
  const state = playerState[player];
  const energyTypes = state.energyTypes || [];
  
  if (energyTypes.length > 1) {
    // Store the old nextTurnEnergy before we use it
    const oldNextTurnEnergy = state.nextTurnEnergy;
    
    // Use the pre-calculated nextTurnEnergy as current turn energy
    // This should have been set during the previous turn (or at game start)
    if (oldNextTurnEnergy) {
      state.currentTurnEnergy = oldNextTurnEnergy;
    } else {
      // Fallback: randomly select if nextTurnEnergy wasn't set (first turn or initialization issue)
      state.currentTurnEnergy = selectRandomEnergy(energyTypes);
    }
    
    // Calculate next turn's energy (randomly selected) - this is for THIS player's NEXT turn
    // (which is 2 turns from now, after the opponent's turn)
    // This is shown in the corner bubble during the current turn
    // Always calculate a new one for the player's next turn (after opponent's turn)
    state.nextTurnEnergy = selectRandomEnergy(energyTypes);
    
    console.log(`[energy] ${player} turn ${globalThis.turnNumber}: current=${state.currentTurnEnergy} (was next=${oldNextTurnEnergy}), next=${state.nextTurnEnergy}`);
  } else if (energyTypes.length === 1) {
    // Only one energy type, use it for both
    state.currentTurnEnergy = energyTypes[0];
    state.nextTurnEnergy = energyTypes[0];
  }
  
  // Re-render energy zone to show updated next turn energy
  renderEnergyZone();

  const turnLabel = `Turn ${globalThis.turnNumber} ‚Äî ${player === 'player1' ? 'Player 1' : 'Player 2'}`;

  const bar = document.createElement("div");
  bar.className = "turn-bar";
  bar.innerHTML = `
      <div class="turn-icon">${globalThis.turnNumber}</div>
      ${turnLabel}
    `;
  logEntriesDiv.appendChild(bar);

  /* ================================
     Reset turn-scoped state
  ================================= */
  hasAttachedEnergyThisTurn = false;
  selectedEnergy = null;
  hasRetreatedThisTurn = false;
  closeAttackMenu();
  hasPlayedSupporterThisTurn[player] = false;

  resetDamageBoostsFor("player1");
  resetDamageBoostsFor("player2");
  
  // Reset abilities for CURRENT player only
  // Reset only THIS player's abilities, not the whole map
  // pk already declared above at line 6577
  window.usedAbilitiesThisTurn[pk] = {};
  // REMOVED: usedAbilitiesThisTurn[pk] = {}; (was duplicate)
  console.log('[TURN] Reset abilities for:', pk);

  // Clear Giovanni boost
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.temp) globalThis.state.temp = {};
  if (!globalThis.state.temp[player]) globalThis.state.temp[player] = {};
  globalThis.state.temp[player].globalDamageBoost = 0;
  
  // üÜï A3b TRAINER - Clear Eevee Bag damage boost for previous player (duration: this_turn)
  if (globalThis.state?.damageBoost?.[previousPk]) {
    const boostData = globalThis.state.damageBoost[previousPk];
    if (boostData.duration === 'this_turn') {
      delete globalThis.state.damageBoost[previousPk];
      console.log(`[Eevee Bag] Cleared damage boost for ${previousPk} (turn ended)`);
    }
  }

  /* ================================
     Determine turn PK
  ================================= */
    if (globalThis.resetAbilityUsage) {
    globalThis.resetAbilityUsage(pk);
  }


  /* ================================
     Between-turn effects (Poison/Burn)
  ================================= */
  await runStatusBetweenTurns();

  /* ================================
     üÜï A4a - End of turn abilities (draw_card_end_of_turn, damage_end_of_opponent_turn)
  ================================= */
  // Check for draw_card_end_of_turn (Entei ex - Legendary Pulse)
  if (typeof getAbilityRow === 'function' && typeof applyAbilityEffectFromCsv === 'function') {
    try {
      const activeImg = getActiveImg(pk);
      if (activeImg) {
        const abilityRow = await getAbilityRow(activeImg.dataset.set, activeImg.dataset.num);
        if (abilityRow?.effect_type === 'draw_card_end_of_turn') {
          const effectState = {
            p1: playerState.player1,
            p2: playerState.player2
          };
          await applyAbilityEffectFromCsv(effectState, pk, abilityRow, { 
            abilityPokemon: activeImg 
          });
        }
      }
    } catch (err) {
      console.error('[startTurn] draw_card_end_of_turn failed:', err);
    }
  }
  
  // Check for damage_end_of_opponent_turn (Mismagius - Cursed Whispers)
  // This triggers at the end of the OPPONENT's turn (previous player)
  if (previousPlayer && typeof getMoveRow === 'function' && typeof applyMoveEffectFromCsv === 'function') {
    try {
      const prevPk = previousPk;
      const prevActiveImg = getActiveImg(prevPk);
      if (prevActiveImg) {
        // Check all moves of the previous player's active Pokemon
        const prevMeta = await fetchCardMeta(prevActiveImg.dataset.set, prevActiveImg.dataset.num);
        if (prevMeta?.attacks) {
          for (const attack of prevMeta.attacks) {
            const moveRow = await globalThis.getMoveRow(prevActiveImg.alt, attack.name);
            if (moveRow?.effect_type === 'damage_end_of_opponent_turn') {
              const effectState = {
                p1: playerState.player1,
                p2: playerState.player2
              };
              const defendingPk = pk; // Current player is the defender
              await applyMoveEffectFromCsv(effectState, prevPk, attack.name, 0, {
                moveName: attack.name,
                isFinal: true,
                defendingPk: defendingPk,
                sourceImg: prevActiveImg
              });
            }
          }
        }
      }
    } catch (err) {
      console.error('[startTurn] damage_end_of_opponent_turn failed:', err);
    }
  }

  /* ================================
     Start-of-turn effects (Sleep/Paralysis)
  ================================= */
  await runStatusStartOfTurn(pk);

  /* ================================
     Draw Phase
  ================================= */
  drawOne(player);

  /* ================================
     Update UI
  ================================= */
  renderAllHands();
  renderEnergyZone();
  updateTurnBox();

setTimeout(() => {
  showPopup(`Player ${player === 'player1' ? '1' : '2'}'s turn`);
}, 900);

}


/* starting hand logic */
async function drawStartingHandForPlayer(key){
  const deck=playerState[key].deck;
  if(deck.length<5)throw new Error('Deck too small');

  let tries=0,hand=[],hasBasic=false;

  while(tries<10){
    tries++;
    shuffle(deck);
    // Animate shuffle on first try
    if (tries === 1) {
      animateDeckShuffle(key);
    }

    hand=deck.slice(0,5);

    const flags=await Promise.all(
      hand.map(c=>isBasicPokemon(c.set,c.number||c.num))
    );

    hasBasic=flags.some(Boolean);
    if(hasBasic) break;
  }

  // Remove from deck (but don't add to hand yet)
  // Remove exactly the 5 cards we're using for the hand
  deck.splice(0,5);
  
  // Animate each card being drawn with staggered timing
  const handDiv = key === 'player1' ? p1HandDiv : p2HandDiv;
  const animationPromises = [];
  for (let i = 0; i < 5; i++) {
    const delay = i * 200; // 200ms delay between each card (slower)
    animationPromises.push(
      new Promise(resolve => {
        setTimeout(async () => {
          const animCard = await animateCardDraw(key, handDiv, hand[i], i, 5); // Pass the actual card, its index, and total cards (5 for starting hand)
          resolve(animCard); // Return the animated card element (or null if no animation)
        }, delay);
      })
    );
  }
  
  // Wait for all animations to complete, then add cards to hand
  const animatedCards = await Promise.all(animationPromises);
  
  // Now add cards to hand after animations complete
  playerState[key].hand = hand;
  updateDeckBubbles();
  
  // Start scale-down animation immediately, don't render hand yet
  requestAnimationFrame(() => {
    // Use default size for scale calculation
    let targetWidth = 69.27; // Default fallback
    let targetHeight = 96.47; // Default fallback
    
    // Scale down animated cards first (before rendering hand)
    animatedCards.forEach(animCard => {
      if (animCard && animCard.parentNode) {
        // Get current size of animated card
        const currentWidth = parseFloat(animCard.style.width) || 69.27;
        const currentHeight = parseFloat(animCard.style.height) || 96.47;
        
        // Calculate scale factor (will be 1:1 if sizes match, but that's fine)
        const scaleX = targetWidth / currentWidth;
        const scaleY = targetHeight / currentHeight;
        
        // Force a reflow to ensure transition works
        void animCard.offsetWidth;
        
        // Scale down and fade out simultaneously
        animCard.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out, width 0.3s ease-out, height 0.3s ease-out';
        animCard.style.transform = `perspective(700px) rotateX(3deg) scale(${scaleX}, ${scaleY})`;
        animCard.style.opacity = '0';
        animCard.style.width = `${targetWidth}px`;
        animCard.style.height = `${targetHeight}px`;
      }
    });
    
    // After scale-down animation completes, THEN render the hand
    setTimeout(() => {
      // Now render the hand - cards will appear after animation
      const hide = key === 'player1' ? currentPlayer === 'player2' : currentPlayer === 'player1';
      renderHand(handDiv, hand, hide, false);
      // Render the other player's hand
      if (key === 'player1') {
        renderHand(p2HandDiv, playerState.player2.hand, currentPlayer === 'player1');
      } else {
        renderHand(p1HandDiv, playerState.player1.hand, currentPlayer === 'player2');
      }
      
      // Remove all animated cards
      animatedCards.forEach(animCard => {
        if (animCard && animCard.parentNode) {
          animCard.remove();
        }
      });
    }, 300);
  });
  
  // Also remove any remaining animated card elements (fallback)
  const remainingAnimatedCards = document.querySelectorAll('[data-animated-card="true"]');
  if (remainingAnimatedCards.length > 0) {
    remainingAnimatedCards.forEach(card => {
      if (card && card.parentNode) {
        // Force a reflow to ensure transition works
        void card.offsetWidth;
        card.style.transition = 'opacity 0.3s ease-out';
        card.style.opacity = '0';
        setTimeout(() => {
          if (card.parentNode) {
            card.remove();
          }
        }, 300);
      }
    });
  }
}

/* ========= energy zone ========= */
function renderEnergyZone(){
  const state = playerState[currentPlayer];
  const energyTypes = state?.energyTypes || [];
  const currentEnergy = state?.currentTurnEnergy || (energyTypes.length > 0 ? energyTypes[0] : null);
  const nextEnergy = state?.nextTurnEnergy || (energyTypes.length > 0 ? energyTypes[0] : null);
  
  energyZoneDiv.innerHTML = '';

  const disable =
    (globalThis.turnNumber === 1 && currentPlayer === firstPlayer) ||
    hasAttachedEnergyThisTurn;

  // Always show current turn's energy (clickable) with next turn's energy as corner badge
  if (currentEnergy) {
    // Create container for current energy with relative positioning
    const energyContainer = document.createElement('div');
    energyContainer.className = 'energy-container';
    energyContainer.style.position = 'relative';
    energyContainer.style.display = 'inline-block';
    
    // Current turn's energy (clickable)
    // Map single letter energy types to full names (w -> water, f -> fire, etc.)
    const energyTypeMap = {
      'w': 'water',
      'f': 'fire',
      'g': 'grass',
      'l': 'lightning',
      'p': 'psychic',
      'r': 'fighting',
      'd': 'darkness',
      'm': 'metal',
      'n': 'dragon',
      'c': 'colorless'
    };
    let lw = currentEnergy.toLowerCase();
    // Convert single letter to full name if needed
    if (energyTypeMap[lw]) {
      lw = energyTypeMap[lw];
    }
    const el = document.createElement('div');
    el.className = 'energy';
    const currentIconUrl = ENERGY_ICONS[lw] || ENERGY_ICONS.colorless;
    el.style.backgroundImage = `url('${currentIconUrl}')`;
    el.style.backgroundSize = 'cover';
    el.style.backgroundRepeat = 'no-repeat';
    el.style.backgroundPosition = 'center';
    el.title = `${currentEnergy} (Current Turn)`;

    if (disable) {
      el.style.filter = 'grayscale(100%) brightness(70%)';
      el.style.cursor  = 'not-allowed';
    } else {
      el.onclick = (ev) => {
        ev.stopPropagation(); // Prevent bubbling to main click handler
        
        // Clear previous selection
        if (selectedEnergyElement) {
          selectedEnergyElement.classList.remove('selected-glow');
        }
        if (selectedToolElement) {
          selectedToolElement.classList.remove('selected-glow');
          toolAttachPending = null;
        }
        
        selectedEnergy = lw;
        selectedEnergyElement = el;
        selectedToolElement = null;
        el.classList.add('selected-glow');
        showPopup(`Selected ${lw} energy. Click a Pok√©mon to attach, or press Escape to cancel.`);
        
        // Add escape key handler
        setupSelectionCancelHandler();
      };
    }

    energyContainer.appendChild(el);
    
    // Next turn's energy preview (corner badge, smaller, unclickable)
    if (nextEnergy) {
      // Map single letter energy types to full names (w -> water, f -> fire, etc.)
      const energyTypeMap = {
        'w': 'water',
        'f': 'fire',
        'g': 'grass',
        'l': 'lightning',
        'p': 'psychic',
        'r': 'fighting',
        'd': 'darkness',
        'm': 'metal',
        'n': 'dragon',
        'c': 'colorless'
      };
      let nextLw = nextEnergy.toLowerCase();
      // Convert single letter to full name if needed
      if (energyTypeMap[nextLw]) {
        nextLw = energyTypeMap[nextLw];
      }
      const nextEl = document.createElement('div');
      nextEl.className = 'energy energy-next-turn';
      const nextIconUrl = ENERGY_ICONS[nextLw] || ENERGY_ICONS.colorless;
      // Use img element instead of background-image for better visibility
      const nextImg = document.createElement('img');
      nextImg.src = nextIconUrl;
      nextImg.style.width = '100%';
      nextImg.style.height = '100%';
      nextImg.style.objectFit = 'cover';
      nextImg.style.borderRadius = '50%';
      nextImg.alt = `${nextEnergy} (Next Turn)`;
      nextEl.appendChild(nextImg);
      nextEl.title = `${nextEnergy} (Next Turn)`;
      energyContainer.appendChild(nextEl);
    }
    
    energyZoneDiv.appendChild(energyContainer);
  } else {
    // Fallback: show all energy types (original behavior) if no currentEnergy set
    for (const t of energyTypes) {
    const lw = t.toLowerCase();
    const el = document.createElement('div');
    el.className = 'energy';
    el.style.backgroundImage = `url('${ENERGY_ICONS[lw] || ''}')`;
    el.title = t;

    if (disable) {
      el.style.filter = 'grayscale(100%) brightness(70%)';
      el.style.cursor  = 'not-allowed';
    } else {
        el.onclick = (ev) => {
          ev.stopPropagation(); // Prevent bubbling to main click handler
          
          // Clear previous selection
          if (selectedEnergyElement) {
            selectedEnergyElement.classList.remove('selected-glow');
          }
          if (selectedToolElement) {
            selectedToolElement.classList.remove('selected-glow');
            toolAttachPending = null;
          }
          
        selectedEnergy = lw;
          selectedEnergyElement = el;
          selectedToolElement = null;
          el.classList.add('selected-glow');
          showPopup(`Selected ${lw} energy. Click a Pok√©mon to attach, or press Escape to cancel.`);
          
          // Add escape key handler
          setupSelectionCancelHandler();
      };
    }

    energyZoneDiv.appendChild(el);
    }
  }
}

/* ========= coin flip + setup ========= */
function flipCoin(){
  coinEl.classList.add('flip');

  const res = Math.random() < 0.5 ? 'player1' : 'player2';
  const front = coinEl.querySelector('.front');
  const back  = coinEl.querySelector('.back');

  setTimeout(() => {
    coinEl.classList.remove('flip');

    if (res === 'player1') {
      front.style.transform = 'rotateY(0deg)';
      back.style.transform  = 'rotateY(180deg)';
    } else {
      front.style.transform = 'rotateY(180deg)';
      back.style.transform  = 'rotateY(0deg)';
    }

    firstPlayer   = res;
    currentPlayer = res;

    // Initialize energy for the first player's turn
    const firstState = playerState[res];
    const firstEnergyTypes = firstState.energyTypes || [];
    if (firstEnergyTypes.length > 1) {
      firstState.currentTurnEnergy = selectRandomEnergy(firstEnergyTypes);
      firstState.nextTurnEnergy = selectRandomEnergy(firstEnergyTypes);
    } else if (firstEnergyTypes.length === 1) {
      firstState.currentTurnEnergy = firstEnergyTypes[0];
      firstState.nextTurnEnergy = firstEnergyTypes[0];
    }
    
    // Also initialize for the other player
    const otherPlayer = res === 'player1' ? 'player2' : 'player1';
    const otherState = playerState[otherPlayer];
    const otherEnergyTypes = otherState.energyTypes || [];
    if (otherEnergyTypes.length > 1) {
      otherState.currentTurnEnergy = selectRandomEnergy(otherEnergyTypes);
      otherState.nextTurnEnergy = selectRandomEnergy(otherEnergyTypes);
    } else if (otherEnergyTypes.length === 1) {
      otherState.currentTurnEnergy = otherEnergyTypes[0];
      otherState.nextTurnEnergy = otherEnergyTypes[0];
    }

    coinResult.textContent = `${res === 'player1' ? 'Player 1' : 'Player 2'} goes first!`;
    showPopup(`${res === 'player1' ? 'Player 1' : 'Player 2'} goes first!`);

    logEvent({
      player: res,
      text:`Won the coin flip and goes first.`
    });

    updateTurnBox();
    renderEnergyZone();
    
    // Initialize deck stacks
    updateDeckStack('player1');
    updateDeckStack('player2');

    drawOne(currentPlayer);
    renderAllHands();

    isSetupPhase = false;
  }, 1500);
}

/* ========= right-click zoom ========= */
document.body.addEventListener('contextmenu', async e => {
  const handImgEl = e.target.closest('.hand img');

  /* Right-click on card in hand */
  if (handImgEl) {
    e.preventDefault();

    const set = handImgEl.dataset.set;
    const num = handImgEl.dataset.num;

    try {
      const meta = await fetchCardMeta(set, num);
      const category = (meta.category || '').toLowerCase();

      if (handBackdrop && handImg) {
        handImg.src = handImgEl.src;
        handBackdrop.classList.add('show');
        handTitle.textContent = meta.name || 'Card';
      }

      if (category === 'pokemon') {
        if (handBackdrop) handBackdrop.classList.remove('show');

        zoomImg.src = handImgEl.src;
        zoomBackdrop.classList.add('show');

        await buildZoomPanel(meta, handImgEl);
        zoomAttacks.querySelectorAll('.zoom-attack').forEach(a => a.classList.add('muted'));
        document.getElementById('zoomRetreatRow')?.classList.add('disabled');
      } else {
        if (handType) {
          handType.textContent = meta.trainerType || meta.category || 'Card';
          handType.style.background = trainerColor(meta.trainerType || meta.category);
        }
        if (handEffect) {
          handEffect.textContent = meta.effect || meta.description || 'No effect listed.';
        }
      }

    } catch {
      showPopup('No data available for this card.');
    }

    return;
  }

  /* Right-click on Pok√©mon in play */
  const img = e.target.closest('.active img, .bench img');
  if (!img) return;

  e.preventDefault();

  zoomImg.src = img.src;
  zoomBackdrop.classList.add('show');

  try {
    const set = img.dataset.set;
    const num = img.dataset.num;
    const meta = await fetchCardMeta(set, num);
    await buildZoomPanel(meta, img);
  } catch {
    zoomTitle.textContent = 'Pok√©mon';
    zoomHp.textContent = '';
    zoomAttacks.innerHTML = '<div style="color:#cbd5e1">No data</div>';
    zoomEnergyCount.textContent = 'x0';
    zoomEnergyIcons.innerHTML = '';
    zoomWeakness.textContent = '‚Äî';
    zoomRetreat.innerHTML = '';
    zoomTools.innerHTML = '<div class="chip">none</div>';
    zoomAbilities.style.display = 'none';
  }
});

/* close zoom */
if (zoomBackdrop) {
  zoomBackdrop.addEventListener('click', e => {
    if (e.target === zoomBackdrop) {
      zoomBackdrop.classList.remove('show');
      currentZoom = { img: null, meta: null };
    }
  });

  document.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
      zoomBackdrop.classList.remove('show');
      currentZoom = { img: null, meta: null };
    }
  });
}

/* ========= discard buttons ========= */
if (p1DiscardBtn) p1DiscardBtn.onclick = () => {
  renderDiscard('player1');
  p1DiscardDrawer.classList.add('show');
  // Update transform if p2 drawer is also open
  updateDiscardDrawerPositions();
};

if (p2DiscardBtn) p2DiscardBtn.onclick = () => {
  renderDiscard('player2');
  p2DiscardDrawer.classList.add('show');
  // Update transform if p1 drawer is also open
  updateDiscardDrawerPositions();
};

// Function to update drawer positions when both are open
function updateDiscardDrawerPositions() {
  const p1Open = p1DiscardDrawer?.classList.contains('show');
  const p2Open = p2DiscardDrawer?.classList.contains('show');
  
  if (p1Open && p2Open) {
    // Both open - shift p1 to the left
    p1DiscardDrawer.style.transform = 'translateX(-340px)';
  } else if (p1Open) {
    // Only p1 open - normal position
    p1DiscardDrawer.style.transform = 'translateX(0)';
  }
  // p2 always stays at translateX(0) when open
}

document.addEventListener('click', e => {
  if (p1DiscardDrawer?.classList.contains('show') &&
      !p1DiscardDrawer.contains(e.target) &&
      e.target !== p1DiscardBtn) {
    p1DiscardDrawer.classList.remove('show');
    updateDiscardDrawerPositions();
  }

  if (p2DiscardDrawer?.classList.contains('show') &&
      !p2DiscardDrawer.contains(e.target) &&
      e.target !== p2DiscardBtn) {
    p2DiscardDrawer.classList.remove('show');
    updateDiscardDrawerPositions();
  }
});

/* ========= main button ========= */
if (mainButton) mainButton.onclick = async () => {
  const label = mainButton.textContent;

  try {
    if (label === 'Draw Hands') {
      // Draw hands for both players (animations will play)
      await Promise.all([
        drawStartingHandForPlayer('player1'),
        drawStartingHandForPlayer('player2')
      ]);

      // Note: renderAllHands and updateDeckBubbles are called inside drawStartingHandForPlayer
      // after animations complete, so we don't need to call them here
      showPopup('Choose Active & Benched Pok√©mon');

      mainButton.textContent = 'Start Game';

    } else if (label === 'Start Game') {
      if (!p1Active.querySelector('img') || !p2Active.querySelector('img')) {
        showPopup('Both players need an Active Pok√©mon.');
        return;
      }

      flipCoin();
      mainButton.textContent = 'End Turn';

    } else {
      /* Regular turn cycling */
      // üÜï A3b TOOL - Leftovers (heal at end of turn)
      const currentActiveImg = getActiveImage(currentPlayer);
      
      if (currentActiveImg) {
        const slot = currentActiveImg.closest('.card-slot');
        const tool = getToolDataFromSlot(slot);
        
        if (tool && tool.num === '067' && tool.set === 'A3b') {
          const maxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : parseInt(currentActiveImg.dataset.hp, 10);
          const curHp = parseInt(currentActiveImg.dataset.chp, 10);
          
          if (curHp < maxHp) {
            const healAmount = 10;
            const newHp = Math.min(maxHp, curHp + healAmount);
            currentActiveImg.dataset.chp = String(newHp);
            
            // Update HP display
            if (typeof setHpOnImage === 'function') {
              setHpOnImage(currentActiveImg, maxHp, newHp);
            }
            
            showPopup(`Leftovers: Healed 10 damage from ${currentActiveImg.alt}!`);
            console.log('[Leftovers] Healed 10 damage at manual end of turn');
          }
        }
      }
      
      const next = currentPlayer === 'player1' ? 'player2' : 'player1';
      startTurn(next);
    }
  } catch (err) {
    console.error('Flow error:', err);
    showPopup('Setup error. Check decks.');
  }
};

/* ========= victory screen actions ========= */
if (playAgainBtn)
  playAgainBtn.addEventListener('click', () => {
    window.location.reload();
  });

if (chooseDecksBtn)
  chooseDecksBtn.addEventListener('click', () => {
    window.location.href = 'index.html';
  });

const victoryShowLogBtn = document.getElementById("victoryShowLogBtn");

if (victoryShowLogBtn) {
  victoryShowLogBtn.onclick = () => {
    if (!fullHistoryLog.length) {
      fullHistoryDiv.innerHTML = '<div class="match-log-entry">No actions logged.</div>';
    } else {
      fullHistoryDiv.innerHTML = fullHistoryLog.map(h => `
        <div class="match-log-entry">
          <div>
            <strong>#${h.id}</strong> ¬∑ ${h.player} ¬∑
            <span style="opacity:.6">${h.ts}</span>
          </div>
          <div>${h.text}</div>
          ${
            h.imgUrl
              ? `<img class="log-thumb" src="${h.imgUrl}"
                  style="margin-top:6px;border-radius:6px;width:52px;height:auto;">`
              : ''
          }
        </div>
      `).join('');
    }
    historyBackdrop.classList.add('show');
  };
}
/* ========= effects bridge ========= */
globalThis.selectPokemon = function (_st, pk, _z) {
  const area = pk === 'p1' ? p1Active : p2Active;
  const img  = area?.querySelector('img');
  if (!img) return null;

  return {
    name: img.alt,
    hp:   parseInt(img.dataset.chp || img.dataset.hp || '0', 10) || 0,
    maxHP: parseInt(img.dataset.hp || '0', 10) || 0
  };
};

globalThis.drawCards = async function (_st, pk, n) {
  const owner = pk === 'p1' ? 'player1' : 'player2';
  const drawCount = parseInt(n) || 0;

  // Draw cards directly without animation (only starting hand gets animation)
  for (let i = 0; i < drawCount; i++) {
    if (playerState[owner].deck.length) {
      const drawnCard = playerState[owner].deck.shift();
      playerState[owner].hand.push(drawnCard);
    }
  }

  // Update UI immediately
  updateDeckBubbles();
  renderAllHands();
};

globalThis.shuffleIntoDeck = function (hand, deck) {
  if (!Array.isArray(hand) || !Array.isArray(deck)) return;

  deck.push(...hand);
  hand.length = 0;
  shuffle(deck);
  
  // Determine owner from deck context (this is a bit tricky, we'll need to check)
  // For now, we'll trigger shuffle animation for both players
  // In practice, you'd want to pass the owner or determine it from context
  const owner = deck === playerState.player1.deck ? 'player1' : 'player2';
  animateDeckShuffle(owner);
};

globalThis.findPokemonByName = function (_st, name) {
  const imgs = $$('#player1 .active img, #player1 .bench img, ' +
                  '#player2 .active img, #player2 .bench img');
  const hit = imgs.find(i => i.alt === name);
  return hit ? { name } : null;
};

// Discard a Pokemon from play (for fossils)
globalThis.discardPokemon = async function(pokemonImg, pk, givePoint = false) {
  if (!pokemonImg) return;
  
  const slot = pokemonImg.closest('.card-slot');
  if (!slot) return;
  
  const pokemonName = pokemonImg.alt || 'Pokemon';
  
  // Get the owner
  const owner = pk === 'p1' ? 'player1' : 'player2';
  
  // Remove all attached energy and tools
  const energyBox = slot.querySelector('.energy-pips');
  if (energyBox) energyBox.remove();
  
  const toolThumb = slot.querySelector('.tool-thumb');
  if (toolThumb) toolThumb.remove();
  
  const hpOverlay = slot.querySelector('.hp-overlay');
  if (hpOverlay) hpOverlay.remove();
  
  // Remove the Pokemon
  pokemonImg.remove();
  
  // Mark slot as empty
  if (globalThis.markSlot) {
    globalThis.markSlot(slot, false);
  }
  
  // Give point to opponent if specified
  if (givePoint) {
    const oppPk = pk === 'p1' ? 'p2' : 'p1';
    const oppOwner = oppPk === 'p1' ? 'player1' : 'player2';
    
    if (globalThis.incrementPoints) {
      globalThis.incrementPoints(oppOwner);
      showPopup(`${pokemonName} was knocked out! ${oppOwner === 'player1' ? 'Player 1' : 'Player 2'} takes a point!`);
    }
  }
  
  console.log(`[discardPokemon] ${pokemonName} discarded, point given: ${givePoint}`);
};

globalThis.promoteFromBench = function (_st, oppKey, requireChoice = true) {
  const owner = oppKey === 'p1' ? 'player1' : 'player2';
  const bench = owner === 'player1' ? p1Bench : p2Bench;
  const imgs  = bench.querySelectorAll('img');

  if (requireChoice && imgs.length === 0) return false;

  beginPromotionFlow(owner);
  showPopup(`${owner === 'player1' ? 'Player 1' : 'Player 2'} choose a Benched Pok√©mon to promote.`);
  return true;
};

/* Expose helpers */
globalThis.shuffle = shuffle;
globalThis.renderAllHands = renderAllHands;
globalThis.renderHand = renderHand;
globalThis.updateDeckBubbles = updateDeckBubbles;
globalThis.animateCardDraw = animateCardDraw;
globalThis.animateDeckShuffle = animateDeckShuffle;
globalThis.showPopup = showPopup;
globalThis.getToolDataFromSlot = getToolDataFromSlot;
globalThis.setToolDataOnSlot = setToolDataOnSlot;
globalThis.setHpOnImage = setHpOnImage;
globalThis.playerState = playerState; // Expose playerState for effects.js

/* Animation support for Pok√© Ball etc. */
globalThis.animateCardToHand = animateCardToHand;

/* Logging bridge for trainer effects (Misty/Brock/etc.) */
globalThis.addLog = function (pk, htmlText, _imgUrl, cardObj) {
  const owner = pk === 'p1' ? 'player1' : 'player2';

  logEvent({
    player: owner,
    text: htmlText,
    cardSet: cardObj?.set,
    cardNum: cardObj?.number || cardObj?.num
  });
};

/* ========= trainer effect application ========= */
async function applyTrainerEffect(effect, owner, trainerCardImg = null, throwOnError = false) {
  try {
    const key = owner === 'player1' ? 'p1' : 'p2';

    // Use the shared global state so temp buffs (Giovanni) are visible to move effects
    const state = globalThis.state || {};

    // Ensure temp structure exists
    if (!state.temp) {
      state.temp = { p1: {}, p2: {} };
    } else {
      state.temp.p1 = state.temp.p1 || {};
      state.temp.p2 = state.temp.p2 || {};
    }

    // Keep per-player references up to date on the same object
    state.p1 = state.p1 || {};
    state.p2 = state.p2 || {};

    state.p1.deck = playerState.player1.deck;
    state.p1.hand = playerState.player1.hand;
    state.p1.discard = playerState.player1.discard;  // üÜï Add discard for Lusamine

    state.p2.deck = playerState.player2.deck;
    state.p2.hand = playerState.player2.hand;
    state.p2.discard = playerState.player2.discard;  // üÜï Add discard for Lusamine
    
    // üÜï Add trainer card to state for fossil effects
    state.trainerCard = trainerCardImg;

    let handler = TRAINER_EFFECTS[effect.effect_type];

    if (!handler && effect.effect_name && TRAINER_EFFECTS[effect.effect_name]) {
      console.warn('No handler for type:', effect.effect_type, '‚Äî using name instead');
      handler = TRAINER_EFFECTS[effect.effect_name];
    }

    if (!handler) {
      const errorMsg = `"${effect.effect_type || 'Unknown'}" effect not implemented for ${effect.name || effect.trainerName || 'this card'}.`;
      console.error('No trainer handler for', effect);
      if (throwOnError) {
        throw new Error(errorMsg);
      } else {
        showPopup(errorMsg);
      }
      return;
    }

    // Giovanni and others now mutate globalThis.state
    await handler(state, key, { param1: effect.param1, param2: effect.param2 });

    renderAllHands();
    updateDeckBubbles();

  } catch (err) {
    console.error('Trainer effect error:', err);
    if (throwOnError) {
      // Re-throw for items so card stays in hand
      throw err;
    } else {
      // Show popup for tools/supporters
      showPopup('Trainer effect failed.');
    }
  }
}

function addTrainerToDiscard(owner, img) {
  pushCardToDiscard(owner, img);
  const drawer = owner === 'player1' ? p1DiscardDrawer : p2DiscardDrawer;

  if (drawer.classList.contains('show')) {
    renderDiscard(owner);
  }
}

/* ============================================================
   STATUS CONDITION ENGINE (MARKERS + BASIC TICKS)
   Uses bottom-left icons on the active Pok√©mon
   ============================================================ */

/* helper: get active image for pk = "p1" | "p2" */
function getActiveImg(pk) {
  const area = pk === 'p1' ? p1Active : p2Active;
  return area ? area.querySelector('img') : null;
}

function isActiveBlockedFromAttacking(pk) {
  const img = getActiveImg(pk);
  if (!img) return false;
  const st = (img.dataset.status || '').toLowerCase();
  return st === 'asleep' || st === 'paralyzed';
}

/* helper: coin flip result "heads" | "tails" (logic only) */
// Unified visual coin flip for all game logic and effects.js
function doCoinFlip(pk = null) {
  // Check for Will's guarantee (guarantee_coin_flip effect)
  // Will guarantees the FIRST coin flip after using it on this turn
  let isHeads = Math.random() < 0.5;
  
  if (pk && globalThis.state?.guaranteedHeads?.[pk]) {
    isHeads = true;
    // Clear the flag after first use (only first coin flip is guaranteed)
    globalThis.state.guaranteedHeads[pk] = false;
  }
  
  const resultStr = isHeads ? 'heads' : 'tails';

  try {
    if (coinEl) {
      const front = coinEl.querySelector('.front');
      const back  = coinEl.querySelector('.back');

      // Trigger CSS animation
      coinEl.classList.add('flip');

      setTimeout(() => {
        coinEl.classList.remove('flip');

        // Display correct side
        if (front && back) {
          if (isHeads) {
            front.style.transform = 'rotateY(0deg)';
            back.style.transform  = 'rotateY(180deg)';
          } else {
            front.style.transform = 'rotateY(180deg)';
            back.style.transform  = 'rotateY(0deg)';
          }
        }

        // Update readout text
        if (coinResult) {
          coinResult.textContent = isHeads ? "Heads" : "Tails";
        }
      }, 1500);
    }
  } catch (e) {
    console.warn("[battle] visual coin flip failed", e);
  }

  return resultStr; // synchronous return so effects.js remains compatible
}

// expose for effects.js
globalThis.doCoinFlip = doCoinFlip;


function flipCoinStatus() {
  return new Promise(resolve => {
    coinEl.classList.add('flip');

    const isHeads = Math.random() < 0.5;
    const front = coinEl.querySelector('.front');
    const back  = coinEl.querySelector('.back');

    setTimeout(() => {
      coinEl.classList.remove('flip');

      if (isHeads) {
        // Heads: show front
        front.style.transform = 'rotateY(0deg)';
        back.style.transform  = 'rotateY(180deg)';
        coinResult.textContent = 'Heads';
      } else {
        // Tails: show back
        front.style.transform = 'rotateY(180deg)';
        back.style.transform  = 'rotateY(0deg)';
        coinResult.textContent = 'Tails';
      }

      resolve(isHeads ? 'heads' : 'tails');
    }, 1500);
  });
}

async function visualCoinFlip(messagePrefix = "Flip") {
  return new Promise(resolve => {
    coinEl.classList.add("flip");

    const flip = Math.random() < 0.5 ? "heads" : "tails";

    setTimeout(() => {
      coinEl.classList.remove("flip");

      // Do NOT change who-goes-first visual state
      // Just flash result in popup
      showPopup(`${messagePrefix}: ${flip.toUpperCase()}`);

      resolve(flip);
    }, 1500);
  });
}


/* normalize string from effects ("Poison", "poisoned", etc.) */
function normalizeStatusName(name) {
  const n = String(name || '').toLowerCase().trim();
  if (!n) return '';

  if (n.startsWith('poison')) return 'poisoned';
  if (n.startsWith('sleep'))  return 'asleep';
  if (n.startsWith('burn'))   return 'burned';
  if (n.startsWith('para'))   return 'paralyzed';
  if (n.startsWith('conf'))   return 'confused';

  return n; // already normalized
}

/* draw or update the status icon for this img */
function drawStatusIcon(img, key) {
  const slot = img.closest('.card-slot');
  if (!slot) return;

  let icon = slot.querySelector('.status-icon');
  if (!icon) {
    icon = document.createElement('div');
    icon.className = 'status-icon';
    slot.appendChild(icon);
  }

  const url = STATUS_ICON_URLS[key];
  if (url) {
    icon.style.backgroundImage = `url('${url}')`;
  } else {
    icon.style.backgroundImage = '';
  }

  // If this card is currently zoomed, update the zoom status icon too 
  if (currentZoom.img === img && zoomStatusIcon) {
    if (url) {
      zoomStatusIcon.style.display = 'inline-block';
      zoomStatusIcon.style.backgroundImage = `url('${url}')`;
    } else {
      zoomStatusIcon.style.display = 'none';
      zoomStatusIcon.style.backgroundImage = '';
    }
  }
}

/* remove icon and dataset from a single img */
function clearStatusOnImg(img) {
  if (!img) return;
  img.dataset.status = '';

  const slot = img.closest('.card-slot');
  if (slot) {
    const icon = slot.querySelector('.status-icon');
    if (icon) icon.remove();
  }

  // Also clear in zoom, if this is the zoomed Pok√©mon
  if (currentZoom.img === img && zoomStatusIcon) {
    zoomStatusIcon.style.display = 'none';
    zoomStatusIcon.style.backgroundImage = '';
  }
}


/* public: set status on active Pok√©mon pk ("p1" | "p2") */
function setStatus(pk, statusName) {
  const img = getActiveImg(pk);
  if (!img) return;

  // üÜï Check for status protection (Comfey - Flower Shield)
  if (img.dataset.statusProtected) {
    console.log(`[Status] ${img.alt} is protected from status (${img.dataset.statusProtected})`);
    showPopup(`${img.alt} is protected from Special Conditions!`);
    return false;
  }

  const key = normalizeStatusName(statusName);
  if (!key) return;

  img.dataset.status = key;
  drawStatusIcon(img, key);
  return true;
}
globalThis.setStatus = setStatus;


/* public: clear status on active Pok√©mon pk */
function clearStatus(pk) {
  const img = getActiveImg(pk);
  clearStatusOnImg(img);
}

/* status BETWEEN turns (poison/burn damage) */
async function runStatusBetweenTurns() {
  for (const pk of ['p1', 'p2']) {
    const img = getActiveImg(pk);
    if (!img) continue;

    const status = (img.dataset.status || '').toLowerCase();
    if (!status) continue;

    const owner = pk === 'p1' ? 'player1' : 'player2';

    /* Poison: 10 damage between turns (or 20 for heavy poison) */
    if (status === 'poisoned') {
      // üÜï A2a MOVE EFFECT - Heavy poison (Toxicroak Toxic)
      let poisonDamage = parseInt(img.dataset.heavyPoison || '10', 10);
      
      // üÜï A3a - Nihilego More Poison (increase poison damage)
      // Check if ANY player has Nihilego with increase_poison_damage
      try {
        const allPokemon = [
          ...document.querySelectorAll('#player1 .card-img'),
          ...document.querySelectorAll('#player2 .card-img')
        ];
        
        for (const pokemon of allPokemon) {
          const cacheKey = `${pokemon.dataset.set}-${pokemon.dataset.num}`;
          const abilityRow = globalThis.abilityCache?.[cacheKey];
          
          if (abilityRow?.effect_type === 'increase_poison_damage') {
            const bonus = parseInt(abilityRow.param1 || '10', 10);
            poisonDamage += bonus;
            console.log(`[More Poison] ${pokemon.alt} increased poison damage by ${bonus}`);
          }
        }
      } catch (err) {
        console.error('[poison] More Poison check failed:', err);
      }
      
      const result = await damageActiveOf(owner, poisonDamage, { isDirectAttack: false });
      
      if (poisonDamage === 20 || poisonDamage > 10) {
        showPopup(`${img.alt || 'Active Pok√©mon'} took ${poisonDamage} damage from Poison!`);
      } else {
        showPopup(`${img.alt || 'Active Pok√©mon'} took ${poisonDamage} damage from Poison.`);
      }

      if (result.knocked) {
        const img2 = getActiveImage(owner);
        if (img2) {
          const ended = await handleKnockOut(owner, img2);
          if (ended) return;
          await beginPromotionFlow(owner);
        }
      }
    }

    /* Burn: 20 damage then flip coin; heads = cured */
    if (status === 'burned') {
      const result = await damageActiveOf(owner, 20, { isDirectAttack: false });
      showPopup(`${img.alt || 'Active Pok√©mon'} took 20 damage from Burn.`);

      if (result.knocked) {
        const img2 = getActiveImage(owner);
        if (img2) {
          const ended = await handleKnockOut(owner, img2);
          if (ended) return;
          await beginPromotionFlow(owner);
        }
        continue;
      }

      const r = doCoinFlip();
      if (r === 'heads') {
        clearStatus(pk);
        showPopup('The burn was healed!');
      }
    }

    /* Confusion has no between-turn effect; handled on attack. */
  }
  
  // üÜï A2a PASSIVE ABILITY - damage_during_checkup (Glaceon ex Snowy Terrain)
  // Check both players for Glaceon ex with this ability
  for (const checkPk of ['p1', 'p2']) {
    const activeImg = getActiveImg(checkPk);
    if (!activeImg) continue;
    
    // Check if this Pokemon has damage_during_checkup ability
    const cacheKey = `${activeImg.dataset.set}-${activeImg.dataset.num}`;
    const abilityRow = globalThis.abilityCache?.[cacheKey];
    
    if (abilityRow?.effect_type === 'damage_during_checkup') {
      const damage = parseInt(abilityRow.param1 || '10', 10);
      const oppPk = checkPk === 'p1' ? 'p2' : 'p1';
      const oppOwner = oppPk === 'p1' ? 'player1' : 'player2';
      
      console.log(`[Glaceon checkup] ${activeImg.alt} dealing ${damage} to opponent`);
      const result = await damageActiveOf(oppOwner, damage, { isDirectAttack: false });
      showPopup(`${activeImg.alt}'s Snowy Terrain: ${damage} damage to opponent!`);
      
      if (result.knocked) {
        const oppImg = getActiveImage(oppOwner);
        if (oppImg) {
          const ended = await handleKnockOut(oppOwner, oppImg);
          if (ended) return;
          await beginPromotionFlow(oppOwner);
        }
      }
    }
  }
}

/* expose to effects.js */
globalThis.setStatus  = setStatus;
globalThis.clearStatus = clearStatus;

/* ========= init ========= */
updateDeckBubbles();
updateTurnBox();
updatePointsUI();
renderAllHands();
</script>
</body>
</html>