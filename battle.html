<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes" />
<title>TCG Pocket Battle</title>
<link rel="icon" type="image/png" href="https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Pok%C3%A9_Ball_icon.svg/768px-Pok%C3%A9_Ball_icon.svg.png?20161023215848"/>
<style>
:root{
  --card-w:75px;
  --card-h:105px;
}
@media (max-width: 768px) {
  :root{
    --card-w:70px;
    --card-h:98px;
  }
}
@media (max-width: 480px) {
  :root{
    --card-w:65px;
    --card-h:91px;
  }
}

@keyframes flipCoin {
  0% {
    transform: rotateY(0deg);
  }
  100% {
    transform: rotateY(1800deg);
  }
}

@keyframes damageFlash {
  0% {
    filter: brightness(1);
    box-shadow: 0 0 0 rgba(239, 68, 68, 0);
  }
  50% {
    filter: brightness(1.8) saturate(1.5);
    box-shadow: 0 0 30px rgba(239, 68, 68, 1);
    border-color: #ef4444;
  }
  100% {
    filter: brightness(1);
    box-shadow: 0 0 0 rgba(239, 68, 68, 0);
  }
}

@keyframes glowPulse {
  0% {
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.4);
    border-color: rgba(0, 212, 255, 0.6);
  }
  50% {
    box-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
    border-color: rgba(0, 212, 255, 1);
  }
  100% {
    box-shadow: 0 0 15px rgba(0, 212, 255, 0.4);
    border-color: rgba(0, 212, 255, 0.6);
  }
}

@keyframes evoGlow {
  0% {
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.6);
    border-color: rgba(34, 197, 94, 0.8);
    filter: brightness(1.1);
  }
  50% {
    box-shadow: 0 0 40px rgba(34, 197, 94, 1);
    border-color: rgba(34, 197, 94, 1);
    filter: brightness(1.3);
  }
  100% {
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.6);
    border-color: rgba(34, 197, 94, 0.8);
    filter: brightness(1.1);
  }
}

@keyframes promoteGlow {
  0% {
    box-shadow: 0 0 20px rgba(168, 85, 247, 0.6);
    border-color: rgba(168, 85, 247, 0.8);
    filter: brightness(1.1);
  }
  50% {
    box-shadow: 0 0 40px rgba(168, 85, 247, 1);
    border-color: rgba(168, 85, 247, 1);
    filter: brightness(1.3);
  }
  100% {
    box-shadow: 0 0 20px rgba(168, 85, 247, 0.6);
    border-color: rgba(168, 85, 247, 0.8);
    filter: brightness(1.1);
  }
}

@keyframes popupSlide {
  0% {
    opacity: 0;
    transform: translate(-50%, -100%);
  }
  10% {
    opacity: 1;
    transform: translate(-50%, -50%);
  }
  90% {
    opacity: 1;
    transform: translate(-50%, -50%);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -50%);
  }
}

@keyframes nebulaPulse {
  0%, 100% {
    opacity: 0.3;
  }
  50% {
    opacity: 0.6;
  }
}

@keyframes twinkle {
  0%, 100% {
    opacity: 0.3;
  }
  50% {
    opacity: 1;
  }
}

body{
  font-family:'Segoe UI',Arial,sans-serif;
  background:linear-gradient(135deg, #0a0a1a 0%, #1a0f2e 50%, #2d1b4e 100%);
  background-size: 200% 200%;
  animation: backgroundShift 30s ease infinite;
  margin:0;
  padding:0;
  color:#e5e7eb;
  height:100vh;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  align-items:center;
  background-attachment:fixed;
  position: relative;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  touch-action: manipulation;
}

@keyframes backgroundShift {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: 
    radial-gradient(circle at 20% 30%, rgba(0, 212, 255, 0.08) 0%, transparent 50%),
    radial-gradient(circle at 80% 70%, rgba(227, 53, 13, 0.08) 0%, transparent 50%),
    radial-gradient(circle at 50% 50%, rgba(138, 43, 226, 0.05) 0%, transparent 70%);
  animation: particleFloat 25s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

@keyframes particleFloat {
  0%, 100% { opacity: 0.5; transform: translate(0, 0) scale(1); }
  33% { opacity: 0.7; transform: translate(20px, -20px) scale(1.1); }
  66% { opacity: 0.6; transform: translate(-20px, 20px) scale(0.9); }
}
h1{
  margin:0;
  width:100%;
  padding:.4rem 0;
  text-align:center;
  background:linear-gradient(135deg,#e3350d,#0074d9);
  color:#fff;
  font-size:1.05rem;
  letter-spacing:.2px;
}
.main-layout{
  display:flex;
  justify-content:center;
  align-items:center;
  width:100%;
  height:calc(100vh - 52px);
  position:relative;
  z-index:1;
}
.battlefield{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:space-evenly;
  max-width:850px !important;
  width:100%;
  height:95%;
  transform-origin:center center;
  transform:scale(0.92);
}
.player-area{
  transition: background 0.6s ease, box-shadow 0.6s ease, border-color 0.6s ease, min-height 0.3s ease !important;
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
  padding:6px 0;
  position:relative;
  z-index:1;
  min-height: fit-content;
}

.card-slot.drag-target {
  border: 2px dashed #6e4e9c;
  background: rgba(110, 78, 156, 0.1);
}

.card-slot.drag-over {
  border: 2px solid #9d7dd4;
  background: rgba(157, 125, 212, 0.2);
  transform: scale(1.05);
}

.hand .card-img[draggable="true"] {
  cursor: grab;
}

.hand .card-img[draggable="true"]:active {
  cursor: grabbing;
}

.hand,.bench,.active{
  display:flex;
  justify-content:center;
  gap:8px;
  flex-wrap:wrap;
  position:relative;
}
.bench,.active{
  min-height:calc(var(--card-h) + 6px);
}
.card-slot{
  width:var(--card-w);
  height:var(--card-h);
  border-radius:8px;
  background:rgba(20, 20, 30, 0.65);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:10px;
  color:#a1a1aa;
  box-shadow:0 1px 3px rgba(0,0,0,.5);
  position:relative;
  flex-shrink:0;
  border:2px solid rgba(138, 43, 226, 0.3);
  backdrop-filter:blur(8px);
  transition: all 0.3s ease;
}

.card-slot:hover {
  border-color: rgba(138, 43, 226, 0.6);
  box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4), 0 0 20px rgba(138, 43, 226, 0.2);
  background: rgba(20, 20, 30, 0.8);
}
.slot-label{
  position:absolute;
  inset:auto 0 6px 0;
  text-align:center;
  font-weight:700;
  background:rgba(0,0,0,.7);
  color:#fff;
  border-radius:12px;
  line-height:1;
  padding:3px 8px;
  width:70px;
  margin:auto;
  font-size:10px;
  pointer-events:none;
}

.hp-badge {
  position: absolute;
  top: 4px;
  right: 4px;
  background: rgba(239, 68, 68, 0.95);
  color: #fff;
  font-weight: 700;
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 8px;
  pointer-events: none;
  z-index: 10;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  border: 1px solid rgba(255, 255, 255, 0.2);
}
.hp-badge.tool-boosted {
  background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
  animation: pulse-green 2s ease-in-out infinite;
}
@keyframes pulse-green {
  0%, 100% { box-shadow: 0 2px 4px rgba(0,0,0,0.3), 0 0 0 0 rgba(34, 197, 94, 0.7); }
  50% { box-shadow: 0 2px 4px rgba(0,0,0,0.3), 0 0 0 4px rgba(34, 197, 94, 0); }
}
.card-img{
  width:var(--card-w);
  height:var(--card-h);
  object-fit:contain;
  border-radius:6px;
  cursor:pointer;
  transition:all .3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), left 0.4s cubic-bezier(0.4, 0, 0.2, 1), top 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  z-index:2;
  position:relative;
  transform:perspective(700px) rotateX(0deg);
  transform-style: preserve-3d;
  will-change: transform;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  user-select: none;
}

.card-img.moving {
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 100;
}

@keyframes cardSlideIn {
  from {
    opacity: 0;
    transform: perspective(700px) rotateX(0deg) translateY(-20px) scale(0.9);
  }
  to {
    opacity: 1;
    transform: perspective(700px) rotateX(0deg) translateY(0) scale(1);
  }
}

.card-img.just-added {
  animation: cardSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.card-img:hover {
  transform: perspective(700px) rotateX(5deg) rotateY(5deg) translateZ(10px) scale(1.05) !important;
  box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4), 0 0 40px rgba(138, 43, 226, 0.3) !important;
  filter: brightness(1.1);
  z-index: 1;
}
.active .card-img{
  border:3px solid #00d4ff !important;
  box-shadow:0 0 8px rgba(255,215,0,.6);
  transform:perspective(700px) rotateX(12deg);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.active .card-img:hover {
  transform: perspective(700px) rotateX(8deg) rotateY(5deg) translateZ(15px) scale(1.08) !important;
  box-shadow: 0 12px 35px rgba(0, 212, 255, 0.5), 0 0 50px rgba(255, 215, 0, 0.4) !important;
  z-index: 1;
}
.bench .card-img{
  transform:perspective(700px) rotateX(6deg);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.bench .card-img:hover {
  transform: perspective(700px) rotateX(4deg) rotateY(5deg) translateZ(12px) scale(1.06) !important;
  box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4), 0 0 40px rgba(138, 43, 226, 0.3) !important;
  z-index: 1;
}
.hand .card-img{
  transform:perspective(700px) rotateX(3deg);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.hand .card-img:hover {
  transform: perspective(700px) rotateX(2deg) rotateY(5deg) translateZ(10px) scale(1.05) !important;
  box-shadow: 0 8px 25px rgba(0, 212, 255, 0.4), 0 0 35px rgba(138, 43, 226, 0.3) !important;
  z-index: 1;
}

.poke-comm-glow {
  animation: poke-comm-pulse 1.5s ease-in-out infinite;
  box-shadow: 0 0 20px rgba(59, 130, 246, 0.8), 0 0 40px rgba(59, 130, 246, 0.4) !important;
  border: 2px solid #3b82f6 !important;
}
@keyframes poke-comm-pulse {
  0%, 100% { transform: perspective(700px) rotateX(3deg) scale(1); }
  50% { transform: perspective(700px) rotateX(3deg) scale(1.05); }
}
#p1Active,#p1Bench{
  outline:1.5px solid #4da3ff;
  outline-offset:3px;
  border-radius:5px;
}
#p2Active,#p2Bench{
  outline:1.5px solid #ff6b6b;
  outline-offset:3px;
  border-radius:5px;
}
.deck-bubble, .hand-bubble, .discard-bubble{
  position:absolute;
  width:32px;
  height:32px;
  border-radius:50%;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  font-weight:700;
  font-size:12px;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 2px 6px rgba(0,0,0,.5);
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  transition: all 0.3s ease;
  cursor: pointer;
  z-index: 100;
}

.deck-bubble:hover, .hand-bubble:hover, .discard-bubble:hover {
  transform: scale(1.15);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.5), 0 0 20px rgba(0, 212, 255, 0.3);
  border-color: rgba(0, 212, 255, 0.6) !important;
  background: rgba(40, 40, 50, 1) !important;
}

#p1Bubble{
  right: 70px;
  bottom: 20px;
  transform: none;
}

#p2Bubble{
  left: 70px;
  top: 20px;
  transform: none;
}

#p1HandBubble{
  right: 10px;
  bottom: 60px;
  transform: none;
}

#p2HandBubble{
  left: 10px;
  top: 80px;
  transform: none;
}

#p1DiscardBubble{
  left: 20px;
  bottom: 20px;
  transform: translateY(0);
}

#p2DiscardBubble{
  left: 20px;
  top: calc(50% + 60px);
  transform: translateY(0);
}

.deck-stack {
  position: absolute;
  width: 60px;
  height: 84px;
  perspective: 1000px;
}

#p1DeckStack {
  right: 20px;
  bottom: 20px;
  transform: none;
}

#p2DeckStack {
  left: 20px;
  top: 20px;
  transform: none;
}

.deck-card {
  position: absolute;
  width: 60px;
  height: 84px;
  background-image: url('imgs/cardback.png');
  background-size: cover;
  background-position: center;
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(100, 100, 120, 0.3);
  transition: transform 0.3s ease, opacity 0.3s ease;
}

.deck-card:nth-child(1) { transform: translateY(0px) rotate(0deg); z-index: 10; }
.deck-card:nth-child(2) { transform: translateY(2px) rotate(0.5deg); z-index: 9; opacity: 0.95; }
.deck-card:nth-child(3) { transform: translateY(4px) rotate(-0.5deg); z-index: 8; opacity: 0.9; }
.deck-card:nth-child(4) { transform: translateY(6px) rotate(0.3deg); z-index: 7; opacity: 0.85; }
.deck-card:nth-child(5) { transform: translateY(8px) rotate(-0.3deg); z-index: 6; opacity: 0.8; }
.deck-card:nth-child(n+6) { transform: translateY(10px) rotate(0deg); z-index: 5; opacity: 0.75; }

.deck-stack.shuffling .deck-card {
  animation: deckShuffle 0.6s ease-in-out;
}

@keyframes deckShuffle {
  0%, 100% { transform: translateY(0) rotate(0deg); }
  25% { transform: translateY(-5px) rotate(2deg); }
  50% { transform: translateY(5px) rotate(-2deg); }
  75% { transform: translateY(-3px) rotate(1deg); }
}

.card-draw-animation {
  position: fixed;
  width: 60px;
  height: 84px;
  background-image: url('imgs/cardback.png');
  background-size: cover;
  background-position: center;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
  border: 1px solid rgba(100, 100, 120, 0.5);
  z-index: 10000;
  pointer-events: none;
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}
.points-indicator{
  position:absolute;
  top:calc(50% + 26px);
  transform:translateY(-50%);
  display:flex;
  gap:6px;
  align-items:center;
  z-index:5;
  filter:brightness(1.1) !important;
}
#p1Points{
  right:4px;transform:translateX(50%);
}
#p2Points{
  left:4px;transform:translateX(-50%);
}
.point-bubble{
  width:14px;
  height:14px;
  border-radius:50%;
  border:1.5px solid #94a3b8;
  background:rgba(40, 40, 50, 0.8) !important;
  box-shadow:0 0 4px rgba(0,0,0,.5);
  transition:background .25s,border-color .25s,box-shadow .25s;
  border-color:rgba(100, 100, 120, 0.5) !important;
}
.point-bubble.filled{
  background:#facc15 !important;
  border-color:#fde047 !important;
  box-shadow:0 0 8px 2px rgba(250, 204, 21, 0.7) !important;
}
.energy-zone{
  display:flex !important;
  flex-wrap:wrap;
  gap:6px !important;
  justify-content:center;
  background:rgba(40, 40, 50, 0.96) !important;
  backdrop-filter:blur(20px);
  border-radius:12px !important;
  padding:10px !important;
  z-index:200 !important;
  position:fixed !important;
  pointer-events:all !important;
  visibility:visible !important;
  left:50% !important;
  transform:translateX(-50%) !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  bottom:60px !important;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4), 0 0 20px rgba(0, 212, 255, 0.2) !important;
  transition: all 0.3s ease;
}

.energy-zone:hover {
  border-color: rgba(0, 212, 255, 0.5) !important;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 30px rgba(0, 212, 255, 0.3) !important;
  background: rgba(40, 40, 50, 1) !important;
}

.energy{
  width:30px !important;
  height:30px !important;
  border-radius:50% !important;
  background-size:contain !important;
  background-position:center !important;
  cursor:pointer !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  box-shadow:0 2px 6px rgba(0, 0, 0, 0.3) !important;
  background-repeat:no-repeat !important;
  transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
  position: relative;
}

.energy-zone .energy-container > .energy {
  width: 36px !important;
  height: 36px !important;
  background-size: cover !important;
}

.energy:hover {
  transform: scale(1.2) rotate(5deg) !important;
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.5), 0 0 20px rgba(0, 212, 255, 0.3) !important;
  border-color: rgba(0, 212, 255, 0.6) !important;
  z-index: 1;
}
.energy-pips{
  position:absolute;
  left:3px;
  bottom:3px;
  height:16px;
  display:flex;
  gap:2px;
  z-index:5;
}
.energy-pip{
  width:16px;
  height:16px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #1f2937;
}
.status-icon{
  position:absolute;
  left:4px;
  top:4px;
  width:20px;
  height:20px;
  border-radius:50%;
  background-size:contain;
  background-repeat:no-repeat;
  background-position:center;
  pointer-events:none;
  z-index:6;
}
.zoom-status{
  width:22px;
  height:22px;
  border-radius:50%;
  background-size:contain;
  background-repeat:no-repeat;
  background-position:center;
  flex-shrink:0;
}
.zoom-status-icon{
  width:22px;
  height:22px;
  border-radius:50%;
  background-size:contain;
  background-position:center;
  background-repeat:no-repeat;
  flex-shrink:0;
}
.hp-overlay{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom:22px;
  min-width:72px;
  text-align:center;
  background:rgba(0,0,0,.85);
  color:#fff;
  font-weight:800;
  font-size:10px;
  padding:2px 8px;
  border-radius:12px;
  z-index:5;
  line-height:1;
  white-space:nowrap;
  pointer-events:none;
  transition: all 0.3s ease;
  box-shadow: 0 2px 8px rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
}

.hp-overlay:hover {
  transform: translateX(-50%) scale(1.1);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.4);
}
.tool-thumb{
  position:absolute;
  top:30px;
  left:6px;
  width:34px;
  height:44px;
  border-radius:4px;
  box-shadow:0 2px 6px rgba(0,0,0,.6);
  border:1px solid #111827;
  background-color:#0b0f14;
  z-index:5;
  cursor:pointer;
  object-fit:cover;
  object-position:center 15%;
  clip-path:inset(15% 5% 45% 5%);
  transition:transform .15s ease;
}
#zoomTools img{
  width:88px;
  height:108px;
  border-radius:8px;
  border:1px solid #444;
  object-fit:cover;
  object-position:center 15%;
  clip-path:inset(15% 10% 45% 10%);
  box-shadow:0 0 8px rgba(0,0,0,.4);
  margin-top:0 !important;
}
#zoomTools{
  display:flex;
  align-items:center;
  gap:10px;
  padding:0 !important;
}
.side-panel{
  position:fixed;
  top:20px;
  right:20px;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:.6rem;
  z-index:10;
}
@media (max-width: 768px) {
  .side-panel {
    top: 50% !important;
    right: 8px !important;
    transform: translateY(-50%) !important;
    margin-top: 35px !important;
  }
}
@media (max-width: 480px) {
  .side-panel {
    top: 50% !important;
    right: 6px !important;
    transform: translateY(-50%) !important;
    margin-top: 30px !important;
  }
}
.coin{
  width:70px;
  height:70px;
  position:relative;
  transform-style:preserve-3d;
  transition:transform 1.5s ease-in-out;
}
.coin img{
  width:100%;
  height:100%;
  border-radius:50%;
  position:absolute;
  backface-visibility:hidden;
}
.coin .back{
  transform:rotateY(180deg);
}
.coin.flip{
  animation:flipCoin 1.5s ease-in-out;
  transform-style: preserve-3d;
}

.coin.flip .front,
.coin.flip .back {
  animation: coinSpin 1.5s ease-in-out;
}

@keyframes coinSpin {
  0% { transform: rotateY(0deg); }
  100% { transform: rotateY(1800deg); }
}
#coinResult{
  text-align:center;
  font-weight:700;
  font-size:13px;
  min-height:35px;
}
button{
  background:linear-gradient(135deg,#e3350d,#0074d9);
  color:#fff;
  border:1px solid #1f2937;
  padding:8px 14px;
  border-radius:10px;
  cursor:pointer;
  font-size:.9rem;
  transition:transform 0.15s ease, box-shadow 0.15s ease;
  position: relative;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  transform: translateY(0);
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4), 0 6px 20px rgba(227, 53, 13, 0.4);
}

button:active {
  transform: translateY(-1px) scale(0.98);
  box-shadow: 0 3px 10px rgba(0,0,0,0.4);
  transition: transform 0.1s ease, box-shadow 0.1s ease;
}

button::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: translate(-50%, -50%);
  transition: width 0.4s ease-out, height 0.4s ease-out, opacity 0.4s ease-out;
  opacity: 0;
  pointer-events: none;
}

button:active::after {
  width: 300px;
  height: 300px;
  opacity: 1;
}
.turnbox{
  width:150px;
  border:1px solid #3b3f46;
  background:#23272e;
  border-radius:12px;
  padding:10px;
  text-align:center;
  font-size:.92rem;
  box-shadow:0 1px 3px rgba(0,0,0,.4);
  color:#e5e7eb;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.turnbox::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(227, 53, 13, 0.1));
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

.turnbox:hover::before {
  opacity: 1;
}

.turnbox:hover {
  border-color: rgba(0, 212, 255, 0.5);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
  transform: translateY(-2px);
}
.turnbox .big{
  font-weight:800;
  font-size:1.05rem;
}
#popup{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%) scale(0.8);
  background:linear-gradient(135deg, rgba(17,17,17,0.95) 0%, rgba(30,30,40,0.95) 100%);
  color:#fff;
  padding:12px 20px;
  border-radius:12px;
  font-size:14px;
  font-weight:800;
  opacity:0;
  z-index:200;
  transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 8px 32px rgba(0,0,0,0.5), 0 0 20px rgba(0, 212, 255, 0.3);
  border: 1px solid rgba(0, 212, 255, 0.3);
  backdrop-filter: blur(10px);
}
#popup.show{
  opacity:1;
  transform:translate(-50%,-50%) scale(1);
  animation: popupBounce 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}
@keyframes popupBounce {
  0% { transform: translate(-50%,-50%) scale(0.3); opacity: 0; }
  50% { transform: translate(-50%,-50%) scale(1.1); }
  100% { transform: translate(-50%,-50%) scale(1); opacity: 1; }
}
.disable-clicks{
  pointer-events:none;
  filter:saturate(.9) brightness(.98);
}
.glow-evo{
  animation:evoGlow 1.5s ease-in-out infinite !important;
  outline:3px solid rgba(255,215,0,.95);
  border-radius:8px;
  cursor:pointer;
  filter:drop-shadow(0 0 6px rgba(255,215,0,.85));
  border:3px solid #ffd700 !important;
}
.promote-glow{
  animation:glowPulse .9s ease-in-out infinite alternate;
  outline:3px solid rgba(59,130,246,.95);
  border-radius:8px;
}
.attack-menu{
  position:fixed !important;
  
  background:rgba(255, 255, 255, 0.98) !important;
  border:1px solid #3b3f46;
  border-radius:12px !important;
  box-shadow:0 14px 38px rgba(0,0,0,.5);
  padding:18px !important;
  min-width:280px !important;
  z-index:1000 !important;
  opacity:0;
  color:#e5e7eb;
  backdrop-filter:blur(20px);
  width:280px !important;
  overflow-y:auto !important;
  
  transform-origin: center center;
}
.attack-menu.show{
  opacity:1;
  
}

@keyframes menuSlideIn {
  0% {
    opacity: 0;
    transform: translateY(-10px) scale(0.9);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}
.attack-item{
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  gap:8px;
  padding:14px 16px !important;
  border-radius:10px !important;
  cursor:pointer;
  background:linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%) !important;
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  color:#ffffff !important;
  min-height:52px;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
}

.attack-item:hover {
  transform: translateX(4px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.attack-item.payable{
  background:rgba(0, 212, 255, 0.15) !important;
  border-color:#00d4ff !important;
}

.attack-item.payable:hover {
  background:rgba(0, 212, 255, 0.25) !important;
  box-shadow: 0 4px 16px rgba(0, 212, 255, 0.4);
  transform: translateX(4px) scale(1.02);
}
.attack-name{
  font-size:14px !important;
  font-weight:700 !important;
  color:#ffffff !important;
  line-height:1.2 !important;
  margin-right:8px !important;
  flex-shrink:0 !important;
}
.attack-cost{
  display:flex !important;
  gap:2px !important;
  margin-right:8px !important;
}
.cost-icon{
  width:16px;
  height:18px !important;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
  margin:0 1px !important;
}
.cost-icon.missing{
  filter:grayscale(100%) brightness(50%);
}
.damage-flash{
  animation:damageFlash 0.4s ease-out !important;
}
.zoom-backdrop{
  position:fixed;
  inset:0;
  background:rgba(0, 0, 0, 0.88) !important;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:3000 !important;
  backdrop-filter:blur(10px);
}
.zoom-backdrop.show{
  display:flex;
}
.zoom-modal{
  display:flex;
  gap:18px;
  align-items:flex-start;
  max-width:1180px;
  animation: zoomModalAppear 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes zoomModalAppear {
  0% {
    opacity: 0;
    transform: scale(0.8) translateY(20px);
  }
  100% {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.zoom-modal img{
  width:calc(var(--card-w) * 4);
  height:auto;
  border-radius:14px;
  box-shadow:0 18px 48px rgba(0,0,0,.65);
  background:#111;
  transition: transform 0.3s ease;
}

.zoom-modal img:hover {
  transform: scale(1.02);
}
.zoom-panel{
  min-width:470px;
  max-width:520px;
  background:rgba(30, 30, 40, 0.98) !important;
  border:1px solid #3b3f46;
  border-radius:18px !important;
  box-shadow:0 10px 28px rgba(0,0,0,.45);
  padding:16px;
  color:#e5e7eb !important;
  backdrop-filter:blur(20px);
  max-height:90vh !important;
  overflow-y:auto !important;
}
.zoom-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:10px;
}
.zoom-title{
  font-weight:700 !important;
  font-size:22px !important;
  color:#ffffff !important;
}
.zoom-hp{
  font-size:12px;
  color:#ffffff !important;
}
.zoom-type{
  width:24px;
  height:24px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
}
.hpbar-container{
  width:100%;
  height:12px;
  background:#2f343c;
  border-radius:8px;
  overflow:hidden;
  margin:8px 0 6px;
}
.hpbar-fill{
  height:100%;
  width:0;
  border-radius:8px;
  transition:width .4s cubic-bezier(0.4, 0, 0.2, 1), background .3s ease;
  background:linear-gradient(90deg,#22c55e,#16a34a);
  position: relative;
  overflow: hidden;
}

.hpbar-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  animation: hpbarShine 2s ease-in-out infinite;
}

@keyframes hpbarShine {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}
.zoom-section{
  border-top:1px solid #3b3f46;
  margin-top:12px;
  padding-top:12px;
  opacity:1 !important;
  margin-bottom:20px !important;
}
.row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  margin:4px 0;
}
.chip{
  font-size:12px;
  background:#2a2f36;
  border:1px solid #3b3f46;
  border-radius:999px;
  padding:2px 8px;
  color:#e5e7eb;
}
.icon-row{
  display:flex;
  gap:6px;
  align-items:center;
  flex-wrap:wrap;
}
.mini-icon{
  width:18px;
  height:18px;
  border-radius:50%;
  background-size:cover;
  background-position:center;
  border:1px solid #111827;
  display:inline-block;
}
.mini-badge{
  font-size:11px;
  color:#cbd5e1;
  margin-left:4px;
}
.zoom-attack{
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  padding:16px !important;
  margin:10px 0;
  cursor:pointer;
  transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
  background:rgba(50, 50, 60, 0.8) !important;
  margin-bottom:12px !important;
  position: relative;
}

.zoom-attack:hover {
  transform: translateX(4px);
  border-color: rgba(0, 212, 255, 0.6) !important;
  box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
  background: rgba(50, 50, 60, 0.95) !important;
}
.zoom-attack .dmg {
  font-size:16px !important;
  font-weight:800 !important;
  color:#000000 !important; 
  transition: all 0.3s ease;
  text-shadow: 0 1px 3px rgba(0,0,0,0.5);
  display: inline-block;
}

.zoom-attack:hover .dmg {
  transform: scale(1.15);
  
  
}

.zoom-attack .top{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
  border-radius:10px;
  padding:8px 10px;
}
.zoom-attack .name{
  font-weight:800;
}
.zoom-attack .dmg{
  font-weight:900;
}
.thin{
  height:1px;
  background:#3b3f46;
  margin:8px 0;
}
.effect{
  font-size:12px;
  color:#cbd5e1;
  line-height:1.25;
}
.muted{
  opacity:.45;cursor:not-allowed;
}
.mini-icon.missing{
  filter:grayscale(100%) brightness(65%);
}
.discard-btn{
  position:absolute;
  left:12px;
  top:50%;
  transform:translateY(-50%);
  z-index:9;
}
.discard-btn.right{
  left:auto;
  right:12px;
}
.discard-drawer{
  position:fixed;
  top:0;
  bottom:0;
  width:320px;
  background:linear-gradient(180deg, #1a1e24 0%, #0f1216 100%);
  right:0;
  left:auto;
  border-left:2px solid rgba(0, 212, 255, 0.3);
  box-shadow:-20px 0 40px rgba(0,0,0,.7), 0 0 30px rgba(0, 212, 255, 0.1);
  z-index:1200;
  padding:20px;
  display:none;
  overflow:auto;
  color:#e5e7eb;
  backdrop-filter: blur(20px);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  transform: translateX(100%);
}

.discard-drawer.show {
  transform: translateX(0);
}

.discard-drawer::-webkit-scrollbar {
  width: 8px;
}

.discard-drawer::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}

.discard-drawer::-webkit-scrollbar-thumb {
  background: rgba(0, 212, 255, 0.4);
  border-radius: 4px;
}

.discard-drawer::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 212, 255, 0.6);
}

#p1DiscardDrawer {
  z-index: 1201;
}

#p2DiscardDrawer {
  z-index: 1200;
}

.discard-drawer.show{
  display:block;
  animation: drawerSlideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes drawerSlideInRight {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.discard-item{
  display:flex;
  align-items:center;
  gap:12px;
  margin:12px 0;
  padding:10px;
  background:rgba(30, 34, 42, 0.6);
  border-radius:12px;
  border:1px solid rgba(100, 100, 120, 0.2);
  transition: all 0.2s ease;
}

.discard-item:hover {
  background:rgba(40, 44, 52, 0.8);
  border-color: rgba(0, 212, 255, 0.4);
  transform: translateX(4px);
  box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
}

.discard-item img{
  width:65px;
  height:91px;
  border-radius:10px;
  box-shadow:0 8px 20px rgba(0,0,0,.6), 0 0 15px rgba(0, 212, 255, 0.2);
  transition: all 0.3s ease;
  border: 2px solid rgba(100, 100, 120, 0.3);
}

.discard-item:hover img {
  transform: scale(1.05) rotate(2deg);
  box-shadow: 0 10px 25px rgba(0,0,0,.7), 0 0 20px rgba(0, 212, 255, 0.3);
  border-color: rgba(0, 212, 255, 0.5);
}

.discard-group{
  display:flex;
  align-items:center;
  gap:12px;
  flex-wrap: wrap;
}

.discard-count{
  font-weight:800;
  color:#ffffff;
  background:linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(138, 43, 226, 0.2));
  border:1px solid rgba(0, 212, 255, 0.4);
  border-radius:999px;
  padding:4px 12px;
  box-shadow: 0 2px 8px rgba(0, 212, 255, 0.2);
  font-size: 13px;
}
#victoryOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.68);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
  backdrop-filter: blur(8px);
  animation: fadeInOverlay 0.4s ease;
}

@keyframes fadeInOverlay {
  from { opacity: 0; }
  to { opacity: 1; }
}

#victoryCard{
  width:min(540px,92vw);
  background:#101418;
  border:1px solid #334155;
  border-radius:16px;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
  padding:22px;
  color:#e5e7eb;
  text-align:center;
  animation: victoryCardAppear 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  overflow: hidden;
}

@keyframes victoryCardAppear {
  0% {
    opacity: 0;
    transform: scale(0.5) translateY(-50px);
  }
  50% {
    transform: scale(1.05) translateY(0);
  }
  100% {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

#victoryCard::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: 
    radial-gradient(circle at 20% 30%, rgba(255, 215, 0, 0.3) 0%, transparent 2%),
    radial-gradient(circle at 80% 70%, rgba(0, 212, 255, 0.3) 0%, transparent 2%),
    radial-gradient(circle at 50% 50%, rgba(227, 53, 13, 0.3) 0%, transparent 2%);
  animation: confettiFall 3s ease-in-out infinite;
  pointer-events: none;
}

@keyframes confettiFall {
  0% { transform: translateY(-100%) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
}
#victoryCard h2{
  margin:4px 0 8px 0;
  font-size:24px;
}
#victoryCard p{
  margin:6px 0 16px 0;
  color:#cbd5e1;
}
#victoryBtns{
  display:flex;
  gap:10px;
  justify-content:center;
}
#victoryOverlay,#victoryOverlay *{
  pointer-events:auto;
}
#toolBackdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:1100;
}
#toolBackdrop.show{
  display:flex;
}
#toolCard{
  display:flex;
  gap:18px;
  align-items:flex-start;
  max-width:980px;
}
#toolCard img{
  width:calc(var(--card-w) * 4);
  height:auto;
  border-radius:14px;
  box-shadow:0 18px 48px rgba(0,0,0,.65);
  background:#111;
}
#toolPanel{
  min-width:360px;
  max-width:420px;
  background:#1f232a;
  border:1px solid #3b3f46;
  border-radius:16px;
  box-shadow:0 10px 28px rgba(0,0,0,.45);
  padding:16px;
  color:#e5e7eb;
}
#toolPanel h3{
  margin:0 0 8px 0;
}
#zoomAttached{
  padding-bottom:0;margin-bottom:0 !important;
}
#zoomAttached .row{
  margin:0 0 4px 0 !important;
}
#zoomAttached+.zoom-section{
  margin-top:6px;padding-top:8px !important;
}
.ability-box{
  border:1px solid #3b3f46;
  border-radius:10px;
  background:#23272e;
  margin:6px 0;
  padding:6px 8px;
}
.ability-head{
  display:flex;
  align-items:center;
  gap:6px;
  border-radius:8px;
  padding:6px 8px;
  font-weight:800;
  color:#0b0f14;
}
.ability-head img{
  width:60px;
  height:18px;
  border-radius:3px;
  display:block;
}
.ability-name{
  font-size:13px;
}
.ability-text{
  font-size:12px;
  color:#cbd5e1;
  margin-top:6px;
  line-height:1.25;
}
.heal-glow{
  animation:glowPulse .9s ease-in-out infinite alternate;
  outline:3px solid rgba(74,222,128,.95);
  border-radius:8px;
  cursor:pointer;
  filter:drop-shadow(0 0 6px rgba(74,222,128,.85));
}
#zoomRetreatRow{
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  background:linear-gradient(180deg,#2a2f36,#262b32);
  transition:all .2s ease;
  margin-top:10px;
  padding:8px 10px;
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  font-weight:700 !important;
  color:#ffffff !important;
  user-select:none;
  min-height:36px !important;
}
#zoomRetreatRow.enabled{
  cursor:pointer;
  filter:brightness(1.08);
  transform:scale(1.02);
}
#zoomRetreatRow.disabled{
  opacity:.5;
  cursor:not-allowed;
  filter:grayscale(80%);
}
#handType{
  color:#fff;
  font-weight:700;
  border:none;
  text-transform:capitalize;
}
#logToggleBtn{
  position:fixed;
  right:30px;
  top:355px;
  z-index:1500;
  background:linear-gradient(90deg,#2a2f36,#1f232a);
  border:1px solid #334155;
  padding:8px 14px;
  color:#e5e7eb;
  border-radius:10px;
  font-size:.85rem;
  cursor:pointer;
  box-shadow:0 4px 10px rgba(0,0,0,.4);
}
#logPanel{
  position:fixed;
  top:100px;
  right:-380px;
  width:360px;
  height:calc(100vh - 140px);
  background:linear-gradient(180deg, #0f1216 0%, #1a1e24 100%);
  border-left:2px solid rgba(0, 212, 255, 0.3);
  box-shadow:-15px 0 35px rgba(0,0,0,.7), 0 0 25px rgba(0, 212, 255, 0.1);
  padding:16px 16px 24px 16px;
  overflow-y:auto;
  transition:right .3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index:1200;
  color:#e5e7eb;
  backdrop-filter: blur(20px);
  clip-path: inset(0 0 0 0);
}

#logPanel:not(.show) {
  overflow: hidden;
  pointer-events: none;
  box-shadow: none !important;
  border-left: none !important;
}

#logPanel::-webkit-scrollbar {
  width: 8px;
}

#logPanel::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}

#logPanel::-webkit-scrollbar-thumb {
  background: rgba(0, 212, 255, 0.4);
  border-radius: 4px;
}

#logPanel::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 212, 255, 0.6);
}

#logPanel.show{
  right:20px;
  animation: logPanelSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes logPanelSlideIn {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}
#closeLogBtn{
  background:#d92d2d;
  color:white;
  border:none;
  padding:6px 10px;
  border-radius:6px;
  cursor:pointer;
  font-size:12px;
  width:100%;
  margin-bottom:10px;
}
#logPanelHeader{
  background:linear-gradient(135deg, rgba(217, 45, 45, 0.95) 0%, rgba(166, 28, 28, 0.95) 100%);
  color:white;
  padding:14px 16px;
  font-size:16px;
  font-weight:800;
  letter-spacing:1px;
  border-bottom:3px solid rgba(138, 20, 20, 0.8);
  margin-bottom:12px;
  border-radius:10px;
  box-shadow: 0 4px 12px rgba(217, 45, 45, 0.3);
  text-transform: uppercase;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
.turn-bar{
  background:linear-gradient(135deg, rgba(47, 52, 60, 0.9) 0%, rgba(36, 42, 49, 0.9) 100%);
  border-top:2px solid rgba(0, 212, 255, 0.3);
  border-bottom:2px solid rgba(0, 212, 255, 0.3);
  padding:12px 16px;
  font-size:14px;
  font-weight:800;
  color:#e5e7eb;
  display:flex;
  align-items:center;
  gap:10px;
  box-shadow:0 4px 12px rgba(0,0,0,.4), 0 0 10px rgba(0, 212, 255, 0.1);
  margin-top:10px;
  margin-bottom:10px;
  border-radius:10px;
  backdrop-filter: blur(10px);
}

.turn-icon{
  width:22px;
  height:22px;
  border-radius:50%;
  background:linear-gradient(135deg, #d92d2d, #a61c1c);
  display:flex;
  align-items:center;
  justify-content:center;
  color:white;
  font-size:12px;
  font-weight:900;
  box-shadow: 0 2px 8px rgba(217, 45, 45, 0.4);
  border: 2px solid rgba(255, 255, 255, 0.2);
}
.log-entry{
  background:linear-gradient(135deg, rgba(31, 35, 42, 0.95) 0%, rgba(20, 24, 30, 0.95) 100%);
  border:1px solid rgba(59, 63, 70, 0.5);
  border-left:4px solid #334155;
  padding:12px 14px;
  margin-bottom:14px;
  border-radius:12px;
  font-size:12px;
  line-height:1.4;
  color:#e5e7eb;
  box-shadow:0 4px 12px rgba(0,0,0,.4), 0 0 8px rgba(0,0,0,.2);
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
  position: relative;
  overflow: hidden;
}

.log-entry::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  background: inherit;
  transition: width 0.3s ease;
}

.log-entry:hover {
  transform: translateX(4px);
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(0, 212, 255, 0.2);
  border-color: rgba(100, 100, 120, 0.6);
}

.log-entry:hover::before {
  width: 6px;
}

.log-entry.p1{
  border-left-color:#3b82f6;
  background:linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(31, 35, 42, 0.95) 100%);
}

.log-entry.p1:hover {
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(59, 130, 246, 0.3);
  border-left-color: #60a5fa;
}

.log-entry.p2{
  border-left-color:#ef4444;
  background:linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(31, 35, 42, 0.95) 100%);
}

.log-entry.p2:hover {
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(239, 68, 68, 0.3);
  border-left-color: #f87171;
}

.log-entry.sys{
  border-left-color:#9ca3af;
  background:linear-gradient(135deg, rgba(156, 163, 175, 0.1) 0%, rgba(31, 35, 42, 0.95) 100%);
}

.log-entry.sys:hover {
  box-shadow: 0 6px 16px rgba(0,0,0,.5), 0 0 12px rgba(156, 163, 175, 0.2);
  border-left-color: #cbd5e1;
}
.entry-player{
  font-weight:800;
  margin-bottom:4px;
}
.entry-player.p1{
  color:#1e73d8;
}
.entry-player.p2{
  color:#d82020;
}
.entry-player.sys{
  color:#888;
}
.entry-text{
  line-height:1.35;
}
.log-thumb{
  width:48px;
  height:67px;
  border-radius:6px;
  margin-top:8px;
  box-shadow:0 2px 6px rgba(0,0,0,.45);
  border:1px solid #1f2937;
  cursor:pointer;
  align-self:flex-start;
}
#historyBackdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.7);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
}
#historyBackdrop.show{
  display:flex;
}
#historyCard{
  width:min(600px,90vw);
  background:#101418;
  border:1px solid #334155;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
  border-radius:16px;
  padding:20px;
  color:#e5e7eb;
  max-height:80vh;
  overflow-y:auto;
}
#historyCard h2{
  margin:0 0 10px 0;
  font-size:22px;
  text-align:center;
}
#fullHistory{
  font-size:13px;
  line-height:1.32;
}
.match-log-entry{
  background:#111827;
  border:1px solid #374151;
  border-left:4px solid #9ca3af;
  border-radius:8px;
  padding:8px 10px;
  box-shadow:0 2px 6px rgba(0,0,0,.4);
  margin-bottom:12px;
  color:#e5e7eb;
}
.ability-glow{
  animation:glowPulse 1.2s infinite;
  cursor:pointer;
  box-shadow:0 0 10px rgba(255,255,255,0.6);
}
.ability-disabled{
  opacity:0.45;
  filter:grayscale(70%);
  pointer-events:none;
}
.ability-entry{
  background:rgba(85, 105, 255, 0.14);
  border:1px solid rgba(110, 150, 255, 0.4);
  border-radius:8px;
  padding:8px 10px;
  margin:6px 0;
  transition:0.15s ease;
}
.ability-entry.disabled{
  opacity:0.45;
  pointer-events:none;
}
.ability-header{
  display:flex;
  align-items:center;
  gap:6px;
  margin-bottom:6px;
}
.ability-badge{
  background:linear-gradient(90deg, #cc2a2a, #ff5959);
  color:white;
  padding:2px 8px;
  border-radius:6px;
  font-size:11px;
  font-weight:700;
  text-transform:uppercase;
  letter-spacing:0.5px;
}
.ability-title{
  font-size:14px;
  font-weight:700;
  color:#ffffff;
}
.ability-desc{
  font-size:12px;
  line-height:1.3;
  opacity:0.9;
  color:#e8e8e8;
  margin-top:3px;
}
.ability-used-tag{
  margin-top:6px;
  font-size:11px;
  font-weight:bold;
  color:#ffaaaa;
  text-align:right;
}
.attack-ability-wrapper{
  margin-bottom:8px;
}
.attack-ability-row{
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  padding:6px 10px;
  border-radius:10px !important;
  background:linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
  box-shadow:0 0 0 1px rgba(15,23,42,0.7);
  cursor:pointer;
  transition:transform 0.08s ease-out, box-shadow 0.08s ease-out, opacity 0.15s;
  min-height:52px;
}
.attack-ability-row.used{
  opacity:0.45;
  cursor:default;
}
.attack-ability-left{
  display:flex;
  flex-direction:column;
  gap:2px;
}
.attack-ability-label{
  font-size:9px !important;
  font-weight:700;
  padding:1px 6px;
  border-radius:999px;
  background:rgba(0,0,0,0.4);
  text-transform:uppercase;
  letter-spacing:0.8px !important;
  color:rgba(255, 255, 255, 0.95) !important;
}
.attack-ability-name{
  font-size:14px !important;
  font-weight:700 !important;
  color:#fff !important;
  margin-top:2px !important;
  line-height:1.2 !important;
}
.attack-ability-right{
  display:flex;
  align-items:center;
  gap:4px;
  font-size:11px;
  opacity:0.8;
}
.attack-ability-toggle{
  cursor:pointer;
}
.attack-ability-desc{
  margin-top:4px;
  padding:6px 10px 7px;
  border-radius:8px;
  background:rgba(254, 226, 226, 0.2) !important;
  font-size:11px;
  color:#fecaca !important;
  line-height:1.3 !important;
  display:none;
}
.attack-desc{
  margin-top:-2px !important;
  margin-bottom:4px !important;
  padding:4px 10px 6px;
  border-radius:8px;
  background:rgba(30, 30, 40, 0.8) !important;
  font-size:11px;
  color:#d1d5db !important;
  display:none;
  line-height:1.3 !important;
}
.attack-info{
  font-size:12px !important;
  margin-left:6px;
  opacity:0.7;
  cursor:pointer;
  padding:2px 6px !important;
  color:#00d4ff !important;
}
#player1{
  border-radius:16px;
  padding:12px;
  box-shadow:0 -4px 16px rgba(0, 212, 255, 0.15);
  transition: background 0.6s ease, box-shadow 0.6s ease, border-color 0.6s ease, opacity 0.3s ease;
  position: relative;
}

#player1::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 16px;
  padding: 2px;
  background: linear-gradient(135deg, rgba(0, 212, 255, 0.3), rgba(0, 212, 255, 0.1));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

#player1:hover::before {
  opacity: 1;
}

#player2{
  border-radius:16px;
  padding:12px;
  box-shadow:0 4px 16px rgba(227, 53, 13, 0.15);
  transition: background 0.6s ease, box-shadow 0.6s ease, border-color 0.6s ease, opacity 0.3s ease;
  position: relative;
}

#player2::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 16px;
  padding: 2px;
  background: linear-gradient(135deg, rgba(227, 53, 13, 0.3), rgba(227, 53, 13, 0.1));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

#player2:hover::before {
  opacity: 1;
}
.zoom-card{
  border-radius:16px !important;
}
.zoom-hp-bar{
  background:linear-gradient(90deg, #22c55e 0%, #16a34a 100%) !important;
  border-radius:8px;
  box-shadow:inset 0 1px 2px rgba(0, 0, 0, 0.2);
}
.zoom-ability-card{
  background:linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border:2px solid #ef4444 !important;
  border-radius:10px !important;
  padding:16px !important;
  backdrop-filter:blur(10px);
  margin-bottom:8px !important;
}
.energy.selected{
  border:3px solid #00d4ff !important;
  box-shadow:0 0 16px rgba(0, 255, 255, 0.8) !important;
  transform:scale(1.2) !important;
}

.energy.selected-glow,
.card-img.selected-glow {
  box-shadow: 0 0 20px rgba(0, 212, 255, 0.8), 0 0 40px rgba(0, 212, 255, 0.6), 0 0 60px rgba(0, 212, 255, 0.4) !important;
  border: 2px solid #00d4ff !important;
  animation: pulse-glow 1.5s ease-in-out infinite !important;
  transform: scale(1.05) !important;
  z-index: 100 !important;
  position: relative;
}

@keyframes pulse-glow {
  0%, 100% {
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.8), 0 0 40px rgba(0, 212, 255, 0.6), 0 0 60px rgba(0, 212, 255, 0.4) !important;
  }
  50% {
    box-shadow: 0 0 30px rgba(0, 212, 255, 1), 0 0 60px rgba(0, 212, 255, 0.8), 0 0 90px rgba(0, 212, 255, 0.6) !important;
  }
}
#mainButton{
  background:rgba(40, 40, 50, 0.98) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:50px !important;
  padding:12px 20px !important;
  font-size:14px !important;
  font-weight:700 !important;
  text-transform:uppercase;
  letter-spacing:1px;
  transition:all 0.3s ease;
  z-index:150 !important;
  backdrop-filter:blur(20px);
  position:fixed !important;
  right:30px !important;
  top:50% !important;
  transform:translateY(-50%) !important;
  bottom:220px !important;
}
.popup{
  background:linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(243, 244, 246, 0.98) 100%) !important;
  backdrop-filter:blur(20px);
  color:#111827 !important;
  border-radius:50px !important;
  padding:14px 28px !important;
  font-weight:600 !important;
  font-size:15px !important;
  border:2px solid #e5e7eb !important;
  z-index:2500 !important;
}
.deck-bubble, .discard-btn{
  background:rgba(15, 15, 25, 0.85) !important;
  backdrop-filter:blur(12px);
  border:2px solid rgba(138, 43, 226, 0.4) !important;
  border-radius:12px !important;
}
.victory-overlay{
  background:rgba(0, 0, 0, 0.9) !important;
  backdrop-filter:blur(12px);
  z-index:5000 !important;
}
.victory-content{
  background:linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(243, 244, 246, 0.98) 100%) !important;
  backdrop-filter:blur(20px);
  border-radius:24px !important;
  border:3px solid #00d4ff !important;
}
.victory-title{
  font-size:44px !important;
  font-weight:700 !important;
  color:#111827 !important;
  text-transform:uppercase;
  letter-spacing:2px;
}
.victory-btn{
  background:linear-gradient(135deg, #00d4ff 0%, #0ff 100%) !important;
  color:#000 !important;
  border:none !important;
  border-radius:50px !important;
  padding:16px 40px !important;
  font-size:17px !important;
  font-weight:700 !important;
  text-transform:uppercase;
  letter-spacing:1px;
  box-shadow:0 8px 24px rgba(0, 212, 255, 0.5) !important;
}
.glow-promote, .promote-glow{
  animation:promoteGlow 1.5s ease-in-out infinite !important;
  border:3px solid #0ff !important;
}
.zoom-attack-name{
  font-size:16px !important;
  font-weight:700 !important;
  color:#ffffff !important;
}
.zoom-attack-text{
  font-size:14px !important;
  line-height:1.4 !important;
  color:#d1d5db !important;
  margin-top:4px !important;
}
.zoom-stats{
  border-radius:10px !important;
  padding:12px !important;
  margin-top:16px !important;
}
.zoom-stat-label{
  color:#9ca3af !important;
  font-weight:600 !important;
  font-size:12px !important;
  text-transform:uppercase;
  letter-spacing:1px;
  margin-bottom:6px !important;
}
.zoom-stat-value{
  color:#ffffff !important;
  font-weight:700 !important;
  display:flex !important;
  align-items:center !important;
  gap:6px !important;
  font-size:16px !important;
}
.attack-ability-wrapper[data-type="grass"] .attack-ability-row{
  background:linear-gradient(90deg, #22c55e 0%, #16a34a 100%) !important;
}
.attack-ability-wrapper[data-type="fire"] .attack-ability-row{
  background:linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
}
.attack-ability-wrapper[data-type="water"] .attack-ability-row{
  background:linear-gradient(90deg, #3b82f6 0%, #2563eb 100%) !important;
}
.attack-ability-wrapper[data-type="lightning"] .attack-ability-row{
  background:linear-gradient(90deg, #eab308 0%, #ca8a04 100%) !important;
}
.attack-ability-wrapper[data-type="psychic"] .attack-ability-row{
  background:linear-gradient(90deg, #a855f7 0%, #9333ea 100%) !important;
}
.attack-ability-wrapper[data-type="fighting"] .attack-ability-row{
  background:linear-gradient(90deg, #f97316 0%, #ea580c 100%) !important;
}
.attack-ability-wrapper[data-type="darkness"] .attack-ability-row{
  background:linear-gradient(90deg, #64748b 0%, #475569 100%) !important;
}
.attack-ability-wrapper[data-type="metal"] .attack-ability-row{
  background:linear-gradient(90deg, #94a3b8 0%, #64748b 100%) !important;
}
.attack-ability-wrapper[data-type="dragon"] .attack-ability-row{
  background:linear-gradient(90deg, #d3ba30 0%, #b89e20 100%) !important;
}
.attack-ability-wrapper[data-type="fairy"] .attack-ability-row{
  background:linear-gradient(90deg, #ec4899 0%, #db2777 100%) !important;
}
.attack-ability-wrapper[data-type="colorless"] .attack-ability-row{
  background:linear-gradient(90deg, #9ca3af 0%, #6b7280 100%) !important;
}
.attack-item.payable[data-type="grass"]{
  background:rgba(34, 197, 94, 0.2) !important;
  border-color:#22c55e !important;
}
.attack-item.payable[data-type="grass"] .attack-name{
  color:#15803d !important;
}
.attack-item.payable[data-type="fire"]{
  background:rgba(239, 68, 68, 0.2) !important;
  border-color:#ef4444 !important;
}
.attack-item.payable[data-type="fire"] .attack-name{
  color:#b91c1c !important;
}
.attack-item.payable[data-type="water"]{
  background:rgba(59, 130, 246, 0.2) !important;
  border-color:#3b82f6 !important;
}
.attack-item.payable[data-type="water"] .attack-name{
  color:#1e40af !important;
}
.attack-item.payable[data-type="lightning"]{
  background:rgba(234, 179, 8, 0.2) !important;
  border-color:#eab308 !important;
}
.attack-item.payable[data-type="lightning"] .attack-name{
  color:#a16207 !important;
}
.attack-item.payable[data-type="psychic"]{
  background:rgba(168, 85, 247, 0.2) !important;
  border-color:#a855f7 !important;
}
.attack-item.payable[data-type="psychic"] .attack-name{
  color:#7e22ce !important;
}
.attack-item.payable[data-type="fighting"]{
  background:rgba(249, 115, 22, 0.2) !important;
  border-color:#f97316 !important;
}
.attack-item.payable[data-type="fighting"] .attack-name{
  color:#c2410c !important;
}
.attack-item.payable[data-type="darkness"]{
  background:rgba(100, 116, 139, 0.2) !important;
  border-color:#64748b !important;
}
.attack-item.payable[data-type="darkness"] .attack-name{
  color:#334155 !important;
}
.attack-item.payable[data-type="metal"]{
  background:rgba(148, 163, 184, 0.2) !important;
  border-color:#94a3b8 !important;
}
.attack-item.payable[data-type="metal"] .attack-name{
  color:#475569 !important;
}
.attack-item.payable[data-type="dragon"]{
  background:linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%) !important;
  border-color:#8b5cf6 !important;
}
.attack-item.payable[data-type="dragon"] .attack-name{
  color:#6d28d9 !important;
}
.attack-item.payable[data-type="fairy"]{
  background:linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%) !important;
  border-color:#ec4899 !important;
}
.attack-item.payable[data-type="fairy"] .attack-name{
  color:#be185d !important;
}
.attack-item.payable[data-type="colorless"]{
  background:linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%) !important;
  border-color:#9ca3af !important;
}
.attack-item.payable[data-type="colorless"] .attack-name{
  color:#4b5563 !important;
}
.log-toggle-btn{
  bottom:20px !important;
  z-index:100 !important;
}
.prize-area{
  z-index:50 !important;
}
.hand{
  max-width:100% !important;
  flex-wrap:wrap !important;
  justify-content:center !important;
  min-height:calc(var(--card-h) + 12px);
  transition: min-height 0.3s ease;
}
.bench{
  max-width:100% !important;
  flex-wrap:wrap !important;
  justify-content:center !important;
}
.player-area > * + *{
  margin-top:2px !important;
}
.zoom-attack-header{
  display:flex !important;
  justify-content:space-between !important;
  align-items:center !important;
  margin-bottom:10px !important;
}
.zoom-attack-damage{
  font-size:20px !important;
  font-weight:900 !important;
  color:#ffffff !important;
  transition: all 0.3s ease;
  text-shadow: 0 1px 3px rgba(0,0,0,0.5);
  display: inline-block;
}

.zoom-attack:hover .zoom-attack-damage {
  transform: scale(1.15);
  text-shadow: 0 2px 6px rgba(0, 212, 255, 0.6), 0 0 12px rgba(0, 212, 255, 0.4);
  color: #00d4ff !important;
}
.zoom-attack-cost{
  display:flex !important;
  gap:3px !important;
  margin-right:8px !important;
}
.zoom-retreat-cost{
  background:rgba(40, 40, 50, 0.6) !important;
  border-radius:10px !important;
  padding:12px !important;
  margin-top:12px !important;
}
.zoom-retreat-btn{
  background:rgba(50, 50, 60, 0.8) !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  color:#ffffff !important;
  border-radius:10px !important;
  padding:14px !important;
  margin-top:12px !important;
  font-size:15px !important;
  font-weight:700 !important;
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
}
.zoom-panel *{
  filter:none !important;
  color:inherit;
}
.attack-damage{
  font-weight:900 !important;
  transition: all 0.3s ease;
  display: inline-block;
}

.attack-item:hover .attack-damage {
  transform: scale(1.15);
  text-shadow: 0 2px 6px rgba(0, 212, 255, 0.6), 0 0 12px rgba(0, 212, 255, 0.4);
  color: #00d4ff !important;
}
[id*="log"] button{
  z-index:90 !important;
}
.zoom-ability-card[data-type="grass"]{
  background:linear-gradient(135deg, rgba(34, 197, 94, 0.3) 0%, rgba(22, 163, 74, 0.3) 100%) !important;
  border-color:#22c55e !important;
}
.zoom-ability-card[data-type="grass"] .zoom-ability-name{
  color:#15803d !important;
}
.zoom-ability-card[data-type="fire"]{
  background:linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border-color:#ef4444 !important;
}
.zoom-ability-card[data-type="fire"] .zoom-ability-name{
  color:#b91c1c !important;
}
.zoom-ability-card[data-type="water"]{
  background:linear-gradient(135deg, rgba(59, 130, 246, 0.3) 0%, rgba(37, 99, 235, 0.3) 100%) !important;
  border-color:#3b82f6 !important;
}
.zoom-ability-card[data-type="water"] .zoom-ability-name{
  color:#1e40af !important;
}
.zoom-ability-card[data-type="lightning"]{
  background:linear-gradient(135deg, rgba(234, 179, 8, 0.3) 0%, rgba(202, 138, 4, 0.3) 100%) !important;
  border-color:#eab308 !important;
}
.zoom-ability-card[data-type="lightning"] .zoom-ability-name{
  color:#a16207 !important;
}
.zoom-ability-card[data-type="psychic"]{
  background:linear-gradient(135deg, rgba(168, 85, 247, 0.3) 0%, rgba(147, 51, 234, 0.3) 100%) !important;
  border-color:#a855f7 !important;
}
.zoom-ability-card[data-type="psychic"] .zoom-ability-name{
  color:#7e22ce !important;
}
.zoom-ability-card[data-type="fighting"]{
  background:linear-gradient(135deg, rgba(249, 115, 22, 0.3) 0%, rgba(234, 88, 12, 0.3) 100%) !important;
  border-color:#f97316 !important;
}
.zoom-ability-card[data-type="fighting"] .zoom-ability-name{
  color:#c2410c !important;
}
.zoom-ability-card[data-type="darkness"]{
  background:linear-gradient(135deg, rgba(100, 116, 139, 0.3) 0%, rgba(71, 85, 105, 0.3) 100%) !important;
  border-color:#64748b !important;
}
.zoom-ability-card[data-type="darkness"] .zoom-ability-name{
  color:#334155 !important;
}
.zoom-ability-card[data-type="metal"]{
  background:linear-gradient(135deg, rgba(148, 163, 184, 0.3) 0%, rgba(100, 116, 139, 0.3) 100%) !important;
  border-color:#94a3b8 !important;
}
.zoom-ability-card[data-type="metal"] .zoom-ability-name{
  color:#475569 !important;
}
.zoom-ability-text{
  -webkit-font-smoothing:antialiased !important;
  -moz-osx-font-smoothing:grayscale !important;
  text-rendering:optimizeLegibility !important;
  font-size:14px !important;
  line-height:1.4 !important;
  color:#d1d5db !important;
}
.zoom-section-title{
  color:#9ca3af !important;
  margin-bottom:10px !important;
}
.zoom-ability-name{
  font-size:18px !important;
  font-weight:700 !important;
  color:#ffffff !important;
  margin-bottom:6px !important;
}
.zoom-ability-card[data-type="grass"] .zoom-ability-text{
  color:#bbf7d0 !important;
}
.zoom-ability-card[data-type="fire"] .zoom-ability-text{
  color:#fecaca !important;
}
.zoom-ability-card[data-type="water"] .zoom-ability-text{
  color:#bfdbfe !important;
}
.zoom-ability-card[data-type="lightning"] .zoom-ability-text{
  color:#fde68a !important;
}
.zoom-ability-card[data-type="psychic"] .zoom-ability-text{
  color:#e9d5ff !important;
}
.zoom-ability-card[data-type="fighting"] .zoom-ability-text{
  color:#fdba74 !important;
}
.zoom-ability-card[data-type="darkness"] .zoom-ability-text{
  color:#cbd5e1 !important;
}
.zoom-ability-card[data-type="metal"] .zoom-ability-text{
  color:#e2e8f0 !important;
}
.zoom-tool-section{
  color:#e5e7eb !important;
}
.zoom-close{
  background:#ef4444 !important;
  color:#fff !important;
}
.zoom-tool-count{
  background:rgba(50, 50, 60, 0.8) !important;
  color:#ffffff !important;
  padding:4px 10px !important;
  border-radius:12px !important;
  font-weight:700 !important;
}
.zoom-attack-cost-icon{
  width:20px !important;
  height:18px !important;
  border-radius:50% !important;
  background-size:contain !important;
  background-position:center !important;
  border:1px solid rgba(255, 255, 255, 0.2) !important;
}
div[style*="retreat"]{
  margin-top:6px !important;
  padding:6px 10px !important;
  min-height:36px !important;
  background:rgba(60, 60, 70, 0.6) !important;
  border:1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:10px !important;
  color:#ffffff !important;
}
[class*="retreat"] button{
  padding:6px 10px !important;
  min-height:36px !important;
  font-size:13px !important;
  color:#ffffff !important;
}
.zoom-ability-badge{
  padding:3px 10px !important;
  font-size:10px !important;
  margin-bottom:6px !important;
}
.zoom-resistance{
  background:rgba(40, 40, 50, 0.6) !important;
  border-radius:8px !important;
}
.attack-menu *{
  color:#ffffff !important;
}
.show-log-btn{
  z-index:100 !important;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:12px !important;
  padding:10px 16px !important;
  font-weight:600 !important;
  position:fixed !important;
  bottom:20px !important;
  right:20px !important;
}
[class*="turn"]{
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:1px solid rgba(100, 100, 120, 0.3) !important;
}
[class*="discard"] button{
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius:12px !important;
  padding:10px 16px !important;
  font-weight:600 !important;
  transition:all 0.2s ease !important;
}
.deck-count{
  color:#ffffff !important;
  font-weight:700 !important;
}
.energy-zone.horizontal{
  flex-direction:row !important;
  border-radius:40px !important;
  padding:10px 14px !important;
}
[class*="turn-box"]{
  position:fixed !important;
  right:30px !important;
  background:rgba(40, 40, 50, 0.9) !important;
  color:#ffffff !important;
  border:2px solid rgba(100, 100, 120, 0.3) !important;
  border-radius:12px !important;
  padding:12px 16px !important;
  font-weight:600 !important;
  text-align:center !important;
  z-index:50 !important;
  min-width:120px !important;
}
#player1 .discard-btn{
  position:absolute !important;
  left:20px !important;
  bottom:50% !important;
  transform:translateY(50%) !important;
}
#player2 .discard-btn{
  position:absolute !important;
  left:20px !important;
  top:50% !important;
  transform:translateY(-50%) !important;
}
#turnInfo{
  bottom:300px !important;
}
.turn-info{
  z-index:50 !important;
}

#logToggleBtn, #showLogBtn, .show-log-btn {
  position: fixed;
  right: 30px;
  bottom: 20px;
  padding: 8px 16px;
  background: rgba(40, 40, 50, 0.9);
  border: 1px solid rgba(100, 100, 120, 0.4);
  border-radius: 12px;
  color: #e5e7eb;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  z-index: 100;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  transition: all 0.2s ease;
  width: auto;
  height: auto;
  min-width: auto;
}

#logToggleBtn:hover, #showLogBtn:hover {
  background: rgba(50, 50, 60, 0.95);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.3);
}

.energy-zone {
  position: fixed;
  right: 30px;
  bottom: 60px;
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 6px;
  padding: 10px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.3);
  border-radius: 12px;
  z-index: 200;
  width: auto;
  max-width: 120px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
}

.energy-container {
  position: relative;
  display: inline-block;
}

.energy-container {
  position: relative;
  display: inline-block;
}

.energy-zone .energy-container > .energy-next-turn {
  position: absolute !important;
  bottom: -2px !important;
  right: -2px !important;
  width: 10px !important;
  height: 10px !important;
  opacity: 1 !important;
  cursor: default !important;
  pointer-events: none !important;
  border: 1.5px solid rgba(255, 255, 255, 1) !important;
  filter: grayscale(0%) brightness(100%) !important;
  border-radius: 50% !important;
  background-color: transparent !important;
  box-shadow: 0 0 0 1px rgba(40, 40, 50, 1), 0 1px 3px rgba(0, 0, 0, 0.9) !important;
  z-index: 10 !important;
  display: block !important;
  visibility: visible !important;
  overflow: hidden !important;
}

.energy-zone .energy-container > .energy-next-turn > img {
  width: 100% !important;
  height: 100% !important;
  object-fit: cover !important;
  border-radius: 50% !important;
  display: block !important;
}

.energy:hover {
  transform: scale(1.1);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.5);
}

.energy.selected {
  border: 3px solid #0ff;
  box-shadow: 0 0 16px rgba(0, 255, 255, 0.8);
  transform: scale(1.15);
}

.discard-btn {
  position: absolute;
  width: 85px;
  height: 36px;
  background: rgba(40, 40, 50, 0.9);
  color: #fff;
  border: 2px solid rgba(100, 100, 120, 0.4);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: 700;
  cursor: pointer;
  z-index: 9;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  transition: all 0.2s ease;
  padding: 0;
}

.discard-btn:hover {
  background: rgba(50, 50, 60, 0.95);
  border-color: #00d4ff;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.4);
  transform: scale(1.05);
}

.deck-bubble {
  width: 36px;
  height: 36px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.4);
  border-radius: 50%;
  font-size: 13px;
  font-weight: 700;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

.turnbox, #turnInfo {
  width: 120px;
  padding: 8px 12px;
  background: rgba(40, 40, 50, 0.9);
  border: 2px solid rgba(100, 100, 120, 0.3);
  border-radius: 10px;
  font-size: 13px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

#mainButton {
  padding: 12px 24px;
  font-size: 15px;
  font-weight: 700;
  min-width: 140px;
  height: auto;
  border-radius: 50px;
}

#mainButton {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  padding: 8px 14px !important;
  font-size: 0.9rem !important;
  min-width: 150px !important;
  max-width: none !important;
  height: auto !important;
  border-radius: 10px !important;
  background: linear-gradient(135deg, #e3350d, #0074d9) !important;
  border: 1px solid #1f2937 !important;
  color: #fff !important;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35) !important;
  cursor: pointer !important;
  z-index: auto !important;
}

#mainButton::after {
  display: none !important;
}

.energy-zone {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  display: flex !important;
  flex-wrap: wrap !important;
  gap: 6px !important;
  justify-content: center !important;
  padding: 0 !important;
  background: transparent !important;
  border: none !important;
  border-radius: 0 !important;
  z-index: auto !important;
  width: auto !important;
  max-width: none !important;
  box-shadow: none !important;
}

.energy.selected {
  border: 3px solid #0ff !important;
  box-shadow: 0 0 12px rgba(0, 255, 255, 0.8) !important;
  transform: scale(1.15) !important;
}

.side-panel {
  position: fixed !important;
  top: 20px !important;
  right: 20px !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  gap: 0.6rem !important;
  z-index: 10 !important;
}

.turnbox, #turnInfo {
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  width: 150px !important;
  border: 1px solid #3b3f46 !important;
  background: #23272e !important;
  border-radius: 12px !important;
  padding: 10px !important;
  text-align: center !important;
  font-size: 0.92rem !important;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4) !important;
  color: #e5e7eb !important;
  z-index: auto !important;
}

.turnbox .big {
  font-weight: 800;
  font-size: 1.05rem;
}

#logToggleBtn, #showLogBtn, .show-log-btn {
  position: fixed !important;
  right: 30px !important;
  top: 355px !important;
  bottom: auto !important;
  z-index: 1500 !important;
  background: linear-gradient(90deg, #2a2f36, #1f232a) !important;
  border: 1px solid #334155 !important;
  padding: 8px 14px !important;
  color: #e5e7eb !important;
  border-radius: 10px !important;
  font-size: 0.85rem !important;
  cursor: pointer !important;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4) !important;
  width: auto !important;
  height: auto !important;
  min-width: auto !important;
}

#logToggleBtn:hover, #showLogBtn:hover {
  filter: brightness(1.08);
}

.energy-zone-label,
#energyZoneLabel {
  display: none !important;
}

.energy-zone::before {
  content: none !important;
  display: none !important;
}

.coin {
  position: static !important;
  top: auto !important;
  right: auto !important;
  width: 70px !important;
  height: 70px !important;
  transform-style: preserve-3d !important;
  transition: transform 1.5s ease-in-out !important;
  z-index: auto !important;
}

#coinResult {
  text-align: center;
  font-weight: 700;
  font-size: 13px;
  min-height: 35px;
}

.side-panel button {
  background: linear-gradient(135deg, #e3350d, #0074d9);
  color: #fff;
  border: none;
  padding: 8px 14px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 0.9rem;
  min-width: 150px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
  border: 1px solid #1f2937;
}

.side-panel button:hover {
  opacity: 0.95;
}

.attack-menu {
  background: rgba(30, 30, 40, 0.98) !important;
  backdrop-filter: blur(20px) !important;
  border: 2px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 12px !important;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8) !important;
  padding: 8px !important;
  min-width: 240px !important;
  color: #e5e7eb !important;
}

.attack-item {
  padding: 8px 10px !important;
  margin-bottom: 4px !important;
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 8px !important;
  color: #ffffff !important;
  min-height: 36px !important;
}

.attack-item:hover {
  background: rgba(60, 60, 70, 0.9) !important;
  border-color: #00d4ff !important;
  box-shadow: 0 0 12px rgba(0, 212, 255, 0.3) !important;
}

.attack-item.payable {
  border-color: #00d4ff !important;
  background: rgba(0, 212, 255, 0.15) !important;
}

.attack-name {
  font-size: 13px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
  line-height: 1.2 !important;
}

.attack-cost {
  gap: 3px !important;
}

.cost-icon {
  width: 18px !important;
  height: 18px !important;
}

.attack-desc {
  padding: 3px 5px !important;
  margin-top: 2px !important;
  margin-bottom: 4px !important;
  font-size: 11px !important;
  line-height: 1.3 !important;
  background: rgba(20, 20, 30, 0.8) !important;
  color: #d1d5db !important;
  border-radius: 6px !important;
}

.attack-ability-wrapper {
  margin-bottom: 6px !important;
}

.attack-ability-row {
  padding: 8px 10px !important;
  background: linear-gradient(90deg, #ef4444 0%, #dc2626 100%) !important;
  border-radius: 8px !important;
  min-height: 36px !important;
}

.attack-ability-row:hover {
  background: linear-gradient(90deg, #dc2626 0%, #b91c1c 100%) !important;
}

.attack-ability-name {
  font-size: 13px !important;
  font-weight: 700 !important;
  color: #fff !important;
  line-height: 1.2 !important;
}

.attack-ability-label {
  font-size: 9px !important;
  padding: 2px 6px !important;
}

.attack-ability-desc {
  padding: 3px 5px !important;
  font-size: 11px !important;
  line-height: 1.3 !important;
  background: rgba(254, 226, 226, 0.2) !important;
  color: #fecaca !important;
}

.zoom-panel {
  background: rgba(30, 30, 40, 0.98) !important;
  backdrop-filter: blur(20px) !important;
  border-radius: 16px !important;
  padding: 16px !important;
  color: #e5e7eb !important;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9) !important;
  border: 2px solid rgba(100, 100, 120, 0.3) !important;
}

.zoom-header {
  margin-bottom: 12px !important;
  padding-bottom: 10px !important;
}

.zoom-title {
  font-size: 20px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
}

.zoom-hp {
  font-size: 14px !important;
  color: #ffffff !important;
  margin-bottom: 8px !important;
}

.hpbar-container {
  margin: 6px 0 !important;
}

.zoom-section {
  margin-top: 10px !important;
  padding-top: 10px !important;
  border-top: 1px solid rgba(100, 100, 120, 0.3) !important;
}

.zoom-attack {
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
  border-radius: 10px !important;
  padding: 10px 12px !important;
  margin: 8px 0 !important;
}

.zoom-attack .top {
  padding: 6px 8px !important;
}

.zoom-attack-name,
.zoom-attack .name {
  font-size: 15px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
}

.zoom-attack-damage,
.zoom-attack .dmg {
  font-size: 18px !important;
  font-weight: 900 !important;
  color: #ffffff !important;
}

.zoom-attack-text,
.effect {
  font-size: 12px !important;
  line-height: 1.4 !important;
  color: #d1d5db !important;
  margin-top: 4px !important;
}

.zoom-ability-card,
.ability-box {
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%) !important;
  border: 2px solid #ef4444 !important;
  border-radius: 10px !important;
  padding: 10px 12px !important;
  margin: 8px 0 !important;
}

.zoom-ability-name,
.ability-name {
  font-size: 16px !important;
  font-weight: 700 !important;
  color: #ffffff !important;
  margin-bottom: 6px !important;
}

.zoom-ability-text,
.ability-text {
  font-size: 12px !important;
  line-height: 1.4 !important;
  color: #fecaca !important;
}

#zoomRetreatRow {
  padding: 10px 12px !important;
  margin-top: 10px !important;
  background: rgba(50, 50, 60, 0.8) !important;
  border: 1px solid rgba(100, 100, 120, 0.4) !important;
}

.row {
  margin: 6px 0 !important;
  gap: 6px !important;
}

.chip {
  padding: 3px 8px !important;
  font-size: 11px !important;
}

#player1.type-grass,
#player2.type-grass {
  background: linear-gradient(180deg, 
    rgba(34, 197, 94, 0.3) 0%, 
    rgba(22, 163, 74, 0.5) 50%, 
    rgba(21, 128, 61, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(34, 197, 94, 0.3) !important;
  border: 1px solid rgba(34, 197, 94, 0.3) !important;
}

#player1.type-fire,
#player2.type-fire {
  background: linear-gradient(180deg, 
    rgba(239, 68, 68, 0.3) 0%, 
    rgba(220, 38, 38, 0.5) 50%, 
    rgba(185, 28, 28, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(239, 68, 68, 0.3) !important;
  border: 1px solid rgba(239, 68, 68, 0.3) !important;
}

#player1.type-water,
#player2.type-water {
  background: linear-gradient(180deg, 
    rgba(59, 130, 246, 0.3) 0%, 
    rgba(37, 99, 235, 0.5) 50%, 
    rgba(29, 78, 216, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(59, 130, 246, 0.3) !important;
  border: 1px solid rgba(59, 130, 246, 0.3) !important;
}

#player1.type-lightning,
#player2.type-lightning {
  background: linear-gradient(180deg, 
    rgba(234, 179, 8, 0.3) 0%, 
    rgba(202, 138, 4, 0.5) 50%, 
    rgba(161, 98, 7, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(234, 179, 8, 0.3) !important;
  border: 1px solid rgba(234, 179, 8, 0.3) !important;
}

#player1.type-psychic,
#player2.type-psychic {
  background: linear-gradient(180deg, 
    rgba(168, 85, 247, 0.3) 0%, 
    rgba(147, 51, 234, 0.5) 50%, 
    rgba(126, 34, 206, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(168, 85, 247, 0.3) !important;
  border: 1px solid rgba(168, 85, 247, 0.3) !important;
}

#player1.type-fighting,
#player2.type-fighting {
  background: linear-gradient(180deg, 
    rgba(249, 115, 22, 0.3) 0%, 
    rgba(234, 88, 12, 0.5) 50%, 
    rgba(194, 65, 12, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(249, 115, 22, 0.3) !important;
  border: 1px solid rgba(249, 115, 22, 0.3) !important;
}

#player1.type-darkness,
#player2.type-darkness {
  background: linear-gradient(180deg, 
    rgba(100, 116, 139, 0.3) 0%, 
    rgba(71, 85, 105, 0.5) 50%, 
    rgba(51, 65, 85, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(100, 116, 139, 0.3) !important;
  border: 1px solid rgba(100, 116, 139, 0.3) !important;
}

#player1.type-metal,
#player2.type-metal {
  background: linear-gradient(180deg, 
    rgba(148, 163, 184, 0.3) 0%, 
    rgba(100, 116, 139, 0.5) 50%, 
    rgba(71, 85, 105, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(148, 163, 184, 0.3) !important;
  border: 1px solid rgba(148, 163, 184, 0.3) !important;
}

#player1.type-dragon,
#player2.type-dragon {
  background: linear-gradient(180deg, 
    rgba(211, 186, 48, 0.3) 0%, 
    rgba(184, 158, 32, 0.5) 50%, 
    rgba(169, 142, 28, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(211, 186, 48, 0.3) !important;
  border: 1px solid rgba(211, 186, 48, 0.3) !important;
}

#player1.type-fairy,
#player2.type-fairy {
  background: linear-gradient(180deg, 
    rgba(236, 72, 153, 0.3) 0%, 
    rgba(219, 39, 119, 0.5) 50%, 
    rgba(190, 24, 93, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(236, 72, 153, 0.3) !important;
  border: 1px solid rgba(236, 72, 153, 0.3) !important;
}

#player1.type-colorless,
#player2.type-colorless {
  background: linear-gradient(180deg, 
    rgba(156, 163, 175, 0.3) 0%, 
    rgba(107, 114, 128, 0.5) 50%, 
    rgba(75, 85, 99, 0.4) 100%) !important;
  box-shadow: 0 0 30px rgba(156, 163, 175, 0.3) !important;
  border: 1px solid rgba(156, 163, 175, 0.3) !important;
}

#player1:not([class*="type-"]) {
  background: linear-gradient(180deg, 
    transparent 0%, 
    rgba(30, 58, 95, 0.4) 15%, 
    rgba(13, 31, 58, 0.6) 100%) !important;
  box-shadow: 0 -6px 24px rgba(59, 130, 246, 0.25) !important;
  border: 1px solid rgba(59, 130, 246, 0.2) !important;
}

#player2:not([class*="type-"]) {
  background: linear-gradient(180deg, 
    rgba(95, 30, 30, 0.6) 0%, 
    rgba(58, 13, 13, 0.4) 75%, 
    transparent 100%) !important;
  box-shadow: 0 6px 24px rgba(239, 68, 68, 0.25) !important;
  border: 1px solid rgba(239, 68, 68, 0.2) !important;
}

.attack-menu {
  z-index: 99999 !important;
  position: fixed !important;
}

.card-slot {
  position: relative;
  isolation: auto !important; 
}

.active {
  position: relative;
  z-index: auto !important;
  isolation: auto !important;
}

#player1, #player2 {
  position: relative;
  z-index: 1 !important;
}

.player-area {
  z-index: auto !important;
}

.active:has(.attack-menu) {
  z-index: 99998 !important;
}

.active:has(.attack-menu) .card-slot {
  z-index: 99998 !important;
}

.active:has(.attack-menu) .attack-menu {
  z-index: 99999 !important;
}

.attack-menu-backdrop { display: none !important; }

.attack-menu.ptcgl-style {
  position: fixed !important;
  z-index: 99999 !important;
  background: transparent !important;
  border: none !important;
  padding: 0 !important;
  display: block !important;
}

.ptcgl-card-container {
  position: relative;
  width: 280px;
  height: 392px;
  border-radius: 12px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
  overflow: hidden;
}

.ptcgl-card-container img {
  width: 100%;
  height: 100%;
  border-radius: 12px;
  object-fit: cover;
}

.ptcgl-hp-type-bar {
  position: absolute;
  top: 6px;
  right: 6px;
  background: rgba(0, 0, 0, 0.85);
  padding: 6px 10px;
  border-radius: 15px;
  display: flex;
  align-items: center;
  gap: 10px;
  z-index: 10;
}

.ptcgl-hp-number {
  font-size: 16px;
  font-weight: 900;
  color: #ffffff;
}

.ptcgl-type-icon-inline {
  width: 20px;
  height: 20px;
  background-size: cover;
  border-radius: 50%;
}

.ptcgl-actions-overlay {
  position: absolute;
  top: 225px;
  left: 10px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 3px;
  z-index: 10;
}

.ptcgl-ability-overlay {
  background: rgba(239, 68, 68, 0.96);  
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  padding: 3px 5px;
  cursor: pointer;
}

.ptcgl-ability-overlay.type-grass {
  background: rgba(139, 195, 74, 0.96);
  border: 1px solid rgba(104, 159, 56, 0.8);
}

.ptcgl-ability-overlay.type-fire {
  background: rgba(239, 83, 80, 0.96);
  border: 1px solid rgba(211, 47, 47, 0.8);
}

.ptcgl-ability-overlay.type-water {
  background: rgba(66, 165, 245, 0.96);
  border: 1px solid rgba(25, 118, 210, 0.8);
}

.ptcgl-ability-overlay.type-lightning {
  background: rgba(255, 202, 40, 0.96);
  border: 1px solid rgba(251, 192, 45, 0.8);
}

.ptcgl-ability-overlay.type-psychic {
  background: rgba(171, 71, 188, 0.96);
  border: 1px solid rgba(123, 31, 162, 0.8);
}

.ptcgl-ability-overlay.type-fighting {
  background: rgba(255, 138, 101, 0.96);
  border: 1px solid rgba(230, 74, 25, 0.8);
}

.ptcgl-ability-overlay.type-darkness {
  background: rgba(66, 66, 66, 0.96);
  border: 1px solid rgba(33, 33, 33, 0.8);
}

.ptcgl-ability-overlay.type-metal {
  background: rgba(158, 158, 158, 0.96);
  border: 1px solid rgba(117, 117, 117, 0.8);
}

.ptcgl-ability-overlay.type-dragon {
  background: rgba(211, 186, 48, 0.96);  
  border: 1px solid rgba(184, 158, 32, 0.8);
}

.ptcgl-ability-overlay.type-fairy {
  background: rgba(236, 64, 122, 0.96);
  border: 1px solid rgba(194, 24, 91, 0.8);
}

.ptcgl-ability-overlay.type-colorless {
  background: rgba(189, 189, 189, 0.96);
  border: 1px solid rgba(158, 158, 158, 0.8);
}

.ptcgl-ability-name {
  font-size: 10px;
  font-weight: 900;
  color: #ffffff;
}

.ptcgl-ability-text {
  font-size: 8px;
  color: rgba(255, 255, 255, 0.95);
}

.ptcgl-attack-overlay {
  background: rgba(255, 255, 255, 0.95);
  border: 2px solid rgba(0, 0, 0, 0.1);
  border-radius: 8px;
  cursor: not-allowed;
  overflow: hidden;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  opacity: 0.7;
}

.ptcgl-attack-overlay.payable {
  cursor: pointer;
  opacity: 1;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25);
}

.ptcgl-attack-overlay.payable:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.ptcgl-attack-overlay.payable.type-grass {
  background: rgba(139, 195, 74, 0.95);
  border: 2px solid rgba(104, 159, 56, 0.8);
}

.ptcgl-attack-overlay.payable.type-fire {
  background: rgba(239, 83, 80, 0.95);
  border: 2px solid rgba(211, 47, 47, 0.8);
}

.ptcgl-attack-overlay.payable.type-water {
  background: rgba(66, 165, 245, 0.95);
  border: 2px solid rgba(25, 118, 210, 0.8);
}

.ptcgl-attack-overlay.payable.type-lightning {
  background: rgba(255, 202, 40, 0.95);
  border: 2px solid rgba(251, 192, 45, 0.8);
}

.ptcgl-attack-overlay.payable.type-psychic {
  background: rgba(171, 71, 188, 0.95);
  border: 2px solid rgba(123, 31, 162, 0.8);
}

.ptcgl-attack-overlay.payable.type-fighting {
  background: rgba(255, 138, 101, 0.95);
  border: 2px solid rgba(230, 74, 25, 0.8);
}

.ptcgl-attack-overlay.payable.type-darkness {
  background: rgba(66, 66, 66, 0.95);
  border: 2px solid rgba(33, 33, 33, 0.8);
}

.ptcgl-attack-overlay.payable.type-metal {
  background: rgba(158, 158, 158, 0.95);
  border: 2px solid rgba(117, 117, 117, 0.8);
}

.ptcgl-attack-overlay.payable.type-dragon {
  background: rgba(211, 186, 48, 0.95);  
  border: 2px solid rgba(184, 158, 32, 0.8);
}

.ptcgl-attack-overlay.payable.type-fairy {
  background: rgba(236, 64, 122, 0.95);
  border: 2px solid rgba(194, 24, 91, 0.8);
}

.ptcgl-attack-overlay.payable.type-colorless {
  background: rgba(189, 189, 189, 0.95);
  border: 2px solid rgba(158, 158, 158, 0.8);
}

.ptcgl-attack-left {
  flex: 1;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 6px 10px;
  z-index: 2;
}

.ptcgl-attack-name {
  font-size: 12px;
  font-weight: 700;
  color: rgba(0, 0, 0, 0.3);
  line-height: 1;
}

.ptcgl-attack-overlay.payable .ptcgl-attack-name {
  color: #000000 !important;
  text-shadow: 0 1px 2px rgba(255,255,255,0.5);
}

.ptcgl-attack-cost {
  display: flex;
  gap: 2px;
}

.ptcgl-cost-icon {
  width: 18px;
  height: 18px;
  background-size: cover;
  border-radius: 50%;
  opacity: 0.4;
}

.ptcgl-attack-overlay.payable .ptcgl-cost-icon {
  opacity: 1;
  filter: brightness(1.1);
}

.ptcgl-attack-separator {
  display: none;
}

.ptcgl-attack-overlay.payable .ptcgl-attack-separator {
  opacity: 0.95;
}

.ptcgl-attack-damage-box {
  position: relative;
  right: auto;
  top: auto;
  width: auto;
  min-width: 40px;
  background: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 8px;
  z-index: 2;
}

.ptcgl-attack-damage {
  font-size: 22px;
  font-weight: 900;
  color: rgba(0, 0, 0, 0.3);
  line-height: 1;
  transition: all 0.3s ease;
  display: inline-block;
}

.ptcgl-attack-overlay.payable .ptcgl-attack-damage {
  color: #000000 !important;
  text-shadow: 0 1px 2px rgba(255,255,255,0.5);
}

.ptcgl-attack-overlay.payable:hover .ptcgl-attack-damage {
  transform: scale(1.15);
  text-shadow: 0 2px 4px rgba(0, 212, 255, 0.5), 0 0 8px rgba(0, 212, 255, 0.3);
  color: #00d4ff !important;
}

.ptcgl-attack-effect {
  font-size: 8px;
  color: rgba(255, 255, 255, 0.85);
  padding: 0 5px 3px 5px;
}

.ptcgl-retreat-corner {
  position: absolute;
  bottom: 35px;
  right: 6px;
  background: rgba(255, 255, 255, 0.98);
  border-radius: 12px;
  padding: 3px 10px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  z-index: 10;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ptcgl-retreat-corner:hover {
  background: rgba(255, 255, 255, 1);
  transform: translateY(-1px);
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
}

.ptcgl-retreat-corner[data-type="water"] { background: #6890f0 !important; }
.ptcgl-retreat-corner[data-type="fire"] { background: #f08030 !important; }
.ptcgl-retreat-corner[data-type="grass"] { background: #78c850 !important; }
.ptcgl-retreat-corner[data-type="lightning"] { background: #f8d030 !important; }
.ptcgl-retreat-corner[data-type="psychic"] { background: #f85888 !important; }
.ptcgl-retreat-corner[data-type="fighting"] { background: #c03028 !important; }
.ptcgl-retreat-corner[data-type="darkness"] { background: #705848 !important; }
.ptcgl-retreat-corner[data-type="metal"] { background: #b8b8d0 !important; }
.ptcgl-retreat-corner[data-type="colorless"] { background: #c6c6a7 !important; }
.ptcgl-retreat-corner[data-type="dragon"] { background: #7038f8 !important; }

.ptcgl-retreat-corner[data-type] .ptcgl-retreat-label,
.ptcgl-retreat-corner[data-type] .ptcgl-retreat-icon {
  color: #ffffff !important;
}

.ptcgl-retreat-label {
  font-size: 10px;
  font-weight: 700;
  color: #000000;
  text-transform: lowercase;
  letter-spacing: 0.3px;
  line-height: 1;
}

.ptcgl-energy-pips {
  position: absolute;
  bottom: 6px;
  left: 6px;
  right: 6px;
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  max-height: 50px;
  z-index: 5;
  pointer-events: none;
}

.ptcgl-energy-pip {
  width: 20px;
  height: 20px;
  background-size: cover;
  background-position: center;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, 0.8);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  flex-shrink: 0;
}

.ptcgl-weakness-corner {
  position: absolute;
  bottom: 35px;
  left: 6px;
  background: rgba(255, 255, 255, 0.98);
  padding: 4px 6px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 4px;
  z-index: 10;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ptcgl-weakness-label {
  font-size: 9px;
  font-weight: 700;
  color: #000000 !important;
  text-transform: lowercase;
  letter-spacing: 0.3px;
  line-height: 1;
}

.ptcgl-weakness-value {
  font-size: 13px;
  font-weight: 900;
  color: #000000 !important;
  line-height: 1;
}

.ptcgl-weakness-icon {
  width: 16px;
  height: 16px;
  background-size: cover;
  border-radius: 50%;
}

.type-grass { color: #22c55e !important; }
.type-fire { color: #ef4444 !important; }
.type-water { color: #3b82f6 !important; }
.type-lightning { color: #eab308 !important; }
.type-psychic { color: #a855f7 !important; }
.type-fighting { color: #f97316 !important; }
.type-darkness { color: #64748b !important; }
.type-metal { color: #94a3b8 !important; }
.type-dragon { color: #8b5cf6 !important; }
.type-fairy { color: #ec4899 !important; }
.type-colorless { color: #9ca3af !important; }

.card-slot.menu-open {
  opacity: 0 !important;
  pointer-events: none !important;
}

.ability-option {
  padding: 12px 16px;
  margin: 8px 0;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  color: white;
  font-weight: 500;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
  border: 2px solid transparent;
}

.ability-option:not(.passive-ability):hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.3);
  border-color: rgba(255,255,255,0.3);
}

.ability-option.passive-ability {
  cursor: not-allowed;
  opacity: 0.75;
  border: 2px solid rgba(255,255,255,0.2);
  filter: saturate(0.7);
}

.ability-option.passive-ability:hover {
  transform: none;
  box-shadow: none;
}

.passive-label {
  display: inline-block;
  padding: 3px 8px;
  background: rgba(0, 0, 0, 0.4);
  border-radius: 4px;
  font-size: 10px;
  font-weight: bold;
  color: white;
  margin-left: 8px;
  letter-spacing: 0.5px;
  vertical-align: middle;
}

.ability-grass {
  background: linear-gradient(135deg, #78C850 0%, #5CA935 100%);
}

.ability-fire {
  background: linear-gradient(135deg, #F08030 0%, #DD6610 100%);
}

.ability-water {
  background: linear-gradient(135deg, #6890F0 0%, #386CEB 100%);
}

.ability-lightning,
.ability-electric {
  background: linear-gradient(135deg, #F8D030 0%, #F0C108 100%);
  color: #333; 
  text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
}

.ability-psychic {
  background: linear-gradient(135deg, #F85888 0%, #F61C5D 100%);
}

.ability-fighting {
  background: linear-gradient(135deg, #C03028 0%, #9D2721 100%);
}

.ability-darkness,
.ability-dark {
  background: linear-gradient(135deg, #705848 0%, #513F34 100%);
}

.ability-metal,
.ability-steel {
  background: linear-gradient(135deg, #B8B8D0 0%, #9999B3 100%);
}

.ability-dragon {
  background: linear-gradient(135deg, #d3ba30 0%, #b89e20 100%);
  color: #2d2d2d; 
  text-shadow: 1px 1px 2px rgba(255,255,255,0.2);
}

.ability-fairy {
  background: linear-gradient(135deg, #EE99AC 0%, #E67199 100%);
}

.ability-colorless,
.ability-normal {
  background: linear-gradient(135deg, #A8A878 0%, #8A8A59 100%);
}

.move-dragon {
  background: linear-gradient(135deg, #d3ba30 0%, #b89e20 100%);
  color: #2d2d2d;
  text-shadow: 1px 1px 2px rgba(255,255,255,0.2);
}

.move-lightning,
.move-electric {
  background: linear-gradient(135deg, #F8D030 0%, #F0C108 100%);
  color: #333;
  text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
}

.ability-option strong {
  font-size: 16px;
  display: block;
  margin-bottom: 4px;
}

.ability-option small {
  font-size: 12px;
  opacity: 0.9;
  line-height: 1.4;
}

@media (max-width: 768px) {
  body {
    overflow-y: auto;
    overflow-x: hidden;
    height: auto;
    min-height: 100vh;
  }
  
  h1 {
    font-size: 0.85rem;
    padding: 0.25rem 0;
  }
  
  .main-layout {
    height: auto;
    min-height: calc(100vh - 40px);
    padding: 4px 0;
  }
  
  .battlefield {
    transform: scale(0.98);
    max-width: 100% !important;
    padding: 0 2px;
    height: auto;
    min-height: 95%;
  }
  
  .player-area {
    padding: 3px 0;
    margin: 2px 0;
  }
  
  .hand, .bench, .active {
    gap: 6px;
  }
  
  .card-slot {
    min-width: var(--card-w);
    min-height: var(--card-h);
  }
  
  .hp-overlay {
    font-size: 11px !important;
    padding: 3px 6px !important;
  }
  
  .hp-badge {
    font-size: 11px !important;
    padding: 2px 5px !important;
    top: 3px !important;
    right: 3px !important;
  }
  
  .energy-pips {
    height: 16px !important;
    gap: 2px !important;
    display: flex !important;
  }
  
  .energy-pip {
    width: 16px !important;
    height: 16px !important;
    min-width: 16px !important;
    min-height: 16px !important;
    display: block !important;
    visibility: visible !important;
  }
  
  .status-icon {
    width: 18px;
    height: 18px;
    top: 3px;
    left: 3px;
  }
  
  .deck-bubble {
    width: 32px;
    height: 32px;
    font-size: 11px;
    min-width: 32px;
    min-height: 32px;
  }
  
  #p1Bubble {
    left: -30px;
  }
  
  #p2Bubble {
    right: -30px;
  }
  
  .points-indicator {
    gap: 4px;
  }
  
  .point-bubble {
    width: 11px;
    height: 11px;
  }
  
  .side-panel {
    top: 50% !important;
    right: 8px !important;
    transform: translateY(-50%) !important;
    margin-top: 0 !important;
    gap: 0.25rem !important;
  }
  
  .side-panel .turnbox {
    order: 1 !important;
  }
  
  .side-panel .energy-zone {
    order: 2 !important;
  }
  
  .side-panel #coin {
    order: 3 !important;
  }
  
  .side-panel #mainButton {
    order: 4 !important;
  }
  
  .side-panel #logToggleBtn,
  .side-panel #showLogBtn {
    order: 5 !important;
  }
  
  .side-panel h4 {
    display: none !important;
  }
  
  .turnbox, [class*="turn-box"] {
    position: static !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    margin-top: 0 !important;
    font-size: 9px !important;
    padding: 3px 6px !important;
    width: auto !important;
    min-width: 55px !important;
  }
  
  .energy-zone {
    position: static !important;
    bottom: auto !important;
    top: auto !important;
    transform: none !important;
    left: auto !important;
    right: auto !important;
    padding: 3px 5px !important;
    gap: 2px !important;
    border-radius: 6px !important;
    width: auto !important;
    max-width: 50px !important;
    margin-top: 0 !important;
    z-index: 10 !important;
  }
  
  .energy-zone .energy-container {
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    gap: 2px !important;
    position: relative !important;
    min-height: 22px !important;
  }
  
  .energy-zone .energy-container > .energy:not(.energy-next-turn) {
    display: block !important;
    width: 22px !important;
    height: 22px !important;
    min-width: 22px !important;
    min-height: 22px !important;
    background-size: cover !important;
    background-repeat: no-repeat !important;
    background-position: center !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn {
    display: block !important;
    width: 10px !important;
    height: 10px !important;
    min-width: 10px !important;
    min-height: 10px !important;
    position: absolute !important;
    bottom: -2px !important;
    right: -2px !important;
    border: 1px solid rgba(255, 255, 255, 1) !important;
    box-shadow: 0 0 0 0.5px rgba(40, 40, 50, 1), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
    z-index: 11 !important;
    background: transparent !important;
    background-image: none !important;
    border-radius: 50% !important;
    overflow: hidden !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn > img {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
    border-radius: 50% !important;
    display: block !important;
  }
  
  #coin, .coin {
    width: 32px !important;
    height: 32px !important;
  }
  
  .energy:not(.energy-next-turn) {
    width: 20px !important;
    height: 20px !important;
    min-width: 20px !important;
    min-height: 20px !important;
  }
  
  .energy.energy-next-turn {
    width: 10px !important;
    height: 10px !important;
    min-width: 10px !important;
    min-height: 10px !important;
  }
  
  #mainButton {
    position: static !important;
    padding: 4px 8px !important;
    font-size: 8px !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    border-radius: 16px !important;
    min-height: 22px !important;
    min-width: 55px !important;
    margin-top: 0 !important;
    width: auto !important;
  }
  
  #logToggleBtn, #showLogBtn {
    position: static !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    margin-top: 0 !important;
    padding: 3px 6px !important;
    font-size: 8px !important;
    min-height: 20px !important;
    min-width: 50px !important;
    width: auto !important;
  }
  
  .points-indicator {
    right: 2px !important;
    left: auto !important;
  }
  
  #p1Points {
    right: 2px !important;
    transform: translateX(0) !important;
  }
  
  #p2Points {
    left: 2px !important;
    transform: translateX(0) !important;
  }
  
  .battlefield {
    margin-left: 0 !important;
    padding-left: 4px !important;
  }
  
  .popup {
    padding: 10px 16px !important;
    font-size: 12px !important;
    border-radius: 30px !important;
  }
  
  .discard-btn {
    padding: 6px 12px !important;
    font-size: 11px !important;
    border-radius: 8px !important;
    min-height: 32px;
  }
  
  .ability-option {
    padding: 10px 12px;
  }
  
  .ability-option strong {
    font-size: 14px;
  }
  
  .ability-option small {
    font-size: 11px;
  }
  
  .passive-label {
    font-size: 9px;
    padding: 2px 6px;
  }
  
  .zoom-backdrop {
    padding: 10px !important;
  }
  
  .zoom-content {
    max-width: 90vw !important;
    max-height: 85vh !important;
  }
  
  .attack-menu {
    max-width: 90vw !important;
    max-height: 80vh !important;
    font-size: 13px !important;
  }
  
  .attack-item {
    padding: 10px !important;
    font-size: 13px !important;
  }
  
  .tool-thumb {
    width: 22px !important;
    height: 22px !important;
  }
  
  .slot-label {
    font-size: 9px;
    padding: 2px 6px;
    width: 55px;
  }
}

@media (max-width: 480px) {
  body {
    overflow-y: auto;
  }
  
  h1 {
    font-size: 0.75rem;
    padding: 0.2rem 0;
  }
  
  .battlefield {
    transform: scale(0.96);
    max-width: 100% !important;
    padding: 0 2px;
  }
  
  .hand, .bench, .active {
    gap: 5px;
  }
  
  .hp-overlay {
    font-size: 10px !important;
    padding: 2px 5px !important;
  }
  
  .hp-badge {
    font-size: 10px !important;
    padding: 2px 4px !important;
  }
  
  .energy-pips {
    height: 14px !important;
    gap: 2px !important;
    display: flex !important;
  }
  
  .energy-pip {
    width: 14px !important;
    height: 14px !important;
    min-width: 14px !important;
    min-height: 14px !important;
    display: block !important;
    visibility: visible !important;
  }
  
  .status-icon {
    width: 17px;
    height: 17px;
  }
  
  .deck-bubble {
    width: 30px;
    height: 30px;
    font-size: 10px;
    min-width: 30px;
    min-height: 30px;
  }
  
  #p1Bubble {
    left: -28px;
  }
  
  #p2Bubble {
    right: -28px;
  }
  
  .point-bubble {
    width: 10px;
    height: 10px;
  }
  
  .energy-zone {
    bottom: auto !important;
    top: 50% !important;
    transform: translate(-50%, -50%) !important;
    left: 50% !important;
    right: auto !important;
    padding: 2px 4px !important;
    gap: 2px !important;
    width: auto !important;
    max-width: 48px !important;
    margin-top: 0 !important;
  }
  
  .energy:not(.energy-next-turn) {
    width: 18px !important;
    height: 18px !important;
    min-width: 18px !important;
    min-height: 18px !important;
  }
  
  .energy.energy-next-turn {
    width: 8px !important;
    height: 8px !important;
    min-width: 8px !important;
    min-height: 8px !important;
  }
  
  .energy-zone .energy-container > .energy:not(.energy-next-turn) {
    width: 20px !important;
    height: 20px !important;
    min-width: 20px !important;
    min-height: 20px !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn {
    width: 8px !important;
    height: 8px !important;
    min-width: 8px !important;
    min-height: 8px !important;
    position: absolute !important;
    bottom: -1px !important;
    right: -1px !important;
    border: 1px solid rgba(255, 255, 255, 1) !important;
    box-shadow: 0 0 0 0.5px rgba(40, 40, 50, 1), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
    z-index: 11 !important;
    background: transparent !important;
    background-image: none !important;
    border-radius: 50% !important;
    overflow: hidden !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn > img {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
    border-radius: 50% !important;
    display: block !important;
  }
  
  .side-panel {
    top: 50% !important;
    right: 6px !important;
    transform: translateY(-50%) !important;
    margin-top: 0 !important;
    gap: 0.2rem !important;
  }
  
  .side-panel .turnbox {
    order: 1 !important;
  }
  
  .side-panel .energy-zone {
    order: 2 !important;
  }
  
  .side-panel #coin {
    order: 3 !important;
  }
  
  .side-panel #mainButton {
    order: 4 !important;
  }
  
  .side-panel #logToggleBtn,
  .side-panel #showLogBtn {
    order: 5 !important;
  }
  
  .side-panel h4 {
    display: none !important;
  }
  
  .turnbox, [class*="turn-box"] {
    position: static !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    margin-top: 0 !important;
    font-size: 8px !important;
    padding: 2px 5px !important;
    width: auto !important;
    min-width: 50px !important;
  }
  
  .energy-zone {
    position: static !important;
    bottom: auto !important;
    top: auto !important;
    transform: none !important;
    left: auto !important;
    right: auto !important;
    padding: 2px 4px !important;
    gap: 2px !important;
    width: auto !important;
    max-width: 48px !important;
    margin-top: 0 !important;
    z-index: 10 !important;
  }
  
  .energy-zone .energy-container {
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    gap: 2px !important;
    position: relative !important;
    min-height: 20px !important;
  }
  
  .energy-zone .energy-container > .energy:not(.energy-next-turn) {
    display: block !important;
    width: 20px !important;
    height: 20px !important;
    min-width: 20px !important;
    min-height: 20px !important;
    background-size: cover !important;
    background-repeat: no-repeat !important;
    background-position: center !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn {
    display: block !important;
    width: 8px !important;
    height: 8px !important;
    min-width: 8px !important;
    min-height: 8px !important;
    position: absolute !important;
    bottom: -1px !important;
    right: -1px !important;
    border: 1px solid rgba(255, 255, 255, 1) !important;
    box-shadow: 0 0 0 0.5px rgba(40, 40, 50, 1), 0 1px 2px rgba(0, 0, 0, 0.9) !important;
    z-index: 11 !important;
    background: transparent !important;
    background-image: none !important;
    border-radius: 50% !important;
    overflow: hidden !important;
  }
  
  .energy-zone .energy-container > .energy-next-turn > img {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
    border-radius: 50% !important;
    display: block !important;
  }
  
  #coin, .coin {
    width: 28px !important;
    height: 28px !important;
  }
  
  #mainButton {
    position: static !important;
    padding: 3px 6px !important;
    font-size: 7px !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    border-radius: 14px !important;
    min-height: 20px !important;
    min-width: 50px !important;
    margin-top: 0 !important;
    width: auto !important;
  }
  
  #logToggleBtn, #showLogBtn {
    position: static !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    margin-top: 0 !important;
    padding: 2px 5px !important;
    font-size: 7px !important;
    min-height: 18px !important;
    min-width: 45px !important;
    width: auto !important;
  }
  
  .points-indicator {
    right: 2px !important;
    left: auto !important;
  }
  
  #p1Points {
    right: 2px !important;
    transform: translateX(0) !important;
  }
  
  #p2Points {
    left: 2px !important;
    transform: translateX(0) !important;
  }
  
  .battlefield {
    margin-left: 0 !important;
    padding-left: 4px !important;
  }
  
  #mainButton {
    position: static !important;
    padding: 3px 6px !important;
    font-size: 7px !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    border-radius: 14px !important;
    min-height: 20px !important;
    min-width: 50px !important;
    margin-top: 0 !important;
    width: auto !important;
  }
  
  #logToggleBtn, #showLogBtn {
    position: static !important;
    left: auto !important;
    right: auto !important;
    top: auto !important;
    bottom: auto !important;
    transform: none !important;
    margin-top: 0 !important;
    padding: 2px 5px !important;
    font-size: 7px !important;
    min-height: 18px !important;
    min-width: 45px !important;
    width: auto !important;
  }
  
  .points-indicator {
    right: 2px !important;
    left: auto !important;
  }
  
  #p1Points {
    right: 2px !important;
    transform: translateX(0) !important;
  }
  
  #p2Points {
    left: 2px !important;
    transform: translateX(0) !important;
  }
  
  .battlefield {
    margin-left: 0 !important;
    padding-left: 4px !important;
  }
  
  #mainButton {
    padding: 4px 8px !important;
    font-size: 8px !important;
    left: 50% !important;
    right: auto !important;
    top: 50% !important;
    transform: translate(-50%, -50%) !important;
    bottom: auto !important;
    border-radius: 16px !important;
    min-height: 24px;
    min-width: 60px;
    margin-top: -60px;
  }
  
  #logToggleBtn, #showLogBtn {
    left: 50% !important;
    right: auto !important;
    top: 50% !important;
    transform: translate(-50%, -50%) !important;
    bottom: auto !important;
    margin-top: 65px;
    padding: 2px 5px !important;
    font-size: 7px !important;
    min-height: 20px;
    min-width: 50px;
  }
  
  .popup {
    padding: 8px 14px !important;
    font-size: 11px !important;
  }
  
  .discard-btn {
    padding: 5px 10px !important;
    font-size: 10px !important;
    min-height: 28px;
  }
  
  .zoom-content {
    max-width: 95vw !important;
    max-height: 90vh !important;
  }
  
  .attack-menu {
    max-width: 95vw !important;
    max-height: 85vh !important;
    font-size: 12px !important;
  }
  
  .attack-item {
    padding: 8px !important;
    font-size: 12px !important;
  }
  
  .ability-option {
    padding: 8px 10px;
  }
  
  .ability-option strong {
    font-size: 13px;
  }
  
  .ability-option small {
    font-size: 10px;
  }
  
  .slot-label {
    font-size: 8px;
    padding: 2px 5px;
    width: 50px;
  }
  
  .tool-thumb {
    width: 20px !important;
    height: 20px !important;
  }
}

</style>

<script type="module">
import { ENERGY_ICONS, STATUS_TYPES, ABILITY_BADGE, STATUS_ICON_URLS } from './js/core/constants.js';
import { pkToPlayer, oppPk, parseInt10, normStr, parseCSV, csvIdFor, getAbilityCardKey, abilityRequiresActive } from './js/core/utils.js';
import { energyIconUrl, updateDeckStack, updateDeckBubbles, updateHandBubbles, updateDiscardBubbles, updatePointsUI, updateTurnBox, setHpOnImage, renderHand, renderAllHands, renderDiscard, renderEnergyZone } from './js/ui/render.js';
import { showPopup, closeAttackMenu, openToolModal, countPipsOn, getToolDataFromSlot, extractAbilities } from './js/ui/modals.js';
import { canAttack, isActiveBlockedFromAttacking, getFightingCoachBoost, getThickFatReduction, applyGuardedGrill, shouldBlockDamageFromEx, getCounterattackDamage, applyTypesToAttackMenu } from './js/game/attacks.js';
import { applyAbilityEffect, populateAbilityCache, hasArceusInPlay, getAbilityRow, getPassiveDamageReduction, checkPassiveAbility, hasCrystalBody, hasLevitateZeroRetreat, getPassiveAbility } from './js/game/abilities.js';
import { canUseSupporter, trainerColor, isGengarBlocking, setToolDataOnSlot, ensureToolThumb, removeToolThumb, attachToolToSlot, applyTrainerEffect, addTrainerToDiscard } from './js/game/trainers.js';

globalThis.ENERGY_ICONS = ENERGY_ICONS;
globalThis.STATUS_TYPES = STATUS_TYPES;
globalThis.ABILITY_BADGE = ABILITY_BADGE;
globalThis.STATUS_ICON_URLS = STATUS_ICON_URLS;
globalThis.pkToPlayer = pkToPlayer;
globalThis.oppPk = oppPk;
globalThis.parseInt10 = parseInt10;
globalThis.normStr = normStr;
globalThis.parseCSV = parseCSV;
globalThis.csvIdFor = csvIdFor;
globalThis.getAbilityCardKey = getAbilityCardKey;
globalThis.abilityRequiresActive = abilityRequiresActive;
globalThis.energyIconUrl = energyIconUrl;
globalThis.updateDeckStack = updateDeckStack;
globalThis.updateDeckBubbles = updateDeckBubbles;
globalThis.updateHandBubbles = updateHandBubbles;
globalThis.updateDiscardBubbles = updateDiscardBubbles;
globalThis.updatePointsUI = updatePointsUI;
globalThis.updateTurnBox = updateTurnBox;
globalThis.setHpOnImage = setHpOnImage;
globalThis.renderHand = renderHand;
globalThis.renderAllHands = renderAllHands;
globalThis.renderDiscard = renderDiscard;
globalThis.renderEnergyZone = renderEnergyZone;
globalThis.showPopup = showPopup;
globalThis.closeAttackMenu = closeAttackMenu;
globalThis.openToolModal = openToolModal;
globalThis.countPipsOn = countPipsOn;
globalThis.getToolDataFromSlot = getToolDataFromSlot;
globalThis.extractAbilities = extractAbilities;
globalThis.canAttack = canAttack;
globalThis.isActiveBlockedFromAttacking = isActiveBlockedFromAttacking;
globalThis.getFightingCoachBoost = getFightingCoachBoost;
globalThis.getThickFatReduction = getThickFatReduction;
globalThis.applyGuardedGrill = applyGuardedGrill;
globalThis.shouldBlockDamageFromEx = shouldBlockDamageFromEx;
globalThis.getCounterattackDamage = getCounterattackDamage;
globalThis.applyTypesToAttackMenu = applyTypesToAttackMenu;
globalThis.applyAbilityEffect = applyAbilityEffect;
globalThis.populateAbilityCache = populateAbilityCache;
globalThis.hasArceusInPlay = hasArceusInPlay;
globalThis.getAbilityRow = getAbilityRow;
globalThis.getPassiveDamageReduction = getPassiveDamageReduction;
globalThis.checkPassiveAbility = checkPassiveAbility;
globalThis.getPassiveAbility = getPassiveAbility;
globalThis.hasCrystalBody = hasCrystalBody;
globalThis.hasLevitateZeroRetreat = hasLevitateZeroRetreat;
globalThis.canUseSupporter = canUseSupporter;
globalThis.trainerColor = trainerColor;
globalThis.isGengarBlocking = isGengarBlocking;
globalThis.setToolDataOnSlot = setToolDataOnSlot;
globalThis.ensureToolThumb = ensureToolThumb;
globalThis.removeToolThumb = removeToolThumb;
globalThis.attachToolToSlot = attachToolToSlot;
globalThis.applyTrainerEffect = applyTrainerEffect;
globalThis.addTrainerToDiscard = addTrainerToDiscard;
</script>
<script src="./effects.js"></script>

</head>
<body>
<h1>Pokmon TCG Pocket Battle</h1>
<div id="popup"></div>
<div class="main-layout">
  <div class="battlefield">
    <div class="player-area" id="player2">
      <div id="p2Bubble" class="deck-bubble">0</div>
      <div id="p2DeckStack" class="deck-stack"></div>
      <div id="p2HandBubble" class="hand-bubble">0</div>
      <div id="p2DiscardBubble" class="discard-bubble">0</div>
      <div class="points-indicator" id="p2Points">
        <div class="point-bubble" data-i="1"></div>
        <div class="point-bubble" data-i="2"></div>
        <div class="point-bubble" data-i="3"></div>
      </div>
      <div class="hand" id="p2Hand"></div>
      <div class="bench" id="p2Bench">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="active" id="p2Active">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <button class="discard-btn right" id="p2DiscardBtn">View Discard</button>
    </div>

    <div class="player-area" id="player1">
      <div id="p1Bubble" class="deck-bubble">0</div>
      <div id="p1DeckStack" class="deck-stack"></div>
      <div id="p1HandBubble" class="hand-bubble">0</div>
      <div id="p1DiscardBubble" class="discard-bubble">0</div>
      <div class="points-indicator" id="p1Points">
        <div class="point-bubble" data-i="1"></div>
        <div class="point-bubble" data-i="2"></div>
        <div class="point-bubble" data-i="3"></div>
      </div>
      <div class="active" id="p1Active">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="bench" id="p1Bench">
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
        <div class="card-slot" data-empty="1"><span class="slot-label">Empty</span></div>
      </div>
      <div class="hand" id="p1Hand"></div>
      <button class="discard-btn" id="p1DiscardBtn">View Discard</button>
    </div>
  </div>

  <div class="side-panel">
    <div class="coin" id="coin">
      <img class="front" crossorigin="anonymous" src="imgs/coin_front.png" alt="Coin front">
      <img class="back" crossorigin="anonymous" src="imgs/Coin_Back_TM.png" alt="Coin back">
    </div>
    <div id="coinResult"></div>
    <button id="mainButton">Draw Hands</button>
    <div class="turnbox">
      <div>Turn</div>
      <div id="turnNum" class="big">1</div>
    </div>
    <h4 style="margin:0 .25rem;">Energy Zone</h4>
    <div class="energy-zone" id="energyZone"></div>
    <button id="logToggleBtn">Show Log</button>
  </div>
</div>

<div id="zoomBackdrop" class="zoom-backdrop">
  <div class="zoom-modal">
    <div style="position: relative;">
      <img id="zoomImg" src="" alt="Card zoom">
      <img id="zoomToolImg" src="" alt="Tool" style="display: none; position: absolute; top: -20px; right: -20px; width: 80px; height: 112px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 2px solid #6e4e9c; z-index: 10;">
    </div>
    <div class="zoom-panel">
<div class="zoom-header">
  <div id="zoomTitle" class="zoom-title"></div>
  <div style="display:flex;align-items:center;gap:8px">
    <div id="zoomStatus" class="zoom-status" style="display:none;"></div>
    <div id="zoomHp" class="zoom-hp"></div>
    <div id="zoomType" class="zoom-type-pill"></div>
  </div>
</div>

      <div class="hpbar-container"><div id="zoomHpBar" class="hpbar-fill"></div></div>
      <div class="zoom-section" id="zoomAttached">
        <div class="row">
          <div><strong>Attached Energy</strong></div>
          <div id="zoomEnergyCount" class="chip">x0</div>
        </div>
        <div id="zoomEnergyIcons" class="icon-row"></div>
        <div class="row" style="margin-top:10px">
          <div><strong>Attached Tools</strong></div>
          <div id="zoomTools" class="icon-row"></div>
        </div>
      </div>
      <div class="zoom-section" id="zoomAbilities" style="display:none"></div>
      <div class="zoom-section">
        <div><strong>Attacks</strong></div>
        <div id="zoomAttacks"></div>
      </div>
      <div class="zoom-section">
        <div class="row">
          <div><strong>Weakness</strong></div>
          <div id="zoomWeakness" class="icon-row"></div>
        </div>
        <div class="row" id="zoomRetreatRow">
          <div><strong>Retreat</strong></div>
          <div id="zoomRetreat" class="icon-row"></div>
        </div>
        <div style="text-align:right;color:#9ca3af;font-size:12px;margin-top:6px">Right-click anywhere or press Esc.</div>
      </div>
    </div>
  </div>
</div>

<div id="toolBackdrop">
  <div id="toolCard">
    <img id="toolImg" src="" alt="Tool Card">
    <div id="toolPanel">
      <h3 id="toolTitle">Tool</h3>
      <div id="toolMeta" class="chip" style="margin-bottom:8px"></div>
      <div class="thin" style="height:1px;background:#3b3f46;margin:8px 0"></div>
      <div id="toolText" style="font-size:13px;color:#cbd5e1;line-height:1.25"></div>
      <div style="margin-top:12px;font-size:12px;color:#9ca3af">Click outside to close.</div>
    </div>
  </div>
</div>

<div id="handBackdrop" class="zoom-backdrop">
  <div class="zoom-modal">
    <div style="position: relative;">
      <img id="handImg" src="" alt="Card image">
      <img id="handToolImg" src="" alt="Tool" style="display: none; position: absolute; top: -20px; right: -20px; width: 80px; height: 112px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); border: 2px solid #6e4e9c; z-index: 10;">
    </div>
    <div class="zoom-panel" id="handPanel">
      <div id="handTitle" class="zoom-title"></div>
      <div id="handType" class="chip" style="margin-top:6px;"></div>
      <div id="handEffect" style="font-size:13px;color:#cbd5e1;margin-top:10px;line-height:1.4"></div>
      <div style="text-align:right;color:#9ca3af;font-size:12px;margin-top:12px">
        Right-click anywhere or press Esc to close.
      </div>
    </div>
  </div>
</div>

<div id="victoryOverlay">
  <div id="victoryCard">
    <h2 id="victoryTitle">Player Wins!</h2>
    <p id="victoryDesc">Game over</p>
    <div style="display:flex;justify-content:center;gap:12px;margin:10px 0 18px 0">
      <div class="chip">P1 Points: <span id="p1Pts">0</span></div>
      <div class="chip">P2 Points: <span id="p2Pts">0</span></div>
    </div>
    <div id="victoryBtns">
      <button id="playAgainBtn">Play again</button>
      <button id="chooseDecksBtn">Choose new decks</button>
      <button id="victoryShowLogBtn">Show Match Log</button>
    </div>
  </div>
</div>

<div id="choiceDialogBackdrop" class="zoom-backdrop">
  <div id="choiceDialogCard" style="width:min(500px,90vw);background:#101418;border:1px solid #334155;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.6);padding:24px;color:#e5e7eb;text-align:center;">
    <h2 id="choiceDialogTitle" style="margin:0 0 12px 0;font-size:20px;font-weight:700;">Choose an Option</h2>
    <p id="choiceDialogDesc" style="margin:0 0 20px 0;color:#cbd5e1;font-size:14px;"></p>
    <div id="choiceDialogButtons" style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
      
    </div>
  </div>
</div>

<div id="hikerReorderBackdrop" class="zoom-backdrop">
  <div id="hikerReorderCard" style="width:min(90vw,1200px);max-width:1200px;background:#101418;border:1px solid #334155;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.6);padding:24px;color:#e5e7eb;">
    <h2 id="hikerReorderTitle" style="margin:0 0 12px 0;font-size:20px;font-weight:700;text-align:center;">Reorder Top Cards</h2>
    <p id="hikerReorderDesc" style="margin:0 0 20px 0;color:#cbd5e1;font-size:14px;text-align:center;">Drag cards to reorder them. The leftmost card will be on top of your deck.</p>
    <div id="hikerReorderCards" style="position:relative;display:flex;gap:12px;justify-content:center;flex-wrap:wrap;min-height:200px;margin-bottom:20px;">
      
    </div>
    <div style="text-align:center;">
      <button id="hikerReorderDone" style="background:#6e4e9c;color:#fff;border:none;padding:10px 24px;border-radius:8px;cursor:pointer;font-size:16px;font-weight:600;">Done</button>
    </div>
  </div>
</div>

<div class="discard-drawer right" id="p1DiscardDrawer"></div>
<div class="discard-drawer right" id="p2DiscardDrawer"></div>

<div id="logPanel">
  <div id="logPanelHeader">Battle Log</div>
  <button id="closeLogBtn" style="margin:8px 14px 10px;width:calc(100% - 28px);background:#e5e7eb;border:1px solid #c2c4c6;color:#111;padding:6px;border-radius:6px;cursor:pointer;">
    Close Log
  </button>
  <div id="logEntries"></div>
</div>

<div id="historyBackdrop">
  <div id="historyCard">
    <h2>Match History</h2>
    <div id="fullHistory"></div>
    <div style="text-align:center;margin-top:14px;">
      <button onclick="document.getElementById('historyBackdrop').classList.remove('show')">
        Close
      </button>
    </div>
  </div>
</div>

<script type="module">
  

  
globalThis.state = { temp: { p1: {}, p2: {} } };

if (!globalThis.__specialEffects) {
  globalThis.__specialEffects = { p1: {}, p2: {} };
}

function canRetreat(pk) {
  
  const img = getActiveImg(pk);
  if (img) {
    const status = (img.dataset.status || '').toLowerCase();
    if (status === 'asleep') {
      return false;
    }
    if (status === 'paralyzed') {
      return false;
    }
  }
  
  if (globalThis.__specialEffects?.[pk]?.retreatLock) {
    return false;
  }
  return true;
}



function applySpecialEffectsToDamage(defendingPk, baseDamage) {
  let damage = baseDamage;
  
  
  const defenderImg = getActiveImg(defendingPk);
  if (defenderImg?.dataset.preventAllNextTurn === 'true') {
    showPopup("All damage and effects prevented!");
    delete defenderImg.dataset.preventAllNextTurn; 
    return 0;
  }
  
  
  if (defenderImg?.dataset.preventDamageAndEffectsNextTurn === 'true') {
    showPopup("All damage and effects prevented!");
    delete defenderImg.dataset.preventDamageAndEffectsNextTurn; 
    return 0;
  }
  
  
  if (globalThis.__specialEffects?.[defendingPk]?.preventDamage) {
    showPopup("Attack prevented!");
    return 0;
  }
  
  
  if (defenderImg?.dataset.incomingDamageIncrease) {
    const increase = parseInt(defenderImg.dataset.incomingDamageIncrease, 10);
    damage += increase;
    showPopup(`Damage increased by ${increase}!`);
    delete defenderImg.dataset.incomingDamageIncrease; 
  }
  
  
  const reduction = globalThis.__specialEffects?.[defendingPk]?.damageReduction || 0;
  if (reduction > 0) {
    damage = Math.max(0, damage - reduction);
    if (damage > 0) {
      showPopup(`Damage reduced by ${reduction}!`);
    } else {
      showPopup(`All damage blocked!`);
    }
  }
  
  return damage;
}

function clearSpecialEffects(pk) {
  if (globalThis.__specialEffects?.[pk]) {
    const had = Object.keys(globalThis.__specialEffects[pk]).length > 0;
    if (had) {
    }
    globalThis.__specialEffects[pk] = {};
  }
}

function clearExpiredEffectsOnTurnStart(pk) {
  
  const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
  
  if (attackLock) {
  }
  
  clearSpecialEffects(pk);
  
  
  if (attackLock && globalThis.__specialEffects?.[pk]) {
    globalThis.__specialEffects[pk].attackLock = attackLock;
  } else if (attackLock) {
    
    if (!globalThis.__specialEffects) globalThis.__specialEffects = { p1: {}, p2: {} };
    if (!globalThis.__specialEffects[pk]) globalThis.__specialEffects[pk] = {};
    globalThis.__specialEffects[pk].attackLock = attackLock;
  }
  
  
  if (globalThis.__specialEffects?.[pk]?.attackLock) {
    const lock = globalThis.__specialEffects[pk].attackLock;
    const currentTurn = globalThis.turnNumber || 0;
    
    if (typeof lock === 'object' && lock.lockedOnTurn !== undefined) {
      
      if (currentTurn > lock.lockedOnTurn + 2) {
        delete globalThis.__specialEffects[pk].attackLock;
      }
    } else if (lock === true) {
      
      delete globalThis.__specialEffects[pk].attackLock;
    }
  }
  
  
  const allPokemon = [getActiveImg(pk), ...getBenchImgs(pk)].filter(Boolean);
  for (const img of allPokemon) {
    if (img.dataset.lockedAttack) {
      delete img.dataset.lockedAttack;
    }
  }
}

globalThis.canRetreat = canRetreat;
globalThis.canAttack = canAttack;
globalThis.applySpecialEffectsToDamage = applySpecialEffectsToDamage;
globalThis.clearSpecialEffects = clearSpecialEffects;
globalThis.clearExpiredEffectsOnTurnStart = clearExpiredEffectsOnTurnStart;

const popupEl = document.getElementById("popup");
globalThis.popupEl = popupEl;

let TRAINER_EFFECT_DATA=[];
fetch('trainer_effects.csv')
  .then(r=>r.text())
  .then(t=>{
    TRAINER_EFFECT_DATA=(globalThis.parseCSV || parseCSV)(t);
    
    globalThis.TRAINER_EFFECT_DATA = TRAINER_EFFECT_DATA;
    window.TRAINER_EFFECT_DATA = TRAINER_EFFECT_DATA;
  });



const TYPE_HEX={
  fire:'#f08030',water:'#6890f0',grass:'#78c850',lightning:'#f8d030',
  psychic:'#f85888',fighting:'#c03028',darkness:'#705848',
  metal:'#b8b8d0',dragon:'#d3ba30',colorless:'#c6c6a7'
};

const $=s=>document.querySelector(s);
const $$=s=>Array.from(document.querySelectorAll(s));

const popup=$('#popup'),
      energyZoneDiv=$('#energyZone'),
      coinEl=$('#coin'),
      coinResult=$('#coinResult'),
      mainButton=$('#mainButton'),
      turnNumEl=$('#turnNum'),
      turnPlayerEl=$('#turnPlayer');

const p1HandDiv=$('#p1Hand'),
      p2HandDiv=$('#p2Hand'),
      p1Active=$('#p1Active'),
      p2Active=$('#p2Active'),
      p1Bench=$('#p1Bench'),
      p2Bench=$('#p2Bench'),
      p1Bubble=$('#p1Bubble'),
      p2Bubble=$('#p2Bubble');

const zoomBackdrop=$('#zoomBackdrop'),
      zoomImg=$('#zoomImg'),
      zoomToolImg=$('#zoomToolImg'),
      zoomTitle=$('#zoomTitle'),
      zoomHp=$('#zoomHp'),
      zoomHpBar=$('#zoomHpBar'),
      zoomType=$('#zoomType'),
      zoomStatusIcon=$('#zoomStatusIcon'),
      zoomAttacks=$('#zoomAttacks'),
      zoomEnergyCount=$('#zoomEnergyCount'),
      zoomEnergyIcons=$('#zoomEnergyIcons'),
      zoomWeakness=$('#zoomWeakness'),
      zoomRetreat=$('#zoomRetreat'),
      zoomTools=$('#zoomTools'),
      zoomAbilities=$('#zoomAbilities');

const p1DiscardBtn=$('#p1DiscardBtn'),
      p2DiscardBtn=$('#p2DiscardBtn'),
      p1DiscardDrawer=$('#p1DiscardDrawer'),
      p2DiscardDrawer=$('#p2DiscardDrawer');

const victoryOverlay=$('#victoryOverlay'),
      victoryTitle=$('#victoryTitle'),
      victoryDesc=$('#victoryDesc'),
      p1PtsText=$('#p1Pts'),
      p2PtsText=$('#p2Pts'),
      playAgainBtn=$('#playAgainBtn'),
      chooseDecksBtn=$('#chooseDecksBtn');

const toolBackdrop=$('#toolBackdrop'),
      toolImg=$('#toolImg'),
      toolTitle=$('#toolTitle'),
      toolMeta=$('#toolMeta'),
      toolText=$('#toolText');

const handBackdrop=$('#handBackdrop'),
      handImg=$('#handImg'),
      handToolImg=$('#handToolImg'),
      handTitle=$('#handTitle'),
      handType=$('#handType'),
      handEffect=$('#handEffect');

const logPanel=$('#logPanel'),
      logEntriesDiv=$('#logEntries'),
      logToggleBtn=$('#logToggleBtn'),
      historyBackdrop=$('#historyBackdrop'),
      fullHistoryDiv=$('#fullHistory');

globalThis.turnNumber=1;
let currentPlayer=null,firstPlayer=null;

Object.defineProperty(globalThis, 'currentPlayer', {
  get: () => currentPlayer,
  set: (val) => { currentPlayer = val; }
});
let hasAttachedEnergyThisTurn=false,selectedEnergy=null,isSetupPhase=true,selectedEnergyElement=null,selectedToolElement=null;
globalThis.setSelectedEnergy = (val) => { selectedEnergy = val; };
let isEvoMode=false,evoMeta=null,evoOwner=null,evoHandCard=null;
let isPromotionPhase=false,openAttackMenu=null,gameOver=false,hasRetreatedThisTurn=false,isRetreatSelection=false,lastRetreatTime=0,abilityJustUsed=false,menuJustClosed=false;
globalThis.setMenuJustClosed = (val) => { menuJustClosed = val; };
const hasPlayedSupporterThisTurn={player1:false,player2:false};
let p1Points=0,p2Points=0,toolAttachPending=null,currentZoom={img:null,meta:null};

globalThis.getPoints = function(player) {
  if (player === 'player1' || player === 'p1') return p1Points;
  if (player === 'player2' || player === 'p2') return p2Points;
  return 0;
};
if (!window.usedAbilitiesThisTurn) {
  window.usedAbilitiesThisTurn = {
    p1: {},
    p2: {}
  };
}

let usedAbilitiesThisTurn = window.usedAbilitiesThisTurn;

function typeColorHex(t) {
  const key = (t || '').toLowerCase();
  switch (key) {
    case 'fire':      return '#f97316';
    case 'water':     return '#38bdf8';
    case 'grass':     return '#22c55e';
    case 'lightning': return '#facc15';
    case 'psychic':   return '#a855f7';
    case 'fighting':  return '#f97316';
    case 'metal':
    case 'steel':     return '#9ca3af';
    case 'darkness':  return '#4b5563';
    case 'dragon':    return '#22d3ee';
    case 'colorless': return '#e5e7eb';
    default:          return '#64748b';
  }
}

const playerState={
  player1:{deck:[],hand:[],energyTypes:JSON.parse(localStorage.getItem('player1Energy')||'[]'),currentTurnEnergy:null,nextTurnEnergy:null,discard:{cards:[],energyCounts:{}} },
  player2:{deck:[],hand:[],energyTypes:JSON.parse(localStorage.getItem('player2Energy')||'[]'),currentTurnEnergy:null,nextTurnEnergy:null,discard:{cards:[],energyCounts:{}} }
};

function selectRandomEnergy(energyTypes) {
  if (!energyTypes || energyTypes.length === 0) return null;
  if (energyTypes.length === 1) return energyTypes[0];
  
  return energyTypes[Math.floor(Math.random() * energyTypes.length)];
}

function initializePlayerEnergy(player) {
  const state = playerState[player];
  const energyTypes = state.energyTypes || [];
  
  if (energyTypes.length > 0) {
    
    state.currentTurnEnergy = selectRandomEnergy(energyTypes);
    
    
    state.nextTurnEnergy = selectRandomEnergy(energyTypes);
  }
}

initializePlayerEnergy('player1');
initializePlayerEnergy('player2');

function expandDeck(raw){
  const out=[];
  (raw||[]).forEach(c=>{
    if(!c||!c.name||!c.set||(c.number??c.num)==null)return;
    const n=Number(c.quantity)||1;
    for(let i=0;i<n;i++)out.push({...c,quantity:1});
  });
  return out;
}
playerState.player1.deck=expandDeck(JSON.parse(localStorage.getItem('player1Deck')||'[]'));
playerState.player2.deck=expandDeck(JSON.parse(localStorage.getItem('player2Deck')||'[]'));

(globalThis.updateDeckStack || updateDeckStack)('player1');
(globalThis.updateDeckStack || updateDeckStack)('player2');

let fullHistoryLog=[];
let logCounter=1;

function highImgUrl(set,num){
  if(!set || num==null) return null;
  return `https://assets.tcgdex.net/en/tcgp/${set}/${String(num).padStart(3,'0')}/high.png`;
}

function logEvent({ player, text, cardSet = null, cardNum = null }) {
  globalThis.logEvent = logEvent;
  const id = logCounter++;
  const ts = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  const who =
    player === 'player1' ? 'Player 1' :
    player === 'player2' ? 'Player 2' : 'System';

  const cls =
    player === 'player1' ? 'p1' :
    player === 'player2' ? 'p2' : 'sys';
  
  const imgUrl = (cardSet && cardNum) ? highImgUrl(cardSet, cardNum) : null;
  
  const div = document.createElement('div');
  div.className = `log-entry ${cls}`;
  div.dataset.id = id;

  div.innerHTML = `
    <div class="entry-player ${cls}">${who}</div>
    <div class="entry-text">${text}</div>
    ${imgUrl ? `<img class="log-thumb" src="${imgUrl}" alt="card">` : '' }
  `;

  if (logEntriesDiv.firstChild) {
    logEntriesDiv.insertBefore(div, logEntriesDiv.firstChild);
  } else {
  logEntriesDiv.appendChild(div);
  }
  logEntriesDiv.scrollTop = 0;
  
  fullHistoryLog.push({ id, ts, player: who, text, cardSet, cardNum, imgUrl });
}

globalThis.logEvent = logEvent;

logEntriesDiv.addEventListener("click", async (e) => {
  const thumb = e.target.closest(".log-thumb");
  if (!thumb) return;
  
  const match = thumb.src.match(/tcgp\/([^\/]+)\/(\d{3})/i);
  if (!match) return;

  const set = match[1];
  const num = match[2];

  let meta;
  try {
    meta = await fetchCardMeta(set, num);
  } catch (err) {
    console.error("Failed to fetch meta", err);
    showPopup("Unable to load card details.");
    return;
  }

  const category = (meta.category || "").toLowerCase();
  
  const fakeImg = document.createElement("img");
  fakeImg.dataset.set = set;
  fakeImg.dataset.num = num;
  fakeImg.dataset.hp = meta.hp || "0";
  fakeImg.dataset.chp = meta.hp || "0";
  fakeImg.src = thumb.src;
  fakeImg.alt = meta.name;
  
  const fakeSlot = document.createElement("div");
  fakeSlot.className = "card-slot";
  fakeSlot.appendChild(fakeImg);
  
  const fakePips = document.createElement("div");
  fakePips.className = "energy-pips";
  fakeSlot.appendChild(fakePips);

  const fakeHP = document.createElement("div");
  fakeHP.className = "hp-overlay";
  fakeHP.textContent = `${meta.hp} / ${meta.hp}`;
  fakeSlot.appendChild(fakeHP);
  
  if (category === "pokemon") {
    zoomImg.src = thumb.src;
    zoomBackdrop.classList.add("show");
    
    const tempWrap = document.createElement("div");
    tempWrap.style.display = "none";
    tempWrap.appendChild(fakeSlot);
    document.body.appendChild(tempWrap);

    await buildZoomPanel(meta, fakeImg);
    
    zoomBackdrop.addEventListener("transitionend", () => {
      if (!zoomBackdrop.classList.contains("show")) {
        tempWrap.remove();
      }
    }, { once: true });

    return;

  }
  
  handImg.src = thumb.src;
  handBackdrop.classList.add("show");
  handTitle.textContent = meta.name || "Trainer Card";
  handType.textContent = meta.trainerType || "Trainer";
  handType.style.background = trainerColor(meta.trainerType || "trainer");
  handEffect.textContent = meta.effect || meta.description || "No effect listed.";
});

if(logToggleBtn){
  logToggleBtn.onclick = () => {
    logPanel.classList.toggle('show');
  };
}

const closeLogBtn = document.getElementById("closeLogBtn");

if (closeLogBtn) {
  closeLogBtn.onclick = () => {
    logPanel.classList.remove("show");
  };
}

let selectionCancelHandler = null;
function setupSelectionCancelHandler() {
  
  if (selectionCancelHandler) {
    document.removeEventListener('keydown', selectionCancelHandler);
  }
  
  
  selectionCancelHandler = (e) => {
    if (e.key === "Escape") {
      
      if (!logPanel.classList.contains("show")) {
        cancelSelection();
      } else {
        logPanel.classList.remove("show");
      }
    }
  };
  document.addEventListener('keydown', selectionCancelHandler);
}

function cancelSelection() {
  if (selectedEnergy || globalThis.selectedEnergy || toolAttachPending) {
    clearSelectionGlow();
    selectedEnergy = null;
    globalThis.selectedEnergy = null;
    toolAttachPending = null;
    showPopup('Selection cancelled.');
  }
}

function clearSelectionGlow() {
  if (selectedEnergyElement) {
    selectedEnergyElement.classList.remove('selected-glow');
    selectedEnergyElement = null;
  }
  if (selectedToolElement) {
    selectedToolElement.classList.remove('selected-glow');
    selectedToolElement = null;
  }
  
  if (selectionCancelHandler) {
    document.removeEventListener('keydown', selectionCancelHandler);
    selectionCancelHandler = null;
  }
}

document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    
    if (!selectedEnergy && !toolAttachPending) {
    logPanel.classList.remove("show");
    }
  }
});

if(historyBackdrop){
  historyBackdrop.addEventListener('click',e=>{
    if(e.target===historyBackdrop) historyBackdrop.classList.remove('show');
  });
}

function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}


async function animateCardDraw(owner, targetHand, card = null, cardIndex = null, totalCardsBeingDrawn = 1) {
  const stackId = owner === 'player1' ? 'p1DeckStack' : 'p2DeckStack';
  const deckStack = document.getElementById(stackId);
  const handDiv = owner === 'player1' ? p1HandDiv : p2HandDiv;
  
  if (!deckStack || !handDiv) return;
  
  const deckRect = deckStack.getBoundingClientRect();
  const handRect = targetHand.getBoundingClientRect();
  
  
  const currentHandSize = playerState[owner].hand.length;
  const targetIndex = cardIndex !== null ? cardIndex : currentHandSize;
  
  
  const existingHandCard = handDiv.querySelector('.card-img');
  let actualCardWidth = 69.27; 
  let actualCardHeight = 96.47; 
  
  if (existingHandCard) {
    
    const cardRect = existingHandCard.getBoundingClientRect();
    if (cardRect.width > 0 && cardRect.height > 0) {
      actualCardWidth = cardRect.width;
      actualCardHeight = cardRect.height;
    } else {
      
      const computedStyle = window.getComputedStyle(existingHandCard);
      const computedWidth = parseFloat(computedStyle.width);
      const computedHeight = parseFloat(computedStyle.height);
      if (computedWidth && computedHeight) {
        actualCardWidth = computedWidth;
        actualCardHeight = computedHeight;
      }
    }
  }
  
  
  const handCards = handDiv.querySelectorAll('.card-slot');
  const existingCardCount = handCards.length;
  
  
  const finalHandSize = currentHandSize + totalCardsBeingDrawn;
  
  
  let targetX, targetY;
  
  if (handCards.length > 0 && existingHandCard) {
    
    const firstCardRect = existingHandCard.getBoundingClientRect();
    const firstCardCenterX = firstCardRect.left + firstCardRect.width / 2;
    const firstCardCenterY = firstCardRect.top + firstCardRect.height / 2;
    
    
    const secondCard = handDiv.querySelectorAll('.card-img')[1];
    let cardSpacing = actualCardWidth + 8; 
    if (secondCard) {
      const secondCardRect = secondCard.getBoundingClientRect();
      const secondCardCenterX = secondCardRect.left + secondCardRect.width / 2;
      cardSpacing = secondCardCenterX - firstCardCenterX;
    }
    
    
    const indexOffset = targetIndex - (finalHandSize - 1) / 2;
    targetX = firstCardCenterX + (indexOffset * cardSpacing);
    targetY = firstCardCenterY;
  } else {
    
    const cardSlotWidth = 75; 
    const slotGap = 8; 
    const slotSpacing = cardSlotWidth + slotGap;
    
    const handCenterX = handRect.left + handRect.width / 2;
    const slotOffsetFromCenter = (targetIndex - (finalHandSize - 1) / 2) * slotSpacing;
    targetX = handCenterX + slotOffsetFromCenter;
    
    targetY = handRect.top + handRect.height / 2;
    if (handCards.length > 0) {
      const firstSlotRect = handCards[0].getBoundingClientRect();
      targetY = firstSlotRect.top + firstSlotRect.height / 2;
    }
  }
  
  
  let cardImageUrl = null;
  let imageLoaded = false;
  
  if (card) {
    
    
    if (card.imgUrl) {
      cardImageUrl = card.imgUrl;
    } else if (card.set && (card.number || card.num)) {
      
      try {
        const meta = await fetchCardMeta(card.set, card.number || card.num);
        if (meta && meta.image) {
          
          cardImageUrl = meta.image + "/high.png";
        } else {
        }
      } catch (e) {

      }
    } else {
    }
  } else {
  }
  
  
  if (cardImageUrl) {
    await new Promise((resolve) => {
      const img = new Image();
      let resolved = false;
      img.onload = () => {
        if (!resolved) {
          imageLoaded = true;
          resolved = true;
          resolve();
        }
      };
      img.onerror = () => {
        if (!resolved) {
          
          cardImageUrl = null;
          imageLoaded = false;
          resolved = true;
          resolve();
        }
      };
      img.src = cardImageUrl;
      
      if (img.complete && img.naturalWidth > 0) {
        imageLoaded = true;
        resolved = true;
        resolve();
      }
    });
  } else {
  }
  
  
  const animCard = document.createElement('div');
  animCard.setAttribute('data-animated-card', 'true');
  animCard.style.position = 'fixed';
  animCard.style.width = `${actualCardWidth}px`;
  animCard.style.height = `${actualCardHeight}px`;
  
  animCard.style.left = `${deckRect.left + deckRect.width / 2 - actualCardWidth / 2}px`;
  animCard.style.top = `${deckRect.top + deckRect.height / 2 - actualCardHeight / 2}px`;
  animCard.style.transform = 'perspective(700px) rotateX(0deg)'; 
  animCard.style.zIndex = '1000';
  animCard.style.pointerEvents = 'none';
  animCard.style.willChange = 'left, top, transform';
  document.body.appendChild(animCard);
  
  
  if (!cardImageUrl || !imageLoaded) {
    
    return Promise.resolve(null);
  }
  
  
  const cardFront = document.createElement('div');
  cardFront.style.position = 'absolute';
  cardFront.style.width = '100%';
  cardFront.style.height = '100%';
  cardFront.style.backgroundImage = `url('${cardImageUrl}')`;
  cardFront.style.backgroundSize = 'contain'; 
  cardFront.style.backgroundPosition = 'center';
  cardFront.style.backgroundRepeat = 'no-repeat';
  cardFront.style.borderRadius = '6px'; 
  cardFront.style.boxShadow = '0 4px 12px rgba(0,0,0,0.4)';
  cardFront.style.opacity = '1'; 
  cardFront.style.top = '0';
  cardFront.style.left = '0';
  cardFront.style.pointerEvents = 'none';
  cardFront.style.zIndex = '2';
  animCard.appendChild(cardFront);
  
  
  
  
  const animationDuration = 800; 
  
  
  animCard.style.transition = `left ${animationDuration}ms ease-out, top ${animationDuration}ms ease-out, transform ${animationDuration}ms ease-out`;
  
  
  void animCard.offsetWidth;
  
  
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      
      const targetLeft = targetX - actualCardWidth / 2;
      const targetTop = targetY - actualCardHeight / 2;
      
      
      animCard.style.left = `${targetLeft}px`;
      animCard.style.top = `${targetTop}px`;
      
      animCard.style.transform = `perspective(700px) rotateX(3deg)`;
      
      
    });
  });
  
  
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(animCard); 
    }, animationDuration);
  });
}

function animateDeckShuffle(owner) {
  const stackId = owner === 'player1' ? 'p1DeckStack' : 'p2DeckStack';
  const deckStack = document.getElementById(stackId);
  
  if (!deckStack) return;
  
  deckStack.classList.add('shuffling');
  
  setTimeout(() => {
    deckStack.classList.remove('shuffling');
    
    (globalThis.updateDeckStack || updateDeckStack)(owner);
  }, 600);
}

const activeFor=p=>p==='player1'?p1Active:p2Active;
const benchFor=p=>p==='player1'?p1Bench:p2Bench;
const handDivFor=p=>p==='player1'?p1HandDiv:p2HandDiv;
const opponentOf=p=>p==='player1'?'player2':'player1';

let damageBoostThisTurn = {
  player1: { flatAll: 0, flatByName: {} },
  player2: { flatAll: 0, flatByName: {} }
};
globalThis.damageBoostThisTurn = damageBoostThisTurn;
globalThis.resetDamageBoostsFor = function (playerKey) {
  const slot = damageBoostThisTurn[playerKey];
  if (!slot) return;
  slot.flatAll = 0;
  slot.flatByName = {};
};

function markSlot(slot,has){
  const lab=slot.querySelector('.slot-label');
  slot.dataset.empty=has?'0':'1';
  if(lab)lab.style.display=has?'none':'block';
}
globalThis.markSlot = markSlot;

const metaCache={};
async function fetchCardMeta(set,num){
  const key=`${set}-${num}`;
  if(metaCache[key])return metaCache[key];
  const r=await fetch(`https://api.tcgdex.net/v2/en/sets/${set}/${num}`);
  if(!r.ok)throw new Error('meta');
  const d=await r.json();
  metaCache[key]=d;
  return d;
}
async function isBasicPokemon(set,num){
  try{
    const d=await fetchCardMeta(set,num);
    return String(d.category||'').toLowerCase()==='pokemon' &&
           String(d.stage||'').toLowerCase()==='basic';
  }catch{return false}
}

function removeFromHand(owner,set,num){
  const h=playerState[owner].hand;
  const i=h.findIndex(c=>c.set===set&&String(c.number||c.num)===String(num));
  if(i>=0)h.splice(i,1);
}
  
  if (!window.dropHandlersSetup) {
    setupDropHandlers();
    window.dropHandlersSetup = true;
}

function setupDropHandlers() {
  
  const setupSlotsForPlayer = (playerDiv) => {
    const bench = playerDiv.querySelector('.bench');
    const active = playerDiv.querySelector('.active');
    
    [bench, active].forEach(container => {
      if (!container) return;
      
      const slots = container.querySelectorAll('.card-slot');
      slots.forEach(slot => {
        
        if (slot.dataset.dropHandlersSetup === 'true') return;
        slot.dataset.dropHandlersSetup = 'true';
        
        slot.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          
          const slotOwner = slot.closest('#player1') ? 'player1' : 'player2';
          
          if (!isSetupPhase && slotOwner !== currentPlayer) return;
          
          
          slot.classList.add('drag-over');
        });
        
        slot.addEventListener('dragleave', (e) => {
          if (!slot.contains(e.relatedTarget)) {
            slot.classList.remove('drag-over');
          }
        });
        
        slot.addEventListener('drop', async (e) => {
          
          const targetImg = e.target.closest('img.card-img');
          if (targetImg && targetImg.closest('.card-slot') === slot) {
            
            try {
              const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
              if (dragData) {
                const { set, num } = dragData;
                
                const meta = await fetchCardMeta(set, num);
                if (meta && String(meta.trainerType || '').toLowerCase() === 'tool') {
                  
                  e.stopImmediatePropagation();
                  return;
                }
              }
            } catch {}
          }
          
          e.preventDefault();
          e.stopPropagation();
          
          slot.classList.remove('drag-over');
          
          const slotOwner = slot.closest('#player1') ? 'player1' : 'player2';
          
          if (!isSetupPhase && slotOwner !== currentPlayer) return;
          
          try {
            const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
            if (!dragData || dragData.owner !== slotOwner) return;
            
            const { set, num } = dragData;
            
            
            const handCard = playerState[slotOwner].hand.find(c => 
              c.set === set && String(c.number || c.num) === String(num)
            );
            
            if (!handCard) {
              showPopup('Card not found in hand.');
              return;
            }
            
            
            let meta = null;
            try {
              meta = await fetchCardMeta(set, num);
            } catch (err) {
              showPopup('Error loading card data.');
              return;
            }
            
            if (!meta) return;
            
            
            const ttype = String(meta.trainerType || '').toLowerCase();
            if (ttype === 'tool') {
              
              return;
            }
            
            const slotImg = slot.querySelector('img');
            const isActive = slot.closest('.active');
            const isBench = slot.closest('.bench');
            
            
            if (slotImg) {
              
              if (meta.evolveFrom) {
                
                const targetName = (slotImg.alt || '').toLowerCase();
                const evolveFromLower = String(meta.evolveFrom).toLowerCase();
                
                let canEvolve = targetName.includes(evolveFromLower);
                
                
                const FOSSIL_MAP = {
                  'helix fossil': 'omanyte',
                  'dome fossil': 'kabuto',
                  'old amber': 'aerodactyl',
                  'skull fossil': 'cranidos',
                  'armor fossil': 'shieldon'
                };
                
                if (!canEvolve && FOSSIL_MAP[targetName]) {
                  const fossilPokemon = FOSSIL_MAP[targetName];
                  canEvolve = fossilPokemon === evolveFromLower || evolveFromLower.includes(fossilPokemon);
                }
                
                
                if (!canEvolve && targetName.includes('eevee ex')) {
                  const EEVEELUTIONS = [
                    'vaporeon', 'jolteon', 'flareon', 'espeon', 'umbreon',
                    'leafeon', 'glaceon', 'sylveon'
                  ];
                  const evoCardName = (meta.name || '').toLowerCase();
                  canEvolve = EEVEELUTIONS.some(e => evoCardName.includes(e));
                }
                
                if (canEvolve) {
                  
                  const handCardElement = document.querySelector(`.hand img[data-set="${set}"][data-num="${num}"][data-owner="${slotOwner}"]`);
                  if (handCardElement) {
                    
                    const clickEvent = new MouseEvent('click', {
                      bubbles: true,
                      cancelable: true,
                      view: window
                    });
                    handCardElement.dispatchEvent(clickEvent);
                    
                    
                    setTimeout(() => {
                      slotImg.click();
                    }, 100);
                  }
                } else {
                  showPopup(`Cannot evolve ${slotImg.alt} into ${meta.name}.`);
                }
              } else {
                showPopup('This slot is already occupied.');
              }
            } else {
              
              if (String(meta.category || '').toLowerCase() !== 'pokemon') {
                showPopup('Only Pokmon can be placed on the bench.');
                return;
              }
              
              if (String(meta.stage || '').toLowerCase() !== 'basic') {
                showPopup('Only Basic Pokmon can be placed.');
                return;
              }
              
              
              if (isActive) {
                const act = slotOwner === 'player1' ? p1Active : p2Active;
                if (act.querySelector('img')) {
                  showPopup('Active slot is already occupied.');
                  return;
                }
              }
              
              
              if (isBench) {
                const bench = slotOwner === 'player1' ? p1Bench : p2Bench;
                const benchSlots = bench.querySelectorAll('.card-slot');
                const occupiedSlots = Array.from(benchSlots).filter(s => s.querySelector('img'));
                if (occupiedSlots.length >= 3) {
                  showPopup('Bench is full.');
                  return;
                }
              }
              
              
              const handCardElement = document.querySelector(`.hand img[data-set="${set}"][data-num="${num}"][data-owner="${slotOwner}"]`);
              if (!handCardElement) {
                showPopup('Card not found in hand.');
                return;
              }
              
              
              const clone = handCardElement.cloneNode(true);
              clone.dataset.playedTurn = globalThis.turnNumber || 0;
              
              
              if (!window.pokemonInstanceCounter) window.pokemonInstanceCounter = 0;
              clone.dataset.instanceId = ++window.pokemonInstanceCounter;
              clone.dataset.set = set;
              clone.dataset.num = num;
              
              
              slot.innerHTML = '';
              slot.appendChild(clone);
              markSlot(slot, true);
              
              
              if (handCardElement) {
                animateSlideFromHand(handCardElement, slot, clone);
              }
              
              
              removeFromHand(slotOwner, set, num);
              
              
              try {
                const baseHp = parseInt(meta.hp || '0', 10) || 0;
                setHpOnImage(clone, baseHp, baseHp);
              } catch {}
              
              
              if (isActive) {
                const playerNum = slotOwner === 'player1' ? 1 : 2;
                updatePlayerTypeBackground(playerNum);
              }
              
              renderAllHands();
              
              const placedTo = isActive ? 'active' : 'bench';
              logEvent({
                player: slotOwner,
                text: `Played Basic Pokmon to ${placedTo === 'active' ? 'Active' : 'Bench'}: ${meta.name}.`,
                cardSet: set,
                cardNum: num
              });
            }
          } catch (err) {
            console.error('[drop] Error handling drop:', err);
            showPopup('Error placing card.');
          }
        });
      });
    });
  };
  
  
  const player1Div = document.getElementById('player1');
  const player2Div = document.getElementById('player2');
  if (player1Div) setupSlotsForPlayer(player1Div);
  if (player2Div) setupSlotsForPlayer(player2Div);
  
  
  globalThis.reSetupDropHandlers = () => {
    if (player1Div) setupSlotsForPlayer(player1Div);
    if (player2Div) setupSlotsForPlayer(player2Div);
    
    if (globalThis.reSetupToolDropHandlers) {
      globalThis.reSetupToolDropHandlers();
    }
  };
  
  
  setupToolDropHandlers();
}

function setupToolDropHandlers() {
  
  const setupPokemonForPlayer = (playerDiv) => {
    const bench = playerDiv.querySelector('.bench');
    const active = playerDiv.querySelector('.active');
    
    [bench, active].forEach(container => {
      if (!container) return;
      
      const pokemonImgs = container.querySelectorAll('.card-slot img.card-img');
      pokemonImgs.forEach(img => {
        
        if (img.dataset.toolDropHandlersSetup === 'true') return;
        img.dataset.toolDropHandlersSetup = 'true';
        
        
        img.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          
          const pokemonOwner = img.closest('#player1') ? 'player1' : 'player2';
          
          if (!isSetupPhase && pokemonOwner !== currentPlayer) return;
          
          
          img.style.border = '2px solid #9d7dd4';
          img.style.boxShadow = '0 0 16px rgba(157, 125, 212, 0.6)';
        });
        
        img.addEventListener('dragleave', (e) => {
          if (!img.contains(e.relatedTarget)) {
            img.style.border = '';
            img.style.boxShadow = '';
          }
        });
        
        
        img.addEventListener('drop', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation(); 
          
          img.style.border = '';
          img.style.boxShadow = '';
          
          const pokemonOwner = img.closest('#player1') ? 'player1' : 'player2';
          
          if (!isSetupPhase && pokemonOwner !== currentPlayer) return;
          
          try {
            const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
            if (!dragData || dragData.owner !== pokemonOwner) return;
            
            const { set, num } = dragData;
            
            
            const handCard = playerState[pokemonOwner].hand.find(c => 
              c.set === set && String(c.number || c.num) === String(num)
            );
            
            if (!handCard) {
              showPopup('Card not found in hand.');
              return;
            }
            
            
            let meta = null;
            try {
              meta = await fetchCardMeta(set, num);
            } catch (err) {
              showPopup('Error loading card data.');
              return;
            }
            
            if (!meta) return;
            
            
            const ttype = String(meta.trainerType || '').toLowerCase();
            if (ttype !== 'tool') {
              showPopup('Only Tool cards can be attached to Pokmon.');
              return;
            }
            
            
            const targetSlot = img.closest('.card-slot');
            if (!targetSlot) {
              showPopup('Invalid target.');
              return;
            }
            
            if (getToolDataFromSlot(targetSlot)) {
              showPopup('This Pokmon already has a Tool attached.');
              return;
            }
            
            
            await attachToolToSlot(pokemonOwner, targetSlot, {
              set: set,
              num: num,
              src: handCard.image || `https://assets.tcgdex.net/en/tcgp/${set}/${String(num).padStart(3, '0')}/high.png`
            });
            
            
            const cardId = csvIdFor(set, num);
            const effect = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
            
            if (effect && effect.effect_type) {
              globalThis.toolAttachTarget = img;
              
              try {
                await (globalThis.applyTrainerEffect || applyTrainerEffect)(effect, pokemonOwner, null);
                
                
                removeFromHand(pokemonOwner, set, num);
                renderAllHands();

                logEvent({
                  player: pokemonOwner,
                  text: 'Attached Tool.',
                  cardSet: set,
                  cardNum: num
                });
                
              } catch (err) {

                
                const toolThumb = targetSlot.querySelector('.tool-thumb');
                if (toolThumb) toolThumb.remove();
                setToolDataOnSlot(targetSlot, null);
                
                showPopup(err.message || 'Cannot attach this Tool here.');
              } finally {
                globalThis.toolAttachTarget = null;
              }
            } else {
              
              removeFromHand(pokemonOwner, set, num);
              renderAllHands();

              logEvent({
                player: pokemonOwner,
                text: 'Attached Tool.',
                cardSet: set,
                cardNum: num
              });
            }
          } catch (err) {
            console.error('[tool-drop] Error handling drop:', err);
            showPopup('Error attaching tool.');
          }
        });
      });
    });
  };
  
  
  const player1Div = document.getElementById('player1');
  const player2Div = document.getElementById('player2');
  if (player1Div) setupPokemonForPlayer(player1Div);
  if (player2Div) setupPokemonForPlayer(player2Div);
  
  
  globalThis.reSetupToolDropHandlers = () => {
    
    document.querySelectorAll('.card-slot img.card-img').forEach(img => {
      delete img.dataset.toolDropHandlersSetup;
    });
    setupToolDropHandlers();
  };
}


globalThis.setMaxHp = function(img, newMax) {
  if (!img) return;
  const slot = img.closest('.card-slot');
  if (!slot) return;
  
  
  const oldMaxHp = parseInt(img.dataset.hp, 10) || 0;
  const oldCurrentHp = parseInt(img.dataset.chp || img.dataset.hp, 10) || oldMaxHp;
  
  
  const hpIncrease = newMax - oldMaxHp;
  
  
  const newCurrentHp = oldCurrentHp + hpIncrease;
  
  
  slot.dataset.maxHp = String(newMax);
  
  
  img.dataset.chp = String(newCurrentHp);
  
  
  let hpDiv = slot.querySelector('.hp-overlay');
  if (!hpDiv) {
    hpDiv = document.createElement('div');
    hpDiv.className = 'hp-overlay';
    slot.appendChild(hpDiv);
  }
  
  
  hpDiv.textContent = `${newCurrentHp} / ${newMax}`;
  
  
  hpDiv.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
  hpDiv.style.fontWeight = '900';
  
};

globalThis.forceSwitchSpecific = function(state, pk, benchImg) {
  if (!benchImg) return;
  
  const owner = pkToPlayer(pk);
  
  
  const activeDiv = owner === 'player1' ? document.getElementById('p1Active') : document.getElementById('p2Active');
  const activeSlot = activeDiv?.querySelector('.card-slot');
  const benchSlot = benchImg.closest('.card-slot');

  
  if (!activeSlot || !benchSlot) {
    console.error('[forceSwitchSpecific] Could not find slots', { activeSlot, benchSlot });
    return;
  }
  
  
  const activeImg = activeSlot.querySelector('img');
  if (!activeImg) {
    console.error('[forceSwitchSpecific] No active Pokemon to swap');
    return;
  }

  
  
  const activeMaxHp = activeSlot.dataset.maxHp;
  const benchMaxHp = benchSlot.dataset.maxHp;
  
  
  delete activeSlot.dataset.maxHp;
  delete benchSlot.dataset.maxHp;
  
  
  if (benchMaxHp) {
    activeSlot.dataset.maxHp = benchMaxHp;
  }
  if (activeMaxHp) {
    benchSlot.dataset.maxHp = activeMaxHp;
  }
  
  
  const activeInstanceId = activeImg.dataset.instanceId;
  const ownerPk = owner === 'player1' ? 'p1' : 'p2';
  if (activeInstanceId && globalThis.__moveLocks?.[ownerPk]?.[activeInstanceId]) {
    delete globalThis.__moveLocks[ownerPk][activeInstanceId];
  }
  
  
  const activeRect = activeImg.getBoundingClientRect();
  const benchRect = benchImg.getBoundingClientRect();
  
  
  activeImg.style.opacity = '0';
  benchImg.style.opacity = '0';
  
  
  const activeHTML = activeSlot.innerHTML;
  const benchHTML = benchSlot.innerHTML;
  
  activeSlot.innerHTML = benchHTML;
  benchSlot.innerHTML = activeHTML;
  
  
  const newActiveImg = activeSlot.querySelector('img');
  const newBenchImg = benchSlot.querySelector('img');
  
  
  if (newActiveImg && newBenchImg) {
    animateSlideSwap(benchImg, activeSlot, newActiveImg, benchRect);
    animateSlideSwap(activeImg, benchSlot, newBenchImg, activeRect);
  } else if (newActiveImg) {
    
    animateSlideSwap(benchImg, activeSlot, newActiveImg, benchRect);
  }

  
  
  
  if (newActiveImg) {
    const baseHp = parseInt(newActiveImg.dataset.hp, 10) || 0;
    const curHp = parseInt(newActiveImg.dataset.chp || newActiveImg.dataset.hp, 10) || baseHp;
    setHpOnImage(newActiveImg, baseHp, curHp);
  }
  
  if (newBenchImg) {
    const baseHp = parseInt(newBenchImg.dataset.hp, 10) || 0;
    const curHp = parseInt(newBenchImg.dataset.chp || newBenchImg.dataset.hp, 10) || baseHp;
    setHpOnImage(newBenchImg, baseHp, curHp);
  }
  
  
  if (typeof updateAllEnergyVisuals === 'function') {
    updateAllEnergyVisuals();
  }
};

if(handBackdrop){
  handBackdrop.addEventListener('click',e=>{
    if(e.target===handBackdrop){
      handBackdrop.classList.remove('show');
      if(handToolImg) handToolImg.style.display = 'none';
    }
  });
  document.addEventListener('keydown',e=>{
    if(e.key==='Escape'){
      handBackdrop.classList.remove('show');
      if(handToolImg) handToolImg.style.display = 'none';
    }
  });
}

function satisfiedFlags(pips, costArr, pokemonImg = null) {
  const cnt = {...pips};
  const keys = Object.keys(cnt).filter(k => k !== 'total');
  const f = [];
  
  
  let costIncrease = 0;
  if (pokemonImg) {
    let pk = null;
    if (pokemonImg.closest('#player1')) pk = 'p1';
    else if (pokemonImg.closest('#player2')) pk = 'p2';
    
    if (pk && globalThis.__specialEffects?.[pk]?.attackCostIncrease) {
      costIncrease = globalThis.__specialEffects[pk].attackCostIncrease;
    }
    
    
    const oppPk = pk === 'p1' ? 'p2' : 'p1';
    const oppActive = oppPk === 'p1' ? p1Active : p2Active;
    const oppActiveImg = oppActive?.querySelector('img');
    
    if (oppActiveImg) {
      try {
        const cacheKey = `${oppActiveImg.dataset.set}-${oppActiveImg.dataset.num}`;
        const abilityRow = globalThis.abilityCache?.[cacheKey];
        
        if (abilityRow?.effect_type === 'increase_opponent_cost') {
          const increase = parseInt(abilityRow.param1 || '1', 10);
          costIncrease += increase;
        }
      } catch (err) {
        console.error('[canAfford] Guard Dog Visage check failed:', err);
      }
    }
  }
  
  
  let colorlessReduction = 0;
  if (pokemonImg && pokemonImg.dataset.set && pokemonImg.dataset.num) {
    try {
      const cacheKey = `${pokemonImg.dataset.set}-${pokemonImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_attack_cost_if_arceus') {
        
        let pk = null;
        if (pokemonImg.closest('#player1')) pk = 'p1';
        else if (pokemonImg.closest('#player2')) pk = 'p2';
        
        if (pk && typeof hasArceusInPlay === 'function' && hasArceusInPlay(pk)) {
          colorlessReduction = parseInt(abilityRow.param1 || '1', 10);
        }
      }
    } catch (e) {
      
    }
  }
  
  
  if (pokemonImg) {
    const pokemonName = (pokemonImg.alt || '').toLowerCase();
    const barryCostReduction = globalThis.attackCostReduction?.[pokemonName] || 0;
    if (barryCostReduction > 0) {
      colorlessReduction += barryCostReduction;
    }
  }
  
  
  const modifiedCostArr = [...(costArr || [])];
  for (let i = 0; i < costIncrease; i++) {
    modifiedCostArr.push('colorless');
  }
  
  modifiedCostArr.forEach(t => {
    const k = String(t || '').toLowerCase();
    if (k === 'colorless') {
      
      if (colorlessReduction > 0) {
        colorlessReduction--;
        f.push(true);
        return;
      }
      
      
      let ok = false;
      for (const tp of keys) {
        if ((cnt[tp] || 0) > 0) {
          cnt[tp]--;
          cnt.total--;
          ok = true;
          break;
        }
      }
      f.push(ok);
    } else {
      if ((cnt[k] || 0) > 0) {
        cnt[k]--;
        cnt.total--;
        f.push(true);
      } else {
        f.push(false);
      }
    }
  });
  return f;
}

function canPayCostFromAPI(slot, costArr, pokemonImg = null) {
  return satisfiedFlags(countPipsOn(slot), costArr || [], pokemonImg).every(Boolean);
}

function makeCostIcons(costArr, slot, pokemonImg = null) {
  const wrap = document.createElement('div');
  wrap.className = 'attack-cost';
  const flags = satisfiedFlags(countPipsOn(slot), costArr || [], pokemonImg);
  (costArr || []).forEach((t, i) => {
    const ic = document.createElement('div');
    ic.className = 'cost-icon';
    ic.style.backgroundImage = `url('${energyIconUrl(String(t || '').toLowerCase())}')`;
    if (!flags[i]) ic.classList.add('missing');
    wrap.appendChild(ic);
  });
  return wrap;
}

const parseDamage=v=>{const m=String(v??'').match(/\d+/);return m?parseInt(m[0],10):0};
const getActiveImage=p=>activeFor(p).querySelector('img')||null;

function pushCardToDiscard(owner,img){
  playerState[owner].discard.cards.push({set:img.dataset.set,num:img.dataset.num,src:img.src});
}
function moveCardToDiscard(owner,img){
  const slot=img.closest('.card-slot');
  const tool=getToolDataFromSlot(slot);
  if(tool){
    playerState[owner].discard.cards.push({set:tool.set,num:tool.num,src:tool.src});
    removeToolThumb(slot);
    setToolDataOnSlot(slot,null);
  }
  const drawer=owner==='player1'?p1DiscardDrawer:p2DiscardDrawer;
  pushCardToDiscard(owner,img);
  const pips=countPipsOn(slot);
  Object.keys(pips).forEach(k=>{
    if(k==='total')return;
    playerState[owner].discard.energyCounts[k]=(playerState[owner].discard.energyCounts[k]||0)+pips[k];
  });
  slot.innerHTML='';
  slot.classList.remove('damage-flash');
  const lab=document.createElement('span');
  lab.className='slot-label';
  lab.textContent='Empty';
  slot.appendChild(lab);
  markSlot(slot,false);
  if(drawer.classList.contains('show'))renderDiscard(owner);
}
async function pointsForCard(set,num){
  try{
    const meta=await fetchCardMeta(set,num);
    const s=(meta.suffix||'').toUpperCase();
    const name=(meta.name||'').toLowerCase();
    if(s==='EX'&&name.includes('mega'))return 3;
    if(s==='EX')return 2;
  }catch{}
  return 1;
}
const checkBenchOut=owner=>[...benchFor(owner).querySelectorAll('img')].length===0;

function showVictory(winnerKey,reason){
  if(gameOver)return;
  gameOver=true;
  $('.main-layout')?.classList.add('disable-clicks');
  $('.side-panel')?.classList.add('disable-clicks');
  victoryTitle.textContent=winnerKey==='player1'?'Player 1 Wins!':'Player 2 Wins!';
  victoryDesc.textContent=reason||'Game over';
  p1PtsText.textContent=String(p1Points);
  p2PtsText.textContent=String(p2Points);
  victoryOverlay.style.display='flex';
}

async function handleKnockOut(owner, img, wasActive = false){
  const set=img.dataset.set,
        num=img.dataset.num;
  const foe=owner==='player1'?'player2':'player1';
  
  
  const activeImg = getActiveImage(owner);
  const isActive = wasActive || (activeImg === img);
  

  if (typeof getAbilityRow === 'function') {
    try {
      const pk = owner === 'player1' ? 'p1' : 'p2';
      const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
      
      if (abilityRow && typeof applyAbilityEffectFromCsv === 'function') {
        
        if (abilityRow.effect_type === 'counter_on_knockout' && isActive) {
          await applyAbilityEffectFromCsv(abilityRow, pk, { 
            attacker: foe,
            knockedPokemon: img 
          });
        }
        
        
        if (abilityRow.effect_type === 'flip_ko_attacker_on_ko' && isActive) {
          const effectState = {
            p1: playerState.player1,
            p2: playerState.player2
          };
          await applyAbilityEffectFromCsv(effectState, pk, abilityRow, { 
            attacker: foe,
            knockedPokemon: img 
          });
        }
        
        
        if (abilityRow.effect_type === 'move_energy_on_knockout' && isActive) {
          await applyAbilityEffectFromCsv(abilityRow, pk, { 
            knockedPokemon: img 
          });
        }
      }
    } catch (err) {
    }
  }
  
  
  if (isActive) {
    const slot = img.closest('.card-slot');
    const tool = getToolDataFromSlot(slot);
    
    if (tool && tool.num === '065' && tool.set === 'A3a') {
      
      
      try {
        const meta = await fetchCardMeta(img.dataset.set, img.dataset.num);
        const isLightningType = meta.types?.some(t => t.toLowerCase() === 'lightning');
        
        if (isLightningType) {
          
          const energyBox = slot?.querySelector('.energy-pips');
          const pips = energyBox?.querySelectorAll('.energy-pip');
          const lightningPips = Array.from(pips || []).filter(p => p.dataset.type === 'lightning');

          
          if (lightningPips.length >= 2) {
            
            const energyBox = slot?.querySelector('.energy-pips');
            const pips = energyBox?.querySelectorAll('.energy-pip');
            const lightningPipsArray = Array.from(pips || []).filter(p => p.dataset.type === 'lightning');
            
            
            const toRemove = Math.min(2, lightningPipsArray.length);
            for (let i = 0; i < toRemove; i++) {
              lightningPipsArray[i].remove();
            }

            
            
            const pk = owner === 'player1' ? 'p1' : 'p2';
            const bench = [...benchFor(owner).querySelectorAll('img')];
            
            if (bench.length >= 2) {
              showPopup('Electrical Cord: Select 2 Benched Pokmon to receive Lightning Energy');
              
              
              const first = await new Promise(resolve => {
                bench.forEach(b => b.classList.add('selectable'));
                const handler = (e) => {
                  const clicked = e.target.closest('img');
                  if (clicked && bench.includes(clicked)) {
                    bench.forEach(b => {
                      b.classList.remove('selectable');
                      b.removeEventListener('click', handler);
                    });
                    resolve(clicked);
                  }
                };
                bench.forEach(b => b.addEventListener('click', handler));
              });
              
              if (first) {
                
                const remaining = bench.filter(b => b !== first);
                const second = await new Promise(resolve => {
                  remaining.forEach(b => b.classList.add('selectable'));
                  const handler = (e) => {
                    const clicked = e.target.closest('img');
                    if (clicked && remaining.includes(clicked)) {
                      remaining.forEach(b => {
                        b.classList.remove('selectable');
                        b.removeEventListener('click', handler);
                      });
                      resolve(clicked);
                    }
                  };
                  remaining.forEach(b => b.addEventListener('click', handler));
                });
                
                if (second) {
                  
                  attachEnergy(first, 'lightning');
                  attachEnergy(second, 'lightning');
                  showPopup(`Electrical Cord: Distributed Lightning Energy to ${first.alt} and ${second.alt}!`);
                }
              }
            } else if (bench.length === 1) {
              
              attachEnergy(bench[0], 'lightning');
              attachEnergy(bench[0], 'lightning');
              showPopup(`Electrical Cord: Attached 2 Lightning Energy to ${bench[0].alt}!`);
            } else {
            }
          } else {
          }
        }
      } catch (err) {
      }
    }
  }
  
  
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.koLastTurn) globalThis.state.koLastTurn = {};
  
  const ownerPk = owner === 'player1' ? 'p1' : 'p2';
  globalThis.state.koLastTurn[ownerPk] = true;
  
  
  const pokemonName = (img.alt || '').toLowerCase();
  if (pokemonName.includes('serperior')) {
    
    setTimeout(() => {
      if (typeof globalThis.updateAllEnergyVisuals === 'function') {
        globalThis.updateAllEnergyVisuals();
      }
    }, 100); 
  }
  
  logEvent({
    player: foe,
    text:`Knocked out ${img.alt || 'a Pokmon'}.`,
    cardSet:set,cardNum:num
  });

  moveCardToDiscard(owner,img);
  const pts=await pointsForCard(set,num);
  if(foe==='player1')p1Points+=pts;else p2Points+=pts;
  updatePointsUI();
  if(p1Points>=3||p2Points>=3){
    showVictory(p1Points>=3?'player1':'player2','Reached 3 points');
    return true;
  }
  
  
  if(isActive && checkBenchOut(owner)){
    showVictory(foe,'Bench out');
    return true;
  }
  
  return false;
}

async function damageActiveOf(player, amount, options = {}) {
  const img = getActiveImage(player);
  if (!img) return { knocked: false, hpText: '' };
  
  const pk = player === 'player1' ? 'p1' : 'p2';
  
  
  const isDirectAttack = options.isDirectAttack !== false; 
  const attackerImg = options.attackerImg; 

  amount = applySpecialEffectsToDamage(pk, amount);

  
  
  const reduction = getPassiveDamageReduction(pk);
  if (reduction > 0) {
    amount = Math.max(0, amount - reduction);
    showPopup(`Ability reduced damage by ${reduction}!`);
  }
  
  
  const slot = img.closest('.card-slot');
  const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  
  const base = modifiedMaxHp || parseInt(img.dataset.hp || '0', 10) || 0;
  let chp = parseInt(img.dataset.chp || base || '0', 10) || base;
  
  
  if (isDirectAttack && attackerImg && shouldBlockDamageFromEx(pk, attackerImg)) {
    
    const shield = document.createElement('div');
    shield.className = 'safeguard-shield';
    shield.innerHTML = '';
    shield.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 60px;
      z-index: 9999;
      animation: safeguardPulse 0.8s ease-out;
      pointer-events: none;
    `;
    slot.appendChild(shield);
    
    
    if (!document.getElementById('safeguard-animation-style')) {
      const style = document.createElement('style');
      style.id = 'safeguard-animation-style';
      style.textContent = `
        @keyframes safeguardPulse {
          0% {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.3);
            filter: drop-shadow(0 0 10px rgba(59, 130, 246, 0.8));
          }
          50% {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
            filter: drop-shadow(0 0 20px rgba(59, 130, 246, 1));
          }
          100% {
            opacity: 0;
            transform: translate(-50%, -50%) scale(1.5);
            filter: drop-shadow(0 0 30px rgba(59, 130, 246, 0.4));
          }
        }
      `;
      document.head.appendChild(style);
    }
    
    
    setTimeout(() => shield.remove(), 800);
    
    showPopup(`Safeguard: ${img.alt} takes no damage from ${attackerImg.alt}!`);
    return { knocked: false, hpText: `${chp} / ${base}` };
  }
  
  chp = Math.max(0, chp - amount);
  setHpOnImage(img, base, chp);
  
  slot.classList.add('damage-flash');
  setTimeout(() => slot.classList.remove('damage-flash'), 400);

  if (currentZoom.img && currentZoom.img === img) {
    const pct = base > 0 ? Math.round((chp / base) * 100) : 0;
    zoomHp.textContent = `HP: ${chp} / ${base}`;
    zoomHpBar.style.width = pct + "%";
    zoomHpBar.style.background = (chp === base)
      ? 'linear-gradient(90deg,#22c55e,#16a34a)'
      : 'linear-gradient(90deg,#f43f5e,#ef4444)';
  }
  
  if (amount > 0 && isDirectAttack) {
    const counterDmg = getCounterattackDamage(pk);
    if (counterDmg > 0) {
      const attacker = player === 'player1' ? 'player2' : 'player1';
      showPopup(`Counterattack: Dealt ${counterDmg} damage back!`);
      setTimeout(async () => {
        const counterResult = await damageActiveOf(attacker, counterDmg, { isDirectAttack: false });
        
        if (counterResult.knocked && typeof handleKnockOut === 'function') {
          const attackerImg = getActiveImage(attacker);
          if (attackerImg) {
            const gameEnded = await handleKnockOut(attacker, attackerImg, true);
            if (!gameEnded && typeof beginPromotionFlow === 'function') {
              await beginPromotionFlow(attacker);
            }
          }
        }
      }, 600);
    }
    
    
    if (img.dataset.counterDamageNextTurn) {
      const counterDamage = parseInt(img.dataset.counterDamageNextTurn, 10);
      const attacker = player === 'player1' ? 'player2' : 'player1';
      showPopup(`Counter activated: Dealt ${counterDamage} damage back!`);
      delete img.dataset.counterDamageNextTurn; 
      
      setTimeout(async () => {
        const counterResult = await damageActiveOf(attacker, counterDamage, { isDirectAttack: false });
        
        if (counterResult.knocked && typeof handleKnockOut === 'function') {
          const attackerImg = getActiveImage(attacker);
          if (attackerImg) {
            const gameEnded = await handleKnockOut(attacker, attackerImg, true);
            if (!gameEnded && typeof beginPromotionFlow === 'function') {
              await beginPromotionFlow(attacker);
            }
          }
        }
      }, 800);
    }
    
    
    const tool = getToolDataFromSlot(slot);
    if (tool && tool.set && tool.num) {
      const cardId = `${tool.set}-${tool.num}`;
      
      
      if (cardId === 'A2-148') {
        const helmetDamage = 20;
        const attacker = player === 'player1' ? 'player2' : 'player1';
        showPopup(`Rocky Helmet: Dealt ${helmetDamage} damage back!`);
        setTimeout(async () => {
          const helmetResult = await damageActiveOf(attacker, helmetDamage, { isDirectAttack: false });
          
          if (helmetResult.knocked && typeof handleKnockOut === 'function') {
            const attackerImg = getActiveImage(attacker);
            if (attackerImg) {
              const gameEnded = await handleKnockOut(attacker, attackerImg, true);
              if (!gameEnded && typeof beginPromotionFlow === 'function') {
                beginPromotionFlow(attacker);
              }
            }
          }
        }, 800);
      }
      
      
      if (cardId === 'A3-146') {
        const attacker = player === 'player1' ? 'player2' : 'player1';
        const attackerPk = attacker === 'player1' ? 'p1' : 'p2';
        if (typeof setStatus === 'function') {
          setStatus(attackerPk, 'poisoned');
          showPopup(`Poison Barb: Poisoned the attacker!`);
        }
      }
    }
  }

  if (chp <= 0) {
    
    if (typeof getAbilityRow === 'function' && typeof applyAbilityEffectFromCsv === 'function') {
      try {
        const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
        
        if (abilityRow?.effect_type === 'flip_avoid_knockout') {
          const pk = player === 'player1' ? 'p1' : 'player2';
          const result = await applyAbilityEffectFromCsv(abilityRow, pk, { targetImg: img });
          
          if (result?.avoided) {

            return { knocked: false, owner: player };
          }
        }
      } catch (err) {
      }
    }
    
    const owner = img.closest('#player1') ? 'player1' : 'player2';
    return { knocked: true, owner };
  }
  
  return { knocked: false };
}
function animateCardToHand(pk, cardObj) {
  
  const img = document.createElement('img');
  img.src = cardObj.image;
  img.style.position = 'fixed';
  img.style.width = '48px';
  img.style.height = '67px';
  img.style.pointerEvents = 'none';
  img.style.zIndex = 99999;
  img.style.borderRadius = '6px';
  img.style.left = '50%';
  img.style.top = '50%';
  img.style.transform = 'translate(-50%, -50%) scale(2)';
  img.style.opacity = '1';
  img.style.transition = 'all .4s ease-out';

  document.body.appendChild(img);
  
  const handElm = pk === 'p1' ? document.getElementById('p1Hand') : document.getElementById('p2Hand');
  const rect = handElm.getBoundingClientRect();

  setTimeout(() => {
    img.style.left = rect.left + 40 + 'px';
    img.style.top = rect.top + 10 + 'px';
    img.style.transform = 'translate(0,0) scale(.6)';
    img.style.opacity = '0';
  }, 20);

  setTimeout(() => img.remove(), 420);
}

function animateSlideFromHand(sourceImg, targetSlot, targetCard) {
  if (!sourceImg || !targetSlot) return;
  
  
  if (typeof sourceImg.getBoundingClientRect !== 'function') {
    return;
  }
  
  
  if (targetCard) {
    targetCard.style.opacity = '0';
  }
  
  
  const sourceRect = sourceImg.getBoundingClientRect();
  const animationDuration = 250; 
  
  
  requestAnimationFrame(() => {
    const targetRect = targetSlot.getBoundingClientRect();
    
    
    const clone = sourceImg.cloneNode(true);
    clone.style.cssText = `
      position: fixed;
      left: ${sourceRect.left}px;
      top: ${sourceRect.top}px;
      width: ${sourceRect.width}px;
      height: ${sourceRect.height}px;
      z-index: 10000;
      pointer-events: none;
      transition: all ${animationDuration}ms cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 1;
    `;
    document.body.appendChild(clone);
    
    
    void clone.offsetWidth;
    
    
    requestAnimationFrame(() => {
      clone.style.left = `${targetRect.left}px`;
      clone.style.top = `${targetRect.top}px`;
      clone.style.width = `${targetRect.width}px`;
      clone.style.height = `${targetRect.height}px`;
      clone.style.opacity = '0.8';
    });
    
    
    setTimeout(() => {
      clone.remove();
      if (targetCard) {
        targetCard.style.opacity = '1';
        targetCard.style.transition = 'opacity 0.1s ease';
      }
    }, animationDuration);
  });
}

function animateSlideSwap(sourceImg, targetSlot, targetCard, sourceRect) {
  if (!sourceImg || !targetSlot) return;
  
  
  if (targetCard) {
    targetCard.style.opacity = '0';
  }
  
  
  const sourcePosition = sourceRect || sourceImg.getBoundingClientRect();
  const animationDuration = 250; 
  
  
  requestAnimationFrame(() => {
    const targetRect = targetSlot.getBoundingClientRect();
    
    
    const clone = sourceImg.cloneNode(true);
    clone.style.cssText = `
      position: fixed;
      left: ${sourcePosition.left}px;
      top: ${sourcePosition.top}px;
      width: ${sourcePosition.width}px;
      height: ${sourcePosition.height}px;
      z-index: 10000;
      pointer-events: none;
      transition: all ${animationDuration}ms cubic-bezier(0.4, 0, 0.2, 1);
      opacity: 1;
    `;
    document.body.appendChild(clone);
    
    
    void clone.offsetWidth;
    
    
    requestAnimationFrame(() => {
      clone.style.left = `${targetRect.left}px`;
      clone.style.top = `${targetRect.top}px`;
      clone.style.width = `${targetRect.width}px`;
      clone.style.height = `${targetRect.height}px`;
      clone.style.opacity = '0.8';
    });
    
    
    setTimeout(() => {
      clone.remove();
      if (targetCard) {
        targetCard.style.opacity = '1';
        targetCard.style.transition = 'opacity 0.1s ease';
      }
    }, animationDuration);
  });
}


async function calculatePreviewDamage(attack, attackerImg, meta, pk) {
  if (!attack || !attackerImg || !meta) {
    const baseDmg = attack?.damage || '';
    return { damage: baseDmg, hasWeakness: false, hasOtherBoosts: false };
  }
  
  
  let damage = 0;
  let isMultiplicative = false;
  let multiplier = 1;
  if (attack.damage) {
    const dmgStr = String(attack.damage).toLowerCase();
    
    if (dmgStr.includes('x') || dmgStr.includes('')) {
      isMultiplicative = true;
      
      const multMatch = dmgStr.match(/(\d+)\s*[x]/);
      if (multMatch) {
        multiplier = parseInt(multMatch[1], 10);
      } else {
        multiplier = 1; 
      }
      damage = 0; 
    } else {
      
      const match = dmgStr.match(/\d+/);
      if (match) damage = parseInt(match[0], 10);
    }
  }
  
  
  try {
    if (typeof globalThis.getMoveRow === 'function' && typeof globalThis.loadMoveEffects === 'function') {
      await globalThis.loadMoveEffects();
      const moveRow = globalThis.getMoveRow(attackerImg.alt, attack.name);
      if (moveRow?.effect_type === 'bonus_damage_per_energy_on_opponent_all') {
        damage = 0; 
      } else if (moveRow?.effect_type === 'bonus_damage_for_each_bench') {
        damage = 0; 
      }
    }
  } catch (err) {
    console.error('[preview] Error checking move row for base damage:', err);
  }
  
  const foePk = pk === 'p1' ? 'p2' : 'p1';
  const foe = foePk === 'p1' ? 'player1' : 'player2';
  
  
  let hasWeakness = false;
  let hasOtherBoosts = false;
  const baseDamage = damage;
  let totalBonuses = 0; 
  
  
  const effectState = {
    p1: typeof playerState !== 'undefined' ? playerState.player1 : {},
    p2: typeof playerState !== 'undefined' ? playerState.player2 : {},
    activeFor: typeof activeFor === 'function' ? activeFor : () => null,
    benchFor: typeof benchFor === 'function' ? benchFor : () => null,
    opponentOf: typeof opponentOf === 'function' ? opponentOf : (p) => p === 'player1' ? 'player2' : 'player1',
    fetchCardMeta: typeof fetchCardMeta === 'function' ? fetchCardMeta : async () => ({}),
    damageActiveOf: typeof damageActiveOf === 'function' ? damageActiveOf : () => ({ knocked: false }),
    beginPromotionFlow: typeof beginPromotionFlow === 'function' ? beginPromotionFlow : () => {},
    showPopup: () => {}, 
    logEvent: () => {}
  };
  
  try {
      if (typeof applyMoveEffectFromCsv === 'function') {
      const result = await applyMoveEffectFromCsv(effectState, pk, attack.name, damage, { 
        moveName: attack.name,
        isFinal: false, 
        isMultiplicative: isMultiplicative,
        multiplier: multiplier,
        attackCost: attack.cost || [] 
      });
      
      if (typeof result === 'object' && result.damage !== undefined) {
        
        damage = result.damage;
        
        if (isMultiplicative && result.totalBonuses !== undefined) {
          totalBonuses = result.totalBonuses;
        }
      } else {
        
        damage = result;
        
        if (isMultiplicative) {
          totalBonuses = damage;
          damage = 0;
        }
      }
      
      
      
      
      try {
        
        if (typeof globalThis.loadMoveEffects === 'function') {
          await globalThis.loadMoveEffects();
        }
        
        if (typeof globalThis.getMoveRow === 'function') {
          const moveRow = globalThis.getMoveRow(attackerImg.alt, attack.name);
          if (moveRow?.effect_type === 'bonus_damage_if_last_move_name_used') {
            const moveName = moveRow.param1 || 'Sweets Relay';
            const bonus = parseInt(moveRow.param2 || '20', 10);
            
            
            if (!globalThis.__moveHistory) globalThis.__moveHistory = { p1: [], p2: [] };
            const lastTurnMoves = globalThis.__moveHistory[pk] || [];
            const usedLastTurn = lastTurnMoves.some(move => 
              move.name && move.name.toLowerCase() === moveName.toLowerCase()
            );
            
            if (usedLastTurn) {
              if (isMultiplicative) {
                totalBonuses += bonus;
              } else {
                damage += bonus;
              }
              hasOtherBoosts = true;
            }
          }
        }
      } catch (err) {
        console.error('[preview] Sweets Relay check failed:', err);
      }
      
      
      const boost = (globalThis.state?.temp?.[pk]?.globalDamageBoost ?? 0);
      if (boost) {
        if (isMultiplicative) {
          totalBonuses += boost;
        } else {
          damage += boost;
        }
        hasOtherBoosts = true;
      }
      
      
      const nextTurnBonus = (globalThis.state?.temp?.[pkToPlayer(pk)]?.nextTurnDamageBonus ?? 0);
      if (nextTurnBonus > 0) {
        if (isMultiplicative) {
          totalBonuses += nextTurnBonus;
        } else {
          damage += nextTurnBonus;
        }
        hasOtherBoosts = true;
      }
      
      
      const bonusKey = `${attackerImg.dataset.instanceId || attackerImg.alt}_${attack.name}`;
      const nextTurnBonus2 = globalThis.__attackBonuses?.[bonusKey] || 0;
      if (nextTurnBonus2 > 0) {
        if (isMultiplicative) {
          totalBonuses += nextTurnBonus2;
        } else {
          damage += nextTurnBonus2;
        }
        hasOtherBoosts = true;
      }
      
      
      const attackerSlot = attackerImg.closest('.card-slot');
      const tool = getToolDataFromSlot(attackerSlot);
      if (tool && tool.num === '066' && tool.set === 'A3a') {
        const ULTRA_BEASTS = [
          'nihilego', 'buzzwole', 'pheromosa', 'xurkitree', 'celesteela',
          'kartana', 'guzzlord', 'poipole', 'naganadel', 'stakataka', 'blacephalon'
        ];
        const attackerName = (attackerImg.alt || '').toLowerCase();
        const isUltraBeast = ULTRA_BEASTS.some(ub => attackerName.includes(ub));
        if (isUltraBeast) {
          const attackerPlayer = attackerImg.closest('#player1') ? 'player1' : 'player2';
          const points = attackerPlayer === 'player1' ? p1Points : p2Points;
          const bonus = points * 10;
          if (isMultiplicative) {
            totalBonuses += bonus;
          } else {
            damage += bonus;
          }
          hasOtherBoosts = true;
        }
      }
      
      
      if (globalThis.state?.damageBoost?.[pk]) {
        const boostData = globalThis.state.damageBoost[pk];
        if (boostData.target === 'eeveelution' && boostData.duration === 'this_turn') {
          const attackerName = (attackerImg.alt || '').toLowerCase();
          const isEeveelution = boostData.targetNames?.some(ee => attackerName.includes(ee));
          if (isEeveelution) {
            if (isMultiplicative) {
              totalBonuses += boostData.amount;
            } else {
              damage += boostData.amount;
            }
            hasOtherBoosts = true;
          }
        }
      }
      
      
      if (isMultiplicative) {
        damage = totalBonuses * multiplier;
      }
    }
  } catch (err) {
    console.error('[preview] Move effect error:', err);
  }
  
  
  try {
    const effectiveDamage = isMultiplicative ? totalBonuses : damage;
    if (effectiveDamage > 0 && typeof getActiveImage === 'function') {
      const foeImg = getActiveImage(foe);
      if (foeImg && typeof fetchCardMeta === 'function') {
        const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const wk = metaFoe?.weaknesses?.[0];
        if (wk) {
          const wkType = (wk.type || '').toLowerCase();
          if (wkType !== 'colorless') {
            const atkType = (meta.types?.[0] || '').toLowerCase();
            if (atkType === wkType) {
              damage += 20;
              hasWeakness = true;
            }
          }
        }
      }
    }
  } catch (err) {
    console.error('[preview] Weakness check failed:', err);
  }
  
  
  try {
    const attackerType = (meta.types?.[0] || '').toLowerCase();
    if (attackerType) {
      const fightingCoachBoost = getFightingCoachBoost(pk, attackerType);
      if (fightingCoachBoost > 0) {
        damage += fightingCoachBoost;
        hasOtherBoosts = true;
      }
    }
  } catch (err) {
    console.error('[preview] Fighting Coach check failed:', err);
  }
  
  
  try {
    const exBonus = globalThis.state?.temp?.[pk]?.damageVsEx || 0;
    if (exBonus > 0) {
      const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
      if (foeImg && typeof fetchCardMeta === 'function') {
        const foeMeta = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const isEx = foeMeta.suffix?.toUpperCase() === 'EX';
        if (isEx) {
          damage += exBonus;
          hasOtherBoosts = true;
        }
      }
    }
  } catch (err) {
    console.error('[preview] Red ex bonus check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg) {
      const attackerType = (meta.types?.[0] || '').toLowerCase();
      const thickFatReduction = getThickFatReduction(foeImg, attackerType);
      if (thickFatReduction > 0) damage = Math.max(0, damage - thickFatReduction);
    }
  } catch (err) {
    console.error('[preview] Thick Fat check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      const foePk2 = foe === 'player1' ? 'p1' : 'p2';
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      if (abilityRow?.effect_type === 'reduce_damage_if_arceus' && hasArceusInPlay(foePk2)) {
        const reduction = parseInt(abilityRow.param1 || '30', 10);
        damage = Math.max(0, damage - reduction);
      }
    }
  } catch (err) {
    console.error('[preview] reduce_damage_if_arceus check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      if (abilityRow?.effect_type === 'reduce_opponent_damage') {
        const reduction = parseInt(abilityRow.param1 || '20', 10);
        damage = Math.max(0, damage - reduction);
      }
    }
  } catch (err) {
    console.error('[preview] reduce_opponent_damage check failed:', err);
  }
  
  return { damage, hasWeakness, hasOtherBoosts };
}

async function handleAttackClick(attack, meta, ownerKey, activeDiv) {
  
  
  if (!activeDiv) {
    console.error('[attack] No active Pokemon found');
    return;
  }
  
  const pk = ownerKey === 'p1' || ownerKey === 'p2' ? ownerKey : (ownerKey === 'player1' ? 'p1' : 'p2');
  const slot = activeDiv.querySelector('.card-slot');
  if (!slot) {
    console.error('[attack] No card slot found');
    return;
  }
  
  let effectContext = null;
  
  const cost = attack.cost || [];
  
  
  if (typeof isActiveBlockedFromAttacking === 'function' && isActiveBlockedFromAttacking(pk)) {
    const imgBlocked = typeof getActiveImg === 'function' ? getActiveImg(pk) : null;
    const st = (imgBlocked?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      showPopup('This Pokmon is asleep and can\'t attack.');
    } else if (st === 'paralyzed') {
      showPopup('This Pokmon is paralyzed and can\'t attack.');
    }
    return;
  }
  
  
  const attackerImg = typeof getActiveImg === 'function' ? getActiveImg(pk) : null;
  if (globalThis.__specialEffects?.[pk]?.attackLockSelf) {
    showPopup('This Pokmon can\'t attack this turn!');
    delete globalThis.__specialEffects[pk].attackLockSelf;
    return;
  }
  
  
  const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
  if (attackLock) {
    let isLocked = false;
    const currentTurn = globalThis.turnNumber || 0;

    
    
    if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
      
      isLocked = currentTurn === attackLock.lockedOnTurn + 2;
    } else if (typeof attackLock === 'object' && attackLock.locked !== undefined) {
      
      if (attackLock.lockedOnTurn !== undefined) {
        isLocked = currentTurn === attackLock.lockedOnTurn + 2;
      } else {
        isLocked = attackLock.locked === true;
      }
    } else if (attackLock === true) {
      
      isLocked = true;
    }
    
    if (isLocked) {
      showPopup('This Pokmon can\'t attack this turn!');
      return;
    }
  }
  
  
  if (attackerImg) {
    const instanceId = attackerImg.dataset.instanceId;
    const moveName = attack.name?.toLowerCase();
    const moveLock = globalThis.__moveLocks?.[pk]?.[instanceId]?.[moveName];
    if (instanceId && moveName && moveLock) {
      
      const currentTurn = globalThis.turnNumber || 0;
      let isLocked = false;
      
      if (typeof moveLock === 'object' && moveLock.lockedOnTurn !== undefined) {
        
        isLocked = currentTurn === moveLock.lockedOnTurn + 2;
      } else {
        
        isLocked = moveLock === true;
      }
      
      if (isLocked) {
        showPopup(`This Pokmon can't use ${attack.name} this turn!`);
        return;
      }
    }
  }
  
  
  if (globalThis.__specialEffects?.[pk]?.attackLockFlip) {
    showPopup('Must flip to attack...');
    
    const flip = Math.random() < 0.5;
    
    if (flip) {
      
      showPopup('Heads! Attack proceeds.');
      delete globalThis.__specialEffects[pk].attackLockFlip;
    } else {
      
      showPopup('Tails! Attack failed!');
      delete globalThis.__specialEffects[pk].attackLockFlip;
      closeAttackMenu();
      return;
    }
  }
  
  
  if (attackerImg && attackerImg.dataset.status?.toLowerCase() === 'confusion') {
    
    const flip = Math.random() < 0.5;
    
    if (flip) {
      
      showPopup('Confusion: Heads! Attack succeeds.');
      delete attackerImg.dataset.status;
    } else {
      
      showPopup('Confusion: Tails! This Pokmon hurt itself in confusion!');
      
      const player = pk === 'p1' ? 'player1' : 'player2';
      if (typeof damageActiveOf === 'function') {
        setTimeout(async () => {
          await damageActiveOf(player, 20, { isDirectAttack: false });
        }, 500);
      }
      
      
      delete attackerImg.dataset.status;
      
      
      closeAttackMenu();
      return;
    }
  }
  
  
  const foePk = pk === 'p1' ? 'p2' : 'p1';
  const foe = foePk === 'p1' ? 'player1' : 'player2';  
  
  
  let damage = 0;
  let isMultiplicative = false;
  let multiplier = 1;
  let totalBonuses = 0;
  if (attack.damage) {
    const dmgStr = String(attack.damage).toLowerCase();
    
    if (dmgStr.includes('x') || dmgStr.includes('')) {
      isMultiplicative = true;
      
      const multMatch = dmgStr.match(/(\d+)\s*[x]/);
      if (multMatch) {
        multiplier = parseInt(multMatch[1], 10);
      } else {
        multiplier = 1; 
      }
      damage = 0; 
    } else {
      
    const match = dmgStr.match(/\d+/);
      if (match) damage = parseInt(match[0], 10);
    }
  }
  
  
  try {
    if (typeof globalThis.getMoveRow === 'function' && typeof globalThis.loadMoveEffects === 'function') {
      await globalThis.loadMoveEffects();
      const moveRow = globalThis.getMoveRow(attackerImg.alt, attack.name);
      if (moveRow?.effect_type === 'bonus_damage_per_energy_on_opponent_all') {
        damage = 0; 
      } else if (moveRow?.effect_type === 'bonus_damage_for_each_bench') {
        damage = 0; 
      }
    }
  } catch (err) {
    console.error('[attack] Error checking move row for base damage:', err);
  }
  
  
  const effectState = {
    p1: typeof playerState !== 'undefined' ? playerState.player1 : {},
    p2: typeof playerState !== 'undefined' ? playerState.player2 : {},
    activeFor: typeof activeFor === 'function' ? activeFor : () => null,
    benchFor: typeof benchFor === 'function' ? benchFor : () => null,
    opponentOf: typeof opponentOf === 'function' ? opponentOf : (p) => p === 'player1' ? 'player2' : 'player1',
    fetchCardMeta: typeof fetchCardMeta === 'function' ? fetchCardMeta : async () => ({}),
    damageActiveOf: typeof damageActiveOf === 'function' ? damageActiveOf : () => ({ knocked: false }),
    beginPromotionFlow: typeof beginPromotionFlow === 'function' ? beginPromotionFlow : () => {},
    showPopup: showPopup,
    logEvent: typeof logEvent === 'function' ? logEvent : () => {}
  };
  
  try {
    if (typeof applyMoveEffectFromCsv === 'function') {
      const result = await applyMoveEffectFromCsv(effectState, pk, attack.name, damage, { 
        moveName: attack.name,
        isFinal: true, 
        isMultiplicative: isMultiplicative,
        multiplier: multiplier,
        attackCost: attack.cost || [] 
      });
      
      
      if (typeof result === 'object' && result.damage !== undefined) {
        damage = result.damage;
        effectContext = result.context;
        
        if (isMultiplicative && result.totalBonuses !== undefined) {
          totalBonuses = result.totalBonuses;
        }
      } else {
        damage = result;
        
        if (isMultiplicative) {
          totalBonuses = damage;
          damage = 0;
        }
      }
      
      
      const boost = (globalThis.state?.temp?.[pk]?.globalDamageBoost ?? 0);
      if (boost) {
        if (isMultiplicative) {
          totalBonuses += boost;
        } else {
        damage += boost;
        }
      }
      
      
      const nextTurnBonus = (globalThis.state?.temp?.[pkToPlayer(pk)]?.nextTurnDamageBonus ?? 0);
      if (nextTurnBonus > 0) {
        if (isMultiplicative) {
          totalBonuses += nextTurnBonus;
        } else {
        damage += nextTurnBonus;
        }
        
        if (globalThis.state?.temp?.[pkToPlayer(pk)]) {
          globalThis.state.temp[pkToPlayer(pk)].nextTurnDamageBonus = 0;
        }
      }
      
      
      if (attackerImg) {
        const bonusKey = `${attackerImg.dataset.instanceId || attackerImg.alt}_${attack.name}`;
        const nextTurnBonus = globalThis.__attackBonuses?.[bonusKey] || 0;
        
        if (nextTurnBonus > 0) {
          if (isMultiplicative) {
            totalBonuses += nextTurnBonus;
          } else {
          damage += nextTurnBonus;
          }
          showPopup(`+${nextTurnBonus} bonus damage!`);
          
          
          delete globalThis.__attackBonuses[bonusKey];
        }
      }
      
      
      if (attackerImg) {
        const attackerSlot = attackerImg.closest('.card-slot');
        const tool = getToolDataFromSlot(attackerSlot);
        
        if (tool && tool.num === '066' && tool.set === 'A3a') {
          
          const ULTRA_BEASTS = [
            'nihilego', 'buzzwole', 'pheromosa', 'xurkitree', 'celesteela',
            'kartana', 'guzzlord', 'poipole', 'naganadel', 'stakataka', 'blacephalon'
          ];
          
          const attackerName = (attackerImg.alt || '').toLowerCase();
          const isUltraBeast = ULTRA_BEASTS.some(ub => attackerName.includes(ub));
          
          if (isUltraBeast) {
            
            const attackerPlayer = attackerImg.closest('#player1') ? 'player1' : 'player2';
            const points = attackerPlayer === 'player1' ? p1Points : p2Points;
            
            const beastiteBonus = points * 10;
            if (beastiteBonus > 0) {
              if (isMultiplicative) {
                totalBonuses += beastiteBonus;
              } else {
              damage += beastiteBonus;
              }
              showPopup(`Beastite: +${beastiteBonus} damage! (${points} points  10)`);
            }
          }
        }
      }
      
      
      if (attackerImg && globalThis.state?.damageBoost?.[pk]) {
        const boostData = globalThis.state.damageBoost[pk];
        if (boostData.target === 'eeveelution' && boostData.duration === 'this_turn') {
          const attackerName = (attackerImg.alt || '').toLowerCase();
          const isEeveelution = boostData.targetNames?.some(ee => attackerName.includes(ee));
          
          if (isEeveelution) {
            if (isMultiplicative) {
              totalBonuses += boostData.amount;
            } else {
              damage += boostData.amount;
            }
            showPopup(`Eevee Bag: +${boostData.amount} damage!`);
          }
        }
      }
      
      
      if (isMultiplicative) {
        damage = totalBonuses * multiplier;
      }
    }
  } catch (err) {
    console.error('[attack] Move effect error:', err);
  }
  
  
  try {
    if (damage > 0 && typeof getActiveImage === 'function') {
      const foeImg = getActiveImage(foe);
      if (foeImg && typeof fetchCardMeta === 'function') {
        const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const wk = metaFoe?.weaknesses?.[0];
        
        if (wk) {
          const wkType = (wk.type || '').toLowerCase();
          if (wkType !== 'colorless') {
            const atkType = (meta.types?.[0] || '').toLowerCase();
            if (atkType === wkType) {
              damage += 20;
            }
          }
        }
      }
    }
  } catch (err) {
    console.error('[attack] Weakness check failed:', err);
  }
  
  
  try {
    const attackerType = (meta.types?.[0] || '').toLowerCase();
    if (attackerType) {
      const fightingCoachBoost = getFightingCoachBoost(pk, attackerType);
      if (fightingCoachBoost > 0) {
        damage += fightingCoachBoost;
      }
    }
  } catch (err) {
    console.error('[attack] Fighting Coach check failed:', err);
  }
  
  
  try {
    const exBonus = globalThis.state?.temp?.[pk]?.damageVsEx || 0;
    if (exBonus > 0) {
      
      const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
      if (foeImg && typeof fetchCardMeta === 'function') {
        const foeMeta = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
        const isEx = foeMeta.suffix?.toUpperCase() === 'EX';
        
        if (isEx) {
          damage += exBonus;
        }
      }
    }
  } catch (err) {
    console.error('[attack] Red ex bonus check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg) {
      const attackerType = (meta.types?.[0] || '').toLowerCase();
      const thickFatReduction = getThickFatReduction(foeImg, attackerType);
      if (thickFatReduction > 0) {
        damage = Math.max(0, damage - thickFatReduction);
        showPopup(`Thick Fat: Reduced ${thickFatReduction} damage!`);
      }
    }
  } catch (err) {
    console.error('[attack] Thick Fat check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      damage = applyGuardedGrill(foeImg, damage);
    }
  } catch (err) {
    console.error('[attack] Guarded Grill check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      const foePk = foe === 'player1' ? 'p1' : 'p2';
      
      
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_damage_if_arceus' && hasArceusInPlay(foePk)) {
        const reduction = parseInt(abilityRow.param1 || '30', 10);
        damage = Math.max(0, damage - reduction);
        showPopup(`${abilityRow.abilityName}: Reduced ${reduction} damage!`);
      }
    }
  } catch (err) {
    console.error('[attack] reduce_damage_if_arceus check failed:', err);
  }
  
  
  try {
    const foeImg = typeof getActiveImage === 'function' ? getActiveImage(foe) : null;
    if (foeImg && damage > 0) {
      
      const cacheKey = `${foeImg.dataset.set}-${foeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'reduce_opponent_damage') {
        const reduction = parseInt(abilityRow.param1 || '20', 10);
        damage = Math.max(0, damage - reduction);
        showPopup(`${abilityRow.abilityName}: Reduced ${reduction} damage!`);
      }
    }
  } catch (err) {
    console.error('[attack] reduce_opponent_damage check failed:', err);
  }
  
  
  let knocked = false;
  if (typeof damageActiveOf === 'function') {
    const result = await damageActiveOf(foe, damage, { attackerImg: attackerImg });
    knocked = result.knocked;
    showPopup(`${meta.name} used ${attack.name}${damage > 0 ? ` for ${damage} damage!` : '!'}`);
    if (typeof logEvent === 'function') {
      const owner = pk === 'p1' ? 'player1' : 'player2';
      logEvent({
        player: owner,
        text: `${meta.name} used ${attack.name}${damage > 0 ? ` for ${damage} damage` : ''}`,
        cardSet: attackerImg?.dataset?.set,
        cardNum: attackerImg?.dataset?.num
      });
    }
  } else {
    showPopup(`${meta.name} used ${attack.name}!`);
    if (typeof logEvent === 'function') {
      const owner = pk === 'p1' ? 'player1' : 'player2';
      logEvent({
        player: owner,
        text: `${meta.name} used ${attack.name}`,
        cardSet: attackerImg?.dataset?.set,
        cardNum: attackerImg?.dataset?.num
      });
    }
  }
  
  
  closeAttackMenu();
  
  
  if (knocked && typeof handleKnockOut === 'function' && typeof getActiveImage === 'function') {
    const foeImg = getActiveImage(foe);
    if (foeImg) {
      const ended = await handleKnockOut(foe, foeImg);
      if (ended) return;
      
      
      if (typeof beginPromotionFlow === 'function') {
        await beginPromotionFlow(foe);
      }
    }
  }
  
  
  if (knocked && effectContext?.checkKoForRecoil) {
    const recoilDamage = effectContext.checkKoForRecoil;
    const attacker = pk === 'p1' ? 'player1' : 'player2'; 
    setTimeout(async () => {
      if (typeof damageActiveOf === 'function') {
        await damageActiveOf(attacker, recoilDamage, { isDirectAttack: false });
        showPopup(`Rampardos took ${recoilDamage} recoil damage!`);
      }
    }, 800);
  }
  
  
  
  if (typeof startTurn === 'function') {
    setTimeout(() => startTurn(foe), 300);
  }

}

function handleRetreat(activeDiv, meta, retreatCost) {


  if (hasRetreatedThisTurn) {
    showPopup('You can only retreat once per turn!');
    return;
  }
  
  
  if (!activeDiv) {
    console.error('[RETREAT] ERROR - activeDiv is null!');
    showPopup('Cannot retreat - invalid active area');
    return;
  }
  
  const slot = activeDiv.querySelector('.card-slot');
  if (!slot) {
    console.error('[retreat] No card slot found');
    return;
  }
  
  
  if (retreatCost > 0) {
    const energyPipsContainer = slot.querySelector('.energy-pips');
    if (!energyPipsContainer) {
      console.error('[retreat] No energy pips found');
      return;
    }
    
    const pips = energyPipsContainer.querySelectorAll('.energy-pip');
    if (pips.length < retreatCost) {
      showPopup(`Not enough energy to retreat! Need ${retreatCost}, have ${pips.length}`);
      return;
    }
  } else {
  }
  
  
  let ownerKey = null;
  if (activeDiv.closest('#player1')) ownerKey = 'player1';
  else if (activeDiv.closest('#player2')) ownerKey = 'player2';
  
  if (!ownerKey) {
    console.error('[retreat] Could not determine owner');
    return;
  }
  
  
  let hasBench = false;
  if (typeof benchFor === 'function') {
    const benchDiv = benchFor(ownerKey);
    if (benchDiv) {
      const benchSlots = benchDiv.querySelectorAll('.card-slot');
      const occupied = Array.from(benchSlots).filter(s => {
        const img = s.querySelector('img');
        return img && img.dataset.set && img.dataset.num;
      });
      hasBench = occupied.length > 0;
    }
  } else {
    
    const pk = ownerKey === 'player1' ? 'p1' : 'p2';
    const bench = document.querySelector(`#${pk}-bench`);
    if (bench) {
      const benchSlots = bench.querySelectorAll('.card-slot');
      const occupied = Array.from(benchSlots).filter(s => {
        const img = s.querySelector('img');
        return img && img.dataset.set && img.dataset.num;
      });
      hasBench = occupied.length > 0;
    }
  }
  
  if (!hasBench) {
    showPopup('No bench Pokemon to retreat to!');
    return;
  }
  
  
  const storedRetreatCost = retreatCost;
  

  closeAttackMenu();
    isRetreatSelection,

  isRetreatSelection = true;
  
  
  showPopup(`${meta.name} retreated! Choose new active Pokemon (or click anywhere to cancel).`);
  
  
  const benchDiv = typeof benchFor === 'function' ? benchFor(ownerKey) : 
    document.querySelector(`#${ownerKey === 'player1' ? 'p1' : 'p2'}-bench`);
  
  if (!benchDiv) {
    console.error('[retreat] Could not find bench div');
    return;
  }
  
  
  const benchImgs = benchDiv.querySelectorAll('img');
  benchImgs.forEach(img => {
    if (img.dataset.set && img.dataset.num) {
      img.classList.add('promote-glow');
    }
  });
  
  
  const selectReplacement = (e) => {
    console.log('[RETREAT-CLICK] Click detected:', {
      isRetreatSelection: isRetreatSelection,
      target: e.target,
      isModal: !!(e.target.closest('#zoomBackdrop') || e.target.closest('.attack-menu') || e.target.closest('#handBackdrop') || e.target.closest('#toolBackdrop')),
      timestamp: new Date().toISOString()
    });
    
    if (e.target.closest('#zoomBackdrop') || e.target.closest('.attack-menu') || e.target.closest('#handBackdrop') || e.target.closest('#toolBackdrop')) {
      console.log('[RETREAT-CLICK] Click on modal, ignoring');
      return;
    }
    
    if (!isRetreatSelection) {
      console.log('[RETREAT-CLICK] Not in retreat selection, removing listener');
      document.body.removeEventListener('click', selectReplacement, true);
      return;
    }

    
    
    const chosenImg = e.target.closest(`#${ownerKey} .bench img`);
    
    if (chosenImg && chosenImg.dataset.set && chosenImg.dataset.num) {
      
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      document.body.removeEventListener('click', selectReplacement, true);
      
      
      isRetreatSelection = false;
      
      
      benchImgs.forEach(img => img.classList.remove('promote-glow'));
      
      
      if (typeof activeFor === 'function') {
        const activeDiv = activeFor(ownerKey);
        const activeSlot = activeDiv.querySelector('.card-slot');
        const benchSlot = chosenImg.closest('.card-slot');
        const activeImg = activeSlot.querySelector('img');
        
        
        const activePack = typeof detachAttachments === 'function' ? 
          detachAttachments(activeSlot) : { energy: [], tool: null };
        const benchPack = typeof detachAttachments === 'function' ? 
          detachAttachments(benchSlot) : { energy: [], tool: null };
        
        
        if (activeImg) {
          
          if (typeof clearStatusOnImg === 'function') {
            clearStatusOnImg(activeImg);
          }
          
          
          const activeInstanceId = activeImg.dataset.instanceId;
          const ownerPk = ownerKey === 'player1' ? 'p1' : 'p2';
          if (activeInstanceId && globalThis.__moveLocks?.[ownerPk]?.[activeInstanceId]) {
            delete globalThis.__moveLocks[ownerPk][activeInstanceId];
          }
          
          
          const activeRect = activeImg.getBoundingClientRect();
          const chosenRect = chosenImg.getBoundingClientRect();
          
          activeSlot.removeChild(activeImg);
          benchSlot.removeChild(chosenImg);
          activeSlot.appendChild(chosenImg);
          benchSlot.appendChild(activeImg);
          
          
          animateSlideSwap(activeImg, benchSlot, activeImg, activeRect);
          animateSlideSwap(chosenImg, activeSlot, chosenImg, chosenRect);
        } else {
          
          const chosenRect = chosenImg.getBoundingClientRect();
          
          benchSlot.removeChild(chosenImg);
          activeSlot.appendChild(chosenImg);
          
          
          animateSlideSwap(chosenImg, activeSlot, chosenImg, chosenRect);
        }
        
        
        if (typeof attachAttachments === 'function') {
          attachAttachments(activeSlot, benchPack);
          if (activeImg) {
            attachAttachments(benchSlot, activePack);
          }
        }
        
        
        if (typeof markSlot === 'function') {
          markSlot(activeSlot, true);
          markSlot(benchSlot, !!benchSlot.querySelector('img'));
        }
        
        
        if (typeof updatePlayerTypeBackground === 'function') {
          const playerNum = activeDiv.id.includes('p1') ? 1 : 2;
          updatePlayerTypeBackground(playerNum);
        }
        
        
        if (storedRetreatCost > 0) {
          
          const retreatedSlot = benchSlot; 
          const energyPipsContainer = retreatedSlot.querySelector('.energy-pips');
          
          if (energyPipsContainer) {
            const pips = energyPipsContainer.querySelectorAll('.energy-pip:not(.phantom-pip)');
            
            
            for (let i = 0; i < storedRetreatCost && i < pips.length; i++) {
              const energyType = pips[i].dataset.type || 'colorless';
              playerState[ownerKey].discard.energyCounts[energyType] = 
                (playerState[ownerKey].discard.energyCounts[energyType] || 0) + 1;
              pips[i].remove();
            }
            
            
            const phantomPips = energyPipsContainer.querySelectorAll('.energy-pip.phantom-pip');
            for (let i = 0; i < storedRetreatCost && i < phantomPips.length; i++) {
              phantomPips[i].remove();
            }
          }
        } else {
        }
        
        showPopup('Promoted to Active.');

        
        
        if (typeof closeAttackMenu === 'function') {
          closeAttackMenu();
        }
        
        
        document.querySelectorAll('.card-slot.menu-open').forEach(slot => {
          slot.classList.remove('menu-open');
        });
        
        
        document.querySelectorAll('.attack-menu').forEach(menu => {
          menu.remove();
        });
        
        
        const background = document.querySelector('.board') || document.body;
        const clickEvent = new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
          view: window,
          clientX: 10,
          clientY: 10
        });
        background.dispatchEvent(clickEvent);

        
        
        lastRetreatTime = Date.now();  
        
        
        hasRetreatedThisTurn = true;
      }
    } else {
      
      document.body.removeEventListener('click', selectReplacement, true);
      
      
      isRetreatSelection = false;
      
      benchImgs.forEach(img => img.classList.remove('promote-glow'));
      showPopup('Retreat canceled (no replacement selected).');
    }
  };
  
  
  setTimeout(() => {
    document.body.addEventListener('click', selectReplacement, true);
  }, 100);
  
}



function computeRetreatCost(activeDiv, meta) {
  const base = Number(meta.retreat || meta.retreatCost || 0) || 0;
  
  if (!activeDiv) return base;
  
  
  const activeImg = activeDiv.querySelector('img');
  if (activeImg && typeof hasLevitateZeroRetreat === 'function' && hasLevitateZeroRetreat(activeImg)) {
    return 0;
  }
  
  
  if (activeImg && activeImg.dataset.set && activeImg.dataset.num) {
    try {
      
      const cacheKey = `${activeImg.dataset.set}-${activeImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      
      if (abilityRow?.effect_type === 'zero_retreat_if_arceus') {
        
        const pk = activeDiv.closest('#player1') ? 'p1' : 'p2';

        
        
        if (typeof hasArceusInPlay === 'function' && hasArceusInPlay(pk)) {
          return 0;
        } else {
        }
      }
    } catch (e) {
      console.error('[retreat-debug] Error checking Arceus retreat:', e);
      
    }
  }
  
  
  if (activeImg && meta.stage?.toLowerCase() === 'basic') {
    
    const pk = activeDiv.closest('#player1') ? 'p1' : 'p2';
    const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
    const benchImgs = benchDiv ? [...benchDiv.querySelectorAll('img')] : [];

    
    
    for (const benchImg of benchImgs) {
      const name = (benchImg.alt || '').toLowerCase();
      
      if (name.includes('shaymin')) {
        
        try {
          const cacheKey = `${benchImg.dataset.set}-${benchImg.dataset.num}`;
          const abilityRow = globalThis.abilityCache?.[cacheKey];
          
          
          if (abilityRow?.effect_type === 'reduce_active_basic_retreat_cost') {
            const reduction = parseInt(abilityRow.param1 || '1', 10);
            return Math.max(0, base - reduction);
          }
        } catch (e) {
          console.error(`[shaymin-debug] Error checking Shaymin:`, e);
          
        }
      }
    }
  }

  const abs = activeDiv.dataset.tempRetreat;
  const red = Number(activeDiv.dataset.tempRetreatReduce || '0') || 0;

  if (abs != null) return Math.max(0, Number(abs));
  return Math.max(0, base - red);
}

globalThis.setTempRetreatFor = function(pk, amount, mode = 'reduce') {
  const activeDiv = pk === 'p1' ? p1Active : p2Active;
  if (!activeDiv) {
    return;
  }
  
  if (mode === 'reduce') {
    activeDiv.dataset.tempRetreatReduce = String(amount || 0);
  } else if (mode === 'set') {
    activeDiv.dataset.tempRetreat = String(amount || 0);
  }
};

globalThis.clearTempRetreatFor = function(pk) {
  const activeDiv = pk === 'p1' ? p1Active : p2Active;
  if (!activeDiv) return;
  
  delete activeDiv.dataset.tempRetreat;
  delete activeDiv.dataset.tempRetreatReduce;
};

function addRetreatRow(menu, activeDiv, meta){
  const slot = activeDiv.querySelector('.card-slot');
  const costCount = computeRetreatCost(activeDiv, meta);
  const row = document.createElement('div');
  row.style.marginTop = '6px';
  row.innerHTML = '<div class="thin"></div>';

  const btn = document.createElement('div');
  btn.className = 'attack-item';

  const left = document.createElement('div');
  left.style.display = 'flex';
  left.style.alignItems = 'center';
  left.style.gap = '6px';
  const nm = document.createElement('div');
  nm.className = 'attack-name';
  nm.textContent = 'Retreat';
  left.appendChild(nm);

  const icons = document.createElement('div');
  icons.className = 'attack-cost';
  if (costCount > 0) {
    const flags = satisfiedFlags(countPipsOn(slot), Array(costCount).fill('colorless'));
    for (let i = 0; i < costCount; i++) {
      const ic = document.createElement('div');
      ic.className = 'cost-icon';
      ic.style.backgroundImage = `url('${ENERGY_ICONS.colorless}')`;
      if (!flags[i]) ic.classList.add('missing');
      icons.appendChild(ic);
    }
  }
  left.appendChild(icons);

  const arrow = document.createElement('div');
  arrow.style.fontWeight = '900';
  arrow.textContent = '';
  btn.appendChild(left);
  btn.appendChild(arrow);

    const canPay = costCount === 0 || canPayCostFromAPI(slot, Array(costCount).fill('colorless'));
  const hasBench = [...benchFor(currentPlayer).querySelectorAll('img')].length > 0;

  const activeImg = activeDiv.querySelector('img');
  const st = (activeImg?.dataset.status || '').toLowerCase();
  const blockedByStatus = st === 'asleep' || st === 'paralyzed';

  const pk = currentPlayer === 'player1' ? 'p1' : 'p2';

if (!canRetreat(pk)) {
  btn.classList.add('muted');
  btn.onclick = () => {
    const activeImg = activeDiv.querySelector('img');
    const st = (activeImg?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      showPopup("Can't retreat - this Pokmon is asleep!");
    } else if (st === 'paralyzed') {
      showPopup("Can't retreat - this Pokmon is paralyzed!");
    } else {
      showPopup("Can't retreat - this Pokmon is locked!");
    }
  };
  return;
}

const canRetreatNormally = hasBench && canPay && !hasRetreatedThisTurn && !blockedByStatus;

if (canRetreatNormally) {
  btn.classList.add('payable');
  
  
  const mainType = (meta.types && meta.types[0]) ? String(meta.types[0]).toLowerCase() : null;
  if (mainType) {
    btn.setAttribute('data-type', mainType);
  }
} else {
  btn.classList.add('muted');
}
btn.onclick = () => {
  
  if (!canRetreatNormally) {
    if (hasRetreatedThisTurn) {
      showPopup('You can only retreat once per turn.');
    } else if (blockedByStatus) {
      showPopup('Cannot retreat while Asleep or Paralyzed.');
    } else {
      showPopup('Cannot retreat.');
    }
    return;
  }
  
  
  
  let toDiscard = costCount;
  const energyBox = slot.querySelector('.energy-pips');
  if (energyBox && toDiscard > 0) {
    const pips = [...energyBox.querySelectorAll('.energy-pip')];
    for (const pip of pips) {
      if (toDiscard <= 0) break;
      pip.remove();
      toDiscard--;
      const type = (pip.dataset.type || 'colorless').toLowerCase();
      playerState[currentPlayer].discard.energyCounts[type] =
        (playerState[currentPlayer].discard.energyCounts[type] || 0) + 1;
    }
  }
  
  if (activeDiv.dataset.tempRetreatReduce != null) {
    delete activeDiv.dataset.tempRetreatReduce;
  }
  
  hasRetreatedThisTurn = true;
  
  const activeSlot = activeDiv.querySelector('.card-slot');
  const benchDiv = benchFor(currentPlayer);
  const emptyBenchSlot = benchDiv.querySelector('.card-slot[data-empty="1"]');
  
  if (emptyBenchSlot && activeSlot) {
    
    const attachments = detachAttachments(activeSlot);
    
    
    const activeImg = activeSlot.querySelector('img');
    if (activeImg) {
      emptyBenchSlot.innerHTML = '';
      emptyBenchSlot.appendChild(activeImg.cloneNode(true));
      emptyBenchSlot.dataset.empty = '0';
      
      
      attachAttachments(emptyBenchSlot, attachments);
    }
    
    
    activeSlot.innerHTML = '';
    markSlot(activeSlot, false);
    markSlot(emptyBenchSlot, true);
  }
  
  logEvent({
    player: currentPlayer,
    text: 'Retreated their Active Pokmon.'
  });
  
  closeAttackMenu();
  
  beginPromotionFlow(currentPlayer);
};
  row.appendChild(btn);
  menu.appendChild(row);
}

function onPokemonClick(player, slot) {
    const card = (slot === "active")
        ? activePokemon[player]
        : benchPokemon[player][slot];
    
    if (card && ABILITY_EFFECTS[card.id]) {
        openAbilityUI(player, card);
        return; 
    }
    
    showAttackMenuFor(player, slot);
}

async function buildZoomPanel(meta,img){
  currentZoom={img,meta};

  zoomTitle.textContent=meta.name||'Pokmon';

  const mainType=(meta.types&&meta.types[0])?String(meta.types[0]).toLowerCase():null;
  zoomType.style.display=mainType?"block":"none";
  if(mainType)zoomType.style.backgroundImage=`url('${energyIconUrl(mainType)}')`;
  
  const slot = img.closest('.card-slot');
  const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  
  const base = modifiedMaxHp || parseInt(img.dataset.hp||meta.hp||'0',10)||0;
  const chp=parseInt(img.dataset.chp||base||'0',10)||base;

  zoomHp.textContent=`HP: ${chp} / ${base}`;
  
  
  if (modifiedMaxHp) {
    zoomHp.style.color = '#22c55e';
    zoomHp.style.fontWeight = '700';
  } else {
    zoomHp.style.color = '';
    zoomHp.style.fontWeight = '';
  }
  
  const pct=base>0?Math.round((chp/base)*100):0;

  zoomHpBar.style.width=pct+'%';
  zoomHpBar.style.background=
    (chp===base)
      ?'linear-gradient(90deg,#22c55e,#16a34a)'
      :'linear-gradient(90deg,#f43f5e,#ef4444)';

        
  if (zoomStatusIcon) {
    const sKey = (img.dataset.status || '').toLowerCase();
    const url = STATUS_ICON_URLS[sKey];
    if (url) {
      zoomStatusIcon.style.display = 'inline-block';
      zoomStatusIcon.style.backgroundImage = `url('${url}')`;
    } else {
      zoomStatusIcon.style.display = 'none';
      zoomStatusIcon.style.backgroundImage = '';
    }
  }

  
  const pips=countPipsOn(slot);

  zoomEnergyCount.textContent=`x${pips.total||0}`;
  zoomEnergyIcons.innerHTML='';

  Object.keys(pips).filter(k=>k!=='total').forEach(k=>{
    for(let i=0;i<pips[k];i++){
      const ico=document.createElement('span');
      ico.className='mini-icon';
      ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;
      zoomEnergyIcons.appendChild(ico);
    }
  });

  
  zoomTools.innerHTML='';
  const tool=getToolDataFromSlot(slot);

  if(tool){
    
    if (zoomToolImg) {
      zoomToolImg.src = tool.src;
      zoomToolImg.style.display = 'block';
    }
    
    
    const tImg=document.createElement('img');
    tImg.src=tool.src;
    tImg.alt='Tool';
    tImg.style.borderRadius='4px';
    tImg.style.boxShadow='0 2px 6px rgba(0,0,0,.6)';
    tImg.style.cursor='pointer';
    tImg.onclick=async ev=>{
      ev.stopPropagation();
      await openToolModal(tool.set,tool.num,tool.src);
    };
    zoomTools.appendChild(tImg);
  }else{
    
    if (zoomToolImg) {
      zoomToolImg.style.display = 'none';
    }
    
    const none=document.createElement('div');
    none.className='chip';
    none.textContent='none';
    zoomTools.appendChild(none);
  }

  
  
  zoomAbilities.style.display = 'none';
  zoomAbilities.innerHTML = '';
  
  if (typeof ensureAbilityEffectsLoaded === 'function') {
    await ensureAbilityEffectsLoaded();
  }
  
  const metaAbilities = extractAbilities(meta);
  const abilityRows = (window.ABILITY_EFFECT_ROWS || []);

  
  
  const setId = img.dataset.set;
  const numId = img.dataset.num;
  const csvAbilities = abilityRows.filter(r =>
    r.set === setId &&
    String(r.number).padStart(3, '0') === String(numId).padStart(3, '0')
  );

  
  
  const allAbilities = [...metaAbilities];
  csvAbilities.forEach(csvAb => {
    const alreadyHas = metaAbilities.some(metaAb => 
      (metaAb.name || '').toLowerCase() === (csvAb.abilityName || '').toLowerCase()
    );
    if (!alreadyHas) {
      
      allAbilities.push({
        name: csvAb.abilityName,
        effect: csvAb.text || '',
        type: csvAb.abilityType
      });
    }
  });

  if (allAbilities.length) {
    const bandClr = (TYPE_HEX[mainType || 'colorless'] || '#94a3b8');

  let ownerKey = null;
  if (img.closest("#player1") && !img.closest(".hand")) ownerKey = "player1";
  else if (img.closest("#player2") && !img.closest(".hand")) ownerKey = "player2";

    allAbilities.forEach(ab => {
      const box = document.createElement('div');
      box.className = 'ability-box';

      const head = document.createElement('div');
      head.className = 'ability-head';
      head.style.background = bandClr;
      head.style.color = '#0b0f14';

      const badge = document.createElement('img');
      badge.src = ABILITY_BADGE;
      badge.alt = '';

      const nm = document.createElement('div');
      nm.className = 'ability-name';
      nm.textContent = ab.name || 'Ability';

      head.appendChild(badge);
      head.appendChild(nm);

      const tx = document.createElement('div');
      tx.className = 'ability-text';
      tx.textContent = ab.effect || '';

      box.appendChild(head);
      box.appendChild(tx);
      zoomAbilities.appendChild(box);
      
      if (!ownerKey || !currentPlayer) {
        box.classList.add('ability-disabled');
        return;
      }
      const isCurrentPlayersCard = (ownerKey === currentPlayer);
      const setId  = img.dataset.set;
      const numId  = img.dataset.num;
      
      
      const actualPokemonImg = img;
      const cardKey = getAbilityCardKey(setId, numId, actualPokemonImg);
      
      const row = abilityRows.find(r =>
        r.set === setId &&
        String(r.number).padStart(3, '0') === String(numId).padStart(3, '0') &&
        (r.abilityName || '').toLowerCase() === (ab.name || '').toLowerCase()
      );
      
      
      const ownerPk = (ownerKey === 'p1' || ownerKey === 'p2') ? ownerKey : (ownerKey === 'player1' ? 'p1' : 'p2');
      
      
      const isUnlimited = row && (
        (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
        (row.text && /as often as you like/i.test(row.text))
      );
      
      const alreadyUsed = !isUnlimited && !!window.usedAbilitiesThisTurn[ownerPk]?.[cardKey];
      
      const isActiveSlot = img.closest('.active') !== null;
      const requiresActive = row ? abilityRequiresActive(row) : false;
      
      
      const isPassive = row && row.abilityType === 'passive';
      
      if (isPassive) {
        
        
        const passiveLabel = document.createElement('span');
        passiveLabel.textContent = 'PASSIVE';
        passiveLabel.style.cssText = `
          display: inline-block;
          padding: 2px 6px;
          background: rgba(0, 0, 0, 0.4);
          border-radius: 3px;
          font-size: 9px;
          font-weight: bold;
          color: rgba(255, 255, 255, 0.9);
          margin-left: 6px;
          letter-spacing: 0.5px;
          vertical-align: middle;
        `;
        nm.appendChild(passiveLabel);
        
        
        box.classList.add('ability-disabled');
        
        
        return;
      }
      
      if (!row || row.abilityType !== 'active' ||
          !isCurrentPlayersCard || alreadyUsed || gameOver ||
          (requiresActive && !isActiveSlot)) {
        box.classList.add('ability-disabled');
        return;
      }

      box.classList.add('ability-glow');

      box.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        
        
        const isUnlimitedAbility = 
          (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
          (row.text && /as often as you like/i.test(row.text));
        
        if (!isUnlimitedAbility && window.usedAbilitiesThisTurn[ownerPk]?.[cardKey]) return;
        
        if (zoomBackdrop && zoomBackdrop.classList.contains('show')) {
          zoomBackdrop.classList.remove('show');
          currentZoom = { img: null, meta: null };
        }

        if (typeof applyAbilityEffectFromCsv !== 'function') {
          showPopup('Ability engine not available.');
          return;
        }
        
        const pk = ownerPk;
        
        const effectState = {
          p1: playerState.player1,
          p2: playerState.player2,
          activeFor,
          benchFor,
          opponentOf,
          fetchCardMeta,
          damageActiveOf,
          beginPromotionFlow,
          showPopup,
          logEvent,
          attachEnergyToSlot,
          energyZoneDiv,
          renderEnergyZone,
          getActiveImage
        };

try {
          const result = await applyAbilityEffectFromCsv(effectState, pk, row, { abilityPokemon: actualPokemonImg });
          
          const isUnlimited = 
            (row.param2 && row.param2.toLowerCase() === 'unlimited') ||
            (row.text && /as often as you like/i.test(row.text));
          
          if (!isUnlimited) {
            if (!window.usedAbilitiesThisTurn[ownerPk]) {
              window.usedAbilitiesThisTurn[ownerPk] = {};
            }
            window.usedAbilitiesThisTurn[ownerPk][cardKey] = true;
            

            box.classList.remove('ability-glow');
            box.classList.add('ability-disabled');
          } else {
            
          }
          
          if (openAttackMenu) {
            const abilityRow = openAttackMenu.querySelector('.attack-ability-row');
            if (abilityRow) {
              abilityRow.classList.add('used');
            }
          }
          

          if (result && result.knocked) {
            const foePk = ownerPk === 'p1' ? 'p2' : 'p1';
            const foe = foePk === 'p1' ? 'player1' : 'player2';
            
            
            const foeImg = result.knockedImg || getActiveImage(foe);
            
            if (foeImg && typeof handleKnockOut === 'function') {
              
              
              const foeActive = getActiveImage(foe);
              const wasActive = (foeImg === foeActive);
              
              const ended = await handleKnockOut(foe, foeImg, wasActive);
              if (!ended && typeof beginPromotionFlow === 'function') {
                
                if (wasActive) {
                  beginPromotionFlow(foe);
                }
              }
            }
          }

        } catch (err) {
          console.error('Ability effect error:', err);
          showPopup('Ability failed.');
        }
      });
    });

    zoomAbilities.style.display = 'block';
  }

  
  zoomAttacks.innerHTML='';
  
  
  const isFossil = img.dataset.isFossil === 'true';
  
  if (isFossil) {
    const discardCard = document.createElement('div');
    discardCard.className = 'zoom-attack';
    discardCard.style.cursor = 'pointer'; 
    
    const top = document.createElement('div');
    top.className = 'top';
    top.style.background = '#94a3b8'; 
    top.style.color = '#fff';
    
    const nm = document.createElement('div');
    nm.className = 'name';
    nm.textContent = 'Discard';
    
    top.appendChild(nm);
    discardCard.appendChild(top);
    
    const divider = document.createElement('div');
    divider.className = 'thin';
    const eff = document.createElement('div');
    eff.className = 'effect';
    eff.textContent = 'Discard this Fossil from play. Does not give opponent a point.';
    
    discardCard.appendChild(divider);
    discardCard.appendChild(eff);
    
    
    discardCard.addEventListener('click', async (e) => {
      e.stopPropagation();
      
      
      const ownerDiv = img.closest('#player1, #player2');
      const pk = ownerDiv?.id === 'player1' ? 'p1' : 'p2';
      
      
      if (zoomBackdrop) {
        zoomBackdrop.classList.remove('show');
      }
      currentZoom = { img: null, meta: null };
      
      
      const isActive = !!img.closest('.active');
      
      
      if (globalThis.discardPokemon) {
        await globalThis.discardPokemon(img, pk, false);
      }
      
      showPopup(`${meta.name || 'Fossil'} was discarded.`);
      
      
      if (isActive) {
        const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
        const benchImgs = Array.from(benchDiv?.querySelectorAll('img') ?? []);
        
        if (benchImgs.length === 0) {
          
          const winner = pk === 'p1' ? 'player2' : 'player1';
          showVictory(winner, 'Opponent has no Pokmon left!');
          return;
        }
        
        
        if (globalThis.promoteFromBench) {
          await globalThis.promoteFromBench(null, pk); 
        }
      }
    });
    
    zoomAttacks.appendChild(discardCard);

  } else {
  
  let ownerKey = null;
  let pk = null;
  if (img.closest("#player1") && !img.closest(".hand")) {
    ownerKey = "player1";
    pk = "p1";
  } else if (img.closest("#player2") && !img.closest(".hand")) {
    ownerKey = "player2";
    pk = "p2";
  }
  
  let attacks = meta.attacks || [];
  
  const slot = img.closest('.card-slot');
  
  const toolData = getToolDataFromSlot(slot);
  
  if (toolData && toolData.set && toolData.num) {
    try {
      const toolCardId = csvIdFor(toolData.set, toolData.num);
      
      const toolEffect = TRAINER_EFFECT_DATA.find(x => x.id === toolCardId);
      
      if (toolEffect?.effect_type === 'use_previous_evolution_attacks') {
        
        
        async function buildEvolutionChain(currentMeta, owner, visited = new Set(), skipFirstLevel = false) {
          const chain = [];
          const currentKey = `${currentMeta.id || currentMeta.name}`;
          if (visited.has(currentKey)) return chain; 
          visited.add(currentKey);
          
          
          let evolveFrom = currentMeta.evolvesFrom || currentMeta.evolveFrom || [];
          
          
          if (typeof evolveFrom === 'string' && evolveFrom.trim()) {
            const evolveFromLower = evolveFrom.toLowerCase();
            const matchingCards = [];
            
            
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
            const pokemonInPlay = [
              ...(activeDiv?.querySelectorAll('img') || []),
              ...(benchDiv?.querySelectorAll('img') || [])
            ];
            
            for (const pokemonImg of pokemonInPlay) {
              const pokemonName = (pokemonImg.alt || '').toLowerCase();
              
              if (pokemonName === evolveFromLower) {
                const set = pokemonImg.dataset.set;
                const num = pokemonImg.dataset.num;
                if (set && num) matchingCards.push({ set, number: num });
              }
            }
            
            if (matchingCards.length === 0) {
              const hand = playerState[owner]?.hand || [];
              for (const card of hand) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  matchingCards.push({ set: card.set, number: card.number || card.num });
                }
              }
            }
            
            if (matchingCards.length === 0) {
              const deck = playerState[owner]?.deck || [];
              for (const card of deck) {
                try {
                  const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                  const cardName = (cardMeta.name || '').toLowerCase();
                  
                  if (cardMeta.category === 'Pokemon' && cardName === evolveFromLower) {
                    matchingCards.push({ set: card.set, number: card.number || card.num });
                  }
                } catch {}
              }
            }
            
            if (matchingCards.length === 0) {
              const discard = playerState[owner]?.discard?.cards || [];
              for (const card of discard) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  
                  try {
                    const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                    if (cardMeta && cardMeta.category === 'Pokemon' && cardMeta.name && cardMeta.name.toLowerCase() === evolveFromLower) {
                      matchingCards.push({ set: card.set, number: card.number || card.num });
                    }
                  } catch (err) {
                  }
                }
              }
            }
            
            if (matchingCards.length === 0) {
              
              const commonSets = ['A1', 'A1a', 'A2', 'A2a', 'A2b', 'A3', 'A3a', 'A3b', 'A4', 'A4a'];
              for (const set of commonSets) {
                try {
                  const setResponse = await fetch(`https://api.tcgdex.net/v2/en/sets/${set}`);
                  if (!setResponse.ok) continue;
                  const setData = await setResponse.json();
                  if (setData?.cards) {
                    for (const card of setData.cards) {
                      const cardName = (card.name || '').toLowerCase();
                      if (cardName === evolveFromLower || cardName.includes(evolveFromLower) || evolveFromLower.includes(cardName)) {
                        const localId = card.localId || card.number;
                        if (localId) {
                          matchingCards.push({ set, number: localId });
                          break;
                        }
                      }
                    }
                  }
                  if (matchingCards.length > 0) break;
                } catch (err) {
                }
              }
            }
            
            evolveFrom = matchingCards;
          }
          
          
          if (Array.isArray(evolveFrom) && evolveFrom.length > 0) {
            for (const prevEvo of evolveFrom) {
              try {
                const prevEvoMeta = await fetchCardMeta(prevEvo.set, prevEvo.number);
                if (prevEvoMeta) {
                  
                  if (!skipFirstLevel) {
                    chain.push(prevEvoMeta);
                  } else {
                  }
                  
                  const deeperChain = await buildEvolutionChain(prevEvoMeta, owner, visited, false);
                  chain.push(...deeperChain);
                }
              } catch (err) {
                console.error(`[Memory Light Zoom] Error fetching evolution ${prevEvo.set}-${prevEvo.number}:`, err);
              }
            }
          }
          
          return chain;
        }
        
        
        const evolvedViaRareCandy = img.dataset.evolvedViaRareCandy === 'true';
        
        
        const ownerDiv = img.closest('#player1, #player2');
        const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
        const fullChain = await buildEvolutionChain(meta, owner, new Set(), evolvedViaRareCandy);
        
        if (fullChain.length > 0) {
          if (evolvedViaRareCandy) {
            
            const basicMeta = fullChain[fullChain.length - 1]; 
            if (basicMeta?.attacks) {
              attacks = [...attacks, ...basicMeta.attacks];
            } else {
            }
          } else {

            for (const prevEvoMeta of fullChain) {
              if (prevEvoMeta?.attacks) {
                attacks = [...attacks, ...prevEvoMeta.attacks];
              } else {
              }
            }
          }
        } else {
        }
      } else {
      }
    } catch (err) {
      console.error('[Memory Light Zoom]  Error checking tool:', err);
    }
  } else {
  }
  

  attacks.forEach(atk=>{
    const card=document.createElement('div');
    card.className='zoom-attack';

    const top=document.createElement('div');
    top.className='top';

    const left=document.createElement('div');
    left.style.display='flex';
    left.style.alignItems='center';
    left.style.gap='6px';

    const nm=document.createElement('div');
    nm.className='name';
    nm.textContent=atk.name||'Attack';

    const cost=makeCostIcons(atk.cost||[], slot, img);
    left.appendChild(nm);
    left.appendChild(cost);

    const dmg=document.createElement('div');
    dmg.className='dmg';
    dmg.textContent = (atk.damage || '').toString(); 
    
    (async () => {
      try {
        const previewResult = await calculatePreviewDamage(atk, img, meta, pk);
        let previewDamage = typeof previewResult === 'object' ? previewResult.damage : previewResult;
        
        if (typeof previewDamage === 'object') previewDamage = '';
        dmg.textContent = String(previewDamage || '');
        
        
        if (typeof previewResult === 'object') {
          
          dmg.style.setProperty('color', '', 'important');
          dmg.style.setProperty('text-shadow', '', 'important');
          
          if (previewResult.hasWeakness) {
            
            dmg.style.setProperty('color', '#22c55e', 'important');
            dmg.style.setProperty('text-shadow', '0 0 8px rgba(34, 197, 94, 0.6), 0 0 4px rgba(34, 197, 94, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else if (previewResult.hasOtherBoosts) {
            
            dmg.style.setProperty('color', '#fbbf24', 'important');
            dmg.style.setProperty('text-shadow', '0 0 8px rgba(251, 191, 36, 0.6), 0 0 4px rgba(251, 191, 36, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else {
            
            dmg.style.setProperty('color', '#000000', 'important');
            dmg.style.setProperty('text-shadow', '0 1px 3px rgba(0,0,0,0.5)', 'important');
          }
        }
      } catch (err) {
        console.error('[preview] Error calculating damage:', err);
        
      }
    })();

    top.appendChild(left);
    top.appendChild(dmg);
    card.appendChild(top);

    
    const divider=document.createElement('div');
    divider.className='thin';
    const eff=document.createElement('div');
    eff.className='effect';
    eff.textContent=atk.effect?String(atk.effect):'';

    card.appendChild(divider);
    card.appendChild(eff);
    
    let isMoveLocked = false;
    const instanceId = img.dataset.instanceId;
    const moveName = atk.name?.toLowerCase();
    const currentTurn = globalThis.turnNumber || 0;
    
    if (instanceId && moveName && pk && globalThis.__moveLocks?.[pk]?.[instanceId]?.[moveName]) {
      const moveLock = globalThis.__moveLocks[pk][instanceId][moveName];
      
      if (typeof moveLock === 'object' && moveLock.lockedOnTurn !== undefined) {
        
        isMoveLocked = currentTurn === moveLock.lockedOnTurn + 2;
      } else {
        
        isMoveLocked = moveLock === true;
      }
    }
    
    
    const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
    let isAllAttacksLocked = false;
    if (attackLock) {
      const currentTurn = globalThis.turnNumber || 0;
      if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
        isAllAttacksLocked = currentTurn === attackLock.lockedOnTurn + 2;
      } else if (attackLock === true) {
        isAllAttacksLocked = true; 
      }
    }

    const payable=canPayCostFromAPI(slot,atk.cost||[], img) && !isMoveLocked && !isAllAttacksLocked;
    
    if (isMoveLocked || isAllAttacksLocked) {
      card.classList.add('muted');
      card.style.opacity = '0.5';
      card.style.cursor = 'not-allowed';
      if (isMoveLocked) {
        card.title = `This Pokmon can't use ${atk.name} this turn!`;
      } else if (isAllAttacksLocked) {
        card.title = `This Pokmon can't attack this turn!`;
      }
    }

    if(payable&&mainType){
      top.style.background=TYPE_HEX[mainType]||'#94a3b8';
      top.style.color='#fff';
      nm.style.color='#fff';
      dmg.style.color='#fff';
    }else{
      top.style.background='#2a2f36';
      top.style.color='#e5e7eb';
      if (!isMoveLocked && !isAllAttacksLocked) {
      card.classList.add('muted');
      }
    }

    const isActiveCurrent = (currentPlayer && activeFor(currentPlayer).querySelector('img') === img);

    if (isActiveCurrent) {
      card.onclick = async () => {
        const pk  = currentPlayer === 'player1' ? 'p1' : 'p2';
        
        if (isActiveBlockedFromAttacking(pk)) {
          const imgBlocked = getActiveImg(pk);
          const st = (imgBlocked?.dataset.status || '').toLowerCase();
          if (st === 'asleep') {
            showPopup('This Pokmon is asleep and cant attack.');
          } else if (st === 'paralyzed') {
            showPopup('This Pokmon is paralyzed and cant attack.');
          }
          return;
        }
        
        const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
        if (attackLock) {
          const currentTurn = globalThis.turnNumber || 0;
          let isLocked = false;
          if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
            isLocked = currentTurn === attackLock.lockedOnTurn + 2;
          } else if (attackLock === true) {
            isLocked = true; 
          }
          
          if (isLocked) {
            showPopup('This Pokmon can\'t attack this turn!');
            return;
          }
        }
        
        
        let isLockedNow = false;
        const instanceIdCheck = img.dataset.instanceId;
        const moveNameCheck = atk.name?.toLowerCase();
        const currentTurnCheck = globalThis.turnNumber || 0;
        if (instanceIdCheck && moveNameCheck && globalThis.__moveLocks?.[pk]?.[instanceIdCheck]?.[moveNameCheck]) {
          const moveLockCheck = globalThis.__moveLocks[pk][instanceIdCheck][moveNameCheck];
          if (typeof moveLockCheck === 'object' && moveLockCheck.lockedOnTurn !== undefined) {
            isLockedNow = currentTurnCheck === moveLockCheck.lockedOnTurn + 2;
          } else {
            isLockedNow = moveLockCheck === true;
          }
        }
        
        if (isLockedNow) {
          showPopup(`This Pokmon can't use ${atk.name} this turn!`);
          return;
        }

        if (!payable) {
          showPopup('Not enough energy to use this attack.');
          return;
        }

        const foe = opponentOf(currentPlayer);

        let damage = parseDamage(atk.damage);

        const effectState = {
          p1: playerState.player1,
          p2: playerState.player2,
          activeFor,
          benchFor,
          opponentOf,
          fetchCardMeta,
          damageActiveOf,
          beginPromotionFlow,
          showPopup,
          logEvent
        };
        
        try {
          damage = await applyMoveEffectFromCsv(
            effectState,
            pk,
            atk.name,
            damage
          );
          
          const boost = (globalThis.state?.temp?.[pk]?.globalDamageBoost ?? 0);
          if (boost) {
            damage += boost;
          }
          
          
          const nextTurnBonus = (globalThis.state?.temp?.[pkToPlayer(pk)]?.nextTurnDamageBonus ?? 0);
          if (nextTurnBonus > 0) {
            damage += nextTurnBonus;
            
            if (globalThis.state?.temp?.[pkToPlayer(pk)]) {
              globalThis.state.temp[pkToPlayer(pk)].nextTurnDamageBonus = 0;
            }
          }

        } catch (err) {
          console.error('Move effect error (zoom):', err);
        }
        
        try {
          const foeImg = getActiveImage(foe);
          if (foeImg) {
            const metaFoe = await fetchCardMeta(foeImg.dataset.set, foeImg.dataset.num);
            const wk = metaFoe?.weaknesses?.[0];

            if (wk) {
              const wkType = (wk.type || '').toLowerCase();
              if (wkType !== 'colorless') {
                const atkType = (meta.types?.[0] || '').toLowerCase();
                if (atkType === wkType) {
                  damage += 20;
                }
              }
            }
          }
        } catch (err) {
          console.error('Weakness check failed (zoom):', err);
        }

        const result = await damageActiveOf(foe, damage, { attackerImg: img });
        
        const st = (img.dataset.status || "").toLowerCase();
        if (st && STATUS_ICON_URLS[st]) {
          zoomStatus.style.display = "block";
          zoomStatus.style.backgroundImage = `url('${STATUS_ICON_URLS[st]}')`;
        } else {
          zoomStatus.style.display = "none";
          zoomStatus.style.backgroundImage = "";
        }
        
        zoomBackdrop.classList.remove('show');
        currentZoom = { img: null, meta: null };
        
        if (result.knocked) {
          const foeImg2 = getActiveImage(foe);
          if (foeImg2) {
            const ended = await handleKnockOut(foe, foeImg2);
            if (ended) return;
            await beginPromotionFlow(foe);
          }
        }

        setTimeout(() => startTurn(foe), 300);
      };
    } else {
      
      card.classList.add('muted');
    }

    zoomAttacks.appendChild(card);
  });
  
  } 

  
  zoomWeakness.innerHTML='';
  {
    const wk=(meta.weaknesses&&meta.weaknesses[0])||null;
    if(wk){
      const k=String(wk.type||'').toLowerCase();
      if(k==='colorless'){
        zoomWeakness.textContent='';
      }else{
        const ico=document.createElement('span');
        ico.className='mini-icon';
        ico.style.backgroundImage=`url('${energyIconUrl(k)}')`;

        const val=document.createElement('span');
        val.className='mini-badge';
        val.textContent=wk.value||'';

        zoomWeakness.appendChild(ico);
        zoomWeakness.appendChild(val);
      }
    }else zoomWeakness.textContent='';
  }

  
  zoomRetreat.innerHTML='';
  const rcost=computeRetreatCost(img.closest('.active'),meta);

  for(let i=0;i<rcost;i++){
    const ico=document.createElement('span');
    ico.className='mini-icon';
    ico.style.backgroundImage=`url('${ENERGY_ICONS.colorless}')`;
    zoomRetreat.appendChild(ico);
  }
}

if(toolBackdrop){
  toolBackdrop.addEventListener('click',e=>{
    if(e.target===toolBackdrop)toolBackdrop.classList.remove('show');
  });
  document.addEventListener('keydown',e=>{
    if(e.key==='Escape')toolBackdrop.classList.remove('show');
  });
}

function clearGlow(){
  $$('.glow-evo,.promote-glow').forEach(el=>el.classList.remove('glow-evo','promote-glow'));
  isEvoMode=false;evoMeta=null;evoOwner=null;evoHandCard=null;
}

async function evolveCard(target,meta,handCard,owner,set,num){
  const pk = owner === 'player1' ? 'p1' : 'p2';
  const oppPk = pk === 'p1' ? 'p2' : 'p1';
  const activeDiv = owner === 'player1' ? p1Active : p2Active;
  const activeImg = activeDiv?.querySelector('img');
  const isTargetActive = target === activeImg;
  
  
  let hasBoostedEvolution = false;
  if (isTargetActive) {
    const cacheKey = `${target.dataset.set}-${target.dataset.num}`;
    const numPadded = String(target.dataset.num || '').padStart(3, '0');
    const numUnpadded = String(parseInt(target.dataset.num || '0', 10));
    const abilityRow = globalThis.abilityCache?.[cacheKey] || 
                      globalThis.abilityCache?.[`${target.dataset.set}-${numPadded}`] || 
                      globalThis.abilityCache?.[`${target.dataset.set}-${numUnpadded}`];
    
    if (abilityRow?.effect_type === 'allow_evolution_first_turn') {
      hasBoostedEvolution = true;
    }
  }
  
  
  if(globalThis.turnNumber<=2){
    if (!hasBoostedEvolution) {
      showPopup('You cannot evolve during the first two turns.');
      clearGlow();
      return;
    }
  }
  
  
  const playedTurn=parseInt(target.dataset.playedTurn||'0',10);
  if(playedTurn===globalThis.turnNumber){
    if (!hasBoostedEvolution) {
      showPopup('Cannot evolve the turn it was played.');
      clearGlow();
      return;
    }
  }
  
  
  if (isTargetActive) {
    
    const oppActive = oppPk === 'p1' ? p1Active : p2Active;
    const oppBench = oppPk === 'p1' ? p1Bench : p2Bench;
    const oppPokemon = [
      ...(oppActive?.querySelectorAll('img') || []),
      ...(oppBench?.querySelectorAll('img') || [])
    ];
    
    for (const oppImg of oppPokemon) {
      const cacheKey = `${oppImg.dataset.set}-${oppImg.dataset.num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey];
      
      if (abilityRow?.effect_type === 'block_evolution') {
        const targetParam = abilityRow.param1 || 'opponent';
        if (targetParam === 'opponent' || targetParam === 'all') {
          showPopup('Cannot evolve Active Pokmon - blocked by Primeval Law!');
          clearGlow();
          return;
        }
      }
    }
  }

  const slot=target.closest('.card-slot');
  
  
  const prevBaseHp = parseInt(target.dataset.hp||'0',10);
  const prevSlotMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
  const prevHp = prevSlotMaxHp || prevBaseHp; 
  const prevChp=parseInt(target.dataset.chp||prevBaseHp||'0',10);

  const padded=String(num).padStart(3,'0');
  const evolvedImage=`https://assets.tcgdex.net/en/tcgp/${set}/${padded}/high.png`;
  const evo=document.createElement('img');
  evo.className='card-img';
  evo.alt=meta.name;
  evo.src=evolvedImage;
  evo.dataset.playedTurn=globalThis.turnNumber;
  
  
  if (target.dataset.instanceId) {
    evo.dataset.instanceId = target.dataset.instanceId;
  }
  
  if (target.dataset.evolvedViaRareCandy === 'true') {
    evo.dataset.evolvedViaRareCandy = 'true';
  }
  evo.dataset.evolvedFrom=(meta.evolveFrom||'').toLowerCase();
  evo.dataset.set=set;
  evo.dataset.num=num;

  

  clearStatusOnImg(target);

const energyBox = slot.querySelector('.energy-pips');
const hpOverlay = slot.querySelector('.hp-overlay');
const toolThumb = slot.querySelector('.tool-thumb');

const oldImg = slot.querySelector('img'); 
const hadEnergy = !!energyBox;
const hadHP     = !!hpOverlay;
const hadTool   = !!toolThumb;

let handCardForAnimation = null;

if (handCard && typeof handCard.getBoundingClientRect === 'function') {
  handCardForAnimation = handCard;
} else if (evoHandCard && typeof evoHandCard.getBoundingClientRect === 'function') {
  
  handCardForAnimation = evoHandCard;
} else {
  
  const handCardElement = document.querySelector(`.hand img[data-set="${set}"][data-num="${num}"]`);
  if (handCardElement && typeof handCardElement.getBoundingClientRect === 'function') {
    handCardForAnimation = handCardElement;
  } else if (handCard && handCard.set && handCard.number) {
    
    const cardElement = document.querySelector(`.hand img[data-set="${handCard.set}"][data-num="${handCard.number || handCard.num}"]`);
    if (cardElement && typeof cardElement.getBoundingClientRect === 'function') {
      handCardForAnimation = cardElement;
    }
  }
}

if (oldImg) oldImg.remove();

slot.insertBefore(evo, slot.firstChild);

if (handCardForAnimation) {
  animateSlideFromHand(handCardForAnimation, slot, evo);
} else {
  
  evo.style.opacity = '0';
  evo.style.transition = 'opacity 0.2s ease';
  requestAnimationFrame(() => {
    evo.style.opacity = '1';
  });
}

if (hadEnergy) slot.appendChild(energyBox);
if (hadHP)     slot.appendChild(hpOverlay);
if (hadTool)   slot.appendChild(toolThumb);

const toolObj = getToolDataFromSlot(slot);
if (toolObj) {
  setToolDataOnSlot(slot, toolObj);
}
  
  const newHp = parseInt(meta.hp||'0',10) || prevHp || 0;
  
  
  const toolData = getToolDataFromSlot(slot);
  const isGiantCape = toolData && (toolData.set === 'A2' && toolData.num === '147');
  const isLeafCape = toolData && (toolData.set === 'A3' && toolData.num === '147');
  const hasHpBoostingTool = isGiantCape || isLeafCape;
  const hpBonus = isGiantCape ? 20 : (isLeafCape ? 30 : 0);
  
  
  const hpIncrease = newHp - prevBaseHp;
  
  
  let newChp = Math.max(0, prevChp + hpIncrease);
  if (hasHpBoostingTool) {
    newChp += hpBonus; 
  }
  
  
  const newMaxHp = newHp + hpBonus;
  
  
  if (hasHpBoostingTool) {
    slot.dataset.maxHp = String(newMaxHp);
  } else {
    
    delete slot.dataset.maxHp;
  }
  
  setHpOnImage(evo, newHp, newChp);
  markSlot(slot,true);
  removeFromHand(owner,set,num);
  renderAllHands();

  const evolvedViaRareCandy = target.dataset.evolvedViaRareCandy === 'true';
  logEvent({
    player: owner,
    text: evolvedViaRareCandy 
      ? `Evolved ${meta.evolveFrom || 'a Pokmon'} into ${meta.name} (via Rare Candy).`
      : `Evolved ${meta.evolveFrom || 'a Pokmon'} into ${meta.name}.`,
    cardSet:set,cardNum:num
  });

  showPopup(`${meta.evolveFrom}  ${meta.name}`);
  
  
  const isActive = slot.closest('.active');
  if (isActive) {
    const playerNum = owner === 'player1' ? 1 : 2;
    updatePlayerTypeBackground(playerNum);
  }
  
  
  try {
    const cacheKey = `${set}-${num}`;
    const abilityRow = globalThis.abilityCache?.[cacheKey];
    
    if (abilityRow?.effect_type === 'draw_on_evolution') {
      const pkForAbility = owner === 'player1' ? 'p1' : 'p2';
      
      const effectState = {
        p1: playerState.player1,
        p2: playerState.player2
      };
      
      if (typeof applyAbilityEffectFromCsv === 'function') {
        await applyAbilityEffectFromCsv(effectState, pkForAbility, abilityRow, {});
      }
    }
  } catch (err) {
    console.error('[Evolution] Happy Ribbon check failed:', err);
  }
  
  if(currentZoom.img&&currentZoom.img===evo){
    await buildZoomPanel(meta,evo);
  }
}

function handFind(owner,set,num){
  return playerState[owner].hand.find(c=>c.set===set&&String(c.number||c.num)===String(num))||null;
}

async function triggerElectromagneticWall(targetImg) {
  if (!targetImg) return;
  
  try {
    
    const owner = targetImg.closest('#player1') ? 'player1' : 'player2';
    const pk = owner === 'player1' ? 'p1' : 'p2';
    const oppPk = pk === 'p1' ? 'p2' : 'p1';
    
    
    const oppActive = oppPk === 'p1' ? p1Active : p2Active;
    const oppActiveImg = oppActive?.querySelector('img');
    
    if (oppActiveImg) {
      
      const set = oppActiveImg.dataset.set;
      const num = oppActiveImg.dataset.num;
      const numPadded = String(num || '').padStart(3, '0');
      const numUnpadded = String(parseInt(num || '0', 10));
      const cacheKey1 = `${set}-${numPadded}`;
      const cacheKey2 = `${set}-${numUnpadded}`;
      const cacheKey3 = `${set}-${num}`;
      const abilityRow = globalThis.abilityCache?.[cacheKey1] || 
                        globalThis.abilityCache?.[cacheKey2] || 
                        globalThis.abilityCache?.[cacheKey3];
      
      if (abilityRow?.effect_type === 'damage_on_opponent_energy_attach') {
        const damage = parseInt(abilityRow.param1 || '20', 10);
        
        
        const damageFn = globalThis.damageImg || window.damageImg || (typeof damageImg !== 'undefined' ? damageImg : null);
        if (damageFn && typeof damageFn === 'function') {
          const result = damageFn(targetImg, damage);
          showPopup(`Electromagnetic Wall: ${oppActiveImg.alt} deals ${damage} damage to ${targetImg.alt}!`);
          
          
          if (result && result.knocked) {
            
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const activeImg = activeDiv?.querySelector('img');
            const wasActive = targetImg === activeImg;
            
            
            if (typeof handleKnockOut === 'function') {
              const gameEnded = await handleKnockOut(owner, targetImg, wasActive);
              if (!gameEnded && wasActive && typeof beginPromotionFlow === 'function') {
                await beginPromotionFlow(owner);
              }
            }
          }
        } else {
        }
      }
    }
  } catch (err) {
  }
}

globalThis.triggerElectromagneticWall = triggerElectromagneticWall;

function attachEnergyToSlot(owner,slot,energyKey){
  if(!slot||!energyKey)return;
  
  const currentHasAttached = hasAttachedEnergyThisTurn || globalThis.hasAttachedEnergyThisTurn;
  if (currentHasAttached && !isSetupPhase) {
    showPopup('You can only attach one Energy per turn.');
    return;
  }
  
  const img=slot.querySelector('img');
  if(!img){showPopup('Select a Pokmon in play.');return}
  const area=currentPlayer==='player1'?$('#player1'):$('#player2');
  if(!area.contains(slot)||slot.closest('.hand')){
    showPopup('Attach only to Pokmon in play.');
    return;
  }
  const set=img.dataset.set,num=img.dataset.num;
  
    let box=slot.querySelector('.energy-pips');
    if(!box){
      box=document.createElement('div');
      box.className='energy-pips';
      slot.appendChild(box);
    }
    const pip=document.createElement('div');
    pip.className='energy-pip';
    pip.dataset.type=energyKey;
    pip.style.backgroundImage=`url('${ENERGY_ICONS[energyKey]||''}')`;
    box.appendChild(pip);
    
    
    addDoubledEnergyVisuals(img, box, energyKey);
    
    
    if (typeof triggerNightmareAura === 'function') {
      triggerNightmareAura(img, energyKey);
    }
    
    
    (async () => {
      try {
        const pk = owner === 'player1' ? 'p1' : 'p2';
        const abilityRow = await getAbilityRow(img.dataset.set, img.dataset.num);
        
        if (abilityRow?.effect_type === 'inflict_status_on_energy_attach') {
          if (typeof applyAbilityEffectFromCsv === 'function') {
            
            const state = {
              p1: playerState.player1,
              p2: playerState.player2
            };
            await applyAbilityEffectFromCsv(state, pk, abilityRow, { targetImg: img });
          }
        }
      } catch (err) {
      }
    })();
    
    
    triggerElectromagneticWall(img);
    
    hasAttachedEnergyThisTurn=true;
  globalThis.hasAttachedEnergyThisTurn=true;
  
  selectedEnergy = null;
  globalThis.selectedEnergy = null;
  if (globalThis.selectedEnergyElement) {
    globalThis.selectedEnergyElement.classList.remove('selected-glow');
    globalThis.selectedEnergyElement = null;
  }
  
  const renderFn = globalThis.renderEnergyZone || renderEnergyZone;
  if (typeof renderFn === 'function') {
    renderFn();
  }
  
    showPopup('Energy attached');

    logEvent({
      player: owner,
      text:`Attached ${energyKey} Energy.`,
      cardSet:set,cardNum:num
    });

  fetchCardMeta(set,num).then(meta=>{
    const isFossil = img.dataset.isFossil === 'true';
    if(String(meta.category||'').toLowerCase()!=='pokemon' && !isFossil){
      showPopup('Warning: Card may not be a Pokmon.');
    }
    if(currentZoom.img&&slot.contains(currentZoom.img)){
      buildZoomPanel(meta,currentZoom.img);
    }
  }).catch(()=>{
  });
}

function addDoubledEnergyVisuals(img, energyBox, energyKey) {
  if (!img || !energyBox || !energyKey) return;
  
  
  const p1Active = document.querySelector('#player1 .active img');
  const p1Bench = Array.from(document.querySelectorAll('#player1 .bench img'));
  const p2Active = document.querySelector('#player2 .active img');
  const p2Bench = Array.from(document.querySelectorAll('#player2 .bench img'));
  
  let owner = null;
  if (img === p1Active || p1Bench.includes(img)) owner = 'p1';
  else if (img === p2Active || p2Bench.includes(img)) owner = 'p2';
  
  if (!owner) return;
  
  
  const allMyPokemon = owner === 'p1' ? [p1Active, ...p1Bench] : [p2Active, ...p2Bench];
  let hasSerperior = false;
  
  for (const pokemon of allMyPokemon) {
    if (pokemon && pokemon.alt && pokemon.alt.toLowerCase().includes('serperior')) {
      hasSerperior = true;
      break;
    }
  }
  
  
  if (hasSerperior && energyKey.toLowerCase() === 'grass') {
    const types = (img.dataset.pokemonTypes || '').toLowerCase().split(',');
    if (types.includes('grass')) {
      
      const phantomPip = document.createElement('div');
      phantomPip.className = 'energy-pip phantom-pip';
      phantomPip.dataset.type = energyKey;
      phantomPip.dataset.phantom = 'true';  
      phantomPip.style.backgroundImage = `url('${ENERGY_ICONS[energyKey]||''}')`;
      phantomPip.style.opacity = '0.7';
      phantomPip.title = 'Doubled by Jungle Totem';
      energyBox.appendChild(phantomPip);

    }
  }
}

function updateAllEnergyVisuals() {
  
  const observer = globalThis.pokemonTypeObserver;
  if (observer) {
    observer.disconnect();
  }
  
  
  ['p1', 'p2'].forEach(owner => {
    const area = owner === 'p1' ? document.querySelector('#player1') : document.querySelector('#player2');
    if (!area) return;
    
    const allSlots = Array.from(area.querySelectorAll('.card-slot'));
    
    allSlots.forEach(slot => {
      const img = slot.querySelector('img');
      const energyBox = slot.querySelector('.energy-pips');
      if (!img || !energyBox) return;
      
      
      energyBox.querySelectorAll('.phantom-pip').forEach(p => p.remove());
      
      
      const realPips = Array.from(energyBox.querySelectorAll('.energy-pip:not(.phantom-pip)'));
      
      
      realPips.forEach(pip => {
        const energyType = pip.dataset.type;
        if (energyType) {
          addDoubledEnergyVisuals(img, energyBox, energyType);
        }
      });
    });
  });
  
  
  if (observer && document.body) {
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }

}

globalThis.updateAllEnergyVisuals = updateAllEnergyVisuals;

document.body.addEventListener('click', async e => {
  if (menuJustClosed) {
    return;
  }
  
  if (e.target.closest('#zoomBackdrop') || e.target.closest('.attack-menu') || e.target.closest('#handBackdrop') || e.target.closest('#toolBackdrop')) {
    return;
  }
  
  const isPlayerArea = e.target.closest('#player1') || e.target.closest('#player2');
  if (isPlayerArea && !e.target.closest('img') && !e.target.closest('.card-slot') && !e.target.closest('button') && !e.target.closest('.energy-zone') && !e.target.closest('.hand')) {
    if (!isPromotionPhase && !isRetreatSelection) {
      return;
    }
  }
  
  if (e.button !== 0) {
    return;
  }

  
  const toolThumb = e.target.closest('.tool-thumb');
  if (toolThumb) {
    e.stopPropagation();
    e.preventDefault();
    
    const slot = toolThumb.closest('.card-slot');
    const toolData = getToolDataFromSlot(slot);
    const pokemonImg = slot.querySelector('img:not(.tool-thumb)');
    
    if (toolData && toolData.set && toolData.num) {
      try {
        const meta = await fetchCardMeta(toolData.set, toolData.num);
        
        
        if (handBackdrop && handImg && handToolImg) {
          
          if (pokemonImg) {
            handImg.src = pokemonImg.src;
          }
          
          
          handToolImg.src = toolData.src || toolThumb.src;
          handToolImg.style.display = 'block';
          
          handBackdrop.classList.add('show');
          handTitle.textContent = meta.name || 'Tool';
          
          if (handType) {
            handType.textContent = 'Tool';
            handType.style.background = trainerColor('tool');
          }
          if (handEffect) {
            handEffect.textContent = meta.effect || meta.description || 'No effect listed.';
          }
        }

      } catch (err) {
        showPopup('Could not load tool data.');
        console.error('[tool-click] Error:', err);
      }
    }
    
    return;
  }

  
  if (toolAttachPending) {
    const targetImg = e.target.closest('.active img, .bench img');
    
    if (!targetImg) {
      cancelSelection();
      return;
    }
    if (targetImg) {
      const owner = targetImg.closest('#player1') ? 'player1' : 'player2';
      if (owner !== toolAttachPending.owner) {
        showPopup('Attach Tools to your own Pokmon.');
      } else {
        const targetSlot = targetImg.closest('.card-slot');
        if (getToolDataFromSlot(targetSlot)) {
          showPopup('This Pokmon already has a Tool attached.');
        } else {
          
          await attachToolToSlot(owner, targetSlot, {
            set: toolAttachPending.set,
            num: toolAttachPending.num,
            src: toolAttachPending.src
          });
          
          
          const cardId = csvIdFor(toolAttachPending.set, toolAttachPending.num);
          const effect = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
          
          if (effect && effect.effect_type) {
            
            globalThis.toolAttachTarget = targetImg;
            
            try {
              await (globalThis.applyTrainerEffect || applyTrainerEffect)(effect, owner, null); 
              
              
              removeFromHand(owner, toolAttachPending.set, toolAttachPending.num);
              renderAllHands();

              logEvent({
                player: owner,
                text: 'Attached Tool.',
                cardSet: toolAttachPending.set,
                cardNum: toolAttachPending.num
              });

              toolAttachPending = null;
              clearSelectionGlow();
              
            } catch (err) {

              
              
              const toolThumb = targetSlot.querySelector('.tool-thumb');
              if (toolThumb) toolThumb.remove();
              setToolDataOnSlot(targetSlot, null);
              
              showPopup(err.message || 'Cannot attach this Tool here.');
              
            } finally {
              globalThis.toolAttachTarget = null;
            }
          } else {
            
            removeFromHand(owner, toolAttachPending.set, toolAttachPending.num);
            renderAllHands();

            logEvent({
              player: owner,
              text: 'Attached Tool.',
              cardSet: toolAttachPending.set,
              cardNum: toolAttachPending.num
            });

            toolAttachPending = null;
            clearSelectionGlow();
          }
        }
      }
      e.stopPropagation();
      return;
    }
  }

  
  const currentSelectedEnergy = selectedEnergy || globalThis.selectedEnergy;
  if (currentSelectedEnergy) {
    const isEnergyZoneClick = e.target.closest('.energy-zone') || e.target.classList.contains('energy');
    if (isEnergyZoneClick) {
      e.stopPropagation();
      e.preventDefault();
      return;
    }
    
    let img = e.target.closest('img');
    if (!img && e.target.closest('.card-slot')) {
      const slot = e.target.closest('.card-slot');
      img = slot.querySelector('img');
    }
    
    if (!img || img.closest('.hand')) {
      e.stopPropagation();
      e.preventDefault();
      cancelSelection();
      return;
    }
    
    const slot = img.closest('.card-slot');
    
    if (!slot) {
      e.stopPropagation();
      e.preventDefault();
      cancelSelection();
      return;
    }
    
    const owner = img.closest('#player1') ? 'player1' : 'player2';
    
    if (owner !== currentPlayer) {
      e.stopPropagation();
      e.preventDefault();
      e.stopImmediatePropagation();
      showPopup('Attach Energy to your own Pokmon.');
      return;
    }
    
    e.stopPropagation();
    e.preventDefault();
    e.stopImmediatePropagation();
    attachEnergyToSlot(owner, slot, currentSelectedEnergy);
    selectedEnergy = null;
    globalThis.selectedEnergy = null;
    clearSelectionGlow();
    return;
  }

  
  

  const benchImg = e.target.closest('.bench img');
  if (benchImg && !benchImg.closest('.hand')) {
    const isInSelectionMode = isEvoMode || 
                              toolAttachPending || 
                              selectedEnergy || 
                              isPromotionPhase || 
                              isRetreatSelection || 
                              abilityJustUsed ||
                              globalThis.__selectionActive ||
                              globalThis.__pokemonCommActive ||
                              globalThis.__rareCandyActive ||
                              globalThis.__silverSelectionActive ||
                              globalThis.isSelectingPokemon;

    if (!isInSelectionMode) {
      e.preventDefault();
      e.stopPropagation();
      
      zoomImg.src = benchImg.src;
      zoomBackdrop.classList.add('show');
      
      try {
        const set = benchImg.dataset.set;
        const num = benchImg.dataset.num;
        const meta = await fetchCardMeta(set, num);
        await buildZoomPanel(meta, benchImg);
      } catch {
        zoomTitle.textContent = 'Pokmon';
        zoomHp.textContent = '';
        zoomAttacks.innerHTML = '<div style="color:#cbd5e1">No data</div>';
        zoomEnergyCount.textContent = 'x0';
        zoomEnergyIcons.innerHTML = '';
        zoomWeakness.textContent = '';
        zoomRetreat.innerHTML = '';
        zoomTools.innerHTML = '<div class="chip">none</div>';
        zoomAbilities.style.display = 'none';
      }
      
      return;
    }
  }

  
  

  let clickedImg = e.target.closest('img');
  if (!clickedImg && e.target.closest('.card-slot')) {
    const slot = e.target.closest('.card-slot');
    clickedImg = slot.querySelector('img');
  }
  
  if (clickedImg && !clickedImg.closest('.hand')) {
    const activeArea = currentPlayer ? activeFor(currentPlayer) : null;
    
    if (activeArea && activeArea.contains(clickedImg)) {
      if (isEvoMode && clickedImg.classList.contains('glow-evo')) {
        return;
      }

      const currentSelectedEnergy = selectedEnergy || globalThis.selectedEnergy;
      if (isEvoMode || toolAttachPending || currentSelectedEnergy || isPromotionPhase || isRetreatSelection || abilityJustUsed) {
        e.stopPropagation();
        e.preventDefault();
        e.stopImmediatePropagation();
        return;
      }

      const set = clickedImg.dataset.set;
      const num = clickedImg.dataset.num;

      
      if (!set || !num) {
        console.error('[attack-menu] Missing set/num:', { set, num });
        closeAttackMenu();
        return;
      }

      try {
        const meta = await fetchCardMeta(set, num);
        
        if (!meta) {
          showPopup('Could not load card data.');
          return;
        }
        
        
        const category = String(meta.category || '').toLowerCase();
        const isFossil = clickedImg.dataset.isFossil === 'true';
        
        if (category !== 'pokemon' && !isFossil) {
          showPopup('This is not a Pokmon card.');
          return;
        }
        
        
        showAttackMenuFor(clickedImg, meta);
        
      } catch (err) {
        console.error('[attack-menu] Error loading card:', err);
        showPopup('No attacks available.');
      }
      
      return;
    }
  }

  

if (e.target.tagName !== 'IMG') return;
const inHand = e.target.closest('.hand');
if (!inHand) return;

if (globalThis.__selectionActive) {
  
  e.stopPropagation();
  e.preventDefault();
  showPopup('Cannot select cards in hand. Please select a Pokmon in play.');
  return;
}

const owner = e.target.dataset.owner;
const set = e.target.dataset.set;
const num = e.target.dataset.num;
const trainerCardImg = e.target; 

if (currentPlayer && owner !== currentPlayer && !globalThis.__silverSelectionActive) return;

if (globalThis.__silverSelectionActive && owner !== currentPlayer) {
  
  return;
}

if (globalThis.__pokemonCommActive) {
  const selData = globalThis.__pokemonCommSelection;
  if (selData) {
    
    const clickedCard = selData.hand.find(c => 
      (c.set === set && String(c.number || c.num) === String(num))
    );
    
    if (clickedCard && selData.pokemonInHand.includes(clickedCard)) {
      
      globalThis.__pokemonCommActive = false;
      globalThis.__pokemonCommSelection = null;
      
      if (globalThis.__pokemonCommResolve) {
        globalThis.__pokemonCommResolve(clickedCard);
        globalThis.__pokemonCommResolve = null;
      }

      return;
    }
  }
}

if (globalThis.__rareCandyActive) {
  const rareCandyData = globalThis.__rareCandySelection;
  if (rareCandyData && rareCandyData.owner === owner) {
    
    const clickedPair = rareCandyData.pairsForBasic.find(p => 
      p.handCard.set === set && String(p.handCard.number || p.handCard.num) === String(num)
    );
    
    if (clickedPair) {
      
      if (globalThis.__rareCandyResolve) {
        globalThis.__rareCandyResolve(clickedPair);
        globalThis.__rareCandyResolve = null;
      }

      return;
    }
  }
}

let meta = null;
try {
  meta = await fetchCardMeta(set, num);
} catch {}

if (meta && String(meta.category || '').toLowerCase() === 'trainer') {
  if (isSetupPhase) {
    showPopup("You can't play Trainer cards during setup.");
    return;
  }
  
  const ttype = String(meta.trainerType || '').toLowerCase();
  const cardId = csvIdFor(set, num);
  const effect = TRAINER_EFFECT_DATA.find(x => x.id === cardId);
  
  async function validateTrainerEffect(effect, owner) {
    if (!effect || !effect.effect_type) return { valid: true };
    
    const pk = owner === 'player1' ? 'p1' : 'p2';
    const effectType = effect.effect_type;
    const param1 = effect.param1 || '';
    const param2 = effect.param2 || '';
    
    if (effectType === 'heal') {
      const activeImg = globalThis.getActiveImg?.(pk);
      if (!activeImg) return { valid: false, message: 'No Active Pokmon to heal.' };
      
      const slot = activeImg.closest('.card-slot');
      const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
      const maxHp = modifiedMaxHp || parseInt(activeImg.dataset.hp || '0', 10);
      const curHp = parseInt(activeImg.dataset.chp || maxHp, 10);
      
      if (curHp >= maxHp) {
        return { valid: false, message: 'Your Active Pokmon is already at full health.' };
      }
    }
    
    if (effectType === 'heal_type') {
      const type = (param2 || 'grass').toLowerCase();
      const allImgs = globalThis.getAllPokemonImgs?.(pk) || [];
      let hasValidTarget = false;
      
      for (const img of allImgs) {
        try {
          const imgMeta = await fetchCardMeta(img.dataset.set, img.dataset.num);
          if (imgMeta.types?.some(t => t.toLowerCase() === type)) {
            const slot = img.closest('.card-slot');
            const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
            const maxHp = modifiedMaxHp || parseInt(img.dataset.hp || '0', 10);
            const curHp = parseInt(img.dataset.chp || maxHp, 10);
            
            if (curHp < maxHp) {
              hasValidTarget = true;
              break;
            }
          }
        } catch {}
      }
      
      if (!hasValidTarget) {
        return { valid: false, message: `No damaged ${type}-type Pokmon to heal.` };
      }
    }
    
    if (effectType === 'heal_all_with_type_energy') {
      const energyType = (param2 || 'water').toLowerCase();
      const allImgs = globalThis.getAllPokemonImgs?.(pk) || [];
      let hasValidTarget = false;
      
      for (const img of allImgs) {
        const slot = img.closest('.card-slot');
        const energyBox = slot?.querySelector('.energy-pips');
        const pips = Array.from(energyBox?.querySelectorAll('.energy-pip:not(.phantom-pip)') ?? []);
        const hasType = pips.some(pip => (pip.dataset.type || '').toLowerCase() === energyType);
        
        if (hasType) {
          const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
          const maxHp = modifiedMaxHp || parseInt(img.dataset.hp || '0', 10);
          const curHp = parseInt(img.dataset.chp || maxHp, 10);
          
          if (curHp < maxHp) {
            hasValidTarget = true;
            break;
          }
        }
      }
      
      if (!hasValidTarget) {
        return { valid: false, message: `No damaged Pokmon with ${energyType} energy to heal.` };
      }
    }
    
    if (effectType === 'heal_and_cure_status') {
      const allImgs = globalThis.getAllPokemonImgs?.(pk) || [];
      let hasValidTarget = false;
      
      for (const img of allImgs) {
        const hasStatus = !!img.dataset.status;
        const slot = img.closest('.card-slot');
        const modifiedMaxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : null;
        const maxHp = modifiedMaxHp || parseInt(img.dataset.hp || '0', 10);
        const curHp = parseInt(img.dataset.chp || maxHp, 10);
        const hasDamage = curHp < maxHp;
        
        if (hasStatus || hasDamage) {
          hasValidTarget = true;
          break;
        }
      }
      
      if (!hasValidTarget) {
        return { valid: false, message: 'No Pokmon with damage or status conditions to heal.' };
      }
    }
    
    if (effectType === 'flip_attach_energy') {
      const type = (param1 || 'water').toLowerCase();
      const allImgs = globalThis.getAllPokemonImgs?.(pk) || [];
      let hasValidTarget = false;
      
      for (const img of allImgs) {
        try {
          const imgMeta = await fetchCardMeta(img.dataset.set, img.dataset.num);
          if (imgMeta.types?.some(t => t.toLowerCase() === type)) {
            hasValidTarget = true;
            break;
          }
        } catch {}
      }
      
      if (!hasValidTarget) {
        return { valid: false, message: `No ${type}-type Pokmon in play to attach energy to.` };
      }
    }
    
    if (effectType === 'search_pokemon_type_random') {
      const requiredType = (param1 || '').toLowerCase().trim();
      const deck = playerState[owner]?.deck || [];
      
      if (deck.length === 0) {
        return { valid: false, message: 'Deck is empty.' };
      }
      
      let hasValidCard = false;
      for (const card of deck.slice(0, Math.min(deck.length, 20))) {
        try {
          const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
          if (cardMeta.category === 'Pokemon') {
            if (requiredType) {
              if (cardMeta.types?.some(t => t.toLowerCase() === requiredType)) {
                hasValidCard = true;
                break;
              }
            } else {
              hasValidCard = true;
              break;
            }
          }
        } catch {}
      }
      
      if (!hasValidCard) {
        return { valid: false, message: requiredType ? `No ${requiredType}-type Pokmon in deck.` : 'No Pokmon in deck.' };
      }
    }
    
    if (effectType === 'search_basic_pokemon') {
      const deck = playerState[owner]?.deck || [];
      
      if (deck.length === 0) {
        return { valid: false, message: 'Deck is empty.' };
      }
      
      let hasValidCard = false;
      for (const card of deck.slice(0, Math.min(deck.length, 20))) {
        try {
          const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
          if (cardMeta.category === 'Pokemon' && cardMeta.stage?.toLowerCase() === 'basic') {
            hasValidCard = true;
            break;
          }
        } catch {}
      }
      
      if (!hasValidCard) {
        return { valid: false, message: 'No Basic Pokmon in deck.' };
      }
    }
    
    if (effectType === 'search_named_random') {
      const name = (param2 || '').toLowerCase().trim();
      if (!name) return { valid: true };
      
      const deck = playerState[owner]?.deck || [];
      
      if (deck.length === 0) {
        return { valid: false, message: 'Deck is empty.' };
      }
      
      let hasValidCard = false;
      for (const card of deck.slice(0, Math.min(deck.length, 20))) {
        try {
          const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
          if (cardMeta.category === 'Pokemon' && (cardMeta.name || '').toLowerCase().includes(name)) {
            hasValidCard = true;
            break;
          }
        } catch {}
      }
      
      if (!hasValidCard) {
        return { valid: false, message: `No ${name} in deck.` };
      }
    }
    
    return { valid: true };
  }
  
  const doEffect = async () => {
    if (effect) {
      await (globalThis.applyTrainerEffect || applyTrainerEffect)(effect, owner, trainerCardImg, true); 
    } else {
    }
  };

  if (ttype === 'supporter') {
    
        const pk = owner === 'player1' ? 'p1' : 'p2';

    if (!canUseSupporter(pk)) {
      showPopup("Can't use Supporter cards this turn!");
      return;
    }
    
    if (isGengarBlocking(owner)) {
      showPopup('Shadowy Spellbind: You cannot play Supporter cards!');
      return;
    }
    
    if (hasPlayedSupporterThisTurn[owner]) {
      showPopup('Only one Supporter per turn.');
      return;
    }
    
    
    if (!effect) {
      showPopup(`${meta.name || 'This Supporter'} is not yet implemented.`);
      return;
    }

    const validation = await validateTrainerEffect(effect, owner);
    if (!validation.valid) {
      showPopup(validation.message || 'This card would have no effect.');
      return;
    }
    
    logEvent({
      player: owner,
      text: `Played Supporter: ${meta.name}.`,
      cardSet: set,
      cardNum: num
    });
    
    try {
      await doEffect();
      
      
    addTrainerToDiscard(owner, e.target);
    removeFromHand(owner, set, num);
    renderAllHands();
    hasPlayedSupporterThisTurn[owner] = true;
    
    
    const pkForSilvally = owner === 'player1' ? 'p1' : 'p2';
    if (!globalThis.__supporterPlayedThisTurn) globalThis.__supporterPlayedThisTurn = { p1: false, p2: false };
    globalThis.__supporterPlayedThisTurn[pkForSilvally] = true;
      
    showPopup('Supporter played');
    } catch (err) {
      
      if (err.message === 'SELECTION_CANCELLED') {
        showPopup('Supporter use cancelled.');
      } else if (err.message === 'No valid target') {
        showPopup('No valid target');
      } else {
        showPopup(err.message || 'Supporter effect failed.');
      }
      
    }

    return;
  } else if (ttype === 'item') {
    
    if (effect) {
      const validation = await validateTrainerEffect(effect, owner);
      if (!validation.valid) {
        showPopup(validation.message || 'This card would have no effect.');
        return;
      }
    }
    
    logEvent({
      player: owner,
      text: `Played Item: ${meta.name}.`,
      cardSet: set,
      cardNum: num
    });
    
    try {
      await doEffect();
      
      
      const itemRect = e.target.getBoundingClientRect();
      const scaleClone = e.target.cloneNode(true);
      scaleClone.style.cssText = `
        position: fixed;
        left: ${itemRect.left}px;
        top: ${itemRect.top}px;
        width: ${itemRect.width}px;
        height: ${itemRect.height}px;
        z-index: 10000;
        pointer-events: none;
        transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        transform-origin: center center;
      `;
      document.body.appendChild(scaleClone);
      
      
      void scaleClone.offsetWidth;
      
      
      requestAnimationFrame(() => {
        scaleClone.style.transform = 'scale(2)';
        scaleClone.style.opacity = '0.9';
      });
      
      
      setTimeout(() => {
        scaleClone.style.opacity = '0';
        setTimeout(() => scaleClone.remove(), 100);
      }, 500);
      
      
      addTrainerToDiscard(owner, e.target);
      removeFromHand(owner, set, num);
      renderAllHands();
      showPopup('Item played');
    } catch (err) {

      showPopup(err.message || 'Cannot use this Item right now.');
    }

    return;
  } else if (ttype === 'tool') {
    
    if (selectedEnergyElement) {
      selectedEnergyElement.classList.remove('selected-glow');
      selectedEnergy = null;
    }
    if (selectedToolElement) {
      selectedToolElement.classList.remove('selected-glow');
    }
    
    toolAttachPending = { owner, set, num, src: e.target.src };
    selectedToolElement = e.target;
    selectedEnergyElement = null;
    e.target.classList.add('selected-glow');
    showPopup('Select a Pokmon in play to attach this Tool, or press Escape to cancel.');

    logEvent({
      player: owner,
      text: `Played Tool: ${meta.name}.`,
      cardSet: set,
      cardNum: num
    });
    
    
    setupSelectionCancelHandler();

    return;
  } else {
    showPopup('Unknown Trainer type.');
    return;
  }
}

if (meta && meta.evolveFrom) {
  isEvoMode = true;
  evoMeta = meta;
  evoOwner = owner;
  evoHandCard = e.target;
  
  let glow = 0;
  const evolveFromLower = String(meta.evolveFrom).toLowerCase();
  
  
  const FOSSIL_MAP = {
    'helix fossil': 'omanyte',
    'dome fossil': 'kabuto',
    'old amber': 'aerodactyl',
    'skull fossil': 'cranidos',
    'armor fossil': 'shieldon'
  };
  
  $$('#' + owner + ' .active img, #' + owner + ' .bench img').forEach(img => {
    const cardNameLower = (img.alt || '').toLowerCase();
    
    
    let matches = cardNameLower.includes(evolveFromLower);
    
    
    if (!matches && FOSSIL_MAP[cardNameLower]) {
      const fossilPokemon = FOSSIL_MAP[cardNameLower];
      matches = fossilPokemon === evolveFromLower || evolveFromLower.includes(fossilPokemon);
    }
    
    
    if (!matches && cardNameLower.includes('eevee ex')) {
      const EEVEELUTIONS = [
        'vaporeon', 'jolteon', 'flareon', 'espeon', 'umbreon',
        'leafeon', 'glaceon', 'sylveon'
      ];
      
      const evoCardName = (meta.name || '').toLowerCase();
      if (EEVEELUTIONS.some(e => evoCardName.includes(e))) {
        matches = true;
      }
    }
    
    if (matches) {
      img.classList.add('glow-evo');
      glow++;
    }
  });
  
  if (glow === 0) {
    showPopup(`No valid ${meta.evolveFrom} to evolve.`);
    isEvoMode = false;
    return;
  }
  
  showPopup(`Select ${meta.evolveFrom} to evolve.`);
  return;
}

if (!(meta && String(meta.category || '').toLowerCase() === 'pokemon' &&
     String(meta.stage || '').toLowerCase() === 'basic')) {
  showPopup('Only Basic Pokmon can be placed.');
  return;
}

const clone = e.target.cloneNode(true);
clone.dataset.playedTurn = globalThis.turnNumber;
  
  
  if (!window.pokemonInstanceCounter) window.pokemonInstanceCounter = 0;
  clone.dataset.instanceId = ++window.pokemonInstanceCounter;
clone.dataset.set = set;
clone.dataset.num = num;

const act = owner === 'player1' ? p1Active : p2Active;
const bench = owner === 'player1' ? p1Bench : p2Bench;

let placedTo = 'bench';
let targetSlot = null;

if (!act.querySelector('img')) {
  targetSlot = act.querySelector('.card-slot');
  placedTo = 'active';
} else {
  
  const empty = [...bench.querySelectorAll('.card-slot')].find(s => !s.querySelector('img'));
  if (!empty) {
    showPopup('Bench full.');
    return;
  }
  targetSlot = empty;
  placedTo = 'bench';
}

if (placedTo === 'active') {
  const slot = act.querySelector('.card-slot');
  slot.innerHTML = '';
  slot.appendChild(clone);
  markSlot(slot, true);
  
  
  if (targetSlot) {
    animateSlideFromHand(e.target, targetSlot, clone);
  }
  
  
  const playerNum = owner === 'player1' ? 1 : 2;
  updatePlayerTypeBackground(playerNum);
} else {
  const empty = [...bench.querySelectorAll('.card-slot')].find(s => !s.querySelector('img'));
  empty.innerHTML = '';
  empty.appendChild(clone);
  markSlot(empty, true);
  
  
  if (targetSlot) {
    animateSlideFromHand(e.target, targetSlot, clone);
  }
}

removeFromHand(owner, set, num);

try {
  const baseHp = parseInt(meta.hp || '0', 10) || 0;
  setHpOnImage(clone, baseHp, baseHp);
} catch {}

renderAllHands();

logEvent({
  player: owner,
  text: `Played Basic Pokmon to ${placedTo === 'active' ? 'Active' : 'Bench'}: ${meta.name}.`,
  cardSet: set,
  cardNum: num
});
  
});

async function showAttackMenuFor(cardImg, meta) {
  
  
  if (isRetreatSelection) {
    return;
  }

  closeAttackMenu();

  const slot = cardImg.closest('.card-slot');

  if (!slot || !cardImg || !meta) {
    return;
  }
  
  const activeDiv = cardImg.closest('.active, .bench');
  
  const pk = currentPlayer === 'player1' ? 'p1' : 'p2';
  const ownerKey = pk;  
  const abilityRows = window.ABILITY_EFFECT_ROWS || [];
  const cardSet = cardImg.dataset.set;
  const cardNum = cardImg.dataset.num;
  const type0 = ((meta.types && meta.types[0]) || 'colorless').toLowerCase();
  
  const cardSlot = cardImg.closest('.card-slot');
  
  const menu = document.createElement('div');
  menu.className = 'attack-menu ptcgl-style';
  
  
  const timeSinceRetreat = Date.now() - lastRetreatTime;
  const delayForRetreat = (isRetreatSelection || timeSinceRetreat < 1000) ? 500 : 100;
  
  
  menu.addEventListener('click', (e) => {
    if (e.target === menu) {
      console.log('[MENU-CLOSE] Menu backdrop clicked, closing');
      e.stopPropagation();
      e.stopImmediatePropagation();
      if (typeof globalThis.setMenuJustClosed === 'function') {
        globalThis.setMenuJustClosed(true);
      }
      closeAttackMenu();
      console.log('[MENU-CLOSE] Menu closed via backdrop click');
      setTimeout(() => {
        if (typeof globalThis.setMenuJustClosed === 'function') {
          globalThis.setMenuJustClosed(false);
        }
      }, 150);
    }
  });
  
  
  if (cardSlot) {
    cardSlot.classList.add('menu-open');
  }
  
  const cardContainer = document.createElement('div');
  cardContainer.className = 'ptcgl-card-container';
  cardContainer.style.position = 'relative'; 
  
  const cardImgClone = document.createElement('img');
  cardImgClone.src = cardImg.src;
  cardImgClone.alt = meta.name || 'Pokemon';
  cardContainer.appendChild(cardImgClone);
  
  
  const toolData = getToolDataFromSlot(cardSlot);
  if (toolData && toolData.src) {
    const toolThumb = document.createElement('img');
    toolThumb.src = toolData.src;
    toolThumb.alt = 'Tool';
    toolThumb.style.cssText = `
      position: absolute;
      top: 120px;
      left: 8px;
      width: 80px;
      height: 112px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,.6);
      border: 1px solid #6e4e9c;
      background-color: #0b0f14;
      z-index: 10;
      object-fit: cover;
      object-position: center 15%;
      clip-path: inset(15% 5% 45% 5%);
      pointer-events: none;
    `;
    cardContainer.appendChild(toolThumb);
  }
  
  const closeBtn = document.createElement('button');
  closeBtn.className = 'ptcgl-close-btn';
  closeBtn.innerHTML = '';
  closeBtn.addEventListener('click', (e) => {
    console.log('[MENU-CLOSE] Close button clicked:', {
      target: e.target,
      cardImg: cardImg,
      timestamp: new Date().toISOString()
    });
    
    e.stopPropagation();
    e.stopImmediatePropagation();
    e.preventDefault();
    
    const cardRect = cardImg.getBoundingClientRect();
    const returnX = cardRect.left + cardRect.width / 2;
    const returnY = cardRect.top + cardRect.height / 2;
    
    menu.style.transition = 'all 0.25s ease-in';
    menu.style.left = returnX + 'px';
    menu.style.top = returnY + 'px';
    menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
    menu.style.opacity = '0';
    
    setTimeout(() => {
      console.log('[MENU-CLOSE] Calling closeAttackMenu');
      closeAttackMenu();
      console.log('[MENU-CLOSE] closeAttackMenu completed');
    }, 500);  
  });
  cardContainer.appendChild(closeBtn);
  
  const modifiedMaxHp = cardSlot?.dataset.maxHp ? parseInt(cardSlot.dataset.maxHp, 10) : null;
  const baseHp = parseInt(cardImg.dataset.hp || meta.hp || '0', 10);
  const maxHp = modifiedMaxHp || baseHp;
  const chp = parseInt(cardImg.dataset.chp || maxHp || '0', 10);
  
  const hpTypeBar = document.createElement('div');
  hpTypeBar.className = 'ptcgl-hp-type-bar';
  
  
  const hpStyle = modifiedMaxHp ? 'color: #22c55e; font-weight: 700;' : '';
  
  hpTypeBar.innerHTML = `
    <span class="ptcgl-hp-number" style="${hpStyle}">${chp} / ${maxHp}</span>
    <div class="ptcgl-type-icon-inline" style="background-image: url('${energyIconUrl(type0)}')"></div>
  `;
  cardContainer.appendChild(hpTypeBar);
  
  const energyPipsContainer = document.createElement('div');
  energyPipsContainer.className = 'ptcgl-energy-pips';

  
  if (cardSlot) {
    const energyBox = cardSlot.querySelector('.energy-pips');
    
    if (energyBox) {
      const energyPips = energyBox.querySelectorAll('.energy-pip');
      
      energyPips.forEach(pip => {
        const pipClone = document.createElement('div');
        pipClone.className = 'ptcgl-energy-pip';
        const energyType = pip.dataset.type || 'colorless';
        pipClone.style.backgroundImage = `url('${energyIconUrl(energyType)}')`;
        pipClone.dataset.type = energyType;
        energyPipsContainer.appendChild(pipClone);
      });
    }
  }
  
  if (energyPipsContainer.children.length > 0) {
    cardContainer.appendChild(energyPipsContainer);
  } else {
  }
  
  const actionsOverlay = document.createElement('div');
  actionsOverlay.className = 'ptcgl-actions-overlay';
  
  
  
  const allAbilityRows = abilityRows.filter(r => {
    const matches = r.set === cardSet &&
      String(r.number).padStart(3, '0') === String(cardNum).padStart(3, '0');
    
    return matches;
  });
  
  allAbilityRows.forEach(abilityRow => {
    const isPassive = abilityRow.abilityType === 'passive';
    
    
    const isUnlimited = 
      (abilityRow.param2 && abilityRow.param2.toLowerCase() === 'unlimited') ||
      (abilityRow.text && /as often as you like/i.test(abilityRow.text));
    
    const usedMap = window.usedAbilitiesThisTurn;
    usedMap[ownerKey] = usedMap[ownerKey] || {};
    
    
    const pokemonImg = cardImg;
    const cardKey = getAbilityCardKey(abilityRow.set, abilityRow.number, pokemonImg);
    const alreadyUsed = !isUnlimited && !!usedMap[ownerKey][cardKey];

    const abilityBox = document.createElement('div');
    abilityBox.className = 'ptcgl-ability-overlay';
    
    
    const pokemonType = (type0 || 'colorless').toLowerCase();
    abilityBox.classList.add(`type-${pokemonType}`);
    
    
    if (isPassive) {
      abilityBox.classList.add('passive-ability');
      abilityBox.style.opacity = '1';  
      abilityBox.style.pointerEvents = 'none';
      abilityBox.style.cursor = 'default';
    } else if (alreadyUsed) {
      abilityBox.classList.add('used');
      abilityBox.style.pointerEvents = 'none';
      abilityBox.style.opacity = '0.5';
      abilityBox.style.cursor = 'not-allowed';
    }

    const abilityHeader = document.createElement('div');
    abilityHeader.className = 'ptcgl-ability-header';
    
    const abilityLeft = document.createElement('div');
    abilityLeft.className = 'ptcgl-ability-left';
    
    
    const labelText = isPassive ? 'PASSIVE' : 'ABILITY';
    abilityLeft.innerHTML = `
      <img src="${ABILITY_BADGE}" style="width:60px"  />      
      <span class="ptcgl-ability-name">${abilityRow.abilityName || 'Ability'}</span>
    `;
    
    abilityHeader.appendChild(abilityLeft);
    abilityBox.appendChild(abilityHeader);
    
    const abilityText = document.createElement('div');
    abilityText.className = 'ptcgl-ability-text';
    abilityText.textContent = abilityRow.text || '';
    abilityBox.appendChild(abilityText);
    
    
    if (!isPassive && !alreadyUsed) {
      abilityBox.addEventListener('click', async (e) => {
        e.stopPropagation();
        e.preventDefault();
        
        
        if (!isUnlimited && usedMap[ownerKey]?.[cardKey]) {
          showPopup('This ability has already been used this turn.');
          return;
        }
        
        
        if (!isUnlimited) {
          if (!usedMap[ownerKey]) usedMap[ownerKey] = {};
          usedMap[ownerKey][cardKey] = true;
          
          
          abilityBox.classList.add('used');
          abilityBox.style.pointerEvents = 'none';
          abilityBox.style.opacity = '0.5';
          abilityBox.style.cursor = 'not-allowed';
        }
        
        
        abilityJustUsed = true;
        
        
        if (typeof closeAttackMenu === 'function') {
          closeAttackMenu();
        }
        
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
        
        await applyAbilityEffect(abilityRow, ownerKey, pokemonImg);
        
        
        setTimeout(() => {
          abilityJustUsed = false;
        }, 300);
      });
    }

    actionsOverlay.appendChild(abilityBox);
  });
  
  const isFossil = cardImg.dataset.isFossil === 'true';
  
  if (isFossil) {
    
    const discardBox = document.createElement('div');
    discardBox.className = 'ptcgl-attack-overlay payable';
    discardBox.classList.add('type-colorless'); 
    
    const discardHeader = document.createElement('div');
    discardHeader.className = 'ptcgl-attack-header';
    
    const discardLeft = document.createElement('div');
    discardLeft.className = 'ptcgl-attack-left';
    
    const discardName = document.createElement('span');
    discardName.className = 'ptcgl-attack-name type-colorless';
    discardName.textContent = 'Discard';
    
    discardLeft.appendChild(discardName);
    discardHeader.appendChild(discardLeft);
    discardBox.appendChild(discardHeader);
    
    const discardEffect = document.createElement('div');
    discardEffect.className = 'ptcgl-attack-effect';
    discardEffect.textContent = 'Discard this Fossil from play. Does not give opponent a point.';
    discardBox.appendChild(discardEffect);
    
    
    discardBox.addEventListener('click', async () => {
      closeAttackMenu();
      
      
      const isActive = !!cardImg.closest('#p1Active, #p2Active');
      
      
      if (globalThis.discardPokemon) {
        await globalThis.discardPokemon(cardImg, pk, false); 
      } else {
        
        slot.innerHTML = '';
        globalThis.markSlot?.(slot, false);
      }
      
      showPopup(`${meta.name} was discarded.`);
      
      
      if (isActive) {
        const benchDiv = pk === 'p1' ? p1Bench : p2Bench;
        const benchImgs = Array.from(benchDiv?.querySelectorAll('img') ?? []);
        
        if (benchImgs.length === 0) {
          
          const winner = pk === 'p1' ? 'player2' : 'player1';
          showVictory(winner, 'Opponent has no Pokmon left!');
          return;
        }
        
        
        if (globalThis.promoteFromBench) {
          await globalThis.promoteFromBench(null, pk); 
        }
      }
    });
    
    actionsOverlay.appendChild(discardBox);
  }
  
  let attacks = meta.attacks || [];
  

  
  if (toolData && toolData.set && toolData.num) {
    try {
      const toolCardId = csvIdFor(toolData.set, toolData.num);
      
      const toolEffect = TRAINER_EFFECT_DATA.find(x => x.id === toolCardId);
      
      if (toolEffect?.effect_type === 'use_previous_evolution_attacks') {
        
        
        async function buildEvolutionChain(currentMeta, owner, visited = new Set(), skipFirstLevel = false) {
          const chain = [];
          const currentKey = `${currentMeta.id || currentMeta.name}`;
          if (visited.has(currentKey)) return chain; 
          visited.add(currentKey);
          
          
          let evolveFrom = currentMeta.evolvesFrom || currentMeta.evolveFrom || [];
          
          
          if (typeof evolveFrom === 'string' && evolveFrom.trim()) {
            const evolveFromLower = evolveFrom.toLowerCase();
            const matchingCards = [];
            
            
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
            const pokemonInPlay = [
              ...(activeDiv?.querySelectorAll('img') || []),
              ...(benchDiv?.querySelectorAll('img') || [])
            ];
            
            for (const pokemonImg of pokemonInPlay) {
              const pokemonName = (pokemonImg.alt || '').toLowerCase();
              
              if (pokemonName === evolveFromLower) {
                const set = pokemonImg.dataset.set;
                const num = pokemonImg.dataset.num;
                if (set && num) matchingCards.push({ set, number: num });
              }
            }
            
            if (matchingCards.length === 0) {
              const hand = playerState[owner]?.hand || [];
              for (const card of hand) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  matchingCards.push({ set: card.set, number: card.number || card.num });
                }
              }
            }
            
            if (matchingCards.length === 0) {
              const deck = playerState[owner]?.deck || [];
              for (const card of deck) {
                try {
                  const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                  const cardName = (cardMeta.name || '').toLowerCase();
                  
                  if (cardMeta.category === 'Pokemon' && cardName === evolveFromLower) {
                    matchingCards.push({ set: card.set, number: card.number || card.num });
                  }
                } catch {}
              }
            }
            
            if (matchingCards.length === 0) {
              const discard = playerState[owner]?.discard?.cards || [];
              for (const card of discard) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  
                  try {
                    const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                    if (cardMeta && cardMeta.category === 'Pokemon' && cardMeta.name && cardMeta.name.toLowerCase() === evolveFromLower) {
                      matchingCards.push({ set: card.set, number: card.number || card.num });
                    }
                  } catch (err) {
                  }
                }
              }
            }
            
            if (matchingCards.length === 0) {
              
              const commonSets = ['A1', 'A1a', 'A2', 'A2a', 'A2b', 'A3', 'A3a', 'A3b', 'A4', 'A4a'];
              for (const set of commonSets) {
                try {
                  const setResponse = await fetch(`https://api.tcgdex.net/v2/en/sets/${set}`);
                  if (!setResponse.ok) continue;
                  const setData = await setResponse.json();
                  if (setData?.cards) {
                    for (const card of setData.cards) {
                      const cardName = (card.name || '').toLowerCase();
                      if (cardName === evolveFromLower || cardName.includes(evolveFromLower) || evolveFromLower.includes(cardName)) {
                        const localId = card.localId || card.number;
                        if (localId) {
                          matchingCards.push({ set, number: localId });
                          break;
                        }
                      }
                    }
                  }
                  if (matchingCards.length > 0) break;
                } catch (err) {
                }
              }
            }
            
            evolveFrom = matchingCards;
          }
          
          
          if (Array.isArray(evolveFrom) && evolveFrom.length > 0) {
            for (const prevEvo of evolveFrom) {
              try {
                const prevEvoMeta = await fetchCardMeta(prevEvo.set, prevEvo.number);
                if (prevEvoMeta) {
                  
                  if (!skipFirstLevel) {
                    chain.push(prevEvoMeta);
                  } else {
                  }
                  
                  const deeperChain = await buildEvolutionChain(prevEvoMeta, owner, visited, false);
                  chain.push(...deeperChain);
                }
              } catch (err) {
                console.error(`[Memory Light Menu] Error fetching evolution ${prevEvo.set}-${prevEvo.number}:`, err);
              }
            }
          }
          
          return chain;
        }
        
        
        const evolvedViaRareCandy = cardImg.dataset.evolvedViaRareCandy === 'true';
        
        
        let evolveFrom = meta.evolvesFrom || meta.evolveFrom || [];
        
        
        if (typeof evolveFrom === 'string' && evolveFrom.trim()) {
          
          try {
            const ownerDiv = cardImg.closest('#player1, #player2');
            const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
            const evolveFromLower = evolveFrom.toLowerCase();
            const matchingCards = [];
            
            
            const activeDiv = owner === 'player1' ? p1Active : p2Active;
            const benchDiv = owner === 'player1' ? p1Bench : p2Bench;
            const pokemonInPlay = [
              ...(activeDiv?.querySelectorAll('img') || []),
              ...(benchDiv?.querySelectorAll('img') || [])
            ];
            
            for (const pokemonImg of pokemonInPlay) {
              const pokemonName = (pokemonImg.alt || '').toLowerCase();
              if (pokemonName === evolveFromLower || pokemonName.includes(evolveFromLower) || evolveFromLower.includes(pokemonName)) {
                const set = pokemonImg.dataset.set;
                const num = pokemonImg.dataset.num;
                if (set && num) {
                  matchingCards.push({ set, number: num });
                }
              }
            }
            
            
            if (matchingCards.length === 0) {
              const hand = playerState[owner]?.hand || [];
              for (const card of hand) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  matchingCards.push({ set: card.set, number: card.number || card.num });
                }
              }
            }
            
            
            if (matchingCards.length === 0) {
              const deck = playerState[owner]?.deck || [];
              for (const card of deck) {
                try {
                  const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                  const cardName = (cardMeta.name || '').toLowerCase();
                  
                  if (cardMeta.category === 'Pokemon' && cardName === evolveFromLower) {
                    matchingCards.push({ set: card.set, number: card.number || card.num });
                  }
                } catch {}
              }
            }
            
            
            if (matchingCards.length === 0) {
              const discard = playerState[owner]?.discard?.cards || [];
              for (const card of discard) {
                const cardName = (card.name || '').toLowerCase();
                
                if (cardName === evolveFromLower) {
                  
                  try {
                    const cardMeta = await fetchCardMeta(card.set, card.number || card.num);
                    if (cardMeta && cardMeta.category === 'Pokemon' && cardMeta.name && cardMeta.name.toLowerCase() === evolveFromLower) {
                      matchingCards.push({ set: card.set, number: card.number || card.num });
                    }
                  } catch (err) {
                  }
                }
              }
            }
            
            if (matchingCards.length > 0) {
              evolveFrom = matchingCards; 
            } else {

              try {
                
                const commonSets = ['A1', 'A1a', 'A2', 'A2a', 'A2b', 'A3', 'A3a', 'A3b', 'A4', 'A4a'];
                const evolveFromLower = evolveFrom.toLowerCase();
                
                for (const set of commonSets) {
                  try {
                    
                    const setResponse = await fetch(`https://api.tcgdex.net/v2/en/sets/${set}`);
                    if (!setResponse.ok) continue;
                    const setData = await setResponse.json();
                    if (setData?.cards) {
                      for (const card of setData.cards) {
                        const cardName = (card.name || '').toLowerCase();
                        if (cardName === evolveFromLower || cardName.includes(evolveFromLower) || evolveFromLower.includes(cardName)) {
                          const localId = card.localId || card.number;
                          if (localId) {
                            matchingCards.push({ set, number: localId });
                            break;
                          }
                        }
                      }
                    }
                    if (matchingCards.length > 0) break;
                  } catch (err) {
                  }
                }
                
                if (matchingCards.length > 0) {
                  evolveFrom = matchingCards;
                } else {
                  evolveFrom = [];
                }
              } catch (err) {
                console.error('[Memory Light Menu]  Error in API search:', err);
                evolveFrom = [];
              }
            }
          } catch (err) {
            console.error('[Memory Light Menu]  Error looking up evolution:', err);
            evolveFrom = [];
          }
        }
        
        
        
        const ownerDiv = cardImg.closest('#player1, #player2');
        const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
        const fullChain = await buildEvolutionChain(meta, owner, new Set(), evolvedViaRareCandy);
        
        if (fullChain.length > 0) {
          if (evolvedViaRareCandy) {
            
            const basicMeta = fullChain[fullChain.length - 1]; 
            if (basicMeta?.attacks) {
              attacks = [...attacks, ...basicMeta.attacks];
            } else {
            }
          } else {

            for (const prevEvoMeta of fullChain) {
              if (prevEvoMeta?.attacks) {
                attacks = [...attacks, ...prevEvoMeta.attacks];
              } else {
              }
            }
          }
        } else {
        }
      } else {
      }
    } catch (err) {
      console.error('[Memory Light Menu]  Error checking tool:', err);
    }
  } else {
  }

  
  
  for (const atk of attacks) {
    
    const isLocked = cardImg.dataset.lockedAttack === atk.name;
    
    
    let isMoveLocked = false;
    const instanceId = cardImg.dataset.instanceId;
    const moveName = atk.name?.toLowerCase();
    const currentTurn = globalThis.turnNumber || 0;

    
    if (instanceId && moveName && globalThis.__moveLocks?.[pk]?.[instanceId]?.[moveName]) {
      const moveLock = globalThis.__moveLocks[pk][instanceId][moveName];
      
      if (typeof moveLock === 'object' && moveLock.lockedOnTurn !== undefined) {
        
        isMoveLocked = currentTurn === moveLock.lockedOnTurn + 2;
      } else {
        
        isMoveLocked = moveLock === true;
      }
    } else {
    }
    
    
    const attackLock = globalThis.__specialEffects?.[pk]?.attackLock;
    let isAllAttacksLocked = false;
    if (attackLock) {
      const currentTurn = globalThis.turnNumber || 0;
      if (typeof attackLock === 'object' && attackLock.lockedOnTurn !== undefined) {
        isAllAttacksLocked = currentTurn === attackLock.lockedOnTurn + 2;
      } else if (attackLock === true) {
        isAllAttacksLocked = true; 
      }
    }
    
    
    let actualCost = atk.cost || [];
    if (typeof globalThis.getMoveRow === 'function') {
      try {
        const moveRow = globalThis.getMoveRow(cardImg.alt, atk.name);
        
        if (moveRow?.effect_type === 'reduce_energy_cost_if_damaged') {
          
          const maxHp = parseInt(cardImg.dataset.hp || '0', 10);
          const curHp = parseInt(cardImg.dataset.chp || maxHp, 10);
          if (curHp < maxHp) {
            
            const reduceAmount = parseInt(moveRow.param1 || '1', 10);
            
            actualCost = [...actualCost];
            for (let i = 0; i < reduceAmount && actualCost.length > 0; i++) {
              actualCost.pop(); 
            }
          }
        }
      } catch (err) {
        console.error('[reduce_energy_cost_if_damaged] Error:', err);
      }
    }
    
    const pips = countPipsOn(slot);
    
    const canPay = !isLocked && !isMoveLocked && !isAllAttacksLocked && canPayCostFromAPI(slot, actualCost, cardImg);

    const attackBox = document.createElement('div');
    attackBox.className = 'ptcgl-attack-overlay';
    
    
    if (isLocked || isMoveLocked || isAllAttacksLocked) {
      attackBox.classList.add('locked');
      attackBox.style.opacity = '0.5';
      attackBox.style.cursor = 'not-allowed';
      if (isMoveLocked) {
        attackBox.title = `This Pokmon can't use ${atk.name} this turn!`;
      } else if (isAllAttacksLocked) {
        attackBox.title = `This Pokmon can't attack this turn!`;
      }
    }
    
    
    const pokemonType = (type0 || 'colorless').toLowerCase();
    attackBox.classList.add('type-' + pokemonType);
    
    if (canPay) attackBox.classList.add('payable');
    
    const costHTML = actualCost.map(energyType => {
      const type = String(energyType).toLowerCase();
      return `<div class="ptcgl-cost-icon" style="background-image: url('${energyIconUrl(type)}')"></div>`;
    }).join('');

    const attackHeader = document.createElement('div');
    attackHeader.className = 'ptcgl-attack-header';
    
    const attackLeft = document.createElement('div');
    attackLeft.className = 'ptcgl-attack-left';
    
    const attackName = document.createElement('span');
    attackName.className = 'ptcgl-attack-name';
    attackName.textContent = atk.name || 'Attack';
    
    
    if (canPay) {
      attackName.classList.add(`type-${type0.toLowerCase()}`);
    }
    
    
    const attackInfo = document.createElement('div');
    attackInfo.style.display = 'flex';
    attackInfo.style.alignItems = 'center';
    attackInfo.style.gap = '6px';
    
    attackInfo.appendChild(attackName);
    
    const attackCost = document.createElement('div');
    attackCost.className = 'ptcgl-attack-cost';
    attackCost.innerHTML = costHTML;
    attackInfo.appendChild(attackCost);
    
    attackLeft.appendChild(attackInfo);
    
    
    const damageBox = document.createElement('div');
    damageBox.className = 'ptcgl-attack-damage-box';
    
    const attackDamage = document.createElement('span');
    attackDamage.className = 'ptcgl-attack-damage';
    attackDamage.textContent = atk.damage || ''; 
    
    (async () => {
      try {
        const previewResult = await calculatePreviewDamage(atk, cardImg, meta, pk);
        let previewDamage = typeof previewResult === 'object' ? previewResult.damage : previewResult;
        
        if (typeof previewDamage === 'object') previewDamage = '';
        attackDamage.textContent = String(previewDamage || '');
        
        
        if (typeof previewResult === 'object') {
          
          attackDamage.style.setProperty('color', '', 'important');
          attackDamage.style.setProperty('text-shadow', '', 'important');
          
          if (previewResult.hasWeakness) {
            
            attackDamage.style.setProperty('color', '#22c55e', 'important');
            attackDamage.style.setProperty('text-shadow', '0 0 8px rgba(34, 197, 94, 0.6), 0 0 4px rgba(34, 197, 94, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else if (previewResult.hasOtherBoosts) {
            
            attackDamage.style.setProperty('color', '#fbbf24', 'important');
            attackDamage.style.setProperty('text-shadow', '0 0 8px rgba(251, 191, 36, 0.6), 0 0 4px rgba(251, 191, 36, 0.4), 0 1px 3px rgba(0,0,0,0.5)', 'important');
          } else {
            
            attackDamage.style.setProperty('color', '#000000', 'important');
            attackDamage.style.setProperty('text-shadow', '0 1px 3px rgba(0,0,0,0.5)', 'important');
          }
        }
      } catch (err) {
        console.error('[preview] Error calculating damage:', err);
        
      }
    })();
    damageBox.appendChild(attackDamage);
    
    attackLeft.appendChild(damageBox);
    
    attackHeader.appendChild(attackLeft);
    
    attackBox.appendChild(attackHeader);

    if (atk.effect) {
      const attackEffect = document.createElement('div');
      attackEffect.className = 'ptcgl-attack-effect';
      attackEffect.textContent = atk.effect;
      attackBox.appendChild(attackEffect);
    }
    
    if (canPay) {
      attackBox.addEventListener('click', () => {
        handleAttackClick(atk, meta, ownerKey, activeDiv);
        closeAttackMenu();
      });
    }

    actionsOverlay.appendChild(attackBox);
  }
  
  cardContainer.appendChild(actionsOverlay);
  
  const retreatCost = computeRetreatCost(activeDiv, meta);
  const pips = countPipsOn(slot);
  
  
  const retreatAllowed = typeof canRetreat === 'function' ? canRetreat(pk) : true;
  const canPayCost = !isFossil && pips.total >= retreatCost && !hasRetreatedThisTurn;
  const canRetreatFinal = retreatAllowed && canPayCost;

  const retreatCorner = document.createElement('div');
  retreatCorner.className = 'ptcgl-retreat-corner';
  if (!canRetreatFinal) retreatCorner.classList.add('disabled');
  
  
  if (isFossil) {
    retreatCorner.title = "Fossils cannot retreat";
  }
  
  
  if (!retreatAllowed && !isFossil) {
    const activeImg = activeDiv.querySelector('img');
    const st = (activeImg?.dataset.status || '').toLowerCase();
    if (st === 'asleep') {
      retreatCorner.title = "Can't retreat - Pokmon is asleep";
    } else if (st === 'paralyzed') {
      retreatCorner.title = "Can't retreat - Pokmon is paralyzed";
    } else {
      retreatCorner.title = "Can't retreat - Pokmon is locked";
    }
  }
  
  
  if (canRetreatFinal) {
    const mainType = (meta.types && meta.types[0]) ? String(meta.types[0]).toLowerCase() : null;
    if (mainType) {
      retreatCorner.setAttribute('data-type', mainType);
    }
  }

  const costIcons = Array(retreatCost).fill(0).map(() => 
    `<div class="ptcgl-cost-icon" style="background-image: url('${energyIconUrl('colorless')}')"></div>`
  ).join('');

  retreatCorner.innerHTML = `
    <div class="ptcgl-retreat-label">Retreat</div>
    <div class="ptcgl-retreat-cost">${costIcons}</div>
    <div class="ptcgl-retreat-icon"></div>
  `;
  
  if (canRetreatFinal) {
    retreatCorner.addEventListener('click', () => {
      handleRetreat(activeDiv, meta, retreatCost);
      
    });
  }

  cardContainer.appendChild(retreatCorner);
  
  if (meta.weaknesses && meta.weaknesses.length > 0) {
    const wk = meta.weaknesses[0];
    const wkType = String(wk.type || '').toLowerCase();
    const weaknessCorner = document.createElement('div');
    weaknessCorner.className = 'ptcgl-weakness-corner';
    weaknessCorner.innerHTML = `
      <span class="ptcgl-weakness-label">WEAKNESS</span>
      <div class="ptcgl-weakness-icon" style="background-image: url('${energyIconUrl(wkType)}')"></div>
      <span class="ptcgl-weakness-value">${wk.value || '2'}</span>
    `;
    cardContainer.appendChild(weaknessCorner);
  }

  menu.appendChild(cardContainer);
  
  document.body.appendChild(menu);

  let closeHandlerActive = false;
    const closeOnClickOutside = (e) => {
    if (closeHandlerActive) {
      console.log('[MENU-CLOSE] Handler already processing, ignoring duplicate call');
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      return;
    }
    
    if (!menu.contains(e.target) && !e.target.closest('.attack-menu')) {
        if (abilityJustUsed) {
        return;
      }
      
      closeHandlerActive = true;
      
      const clickedCardSlot = e.target.closest('.card-slot');
      const clickedCardImg = clickedCardSlot?.querySelector('img');
      const isClickingOnSameCard = clickedCardImg === cardImg;
      
      console.log('[MENU-CLOSE] Click outside menu detected, closing:', {
        target: e.target,
        clickedCardSlot: !!clickedCardSlot,
        clickedCardImg: !!clickedCardImg,
        isClickingOnSameCard: isClickingOnSameCard,
        cardImg: cardImg,
        cardImgStillExists: !!cardImg?.parentElement,
        timestamp: new Date().toISOString()
      });
      
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      
      if (isClickingOnSameCard) {
        console.log('[MENU-CLOSE] Clicked on same card, just closing menu without further action');
      }
      
      if (!cardImg || !cardImg.parentElement) {
        console.error('[MENU-CLOSE] Card image no longer exists! Cannot close menu properly.');
        closeHandlerActive = false;
          return;
        }
        
      document.removeEventListener('click', closeOnClickOutside, true);
        
        if (!cardImg || !cardImg.parentElement) {
          console.error('[MENU-CLOSE] Card image no longer exists! Cannot close menu properly.');
          closeHandlerActive = false;
          return;
        }
        
        const cardRect = cardImg.getBoundingClientRect();
        const returnX = cardRect.left + cardRect.width / 2;
        const returnY = cardRect.top + cardRect.height / 2;
        
        menu.style.willChange = 'transform, opacity, left, top';
        menu.style.transition = 'all 0.25s cubic-bezier(0.4, 0, 0.2, 1)';
        menu.style.left = returnX + 'px';
        menu.style.top = returnY + 'px';
        menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
        menu.style.opacity = '0';
        
        setTimeout(() => {
          menu.style.willChange = 'auto';
          console.log('[MENU-CLOSE] About to call closeAttackMenu, cardImg still exists:', !!cardImg?.parentElement);
          if (typeof globalThis.setMenuJustClosed === 'function') {
            globalThis.setMenuJustClosed(true);
          }
          closeAttackMenu();
          console.log('[MENU-CLOSE] closeAttackMenu completed, cardImg still exists:', !!cardImg?.parentElement);
          setTimeout(() => {
            if (typeof globalThis.setMenuJustClosed === 'function') {
              globalThis.setMenuJustClosed(false);
            }
            closeHandlerActive = false;
          }, 150);
        }, 250);
      }
    };
    
    
    menu._clickOutsideHandler = closeOnClickOutside;
    setTimeout(() => {
      document.addEventListener('click', closeOnClickOutside, true);
  }, delayForRetreat);  
  
  const cardRect = cardImg.getBoundingClientRect();
  const startX = cardRect.left + cardRect.width / 2;
  const startY = cardRect.top + cardRect.height / 2;
  
  
  const targetX = window.innerWidth * 0.30;
  const targetY = window.innerHeight * 0.50;
  
  
  menu.style.position = 'fixed';
  menu.style.left = startX + 'px';
  menu.style.top = startY + 'px';
  menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
  menu.style.opacity = '0';
  
  
  void menu.offsetHeight;
  
  
  menu.style.willChange = 'transform, opacity, left, top';
  requestAnimationFrame(() => {
    menu.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
    
    
    requestAnimationFrame(() => {
      
      menu.style.left = targetX + 'px';
      menu.style.top = targetY + 'px';
      menu.style.transform = 'translate(-50%, -50%) scale(1)';
      menu.style.opacity = '1';
      menu.classList.add('show');
      
      
      setTimeout(() => {
        
        menu.style.position = 'fixed';
        menu.style.left = targetX + 'px';
        menu.style.top = targetY + 'px';
        menu.style.willChange = 'auto';
      }, 350);
    });
  });

  openAttackMenu = menu;
  globalThis.openAttackMenu = menu;
  
  
  const escapeHandler = (e) => {
    if (e.key === 'Escape') {
      
      const cardRect = cardImg.getBoundingClientRect();
      const returnX = cardRect.left + cardRect.width / 2;
      const returnY = cardRect.top + cardRect.height / 2;
      
      menu.style.transition = 'all 0.25s ease-in';
      menu.style.left = returnX + 'px';
      menu.style.top = returnY + 'px';
      menu.style.transform = 'translate(-50%, -50%) scale(0.3)';
      menu.style.opacity = '0';
      
      setTimeout(() => {
        if (typeof globalThis.setMenuJustClosed === 'function') {
          globalThis.setMenuJustClosed(true);
        }
        closeAttackMenu();
        document.removeEventListener('keydown', escapeHandler);
        setTimeout(() => {
          if (typeof globalThis.setMenuJustClosed === 'function') {
            globalThis.setMenuJustClosed(false);
          }
        }, 150);
      }, 250);
    }
  };
  document.addEventListener('keydown', escapeHandler);
  menu._escapeHandler = escapeHandler;
}


const zoomStatus = document.getElementById("zoomStatus");

document.body.addEventListener('click',async e=>{
  if(!isEvoMode)return;
  
  const target=e.target.closest('img.glow-evo') || (e.target.classList.contains('glow-evo') ? e.target : null);
  
  if(target){
    e.stopPropagation();
    e.stopImmediatePropagation();
    e.preventDefault();
    await evolveCard(target,evoMeta,evoHandCard,evoOwner,evoHandCard.dataset.set,evoHandCard.dataset.num);
    clearGlow();
    return;
  }
  
  const isClickOnModal = e.target.closest('#zoomBackdrop') || 
                         e.target.closest('.attack-menu') || 
                         e.target.closest('#handBackdrop') || 
                         e.target.closest('#toolBackdrop');
  
  if(isClickOnModal)return;
  
  const isClickOnHand = e.target.closest('.hand');
  if(isClickOnHand)return;
  
  const isClickOnButton = e.target.tagName === 'BUTTON' || e.target.closest('button');
  if(isClickOnButton)return;
  
  e.stopPropagation();
  e.preventDefault();
  clearGlow();
  showPopup('Evolution cancelled.');
}, true);

document.addEventListener('keydown', e => {
  if(!isEvoMode)return;
  if(e.key === 'Escape'){
    e.preventDefault();
  e.stopPropagation();
  clearGlow();
    showPopup('Evolution cancelled.');
  }
});

globalThis.abilityCache = {};

if (window.ABILITY_EFFECT_ROWS) {
  populateAbilityCache();
} else {
  let retries = 0;
  const maxRetries = 20;
  const retryInterval = setInterval(() => {
    retries++;
    if (populateAbilityCache()) {
      clearInterval(retryInterval);
    } else if (retries >= maxRetries) {
      clearInterval(retryInterval);
    }
  }, 500);
}

function triggerNightmareAura(pokemonImg, energyType) {
  if (!pokemonImg || !energyType) return;
  
  const aura = globalThis.getPassiveAbility?.(pokemonImg, 'damage_on_energy_attach');
  if (!aura) return;
  
  const triggerType = (aura.param1 || '').toLowerCase();
  const damage = parseInt(aura.param2 || '0', 10);
  
  if (energyType.toLowerCase() === triggerType) {
    
    
    const ownerDiv = pokemonImg.closest('#player1, #player2');
    const owner = ownerDiv?.id === 'player1' ? 'player1' : 'player2';
    const opponent = owner === 'player1' ? 'player2' : 'player1';
    
    setTimeout(async () => {
      const result = await damageActiveOf(opponent, damage, { isDirectAttack: false });
      showPopup(`Nightmare Aura: ${damage} damage!`);
      
      
      if (result.knocked && typeof handleKnockOut === 'function') {
        const oppImg = getActiveImage(opponent);
        if (oppImg) {
          const gameEnded = await handleKnockOut(opponent, oppImg, true);
          if (!gameEnded && typeof beginPromotionFlow === 'function') {
            await beginPromotionFlow(opponent);
          }
        }
      }
    }, 300);
  }
}


globalThis.getActiveImg = getActiveImg;
globalThis.getPassiveDamageReduction = getPassiveDamageReduction;
globalThis.getCounterattackDamage = getCounterattackDamage;

function detachAttachments(slot){
  if (!slot) return { energy: null, hp: null, toolThumb: null, toolData: null, maxHp: null };
  const energy    = slot.querySelector('.energy-pips');
  const hp        = slot.querySelector('.hp-overlay');
  const toolThumb = slot.querySelector('.tool-thumb');

  if (energy)    energy.remove();
  if (hp)        hp.remove();
  if (toolThumb) toolThumb.remove();

  const toolData = getToolDataFromSlot(slot);
  if (toolData) setToolDataOnSlot(slot, null);
  
  
  const maxHp = slot.dataset.maxHp || null;
  if (maxHp) delete slot.dataset.maxHp;

  return { energy, hp, toolThumb, toolData, maxHp };
}
globalThis.detachAttachments = detachAttachments;

function attachAttachments(slot, pack){
  if (!slot || !pack) return;
  const { energy, hp, toolThumb, toolData, maxHp } = pack;
  if (energy)    slot.appendChild(energy);
  if (hp)        slot.appendChild(hp);
  if (toolThumb) slot.appendChild(toolThumb);
  if (toolData)  setToolDataOnSlot(slot, toolData);
  
  
  if (maxHp) {
    slot.dataset.maxHp = maxHp;
  } else {
    
    delete slot.dataset.maxHp;
  }
}
globalThis.attachAttachments = attachAttachments;

function beginPromotionFlow(owner){
  return new Promise((resolve) => {
  isPromotionPhase = true;

  const benchImgs = [...benchFor(owner).querySelectorAll('img')];
  if (!benchImgs.length) {
    const foe = owner === 'player1' ? 'player2' : 'player1';
    showVictory(foe, 'Bench out');
    isPromotionPhase = false;
      resolve();
    return;
  }

  benchImgs.forEach(img => img.classList.add('promote-glow'));
  showPopup('Choose a Benched Pokmon to promote.');

  const clickOnce = (e) => {
    console.log('[PROMOTION-CLICK] Click detected:', {
      isPromotionPhase: isPromotionPhase,
      target: e.target,
      isModal: !!(e.target.closest('#zoomBackdrop') || e.target.closest('.attack-menu') || e.target.closest('#handBackdrop') || e.target.closest('#toolBackdrop')),
      timestamp: new Date().toISOString()
    });
    
    if (!isPromotionPhase) {
      console.log('[PROMOTION-CLICK] Not in promotion phase, ignoring');
      return;
    }
    
    if (e.target.closest('#zoomBackdrop') || e.target.closest('.attack-menu') || e.target.closest('#handBackdrop') || e.target.closest('#toolBackdrop')) {
      console.log('[PROMOTION-CLICK] Click on modal, ignoring');
      return;
    }
    
    const forcedImg = globalThis.__forcedPromotion;
    let chosenImg;
    
    if (forcedImg) {
      
      chosenImg = forcedImg;
      globalThis.__forcedPromotion = null;
    } else {
      
      chosenImg = e.target.closest(`#${owner} .bench img`);
      console.log('[PROMOTION-CLICK] Looking for bench img:', {
        chosenImg: chosenImg,
        target: e.target,
        owner: owner,
        selector: `#${owner} .bench img`
      });
      if (!chosenImg) {
        console.log('[PROMOTION-CLICK] No bench img found, stopping propagation and ignoring click');
        e.stopPropagation();
        e.stopImmediatePropagation();
        return;
      }
      console.log('[PROMOTION-CLICK] Found bench img, proceeding with promotion');
    }

    e.stopPropagation();
    document.body.removeEventListener('click', clickOnce, true);

    const activeDiv  = activeFor(owner);
    const activeSlot = activeDiv.querySelector('.card-slot');
    const benchSlot  = chosenImg.closest('.card-slot');
    const activeImg  = activeSlot.querySelector('img');

    if (activeImg) {
      clearStatusOnImg(activeImg);
    }
    
    if (!activeImg) {
      const benchPack = detachAttachments(benchSlot);
        
        const chosenRect = chosenImg.getBoundingClientRect();

      benchSlot.removeChild(chosenImg);
      activeSlot.appendChild(chosenImg);
        
        
        animateSlideSwap(chosenImg, activeSlot, chosenImg, chosenRect);

      attachAttachments(activeSlot, benchPack);

      markSlot(activeSlot, true);
      markSlot(benchSlot, !!benchSlot.querySelector('img'));

      benchImgs.forEach(x => x.classList.remove('promote-glow'));
      isPromotionPhase = false;

      showPopup(forcedImg ? 'Forced to Active.' : 'Promoted to Active.');
      
      const playerNum = activeDiv === p1Active ? 1 : 2;
      updatePlayerTypeBackground(playerNum);
        resolve();
      return;
    }

    
      
      const activeInstanceId = activeImg.dataset.instanceId;
      const ownerPk = owner === 'player1' ? 'p1' : 'p2';
      if (activeInstanceId && globalThis.__moveLocks?.[ownerPk]?.[activeInstanceId]) {
        delete globalThis.__moveLocks[ownerPk][activeInstanceId];
      }
      
    const activePack = detachAttachments(activeSlot);
    const benchPack  = detachAttachments(benchSlot);
      
      const activeRect = activeImg.getBoundingClientRect();
      const chosenRect = chosenImg.getBoundingClientRect();

    console.log('[PROMOTION-CLICK] Swapping active and bench Pokemon');
    activeSlot.removeChild(activeImg);
    benchSlot.removeChild(chosenImg);

    activeSlot.appendChild(chosenImg);
    benchSlot.appendChild(activeImg);
    console.log('[PROMOTION-CLICK] Swap completed');
      
      
      animateSlideSwap(activeImg, benchSlot, activeImg, activeRect);
      animateSlideSwap(chosenImg, activeSlot, chosenImg, chosenRect);

    attachAttachments(activeSlot, benchPack);
    attachAttachments(benchSlot, activePack);

    markSlot(activeSlot, true);
    markSlot(benchSlot, !!benchSlot.querySelector('img'));

    benchImgs.forEach(x => x.classList.remove('promote-glow'));
    isPromotionPhase = false;

    showPopup(forcedImg ? 'Forced to Active.' : 'Promoted to Active.');
      
      const playerNum = activeDiv === p1Active ? 1 : 2;
      updatePlayerTypeBackground(playerNum);
      resolve();
  };

  document.body.addEventListener('click', clickOnce, true);
  });
}

globalThis.benchFor           = benchFor;
globalThis.activeFor          = activeFor;
globalThis.beginPromotionFlow = beginPromotionFlow;
globalThis.fetchCardMeta      = fetchCardMeta;
globalThis.ENERGY_ICONS       = ENERGY_ICONS;
globalThis.attachEnergyToSlot = attachEnergyToSlot;
globalThis.energyZoneDiv      = energyZoneDiv;
globalThis.renderEnergyZone   = renderEnergyZone;
globalThis.getActiveImage     = getActiveImage;
globalThis.applyAbilityEffectFromCsv = window.applyAbilityEffectFromCsv;

globalThis.evolveCard         = evolveCard;
globalThis.handleKnockOut     = handleKnockOut;
globalThis.damageActiveOf     = damageActiveOf;
globalThis.startTurn          = startTurn;

async function updatePlayerTypeBackground(playerNum) {
  const playerId = `player${playerNum}`;
  const playerDiv = document.getElementById(playerId);
  
  
  const activeDiv = playerNum === 1 ? p1Active : p2Active;
  const activeSlot = activeDiv?.querySelector('.card-slot');
  const activeImg = activeSlot?.querySelector('img');
  
  if (!playerDiv) return;
  
  
  if (!activeImg) {
    
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    
    const overlay = playerDiv.querySelector('.type-overlay');
    if (overlay) {
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 600);
    }
    return;
  }
  
  
  const set = activeImg.dataset.set;
  const num = activeImg.dataset.num;
  
  if (!set || !num) {
    
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    
    const overlay = playerDiv.querySelector('.type-overlay');
    if (overlay) {
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 600);
    }
    return;
  }
  
  try {
    
    const meta = await fetchCardMeta(set, num);
    
    
    let pokemonType = 'colorless';
    if (meta.types && meta.types[0]) {
      pokemonType = String(meta.types[0]).toLowerCase();
    }
    
    
    let overlay = playerDiv.querySelector('.type-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.className = 'type-overlay';
      overlay.style.position = 'absolute';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.right = '0';
      overlay.style.bottom = '0';
      overlay.style.borderRadius = '16px';
      overlay.style.pointerEvents = 'none';
      overlay.style.zIndex = '0';
      overlay.style.transition = 'opacity 0.6s ease';
      overlay.style.opacity = '0';
      
      playerDiv.insertBefore(overlay, playerDiv.firstChild);
    }
    
    
    const typeGradients = {
      grass: 'linear-gradient(180deg, rgba(34, 197, 94, 0.3) 0%, rgba(22, 163, 74, 0.5) 50%, rgba(21, 128, 61, 0.4) 100%)',
      fire: 'linear-gradient(180deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.5) 50%, rgba(185, 28, 28, 0.4) 100%)',
      water: 'linear-gradient(180deg, rgba(59, 130, 246, 0.3) 0%, rgba(37, 99, 235, 0.5) 50%, rgba(29, 78, 216, 0.4) 100%)',
      lightning: 'linear-gradient(180deg, rgba(234, 179, 8, 0.3) 0%, rgba(202, 138, 4, 0.5) 50%, rgba(161, 98, 7, 0.4) 100%)',
      psychic: 'linear-gradient(180deg, rgba(168, 85, 247, 0.3) 0%, rgba(147, 51, 234, 0.5) 50%, rgba(126, 34, 206, 0.4) 100%)',
      fighting: 'linear-gradient(180deg, rgba(249, 115, 22, 0.3) 0%, rgba(234, 88, 12, 0.5) 50%, rgba(194, 65, 12, 0.4) 100%)',
      darkness: 'linear-gradient(180deg, rgba(100, 116, 139, 0.3) 0%, rgba(71, 85, 105, 0.5) 50%, rgba(51, 65, 85, 0.4) 100%)',
      metal: 'linear-gradient(180deg, rgba(148, 163, 184, 0.3) 0%, rgba(100, 116, 139, 0.5) 50%, rgba(71, 85, 105, 0.4) 100%)',
      dragon: 'linear-gradient(180deg, rgba(211, 186, 48, 0.3) 0%, rgba(184, 158, 32, 0.5) 50%, rgba(169, 142, 28, 0.4) 100%)',
      fairy: 'linear-gradient(180deg, rgba(236, 72, 153, 0.3) 0%, rgba(219, 39, 119, 0.5) 50%, rgba(190, 24, 93, 0.4) 100%)',
      colorless: 'linear-gradient(180deg, rgba(156, 163, 175, 0.3) 0%, rgba(107, 114, 128, 0.5) 50%, rgba(75, 85, 99, 0.4) 100%)'
    };
    
    const typeShadows = {
      grass: '0 0 30px rgba(34, 197, 94, 0.3)',
      fire: '0 0 30px rgba(239, 68, 68, 0.3)',
      water: '0 0 30px rgba(59, 130, 246, 0.3)',
      lightning: '0 0 30px rgba(234, 179, 8, 0.3)',
      psychic: '0 0 30px rgba(168, 85, 247, 0.3)',
      fighting: '0 0 30px rgba(249, 115, 22, 0.3)',
      darkness: '0 0 30px rgba(100, 116, 139, 0.3)',
      metal: '0 0 30px rgba(148, 163, 184, 0.3)',
      dragon: '0 0 30px rgba(211, 186, 48, 0.3)',
      fairy: '0 0 30px rgba(236, 72, 153, 0.3)',
      colorless: '0 0 30px rgba(156, 163, 175, 0.3)'
    };
    
    const typeBorders = {
      grass: '1px solid rgba(34, 197, 94, 0.3)',
      fire: '1px solid rgba(239, 68, 68, 0.3)',
      water: '1px solid rgba(59, 130, 246, 0.3)',
      lightning: '1px solid rgba(234, 179, 8, 0.3)',
      psychic: '1px solid rgba(168, 85, 247, 0.3)',
      fighting: '1px solid rgba(249, 115, 22, 0.3)',
      darkness: '1px solid rgba(100, 116, 139, 0.3)',
      metal: '1px solid rgba(148, 163, 184, 0.3)',
      dragon: '1px solid rgba(211, 186, 48, 0.3)',
      fairy: '1px solid rgba(236, 72, 153, 0.3)',
      colorless: '1px solid rgba(156, 163, 175, 0.3)'
    };
    
    
    if (overlay.style.opacity !== '0') {
      overlay.style.opacity = '0';
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    
    overlay.style.background = typeGradients[pokemonType] || typeGradients.colorless;
    overlay.style.boxShadow = typeShadows[pokemonType] || typeShadows.colorless;
    overlay.style.border = typeBorders[pokemonType] || typeBorders.colorless;
    
    
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    playerDiv.classList.add(`type-${pokemonType}`);
    
    
    void overlay.offsetWidth;
    requestAnimationFrame(() => {
      overlay.style.opacity = '1';
    });
    
  } catch (error) {
    console.error('Error updating player background:', error);
    
    const typeClasses = Array.from(playerDiv.classList).filter(cls => cls.startsWith('type-'));
    typeClasses.forEach(cls => playerDiv.classList.remove(cls));
    
    const overlay = playerDiv.querySelector('.type-overlay');
    if (overlay) {
      overlay.style.opacity = '0';
      setTimeout(() => overlay.remove(), 600);
    }
  }
}

globalThis.updatePlayerTypeBackground = updatePlayerTypeBackground;

function updateAllPlayerBackgrounds() {
  updatePlayerTypeBackground(1);
  updatePlayerTypeBackground(2);
}
globalThis.updateAllPlayerBackgrounds = updateAllPlayerBackgrounds;

function drawOne(player){
  const d=playerState[player].deck,
        h=playerState[player].hand;
  if(!d.length) return false;
  
  
  const handDiv = player === 'player1' ? p1HandDiv : p2HandDiv;
  animateCardDraw(player, handDiv);
  
  h.push(d.shift());
  updateDeckBubbles();
  return true;
}

async function runStatusStartOfTurn(pk) {
  const img = getActiveImg(pk);
  if (!img) return;

  const status = (img.dataset.status || "").toLowerCase();
  
  if (status === "paralyzed") {
    clearStatus(pk);
    showPopup("The Active Pokmon is no longer paralyzed.", 1800);
  }
  
}

async function checkSleepEndOfTurn() {
  
  for (const pk of ['p1', 'p2']) {
    const img = getActiveImg(pk);
    if (!img) continue;
    
    const status = (img.dataset.status || "").toLowerCase();
    
    if (status === "asleep") {
      const pokemonName = img.alt || "Active Pokmon";
      showPopup(`${pokemonName} is asleep. Flipping coin...`, 2000);
      await new Promise(resolve => setTimeout(resolve, 500));
      
      
      coinEl.classList.add('flip');
      const isHeads = Math.random() < 0.5;
      const front = coinEl.querySelector('.front');
      const back = coinEl.querySelector('.back');
      
      await new Promise(resolve => setTimeout(() => {
        coinEl.classList.remove('flip');
        
        
        if (front && back) {
          if (isHeads) {
            front.style.transform = 'rotateY(0deg)';
            back.style.transform = 'rotateY(180deg)';
          } else {
            front.style.transform = 'rotateY(180deg)';
            back.style.transform = 'rotateY(0deg)';
          }
        }
        
        
        if (coinResult) {
          coinResult.textContent = isHeads ? "Heads" : "Tails";
        }
        
        resolve();
      }, 1500));
      
      if (isHeads) {
        clearStatus(pk);
        showPopup(`${pokemonName} woke up!`, 1800);
      } else {
        showPopup(`${pokemonName} is still asleep.`, 1800);
      }
      
      
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}

async function runStatusStartOfOpponentTurn(pk) {
    const opp = pk === "p1" ? "p2" : "p1";
    const img = getActiveImg(opp);
    if (!img) return;

    const status = (img.dataset.status || "").toLowerCase();

    const base = parseInt(img.dataset.hp || 0, 10);
    let cur = parseInt(img.dataset.chp || base, 10);

    if (status === "poisoned") {
        cur = Math.max(0, cur - 10);
        setHpOverlayForImg(img, base, cur);
        showPopup("Poison deals 10 damage!");
    }

    if (status === "burned") {
        cur = Math.max(0, cur - 20);
        setHpOverlayForImg(img, base, cur);
        showPopup("Burn deals 20 damage!");

        let flip = Math.random() < 0.5 ? "heads" : "tails";
        if (flip === "heads") {
            img.dataset.status = "";
            removeStatusMarker(img);
            showPopup("Burn was healed!");
        } else {
            showPopup("Burn remains.");
        }
    }

    if (cur <= 0) {
        await handleKnockout(opp);
    }
}

async function startTurn(player) {
  
  await checkSleepEndOfTurn();
  
  
  const previousPlayer = currentPlayer;
  const previousPk = previousPlayer === 'player1' ? 'p1' : 'p2';
  
  if (previousPlayer) {
    try {
      const prevActiveDiv = previousPlayer === 'player1' ? p1Active : p2Active;
      const prevBenchDiv = previousPlayer === 'player1' ? p1Bench : p2Bench;
      const prevPokemon = [
        ...(prevActiveDiv?.querySelectorAll('img') || []),
        ...(prevBenchDiv?.querySelectorAll('img') || [])
      ];
      
      
      const prevActiveImg = prevActiveDiv?.querySelector('img');
      if (prevActiveImg) {
        const cacheKey = `${prevActiveImg.dataset.set}-${prevActiveImg.dataset.num}`;
        const abilityRow = globalThis.abilityCache?.[cacheKey];
        
        if (abilityRow?.effect_type === 'heal_active_end_of_turn') {
          const effectState = {
            p1: playerState.player1,
            p2: playerState.player2
          };
          
          if (typeof applyAbilityEffectFromCsv === 'function') {
            await applyAbilityEffectFromCsv(effectState, previousPk, abilityRow, { 
              abilityPokemon: prevActiveImg 
            });
          }
        }
        
        
        const slot = prevActiveImg.closest('.card-slot');
        if (slot) {
          const tool = getToolDataFromSlot(slot);
          
          if (tool && tool.num === '067' && tool.set === 'A3b') {
            const maxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : parseInt(prevActiveImg.dataset.hp, 10);
            const curHp = parseInt(prevActiveImg.dataset.chp, 10);
            
            if (curHp < maxHp) {
              const healAmount = 10;
              const newHp = Math.min(maxHp, curHp + healAmount);
              prevActiveImg.dataset.chp = String(newHp);
              
              
              if (typeof setHpOnImage === 'function') {
                setHpOnImage(prevActiveImg, maxHp, newHp);
              }
              
              showPopup(`Leftovers: Healed 10 damage from ${prevActiveImg.alt}!`);
            }
          }
        }
      }
      
      
      if (globalThis.turnNumber === 1 || globalThis.turnNumber === 2) {
        
        let firstTurnPk, firstTurnPlayer;
        if (globalThis.turnNumber === 1) {
          
          firstTurnPlayer = firstPlayer || 'player1'; 
          firstTurnPk = firstTurnPlayer === 'player1' ? 'p1' : 'p2';
        } else {
          
          firstTurnPlayer = firstPlayer === 'player1' ? 'player2' : 'player1';
          firstTurnPk = firstTurnPlayer === 'player1' ? 'p1' : 'p2';
        }
        const firstTurnActiveDiv = firstTurnPlayer === 'player1' ? p1Active : p2Active;
        const firstTurnBenchDiv = firstTurnPlayer === 'player1' ? p1Bench : p2Bench;
        const activePokemon = firstTurnActiveDiv?.querySelectorAll('img') || [];
        const benchPokemon = firstTurnBenchDiv?.querySelectorAll('img') || [];
        const firstTurnPokemon = [...activePokemon, ...benchPokemon];
        
        
        for (const img of firstTurnPokemon) {
          
          const set = img.dataset.set;
          const num = img.dataset.num;
          const cacheKeyPadded = `${set}-${String(num).padStart(3, '0')}`; 
          const cacheKeyUnpadded = `${set}-${parseInt(num, 10)}`; 
          const cacheKey = `${set}-${num}`; 

          
          
          const abilityRow = globalThis.abilityCache?.[cacheKeyPadded] || 
                           globalThis.abilityCache?.[cacheKeyUnpadded] || 
                           globalThis.abilityCache?.[cacheKey];
          
          if (abilityRow?.effect_type === 'attach_energy_end_of_first_turn') {
            const effectState = {
              p1: playerState.player1,
              p2: playerState.player2
            };
            
            if (typeof applyAbilityEffectFromCsv === 'function') {
              await applyAbilityEffectFromCsv(effectState, firstTurnPk, abilityRow, { 
                abilityPokemon: img 
              });
            } else {
              console.error(`[Thunderclap Flash] applyAbilityEffectFromCsv is not a function!`);
            }
          } else {
          }
        }
      }
    } catch (err) {
      console.error('[startTurn] End of turn abilities failed:', err);
    }
  }
  
  globalThis.turnNumber++;

  logEvent({
    player,
    text: `Turn ${globalThis.turnNumber} started for ${player === 'player1' ? 'Player 1' : 'Player 2'}.`
  });

  const pk = player === 'player1' ? 'p1' : 'p2';
  
  
  if (!globalThis.__supporterPlayedThisTurn) globalThis.__supporterPlayedThisTurn = { p1: false, p2: false };
  globalThis.__supporterPlayedThisTurn[pk] = false;
  
  
  if (globalThis.__moveLocks?.[pk]) {
    const currentTurn = globalThis.turnNumber || 0;
    
    for (const instanceId in globalThis.__moveLocks[pk]) {
      for (const moveName in globalThis.__moveLocks[pk][instanceId]) {
        const lock = globalThis.__moveLocks[pk][instanceId][moveName];
        if (typeof lock === 'object' && lock.lockedOnTurn) {
          
          if (currentTurn > lock.lockedOnTurn + 2) {
            delete globalThis.__moveLocks[pk][instanceId][moveName];
          }
        }
      }
    }
  }
  
  
  clearExpiredEffectsOnTurnStart(previousPk);
  
  
  clearExpiredEffectsOnTurnStart(pk);
  
  
  if (typeof clearTurnEffects === 'function') {
    
    if (!globalThis.state) {
      globalThis.state = { temp: { p1: {}, p2: {} } };
    }
    clearTurnEffects(globalThis.state, previousPk);
  }
  
  
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.koLastTurn) globalThis.state.koLastTurn = {};
  
  
  if (globalThis.state.koLastTurn[pk]) {
    globalThis.state.koLastTurn[pk] = false;
  }

  currentPlayer = player;
  
  const state = playerState[player];
  const energyTypes = state.energyTypes || [];
  
  if (energyTypes.length > 1) {
    
    const oldNextTurnEnergy = state.nextTurnEnergy;
    
    
    if (oldNextTurnEnergy) {
      state.currentTurnEnergy = oldNextTurnEnergy;
    } else {
      
      state.currentTurnEnergy = selectRandomEnergy(energyTypes);
    }
    
    
    state.nextTurnEnergy = selectRandomEnergy(energyTypes);
    
  } else if (energyTypes.length === 1) {
    
    state.currentTurnEnergy = energyTypes[0];
    state.nextTurnEnergy = energyTypes[0];
  }
  
  
  renderEnergyZone();

  const turnLabel = `Turn ${globalThis.turnNumber}  ${player === 'player1' ? 'Player 1' : 'Player 2'}`;

  const bar = document.createElement("div");
  bar.className = "turn-bar";
  bar.innerHTML = `
      <div class="turn-icon">${globalThis.turnNumber}</div>
      ${turnLabel}
    `;
  if (logEntriesDiv.firstChild) {
    logEntriesDiv.insertBefore(bar, logEntriesDiv.firstChild);
  } else {
  logEntriesDiv.appendChild(bar);
  }

  
  hasAttachedEnergyThisTurn = false;
  globalThis.hasAttachedEnergyThisTurn = false;
  selectedEnergy = null;
  hasRetreatedThisTurn = false;
  closeAttackMenu();
  hasPlayedSupporterThisTurn[player] = false;

  resetDamageBoostsFor("player1");
  resetDamageBoostsFor("player2");
  
  
  window.usedAbilitiesThisTurn[pk] = {};
  
  if (!globalThis.state) globalThis.state = {};
  if (!globalThis.state.temp) globalThis.state.temp = {};
  if (!globalThis.state.temp[player]) globalThis.state.temp[player] = {};
  globalThis.state.temp[player].globalDamageBoost = 0;
  
  
  if (globalThis.state?.damageBoost?.[previousPk]) {
    const boostData = globalThis.state.damageBoost[previousPk];
    if (boostData.duration === 'this_turn') {
      delete globalThis.state.damageBoost[previousPk];
    }
  }

  
    if (globalThis.resetAbilityUsage) {
    globalThis.resetAbilityUsage(pk);
  }

  
  await runStatusBetweenTurns();

  
  
  
  
  if (previousPlayer && typeof getMoveRow === 'function' && typeof applyMoveEffectFromCsv === 'function') {
    try {
      const prevPk = previousPk;
      const prevActiveImg = getActiveImg(prevPk);
      if (prevActiveImg) {
        
        const prevMeta = await fetchCardMeta(prevActiveImg.dataset.set, prevActiveImg.dataset.num);
        if (prevMeta?.attacks) {
          for (const attack of prevMeta.attacks) {
            const moveRow = await globalThis.getMoveRow(prevActiveImg.alt, attack.name);
            if (moveRow?.effect_type === 'damage_end_of_opponent_turn') {
              const effectState = {
                p1: playerState.player1,
                p2: playerState.player2
              };
              const defendingPk = pk; 
              await applyMoveEffectFromCsv(effectState, prevPk, attack.name, 0, {
                moveName: attack.name,
                isFinal: true,
                defendingPk: defendingPk,
                sourceImg: prevActiveImg
              });
            }
          }
        }
      }
    } catch (err) {
      console.error('[startTurn] damage_end_of_opponent_turn failed:', err);
    }
  }

  
  await runStatusStartOfTurn(pk);

  
  drawOne(player);

  
  renderAllHands();
  renderEnergyZone();
  updateTurnBox();

setTimeout(() => {
  showPopup(`Player ${player === 'player1' ? '1' : '2'}'s turn`);
}, 900);

}

async function drawStartingHandForPlayer(key){
  const deck=playerState[key].deck;
  if(deck.length<5)throw new Error('Deck too small');

  let tries=0,hand=[],hasBasic=false;

  while(tries<10){
    tries++;
    shuffle(deck);
    
    if (tries === 1) {
      animateDeckShuffle(key);
    }

    hand=deck.slice(0,5);

    const flags=await Promise.all(
      hand.map(c=>isBasicPokemon(c.set,c.number||c.num))
    );

    hasBasic=flags.some(Boolean);
    if(hasBasic) break;
  }
  
  deck.splice(0,5);
  
  
  const handDiv = key === 'player1' ? p1HandDiv : p2HandDiv;
  const animationPromises = [];
  for (let i = 0; i < 5; i++) {
    const delay = i * 200; 
    animationPromises.push(
      new Promise(resolve => {
        setTimeout(async () => {
          const animCard = await animateCardDraw(key, handDiv, hand[i], i, 5); 
          resolve(animCard); 
        }, delay);
      })
    );
  }
  
  
  const animatedCards = await Promise.all(animationPromises);
  
  
  playerState[key].hand = hand;
  updateDeckBubbles();
  
  
  requestAnimationFrame(() => {
    
    let targetWidth = 69.27; 
    let targetHeight = 96.47; 
    
    
    animatedCards.forEach(animCard => {
      if (animCard && animCard.parentNode) {
        
        const currentWidth = parseFloat(animCard.style.width) || 69.27;
        const currentHeight = parseFloat(animCard.style.height) || 96.47;
        
        
        const scaleX = targetWidth / currentWidth;
        const scaleY = targetHeight / currentHeight;
        
        
        void animCard.offsetWidth;
        
        
        animCard.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out, width 0.3s ease-out, height 0.3s ease-out';
        animCard.style.transform = `perspective(700px) rotateX(3deg) scale(${scaleX}, ${scaleY})`;
        animCard.style.opacity = '0';
        animCard.style.width = `${targetWidth}px`;
        animCard.style.height = `${targetHeight}px`;
      }
    });
    
    
    setTimeout(() => {
      
      const hide = key === 'player1' ? currentPlayer === 'player2' : currentPlayer === 'player1';
      renderHand(handDiv, hand, hide, false);
      
      if (key === 'player1') {
        renderHand(p2HandDiv, playerState.player2.hand, currentPlayer === 'player1');
      } else {
        renderHand(p1HandDiv, playerState.player1.hand, currentPlayer === 'player2');
      }
      
      
      animatedCards.forEach(animCard => {
        if (animCard && animCard.parentNode) {
          animCard.remove();
        }
      });
    }, 300);
  });
  
  
  const remainingAnimatedCards = document.querySelectorAll('[data-animated-card="true"]');
  if (remainingAnimatedCards.length > 0) {
    remainingAnimatedCards.forEach(card => {
      if (card && card.parentNode) {
        
        void card.offsetWidth;
        card.style.transition = 'opacity 0.3s ease-out';
        card.style.opacity = '0';
        setTimeout(() => {
          if (card.parentNode) {
            card.remove();
          }
        }, 300);
      }
    });
  }
}


function flipCoin(){
  coinEl.classList.add('flip');

  const res = Math.random() < 0.5 ? 'player1' : 'player2';
  const front = coinEl.querySelector('.front');
  const back  = coinEl.querySelector('.back');

  setTimeout(() => {
    coinEl.classList.remove('flip');

    if (res === 'player1') {
      front.style.transform = 'rotateY(0deg)';
      back.style.transform  = 'rotateY(180deg)';
    } else {
      front.style.transform = 'rotateY(180deg)';
      back.style.transform  = 'rotateY(0deg)';
    }

    firstPlayer   = res;
    currentPlayer = res;
    globalThis.firstPlayer = res;
    
    const firstState = playerState[res];
    const firstEnergyTypes = firstState.energyTypes || [];
    if (firstEnergyTypes.length > 1) {
      firstState.currentTurnEnergy = selectRandomEnergy(firstEnergyTypes);
      firstState.nextTurnEnergy = selectRandomEnergy(firstEnergyTypes);
    } else if (firstEnergyTypes.length === 1) {
      firstState.currentTurnEnergy = firstEnergyTypes[0];
      firstState.nextTurnEnergy = firstEnergyTypes[0];
    }
    
    
    const otherPlayer = res === 'player1' ? 'player2' : 'player1';
    const otherState = playerState[otherPlayer];
    const otherEnergyTypes = otherState.energyTypes || [];
    if (otherEnergyTypes.length > 1) {
      otherState.currentTurnEnergy = selectRandomEnergy(otherEnergyTypes);
      otherState.nextTurnEnergy = selectRandomEnergy(otherEnergyTypes);
    } else if (otherEnergyTypes.length === 1) {
      otherState.currentTurnEnergy = otherEnergyTypes[0];
      otherState.nextTurnEnergy = otherEnergyTypes[0];
    }

    coinResult.textContent = `${res === 'player1' ? 'Player 1' : 'Player 2'} goes first!`;
    showPopup(`${res === 'player1' ? 'Player 1' : 'Player 2'} goes first!`);

    logEvent({
      player: res,
      text:`Won the coin flip and goes first.`
    });

    updateTurnBox();
    renderEnergyZone();
    
    
    (globalThis.updateDeckStack || updateDeckStack)('player1');
    (globalThis.updateDeckStack || updateDeckStack)('player2');

    drawOne(currentPlayer);
    renderAllHands();

    isSetupPhase = false;
  }, 1500);
}

document.body.addEventListener('contextmenu', async e => {
  const handImgEl = e.target.closest('.hand img');

  
  if (handImgEl) {
    e.preventDefault();

    const set = handImgEl.dataset.set;
    const num = handImgEl.dataset.num;

    try {
      const meta = await fetchCardMeta(set, num);
      const category = (meta.category || '').toLowerCase();

      if (handBackdrop && handImg) {
        handImg.src = handImgEl.src;
        handBackdrop.classList.add('show');
        handTitle.textContent = meta.name || 'Card';
      }

      if (category === 'pokemon') {
        if (handBackdrop) handBackdrop.classList.remove('show');

        zoomImg.src = handImgEl.src;
        zoomBackdrop.classList.add('show');

        await buildZoomPanel(meta, handImgEl);
        zoomAttacks.querySelectorAll('.zoom-attack').forEach(a => a.classList.add('muted'));
        document.getElementById('zoomRetreatRow')?.classList.add('disabled');
      } else {
        if (handType) {
          handType.textContent = meta.trainerType || meta.category || 'Card';
          handType.style.background = trainerColor(meta.trainerType || meta.category);
        }
        if (handEffect) {
          handEffect.textContent = meta.effect || meta.description || 'No effect listed.';
        }
      }

    } catch {
      showPopup('No data available for this card.');
    }

    return;
  }

  
  const img = e.target.closest('.active img, .bench img');
  if (!img) return;

  e.preventDefault();

  zoomImg.src = img.src;
  zoomBackdrop.classList.add('show');

  try {
    const set = img.dataset.set;
    const num = img.dataset.num;
    const meta = await fetchCardMeta(set, num);
    await buildZoomPanel(meta, img);
  } catch {
    zoomTitle.textContent = 'Pokmon';
    zoomHp.textContent = '';
    zoomAttacks.innerHTML = '<div style="color:#cbd5e1">No data</div>';
    zoomEnergyCount.textContent = 'x0';
    zoomEnergyIcons.innerHTML = '';
    zoomWeakness.textContent = '';
    zoomRetreat.innerHTML = '';
    zoomTools.innerHTML = '<div class="chip">none</div>';
    zoomAbilities.style.display = 'none';
  }
});

if (zoomBackdrop) {
  zoomBackdrop.addEventListener('click', e => {
    console.log('[ZOOM-CLOSE] Click on zoom backdrop:', {
      target: e.target,
      isBackdrop: e.target === zoomBackdrop,
      isClosest: !!e.target.closest('.zoom-backdrop'),
      timestamp: new Date().toISOString()
    });
    
    if (e.target === zoomBackdrop || e.target.closest('.zoom-backdrop')) {
      console.log('[ZOOM-CLOSE] Closing zoom backdrop');
      e.stopPropagation();
      e.stopImmediatePropagation();
      e.preventDefault();
      zoomBackdrop.classList.remove('show');
      currentZoom = { img: null, meta: null };
      console.log('[ZOOM-CLOSE] Zoom backdrop closed');
    }
  });

  document.addEventListener('keydown', e => {
    if (e.key === 'Escape' && zoomBackdrop.classList.contains('show')) {
      console.log('[ZOOM-CLOSE] Escape key pressed, closing zoom');
      e.stopPropagation();
      e.stopImmediatePropagation();
      zoomBackdrop.classList.remove('show');
      currentZoom = { img: null, meta: null };
      console.log('[ZOOM-CLOSE] Zoom backdrop closed via Escape');
    }
  });
}

if (p1DiscardBtn) p1DiscardBtn.onclick = () => {
  renderDiscard('player1');
  p1DiscardDrawer.classList.add('show');
  
  updateDiscardDrawerPositions();
};

if (p2DiscardBtn) p2DiscardBtn.onclick = () => {
  renderDiscard('player2');
  p2DiscardDrawer.classList.add('show');
  
  updateDiscardDrawerPositions();
};

function updateDiscardDrawerPositions() {
  const p1Open = p1DiscardDrawer?.classList.contains('show');
  const p2Open = p2DiscardDrawer?.classList.contains('show');
  
  if (p1Open && p2Open) {
    
    p1DiscardDrawer.style.transform = 'translateX(-340px)';
  } else if (p1Open) {
    
    p1DiscardDrawer.style.transform = 'translateX(0)';
  }
  
}

document.addEventListener('click', e => {
  if (p1DiscardDrawer?.classList.contains('show') &&
      !p1DiscardDrawer.contains(e.target) &&
      e.target !== p1DiscardBtn) {
    p1DiscardDrawer.classList.remove('show');
    updateDiscardDrawerPositions();
  }

  if (p2DiscardDrawer?.classList.contains('show') &&
      !p2DiscardDrawer.contains(e.target) &&
      e.target !== p2DiscardBtn) {
    p2DiscardDrawer.classList.remove('show');
    updateDiscardDrawerPositions();
  }
});

if (mainButton) mainButton.onclick = async () => {
  const label = mainButton.textContent;

  try {
    if (label === 'Draw Hands') {
      
      await Promise.all([
        drawStartingHandForPlayer('player1'),
        drawStartingHandForPlayer('player2')
      ]);
      
      showPopup('Choose Active & Benched Pokmon');

      mainButton.textContent = 'Start Game';

    } else if (label === 'Start Game') {
      if (!p1Active.querySelector('img') || !p2Active.querySelector('img')) {
        showPopup('Both players need an Active Pokmon.');
        return;
      }

      flipCoin();
      mainButton.textContent = 'End Turn';

    } else {
      
      
      const currentActiveImg = getActiveImage(currentPlayer);
      
      if (currentActiveImg) {
        const slot = currentActiveImg.closest('.card-slot');
        const tool = getToolDataFromSlot(slot);
        
        if (tool && tool.num === '067' && tool.set === 'A3b') {
          const maxHp = slot?.dataset.maxHp ? parseInt(slot.dataset.maxHp, 10) : parseInt(currentActiveImg.dataset.hp, 10);
          const curHp = parseInt(currentActiveImg.dataset.chp, 10);
          
          if (curHp < maxHp) {
            const healAmount = 10;
            const newHp = Math.min(maxHp, curHp + healAmount);
            currentActiveImg.dataset.chp = String(newHp);
            
            
            if (typeof setHpOnImage === 'function') {
              setHpOnImage(currentActiveImg, maxHp, newHp);
            }
            
            showPopup(`Leftovers: Healed 10 damage from ${currentActiveImg.alt}!`);
          }
        }
      }
      
      const currentPk = currentPlayer === 'player1' ? 'p1' : 'p2';
      
      if (typeof getAbilityRow === 'function' && typeof applyAbilityEffectFromCsv === 'function') {
        try {
          if (currentActiveImg) {
            const abilityRow = await getAbilityRow(currentActiveImg.dataset.set, currentActiveImg.dataset.num);
            if (abilityRow?.effect_type === 'draw_card_end_of_turn') {
              const effectState = {
                p1: playerState.player1,
                p2: playerState.player2
              };
              await applyAbilityEffectFromCsv(effectState, currentPk, abilityRow, {
                abilityPokemon: currentActiveImg
              });
            }
          }
        } catch (err) {
          console.error('[endTurn] draw_card_end_of_turn failed:', err);
        }
      }
      
      const next = currentPlayer === 'player1' ? 'player2' : 'player1';
      startTurn(next);
    }
  } catch (err) {
    console.error('Flow error:', err);
    showPopup('Setup error. Check decks.');
  }
};

if (playAgainBtn)
  playAgainBtn.addEventListener('click', () => {
    window.location.reload();
  });

if (chooseDecksBtn)
  chooseDecksBtn.addEventListener('click', () => {
    window.location.href = 'index.html';
  });

const victoryShowLogBtn = document.getElementById("victoryShowLogBtn");

if (victoryShowLogBtn) {
  victoryShowLogBtn.onclick = () => {
    if (!fullHistoryLog.length) {
      fullHistoryDiv.innerHTML = '<div class="match-log-entry">No actions logged.</div>';
    } else {
      fullHistoryDiv.innerHTML = fullHistoryLog.map(h => `
        <div class="match-log-entry">
          <div>
            <strong>#${h.id}</strong>  ${h.player} 
            <span style="opacity:.6">${h.ts}</span>
          </div>
          <div>${h.text}</div>
          ${
            h.imgUrl
              ? `<img class="log-thumb" src="${h.imgUrl}"
                  style="margin-top:6px;border-radius:6px;width:52px;height:auto;">`
              : ''
          }
        </div>
      `).join('');
    }
    historyBackdrop.classList.add('show');
  };
}

globalThis.selectPokemon = function (_st, pk, _z) {
  const area = pk === 'p1' ? p1Active : p2Active;
  const img  = area?.querySelector('img');
  if (!img) return null;

  return {
    name: img.alt,
    hp:   parseInt(img.dataset.chp || img.dataset.hp || '0', 10) || 0,
    maxHP: parseInt(img.dataset.hp || '0', 10) || 0
  };
};

globalThis.drawCards = async function (_st, pk, n) {
  const owner = pk === 'p1' ? 'player1' : 'player2';
  const drawCount = parseInt(n) || 0;
  const drawnCards = [];
  
  for (let i = 0; i < drawCount; i++) {
    if (playerState[owner].deck.length) {
      const drawnCard = playerState[owner].deck.shift();
      playerState[owner].hand.push(drawnCard);
      drawnCards.push(drawnCard);
    }
  }
  
  if (drawnCards.length > 0 && typeof logEvent === 'function') {
    for (const card of drawnCards) {
      logEvent({
        player: owner,
        text: `Drew ${card.name}`,
        cardSet: card.set,
        cardNum: card.number || card.num
      });
    }
  }
  
  updateDeckBubbles();
updateHandBubbles();
updateDiscardBubbles();
  renderAllHands();
};

globalThis.shuffleIntoDeck = function (hand, deck) {
  if (!Array.isArray(hand) || !Array.isArray(deck)) return;

  deck.push(...hand);
  hand.length = 0;
  shuffle(deck);
  
  
  const owner = deck === playerState.player1.deck ? 'player1' : 'player2';
  animateDeckShuffle(owner);
};

globalThis.findPokemonByName = function (_st, name) {
  const imgs = $$('#player1 .active img, #player1 .bench img, ' +
                  '#player2 .active img, #player2 .bench img');
  const hit = imgs.find(i => i.alt === name);
  return hit ? { name } : null;
};

globalThis.discardPokemon = async function(pokemonImg, pk, givePoint = false) {
  if (!pokemonImg) return;
  
  const slot = pokemonImg.closest('.card-slot');
  if (!slot) return;
  
  const pokemonName = pokemonImg.alt || 'Pokemon';
  
  
  const owner = pk === 'p1' ? 'player1' : 'player2';
  
  
  const energyBox = slot.querySelector('.energy-pips');
  if (energyBox) energyBox.remove();
  
  const toolThumb = slot.querySelector('.tool-thumb');
  if (toolThumb) toolThumb.remove();
  
  const hpOverlay = slot.querySelector('.hp-overlay');
  if (hpOverlay) hpOverlay.remove();
  
  
  pokemonImg.remove();
  
  
  if (globalThis.markSlot) {
    globalThis.markSlot(slot, false);
  }
  
  
  if (givePoint) {
    const oppPk = pk === 'p1' ? 'p2' : 'p1';
    const oppOwner = oppPk === 'p1' ? 'player1' : 'player2';
    
    if (globalThis.incrementPoints) {
      globalThis.incrementPoints(oppOwner);
      showPopup(`${pokemonName} was knocked out! ${oppOwner === 'player1' ? 'Player 1' : 'Player 2'} takes a point!`);
    }
  }

};

globalThis.promoteFromBench = function (_st, oppKey, requireChoice = true) {
  const owner = oppKey === 'p1' ? 'player1' : 'player2';
  const bench = owner === 'player1' ? p1Bench : p2Bench;
  const imgs  = bench.querySelectorAll('img');

  if (requireChoice && imgs.length === 0) return false;

  beginPromotionFlow(owner);
  showPopup(`${owner === 'player1' ? 'Player 1' : 'Player 2'} choose a Benched Pokmon to promote.`);
  return true;
};

globalThis.shuffle = shuffle;
globalThis.renderAllHands = renderAllHands;
globalThis.renderHand = renderHand;
globalThis.updateDeckBubbles = updateDeckBubbles;
globalThis.animateCardDraw = animateCardDraw;
globalThis.animateDeckShuffle = animateDeckShuffle;
globalThis.showPopup = showPopup;
globalThis.getToolDataFromSlot = getToolDataFromSlot;
globalThis.setHpOnImage = setHpOnImage;
globalThis.playerState = playerState; 

globalThis.animateCardToHand = animateCardToHand;

globalThis.addLog = function (pk, htmlText, _imgUrl, cardObj) {
  const owner = pk === 'p1' ? 'player1' : 'player2';

  logEvent({
    player: owner,
    text: htmlText,
    cardSet: cardObj?.set,
    cardNum: cardObj?.number || cardObj?.num
  });
};


function getActiveImg(pk) {
  const area = pk === 'p1' ? p1Active : p2Active;
  return area ? area.querySelector('img') : null;
}


function doCoinFlip(pk = null) {
  
  let isHeads = Math.random() < 0.5;
  
  if (pk && globalThis.state?.guaranteedHeads?.[pk]) {
    isHeads = true;
    
    globalThis.state.guaranteedHeads[pk] = false;
  }
  
  const resultStr = isHeads ? 'heads' : 'tails';

  try {
    if (coinEl) {
      const front = coinEl.querySelector('.front');
      const back  = coinEl.querySelector('.back');
      
      coinEl.classList.add('flip');

      setTimeout(() => {
        coinEl.classList.remove('flip');
        
        if (front && back) {
          if (isHeads) {
            front.style.transform = 'rotateY(0deg)';
            back.style.transform  = 'rotateY(180deg)';
          } else {
            front.style.transform = 'rotateY(180deg)';
            back.style.transform  = 'rotateY(0deg)';
          }
        }
        
        if (coinResult) {
          coinResult.textContent = isHeads ? "Heads" : "Tails";
        }
      }, 1500);
    }
  } catch (e) {
  }

  return resultStr; 
}

globalThis.doCoinFlip = doCoinFlip;

function flipCoinStatus() {
  return new Promise(resolve => {
    coinEl.classList.add('flip');

    const isHeads = Math.random() < 0.5;
    const front = coinEl.querySelector('.front');
    const back  = coinEl.querySelector('.back');

    setTimeout(() => {
      coinEl.classList.remove('flip');

      if (isHeads) {
        
        front.style.transform = 'rotateY(0deg)';
        back.style.transform  = 'rotateY(180deg)';
        coinResult.textContent = 'Heads';
      } else {
        
        front.style.transform = 'rotateY(180deg)';
        back.style.transform  = 'rotateY(0deg)';
        coinResult.textContent = 'Tails';
      }

      resolve(isHeads ? 'heads' : 'tails');
    }, 1500);
  });
}

async function visualCoinFlip(messagePrefix = "Flip") {
  return new Promise(resolve => {
    coinEl.classList.add("flip");

    const flip = Math.random() < 0.5 ? "heads" : "tails";

    setTimeout(() => {
      coinEl.classList.remove("flip");
      
      showPopup(`${messagePrefix}: ${flip.toUpperCase()}`);

      resolve(flip);
    }, 1500);
  });
}

function normalizeStatusName(name) {
  const n = String(name || '').toLowerCase().trim();
  if (!n) return '';

  if (n.startsWith('poison')) return 'poisoned';
  if (n.startsWith('sleep'))  return 'asleep';
  if (n.startsWith('burn'))   return 'burned';
  if (n.startsWith('para'))   return 'paralyzed';
  if (n.startsWith('conf'))   return 'confused';

  return n; 
}

function drawStatusIcon(img, key) {
  const slot = img.closest('.card-slot');
  if (!slot) return;

  let icon = slot.querySelector('.status-icon');
  if (!icon) {
    icon = document.createElement('div');
    icon.className = 'status-icon';
    slot.appendChild(icon);
  }

  const url = STATUS_ICON_URLS[key];
  if (url) {
    icon.style.backgroundImage = `url('${url}')`;
  } else {
    icon.style.backgroundImage = '';
  }
  
  if (currentZoom.img === img && zoomStatusIcon) {
    if (url) {
      zoomStatusIcon.style.display = 'inline-block';
      zoomStatusIcon.style.backgroundImage = `url('${url}')`;
    } else {
      zoomStatusIcon.style.display = 'none';
      zoomStatusIcon.style.backgroundImage = '';
    }
  }
}

function clearStatusOnImg(img) {
  if (!img) return;
  img.dataset.status = '';

  const slot = img.closest('.card-slot');
  if (slot) {
    const icon = slot.querySelector('.status-icon');
    if (icon) icon.remove();
  }
  
  if (currentZoom.img === img && zoomStatusIcon) {
    zoomStatusIcon.style.display = 'none';
    zoomStatusIcon.style.backgroundImage = '';
  }
}

function setStatus(pk, statusName) {
  const img = getActiveImg(pk);
  if (!img) return;
  
  if (img.dataset.statusProtected) {
    showPopup(`${img.alt} is protected from Special Conditions!`);
    return false;
  }

  const key = normalizeStatusName(statusName);
  if (!key) return;

  img.dataset.status = key;
  drawStatusIcon(img, key);
  return true;
}
globalThis.setStatus = setStatus;

function clearStatus(pk) {
  const img = getActiveImg(pk);
  clearStatusOnImg(img);
}

async function runStatusBetweenTurns() {
  for (const pk of ['p1', 'p2']) {
    const img = getActiveImg(pk);
    if (!img) continue;

    const status = (img.dataset.status || '').toLowerCase();
    if (!status) continue;

    const owner = pk === 'p1' ? 'player1' : 'player2';

    
    if (status === 'poisoned') {
      
      let poisonDamage = parseInt(img.dataset.heavyPoison || '10', 10);
      
      
      try {
        const allPokemon = [
          ...document.querySelectorAll('#player1 .card-img'),
          ...document.querySelectorAll('#player2 .card-img')
        ];
        
        for (const pokemon of allPokemon) {
          const cacheKey = `${pokemon.dataset.set}-${pokemon.dataset.num}`;
          const abilityRow = globalThis.abilityCache?.[cacheKey];
          
          if (abilityRow?.effect_type === 'increase_poison_damage') {
            const bonus = parseInt(abilityRow.param1 || '10', 10);
            poisonDamage += bonus;
          }
        }
      } catch (err) {
        console.error('[poison] More Poison check failed:', err);
      }
      
      const result = await damageActiveOf(owner, poisonDamage, { isDirectAttack: false });
      
      if (poisonDamage === 20 || poisonDamage > 10) {
        showPopup(`${img.alt || 'Active Pokmon'} took ${poisonDamage} damage from Poison!`);
      } else {
        showPopup(`${img.alt || 'Active Pokmon'} took ${poisonDamage} damage from Poison.`);
      }

      if (result.knocked) {
        const img2 = getActiveImage(owner);
        if (img2) {
          const ended = await handleKnockOut(owner, img2);
          if (ended) return;
          await beginPromotionFlow(owner);
        }
      }
    }

    
    if (status === 'burned') {
      const result = await damageActiveOf(owner, 20, { isDirectAttack: false });
      showPopup(`${img.alt || 'Active Pokmon'} took 20 damage from Burn.`);

      if (result.knocked) {
        const img2 = getActiveImage(owner);
        if (img2) {
          const ended = await handleKnockOut(owner, img2);
          if (ended) return;
          await beginPromotionFlow(owner);
        }
        continue;
      }

      const r = doCoinFlip();
      if (r === 'heads') {
        clearStatus(pk);
        showPopup('The burn was healed!');
      }
    }

    
  }
  
  
  for (const checkPk of ['p1', 'p2']) {
    const activeImg = getActiveImg(checkPk);
    if (!activeImg) continue;
    
    
    const cacheKey = `${activeImg.dataset.set}-${activeImg.dataset.num}`;
    const abilityRow = globalThis.abilityCache?.[cacheKey];
    
    if (abilityRow?.effect_type === 'damage_during_checkup') {
      const damage = parseInt(abilityRow.param1 || '10', 10);
      const oppPk = checkPk === 'p1' ? 'p2' : 'p1';
      const oppOwner = oppPk === 'p1' ? 'player1' : 'player2';

      const result = await damageActiveOf(oppOwner, damage, { isDirectAttack: false });
      showPopup(`${activeImg.alt}'s Snowy Terrain: ${damage} damage to opponent!`);
      
      if (result.knocked) {
        const oppImg = getActiveImage(oppOwner);
        if (oppImg) {
          const ended = await handleKnockOut(oppOwner, oppImg);
          if (ended) return;
          await beginPromotionFlow(oppOwner);
        }
      }
    }
  }
}

globalThis.setStatus  = setStatus;
globalThis.clearStatus = clearStatus;

updateDeckBubbles();
updateTurnBox();
updatePointsUI();
renderAllHands();
</script>
</body>
</html>